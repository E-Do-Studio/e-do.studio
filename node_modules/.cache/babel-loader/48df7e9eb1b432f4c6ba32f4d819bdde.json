{"ast":null,"code":"import _classCallCheck from \"/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { Loader, FileLoader, LoaderUtils, SkinnedMesh, Skeleton, Bone, Vector3, Float32BufferAttribute, BufferGeometry, Uint16BufferAttribute, TextureLoader, Color, CustomBlending, SrcAlphaFactor, OneMinusSrcAlphaFactor, DstAlphaFactor, DoubleSide, FrontSide, MultiplyOperation, AddOperation, MeshToonMaterial, NearestFilter, RepeatWrapping, AnimationClip, VectorKeyframeTrack, QuaternionKeyframeTrack, NumberKeyframeTrack, Quaternion, Euler, Interpolant } from \"three\";\nimport { TGALoader } from \"./TGALoader.js\";\nimport { Parser } from \"mmd-parser\";\n\nvar MMDLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(MMDLoader, _Loader);\n\n  var _super = _createSuper(MMDLoader);\n\n  function MMDLoader(manager) {\n    var _this;\n\n    _classCallCheck(this, MMDLoader);\n\n    _this = _super.call(this, manager);\n    _this.loader = new FileLoader(_this.manager);\n    _this.parser = null;\n    _this.meshBuilder = new MeshBuilder(_this.manager);\n    _this.animationBuilder = new AnimationBuilder();\n    return _this;\n  }\n  /**\n   * @param {string} animationPath\n   * @return {MMDLoader}\n   */\n\n\n  _createClass(MMDLoader, [{\n    key: \"setAnimationPath\",\n    value: function setAnimationPath(animationPath) {\n      this.animationPath = animationPath;\n      return this;\n    } // Load MMD assets as Three.js Object\n\n    /**\n     * Loads Model file (.pmd or .pmx) as a SkinnedMesh.\n     *\n     * @param {string} url - url to Model(.pmd or .pmx) file\n     * @param {function} onLoad\n     * @param {function} onProgress\n     * @param {function} onError\n     */\n\n  }, {\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var builder = this.meshBuilder.setCrossOrigin(this.crossOrigin);\n      var resourcePath;\n\n      if (this.resourcePath !== \"\") {\n        resourcePath = this.resourcePath;\n      } else if (this.path !== \"\") {\n        resourcePath = this.path;\n      } else {\n        resourcePath = LoaderUtils.extractUrlBase(url);\n      }\n\n      var modelExtension = this._extractExtension(url).toLowerCase();\n\n      if (modelExtension !== \"pmd\" && modelExtension !== \"pmx\") {\n        if (onError) onError(new Error(\"THREE.MMDLoader: Unknown model file extension .\" + modelExtension + \".\"));\n        return;\n      }\n\n      this[modelExtension === \"pmd\" ? \"loadPMD\" : \"loadPMX\"](url, function (data) {\n        onLoad(builder.build(data, resourcePath, onProgress, onError));\n      }, onProgress, onError);\n    }\n    /**\n     * Loads Motion file(s) (.vmd) as a AnimationClip.\n     * If two or more files are specified, they'll be merged.\n     *\n     * @param {string|Array<string>} url - url(s) to animation(.vmd) file(s)\n     * @param {SkinnedMesh|THREE.Camera} object - tracks will be fitting to this object\n     * @param {function} onLoad\n     * @param {function} onProgress\n     * @param {function} onError\n     */\n\n  }, {\n    key: \"loadAnimation\",\n    value: function loadAnimation(url, object, onLoad, onProgress, onError) {\n      var builder = this.animationBuilder;\n      this.loadVMD(url, function (vmd) {\n        onLoad(object.isCamera ? builder.buildCameraAnimation(vmd) : builder.build(vmd, object));\n      }, onProgress, onError);\n    }\n    /**\n     * Loads mode file and motion file(s) as an object containing\n     * a SkinnedMesh and a AnimationClip.\n     * Tracks of AnimationClip are fitting to the model.\n     *\n     * @param {string} modelUrl - url to Model(.pmd or .pmx) file\n     * @param {string|Array{string}} vmdUrl - url(s) to animation(.vmd) file\n     * @param {function} onLoad\n     * @param {function} onProgress\n     * @param {function} onError\n     */\n\n  }, {\n    key: \"loadWithAnimation\",\n    value: function loadWithAnimation(modelUrl, vmdUrl, onLoad, onProgress, onError) {\n      var scope = this;\n      this.load(modelUrl, function (mesh) {\n        scope.loadAnimation(vmdUrl, mesh, function (animation) {\n          onLoad({\n            mesh: mesh,\n            animation: animation\n          });\n        }, onProgress, onError);\n      }, onProgress, onError);\n    } // Load MMD assets as Object data parsed by MMDParser\n\n    /**\n     * Loads .pmd file as an Object.\n     *\n     * @param {string} url - url to .pmd file\n     * @param {function} onLoad\n     * @param {function} onProgress\n     * @param {function} onError\n     */\n\n  }, {\n    key: \"loadPMD\",\n    value: function loadPMD(url, onLoad, onProgress, onError) {\n      var parser = this._getParser();\n\n      this.loader.setMimeType(void 0).setPath(this.path).setResponseType(\"arraybuffer\").setRequestHeader(this.requestHeader).setWithCredentials(this.withCredentials).load(url, function (buffer) {\n        onLoad(parser.parsePmd(buffer, true));\n      }, onProgress, onError);\n    }\n    /**\n     * Loads .pmx file as an Object.\n     *\n     * @param {string} url - url to .pmx file\n     * @param {function} onLoad\n     * @param {function} onProgress\n     * @param {function} onError\n     */\n\n  }, {\n    key: \"loadPMX\",\n    value: function loadPMX(url, onLoad, onProgress, onError) {\n      var parser = this._getParser();\n\n      this.loader.setMimeType(void 0).setPath(this.path).setResponseType(\"arraybuffer\").setRequestHeader(this.requestHeader).setWithCredentials(this.withCredentials).load(url, function (buffer) {\n        onLoad(parser.parsePmx(buffer, true));\n      }, onProgress, onError);\n    }\n    /**\n     * Loads .vmd file as an Object. If two or more files are specified\n     * they'll be merged.\n     *\n     * @param {string|Array<string>} url - url(s) to .vmd file(s)\n     * @param {function} onLoad\n     * @param {function} onProgress\n     * @param {function} onError\n     */\n\n  }, {\n    key: \"loadVMD\",\n    value: function loadVMD(url, onLoad, onProgress, onError) {\n      var urls = Array.isArray(url) ? url : [url];\n      var vmds = [];\n      var vmdNum = urls.length;\n\n      var parser = this._getParser();\n\n      this.loader.setMimeType(void 0).setPath(this.animationPath).setResponseType(\"arraybuffer\").setRequestHeader(this.requestHeader).setWithCredentials(this.withCredentials);\n\n      for (var i = 0, il = urls.length; i < il; i++) {\n        this.loader.load(urls[i], function (buffer) {\n          vmds.push(parser.parseVmd(buffer, true));\n          if (vmds.length === vmdNum) onLoad(parser.mergeVmds(vmds));\n        }, onProgress, onError);\n      }\n    }\n    /**\n     * Loads .vpd file as an Object.\n     *\n     * @param {string} url - url to .vpd file\n     * @param {boolean} isUnicode\n     * @param {function} onLoad\n     * @param {function} onProgress\n     * @param {function} onError\n     */\n\n  }, {\n    key: \"loadVPD\",\n    value: function loadVPD(url, isUnicode, onLoad, onProgress, onError) {\n      var parser = this._getParser();\n\n      this.loader.setMimeType(isUnicode ? void 0 : \"text/plain; charset=shift_jis\").setPath(this.animationPath).setResponseType(\"text\").setRequestHeader(this.requestHeader).setWithCredentials(this.withCredentials).load(url, function (text) {\n        onLoad(parser.parseVpd(text, true));\n      }, onProgress, onError);\n    } // private methods\n\n  }, {\n    key: \"_extractExtension\",\n    value: function _extractExtension(url) {\n      var index = url.lastIndexOf(\".\");\n      return index < 0 ? \"\" : url.slice(index + 1);\n    }\n  }, {\n    key: \"_getParser\",\n    value: function _getParser() {\n      if (this.parser === null) {\n        this.parser = new Parser();\n      }\n\n      return this.parser;\n    }\n  }]);\n\n  return MMDLoader;\n}(Loader);\n\nvar DEFAULT_TOON_TEXTURES = [\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=\", \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAN0lEQVRYR+3WQREAMBACsZ5/bWiiMvgEBTt5cW37hjsBBAgQIECAwFwgyfYPCCBAgAABAgTWAh8aBHZBl14e8wAAAABJRU5ErkJggg==\", \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAOUlEQVRYR+3WMREAMAwDsYY/yoDI7MLwIiP40+RJklfcCCBAgAABAgTqArfb/QMCCBAgQIAAgbbAB3z/e0F3js2cAAAAAElFTkSuQmCC\", \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAN0lEQVRYR+3WQREAMBACsZ5/B5ilMvgEBTt5cW37hjsBBAgQIECAwFwgyfYPCCBAgAABAgTWAh81dWyx0gFwKAAAAABJRU5ErkJggg==\", \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAOklEQVRYR+3WoREAMAwDsWb/UQtCy9wxTOQJ/oQ8SXKKGwEECBAgQIBAXeDt7f4BAQQIECBAgEBb4AOz8Hzx7WLY4wAAAABJRU5ErkJggg==\", \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABPUlEQVRYR+1XwW7CMAy1+f9fZOMysSEOEweEOPRNdm3HbdOyIhAcklPrOs/PLy9RygBALxzcCDQFmgJNgaZAU6Ap0BR4PwX8gsRMVLssMRH5HcpzJEaWL7EVg9F1IHRlyqQohgVr4FGUlUcMJSjcUlDw0zvjeun70cLWmneoyf7NgBTQSniBTQQSuJAZsOnnaczjIMb5hCiuHKxokCrJfVnrctyZL0PkJAJe1HMil4nxeyi3Ypfn1kX51jpPvo/JeCNC4PhVdHdJw2XjBR8brF8PEIhNVn12AgP7uHsTBguBn53MUZCqv7Lp07Pn5k1Ro+uWmUNn7D+M57rtk7aG0Vo73xyF/fbFf0bPJjDXngnGocDTdFhygZjwUQrMNrDcmZlQT50VJ/g/UwNyHpu778+yW+/ksOz/BFo54P4AsUXMfRq7XWsAAAAASUVORK5CYII=\", \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAACMElEQVRYR+2Xv4pTQRTGf2dubhLdICiii2KnYKHVolhauKWPoGAnNr6BD6CvIVaihYuI2i1ia0BY0MZGRHQXjZj/mSPnnskfNWiWZUlzJ5k7M2cm833nO5Mziej2DWWJRUoCpQKlAntSQCqgw39/iUWAGmh37jrRnVsKlgpiqmkoGVABA7E57fvY+pJDdgKqF6HzFCSADkDq+F6AHABtQ+UMVE5D7zXod7fFNhTEckTbj5XQgHzNN+5tQvc5NG7C6BNkp6D3EmpXHDR+dQAjFLchW3VS9rlw3JBh+B7ys5Cf9z0GW1C/7P32AyBAOAz1q4jGliIH3YPuBnSfQX4OGreTIgEYQb/pBDtPnEQ4CivXYPAWBk13oHrB54yA9QuSn2H4AcKRpEILDt0BUzj+RLR1V5EqjD66NPRBVpLcQwjHoHYJOhsQv6U4mnzmrIXJCFr4LDwm/xBUoboG9XX4cc9VKdYoSA2yk5NQLJaKDUjTBoveG3Z2TElTxwjNK4M3LEZgUdDdruvcXzKBpStgp2NPiWi3ks9ZXxIoFVi+AvHLdc9TqtjL3/aYjpPlrzOcEnK62Szhimdd7xX232zFDTgtxezOu3WNMRLjiKgjtOhHVMd1loynVHvOgjuIIJMaELEqhJAV/RCSLbWTcfPFakFgFlALTRRvx+ok6Hlp/Q+v3fmx90bMyUzaEAhmM3KvHlXTL5DxnbGf/1M8RNNACLL5MNtPxP/mypJAqcDSFfgFhpYqWUzhTEAAAAAASUVORK5CYII=\", \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=\", \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=\", \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=\", \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=\"];\n\nvar MeshBuilder = /*#__PURE__*/function () {\n  function MeshBuilder(manager) {\n    _classCallCheck(this, MeshBuilder);\n\n    this.crossOrigin = \"anonymous\";\n    this.geometryBuilder = new GeometryBuilder();\n    this.materialBuilder = new MaterialBuilder(manager);\n  }\n  /**\n   * @param {string} crossOrigin\n   * @return {MeshBuilder}\n   */\n\n\n  _createClass(MeshBuilder, [{\n    key: \"setCrossOrigin\",\n    value: function setCrossOrigin(crossOrigin) {\n      this.crossOrigin = crossOrigin;\n      return this;\n    }\n    /**\n     * @param {Object} data - parsed PMD/PMX data\n     * @param {string} resourcePath\n     * @param {function} onProgress\n     * @param {function} onError\n     * @return {SkinnedMesh}\n     */\n\n  }, {\n    key: \"build\",\n    value: function build(data, resourcePath, onProgress, onError) {\n      var geometry = this.geometryBuilder.build(data);\n      var material = this.materialBuilder.setCrossOrigin(this.crossOrigin).setResourcePath(resourcePath).build(data, geometry, onProgress, onError);\n      var mesh = new SkinnedMesh(geometry, material);\n      var skeleton = new Skeleton(initBones(mesh));\n      mesh.bind(skeleton);\n      return mesh;\n    }\n  }]);\n\n  return MeshBuilder;\n}();\n\nfunction initBones(mesh) {\n  var geometry = mesh.geometry;\n  var bones = [];\n\n  if (geometry && geometry.bones !== void 0) {\n    for (var i = 0, il = geometry.bones.length; i < il; i++) {\n      var gbone = geometry.bones[i];\n      var bone = new Bone();\n      bones.push(bone);\n      bone.name = gbone.name;\n      bone.position.fromArray(gbone.pos);\n      bone.quaternion.fromArray(gbone.rotq);\n      if (gbone.scl !== void 0) bone.scale.fromArray(gbone.scl);\n    }\n\n    for (var _i = 0, _il = geometry.bones.length; _i < _il; _i++) {\n      var _gbone = geometry.bones[_i];\n\n      if (_gbone.parent !== -1 && _gbone.parent !== null && bones[_gbone.parent] !== void 0) {\n        bones[_gbone.parent].add(bones[_i]);\n      } else {\n        mesh.add(bones[_i]);\n      }\n    }\n  }\n\n  mesh.updateMatrixWorld(true);\n  return bones;\n}\n\nvar GeometryBuilder = /*#__PURE__*/function () {\n  function GeometryBuilder() {\n    _classCallCheck(this, GeometryBuilder);\n  }\n\n  _createClass(GeometryBuilder, [{\n    key: \"build\",\n    value:\n    /**\n     * @param {Object} data - parsed PMD/PMX data\n     * @return {BufferGeometry}\n     */\n    function build(data) {\n      var positions = [];\n      var uvs = [];\n      var normals = [];\n      var indices = [];\n      var groups = [];\n      var bones = [];\n      var skinIndices = [];\n      var skinWeights = [];\n      var morphTargets = [];\n      var morphPositions = [];\n      var iks = [];\n      var grants = [];\n      var rigidBodies = [];\n      var constraints = [];\n      var offset = 0;\n      var boneTypeTable = {};\n\n      for (var i = 0; i < data.metadata.vertexCount; i++) {\n        var v = data.vertices[i];\n\n        for (var j = 0, jl = v.position.length; j < jl; j++) {\n          positions.push(v.position[j]);\n        }\n\n        for (var _j = 0, _jl = v.normal.length; _j < _jl; _j++) {\n          normals.push(v.normal[_j]);\n        }\n\n        for (var _j2 = 0, _jl2 = v.uv.length; _j2 < _jl2; _j2++) {\n          uvs.push(v.uv[_j2]);\n        }\n\n        for (var _j3 = 0; _j3 < 4; _j3++) {\n          skinIndices.push(v.skinIndices.length - 1 >= _j3 ? v.skinIndices[_j3] : 0);\n        }\n\n        for (var _j4 = 0; _j4 < 4; _j4++) {\n          skinWeights.push(v.skinWeights.length - 1 >= _j4 ? v.skinWeights[_j4] : 0);\n        }\n      }\n\n      for (var _i2 = 0; _i2 < data.metadata.faceCount; _i2++) {\n        var face = data.faces[_i2];\n\n        for (var _j5 = 0, _jl3 = face.indices.length; _j5 < _jl3; _j5++) {\n          indices.push(face.indices[_j5]);\n        }\n      }\n\n      for (var _i3 = 0; _i3 < data.metadata.materialCount; _i3++) {\n        var material = data.materials[_i3];\n        groups.push({\n          offset: offset * 3,\n          count: material.faceCount * 3\n        });\n        offset += material.faceCount;\n      }\n\n      for (var _i4 = 0; _i4 < data.metadata.rigidBodyCount; _i4++) {\n        var body = data.rigidBodies[_i4];\n        var value = boneTypeTable[body.boneIndex];\n        value = value === void 0 ? body.type : Math.max(body.type, value);\n        boneTypeTable[body.boneIndex] = value;\n      }\n\n      for (var _i5 = 0; _i5 < data.metadata.boneCount; _i5++) {\n        var boneData = data.bones[_i5];\n        var bone = {\n          index: _i5,\n          transformationClass: boneData.transformationClass,\n          parent: boneData.parentIndex,\n          name: boneData.name,\n          pos: boneData.position.slice(0, 3),\n          rotq: [0, 0, 0, 1],\n          scl: [1, 1, 1],\n          rigidBodyType: boneTypeTable[_i5] !== void 0 ? boneTypeTable[_i5] : -1\n        };\n\n        if (bone.parent !== -1) {\n          bone.pos[0] -= data.bones[bone.parent].position[0];\n          bone.pos[1] -= data.bones[bone.parent].position[1];\n          bone.pos[2] -= data.bones[bone.parent].position[2];\n        }\n\n        bones.push(bone);\n      }\n\n      if (data.metadata.format === \"pmd\") {\n        for (var _i6 = 0; _i6 < data.metadata.ikCount; _i6++) {\n          var ik = data.iks[_i6];\n          var param = {\n            target: ik.target,\n            effector: ik.effector,\n            iteration: ik.iteration,\n            maxAngle: ik.maxAngle * 4,\n            links: []\n          };\n\n          for (var _j6 = 0, _jl4 = ik.links.length; _j6 < _jl4; _j6++) {\n            var link = {};\n            link.index = ik.links[_j6].index;\n            link.enabled = true;\n\n            if (data.bones[link.index].name.indexOf(\"ひざ\") >= 0) {\n              link.limitation = new Vector3(1, 0, 0);\n            }\n\n            param.links.push(link);\n          }\n\n          iks.push(param);\n        }\n      } else {\n        for (var _i7 = 0; _i7 < data.metadata.boneCount; _i7++) {\n          var _ik = data.bones[_i7].ik;\n          if (_ik === void 0) continue;\n          var _param = {\n            target: _i7,\n            effector: _ik.effector,\n            iteration: _ik.iteration,\n            maxAngle: _ik.maxAngle,\n            links: []\n          };\n\n          for (var _j7 = 0, _jl5 = _ik.links.length; _j7 < _jl5; _j7++) {\n            var _link = {};\n            _link.index = _ik.links[_j7].index;\n            _link.enabled = true;\n\n            if (_ik.links[_j7].angleLimitation === 1) {\n              var rotationMin = _ik.links[_j7].lowerLimitationAngle;\n              var rotationMax = _ik.links[_j7].upperLimitationAngle;\n              var tmp1 = -rotationMax[0];\n              var tmp2 = -rotationMax[1];\n              rotationMax[0] = -rotationMin[0];\n              rotationMax[1] = -rotationMin[1];\n              rotationMin[0] = tmp1;\n              rotationMin[1] = tmp2;\n              _link.rotationMin = new Vector3().fromArray(rotationMin);\n              _link.rotationMax = new Vector3().fromArray(rotationMax);\n            }\n\n            _param.links.push(_link);\n          }\n\n          iks.push(_param);\n          bones[_i7].ik = _param;\n        }\n      }\n\n      if (data.metadata.format === \"pmx\") {\n        var traverse = function traverse(entry) {\n          if (entry.param) {\n            grants.push(entry.param);\n            bones[entry.param.index].grant = entry.param;\n          }\n\n          entry.visited = true;\n\n          for (var _i8 = 0, il = entry.children.length; _i8 < il; _i8++) {\n            var child = entry.children[_i8];\n            if (!child.visited) traverse(child);\n          }\n        };\n\n        var grantEntryMap = {};\n\n        for (var _i9 = 0; _i9 < data.metadata.boneCount; _i9++) {\n          var _boneData = data.bones[_i9];\n          var grant = _boneData.grant;\n          if (grant === void 0) continue;\n          var _param2 = {\n            index: _i9,\n            parentIndex: grant.parentIndex,\n            ratio: grant.ratio,\n            isLocal: grant.isLocal,\n            affectRotation: grant.affectRotation,\n            affectPosition: grant.affectPosition,\n            transformationClass: _boneData.transformationClass\n          };\n          grantEntryMap[_i9] = {\n            parent: null,\n            children: [],\n            param: _param2,\n            visited: false\n          };\n        }\n\n        var rootEntry = {\n          parent: null,\n          children: [],\n          param: null,\n          visited: false\n        };\n\n        for (var boneIndex in grantEntryMap) {\n          var grantEntry = grantEntryMap[boneIndex];\n          var parentGrantEntry = grantEntryMap[grantEntry.parentIndex] || rootEntry;\n          grantEntry.parent = parentGrantEntry;\n          parentGrantEntry.children.push(grantEntry);\n        }\n\n        traverse(rootEntry);\n      }\n\n      function updateAttributes(attribute, morph, ratio) {\n        for (var _i10 = 0; _i10 < morph.elementCount; _i10++) {\n          var element = morph.elements[_i10];\n          var index = void 0;\n\n          if (data.metadata.format === \"pmd\") {\n            index = data.morphs[0].elements[element.index].index;\n          } else {\n            index = element.index;\n          }\n\n          attribute.array[index * 3 + 0] += element.position[0] * ratio;\n          attribute.array[index * 3 + 1] += element.position[1] * ratio;\n          attribute.array[index * 3 + 2] += element.position[2] * ratio;\n        }\n      }\n\n      for (var _i11 = 0; _i11 < data.metadata.morphCount; _i11++) {\n        var morph = data.morphs[_i11];\n        var params = {\n          name: morph.name\n        };\n        var attribute = new Float32BufferAttribute(data.metadata.vertexCount * 3, 3);\n        attribute.name = morph.name;\n\n        for (var _j8 = 0; _j8 < data.metadata.vertexCount * 3; _j8++) {\n          attribute.array[_j8] = positions[_j8];\n        }\n\n        if (data.metadata.format === \"pmd\") {\n          if (_i11 !== 0) {\n            updateAttributes(attribute, morph, 1);\n          }\n        } else {\n          if (morph.type === 0) {\n            for (var _j9 = 0; _j9 < morph.elementCount; _j9++) {\n              var morph2 = data.morphs[morph.elements[_j9].index];\n              var ratio = morph.elements[_j9].ratio;\n\n              if (morph2.type === 1) {\n                updateAttributes(attribute, morph2, ratio);\n              } else {}\n            }\n          } else if (morph.type === 1) {\n            updateAttributes(attribute, morph, 1);\n          } else if (morph.type === 2) {} else if (morph.type === 3) {} else if (morph.type === 4) {} else if (morph.type === 5) {} else if (morph.type === 6) {} else if (morph.type === 7) {} else if (morph.type === 8) {}\n        }\n\n        morphTargets.push(params);\n        morphPositions.push(attribute);\n      }\n\n      for (var _i12 = 0; _i12 < data.metadata.rigidBodyCount; _i12++) {\n        var rigidBody = data.rigidBodies[_i12];\n        var _params = {};\n\n        for (var key in rigidBody) {\n          _params[key] = rigidBody[key];\n        }\n\n        if (data.metadata.format === \"pmx\") {\n          if (_params.boneIndex !== -1) {\n            var _bone = data.bones[_params.boneIndex];\n            _params.position[0] -= _bone.position[0];\n            _params.position[1] -= _bone.position[1];\n            _params.position[2] -= _bone.position[2];\n          }\n        }\n\n        rigidBodies.push(_params);\n      }\n\n      for (var _i13 = 0; _i13 < data.metadata.constraintCount; _i13++) {\n        var constraint = data.constraints[_i13];\n        var _params2 = {};\n\n        for (var _key in constraint) {\n          _params2[_key] = constraint[_key];\n        }\n\n        var bodyA = rigidBodies[_params2.rigidBodyIndex1];\n        var bodyB = rigidBodies[_params2.rigidBodyIndex2];\n\n        if (bodyA.type !== 0 && bodyB.type === 2) {\n          if (bodyA.boneIndex !== -1 && bodyB.boneIndex !== -1 && data.bones[bodyB.boneIndex].parentIndex === bodyA.boneIndex) {\n            bodyB.type = 1;\n          }\n        }\n\n        constraints.push(_params2);\n      }\n\n      var geometry = new BufferGeometry();\n      geometry.setAttribute(\"position\", new Float32BufferAttribute(positions, 3));\n      geometry.setAttribute(\"normal\", new Float32BufferAttribute(normals, 3));\n      geometry.setAttribute(\"uv\", new Float32BufferAttribute(uvs, 2));\n      geometry.setAttribute(\"skinIndex\", new Uint16BufferAttribute(skinIndices, 4));\n      geometry.setAttribute(\"skinWeight\", new Float32BufferAttribute(skinWeights, 4));\n      geometry.setIndex(indices);\n\n      for (var _i14 = 0, il = groups.length; _i14 < il; _i14++) {\n        geometry.addGroup(groups[_i14].offset, groups[_i14].count, _i14);\n      }\n\n      geometry.bones = bones;\n      geometry.morphTargets = morphTargets;\n      geometry.morphAttributes.position = morphPositions;\n      geometry.morphTargetsRelative = false;\n      geometry.userData.MMD = {\n        bones: bones,\n        iks: iks,\n        grants: grants,\n        rigidBodies: rigidBodies,\n        constraints: constraints,\n        format: data.metadata.format\n      };\n      geometry.computeBoundingSphere();\n      return geometry;\n    }\n  }]);\n\n  return GeometryBuilder;\n}();\n\nvar MaterialBuilder = /*#__PURE__*/function () {\n  function MaterialBuilder(manager) {\n    _classCallCheck(this, MaterialBuilder);\n\n    this.manager = manager;\n    this.textureLoader = new TextureLoader(this.manager);\n    this.tgaLoader = null;\n    this.crossOrigin = \"anonymous\";\n    this.resourcePath = void 0;\n  }\n  /**\n   * @param {string} crossOrigin\n   * @return {MaterialBuilder}\n   */\n\n\n  _createClass(MaterialBuilder, [{\n    key: \"setCrossOrigin\",\n    value: function setCrossOrigin(crossOrigin) {\n      this.crossOrigin = crossOrigin;\n      return this;\n    }\n    /**\n     * @param {string} resourcePath\n     * @return {MaterialBuilder}\n     */\n\n  }, {\n    key: \"setResourcePath\",\n    value: function setResourcePath(resourcePath) {\n      this.resourcePath = resourcePath;\n      return this;\n    }\n    /**\n     * @param {Object} data - parsed PMD/PMX data\n     * @param {BufferGeometry} geometry - some properties are dependend on geometry\n     * @param {function} onProgress\n     * @param {function} onError\n     * @return {Array<MeshToonMaterial>}\n     */\n\n  }, {\n    key: \"build\",\n    value: function build(data, geometry) {\n      var materials = [];\n      var textures = {};\n      this.textureLoader.setCrossOrigin(this.crossOrigin);\n\n      for (var i = 0; i < data.metadata.materialCount; i++) {\n        var material = data.materials[i];\n        var params = {\n          userData: {}\n        };\n        if (material.name !== void 0) params.name = material.name;\n        params.color = new Color().fromArray(material.diffuse);\n        params.opacity = material.diffuse[3];\n        params.emissive = new Color().fromArray(material.ambient);\n        params.transparent = params.opacity !== 1;\n        params.skinning = geometry.bones.length > 0 ? true : false;\n        params.morphTargets = geometry.morphTargets.length > 0 ? true : false;\n        params.fog = true;\n        params.blending = CustomBlending;\n        params.blendSrc = SrcAlphaFactor;\n        params.blendDst = OneMinusSrcAlphaFactor;\n        params.blendSrcAlpha = SrcAlphaFactor;\n        params.blendDstAlpha = DstAlphaFactor;\n\n        if (data.metadata.format === \"pmx\" && (material.flag & 1) === 1) {\n          params.side = DoubleSide;\n        } else {\n          params.side = params.opacity === 1 ? FrontSide : DoubleSide;\n        }\n\n        if (data.metadata.format === \"pmd\") {\n          if (material.fileName) {\n            var fileName = material.fileName;\n            var fileNames = fileName.split(\"*\");\n            params.map = this._loadTexture(fileNames[0], textures);\n\n            if (fileNames.length > 1) {\n              var extension = fileNames[1].slice(-4).toLowerCase();\n              params.envMap = this._loadTexture(fileNames[1], textures);\n              params.combine = extension === \".sph\" ? MultiplyOperation : AddOperation;\n            }\n          }\n\n          var toonFileName = material.toonIndex === -1 ? \"toon00.bmp\" : data.toonTextures[material.toonIndex].fileName;\n          params.gradientMap = this._loadTexture(toonFileName, textures, {\n            isToonTexture: true,\n            isDefaultToonTexture: this._isDefaultToonTexture(toonFileName)\n          });\n          params.userData.outlineParameters = {\n            thickness: material.edgeFlag === 1 ? 3e-3 : 0,\n            color: [0, 0, 0],\n            alpha: 1,\n            visible: material.edgeFlag === 1\n          };\n        } else {\n          if (material.textureIndex !== -1) {\n            params.map = this._loadTexture(data.textures[material.textureIndex], textures);\n          }\n\n          if (material.envTextureIndex !== -1 && (material.envFlag === 1 || material.envFlag == 2)) {\n            params.envMap = this._loadTexture(data.textures[material.envTextureIndex], textures);\n            params.combine = material.envFlag === 1 ? MultiplyOperation : AddOperation;\n          }\n\n          var _toonFileName = void 0,\n              isDefaultToon = void 0;\n\n          if (material.toonIndex === -1 || material.toonFlag !== 0) {\n            _toonFileName = \"toon\" + (\"0\" + (material.toonIndex + 1)).slice(-2) + \".bmp\";\n            isDefaultToon = true;\n          } else {\n            _toonFileName = data.textures[material.toonIndex];\n            isDefaultToon = false;\n          }\n\n          params.gradientMap = this._loadTexture(_toonFileName, textures, {\n            isToonTexture: true,\n            isDefaultToonTexture: isDefaultToon\n          });\n          params.userData.outlineParameters = {\n            thickness: material.edgeSize / 300,\n            // TODO: better calculation?\n            color: material.edgeColor.slice(0, 3),\n            alpha: material.edgeColor[3],\n            visible: (material.flag & 16) !== 0 && material.edgeSize > 0\n          };\n        }\n\n        if (params.map !== void 0) {\n          if (!params.transparent) {\n            this._checkImageTransparency(params.map, geometry, i);\n          }\n\n          params.emissive.multiplyScalar(0.2);\n        }\n\n        materials.push(new MeshToonMaterial(params));\n      }\n\n      if (data.metadata.format === \"pmx\") {\n        var checkAlphaMorph = function checkAlphaMorph(elements, materials2) {\n          for (var _i15 = 0, il = elements.length; _i15 < il; _i15++) {\n            var element = elements[_i15];\n            if (element.index === -1) continue;\n            var _material = materials2[element.index];\n\n            if (_material.opacity !== element.diffuse[3]) {\n              _material.transparent = true;\n            }\n          }\n        };\n\n        for (var _i16 = 0, il = data.morphs.length; _i16 < il; _i16++) {\n          var morph = data.morphs[_i16];\n          var elements = morph.elements;\n\n          if (morph.type === 0) {\n            for (var j = 0, jl = elements.length; j < jl; j++) {\n              var morph2 = data.morphs[elements[j].index];\n              if (morph2.type !== 8) continue;\n              checkAlphaMorph(morph2.elements, materials);\n            }\n          } else if (morph.type === 8) {\n            checkAlphaMorph(elements, materials);\n          }\n        }\n      }\n\n      return materials;\n    } // private methods\n\n  }, {\n    key: \"_getTGALoader\",\n    value: function _getTGALoader() {\n      if (this.tgaLoader === null) {\n        if (TGALoader === void 0) {\n          throw new Error(\"THREE.MMDLoader: Import TGALoader\");\n        }\n\n        this.tgaLoader = new TGALoader(this.manager);\n      }\n\n      return this.tgaLoader;\n    }\n  }, {\n    key: \"_isDefaultToonTexture\",\n    value: function _isDefaultToonTexture(name) {\n      if (name.length !== 10) return false;\n      return /toon(10|0[0-9])\\.bmp/.test(name);\n    }\n  }, {\n    key: \"_loadTexture\",\n    value: function _loadTexture(filePath, textures, params, onProgress, onError) {\n      params = params || {};\n      var scope = this;\n      var fullPath;\n\n      if (params.isDefaultToonTexture === true) {\n        var index;\n\n        try {\n          index = parseInt(filePath.match(/toon([0-9]{2})\\.bmp$/)[1]);\n        } catch (e) {\n          console.warn(\"THREE.MMDLoader: \" + filePath + \" seems like a not right default texture path. Using toon00.bmp instead.\");\n          index = 0;\n        }\n\n        fullPath = DEFAULT_TOON_TEXTURES[index];\n      } else {\n        fullPath = this.resourcePath + filePath;\n      }\n\n      if (textures[fullPath] !== void 0) return textures[fullPath];\n      var loader = this.manager.getHandler(fullPath);\n\n      if (loader === null) {\n        loader = filePath.slice(-4).toLowerCase() === \".tga\" ? this._getTGALoader() : this.textureLoader;\n      }\n\n      var texture = loader.load(fullPath, function (t) {\n        if (params.isToonTexture === true) {\n          t.image = scope._getRotatedImage(t.image);\n          t.magFilter = NearestFilter;\n          t.minFilter = NearestFilter;\n        }\n\n        t.flipY = false;\n        t.wrapS = RepeatWrapping;\n        t.wrapT = RepeatWrapping;\n\n        for (var i = 0; i < texture.readyCallbacks.length; i++) {\n          texture.readyCallbacks[i](texture);\n        }\n\n        delete texture.readyCallbacks;\n      }, onProgress, onError);\n      texture.readyCallbacks = [];\n      textures[fullPath] = texture;\n      return texture;\n    }\n  }, {\n    key: \"_getRotatedImage\",\n    value: function _getRotatedImage(image) {\n      var canvas = document.createElement(\"canvas\");\n      var context = canvas.getContext(\"2d\");\n      var width = image.width;\n      var height = image.height;\n      canvas.width = width;\n      canvas.height = height;\n      context.clearRect(0, 0, width, height);\n      context.translate(width / 2, height / 2);\n      context.rotate(0.5 * Math.PI);\n      context.translate(-width / 2, -height / 2);\n      context.drawImage(image, 0, 0);\n      return context.getImageData(0, 0, width, height);\n    } // Check if the partial image area used by the texture is transparent.\n\n  }, {\n    key: \"_checkImageTransparency\",\n    value: function _checkImageTransparency(map, geometry, groupIndex) {\n      map.readyCallbacks.push(function (texture) {\n        function createImageData(image) {\n          var canvas = document.createElement(\"canvas\");\n          canvas.width = image.width;\n          canvas.height = image.height;\n          var context = canvas.getContext(\"2d\");\n          context.drawImage(image, 0, 0);\n          return context.getImageData(0, 0, canvas.width, canvas.height);\n        }\n\n        function detectImageTransparency(image, uvs, indices) {\n          var width = image.width;\n          var height = image.height;\n          var data = image.data;\n          var threshold = 253;\n          if (data.length / (width * height) !== 4) return false;\n\n          for (var i = 0; i < indices.length; i += 3) {\n            var centerUV = {\n              x: 0,\n              y: 0\n            };\n\n            for (var j = 0; j < 3; j++) {\n              var index = indices[i * 3 + j];\n              var uv = {\n                x: uvs[index * 2 + 0],\n                y: uvs[index * 2 + 1]\n              };\n              if (getAlphaByUv(image, uv) < threshold) return true;\n              centerUV.x += uv.x;\n              centerUV.y += uv.y;\n            }\n\n            centerUV.x /= 3;\n            centerUV.y /= 3;\n            if (getAlphaByUv(image, centerUV) < threshold) return true;\n          }\n\n          return false;\n        }\n\n        function getAlphaByUv(image, uv) {\n          var width = image.width;\n          var height = image.height;\n          var x = Math.round(uv.x * width) % width;\n          var y = Math.round(uv.y * height) % height;\n          if (x < 0) x += width;\n          if (y < 0) y += height;\n          var index = y * width + x;\n          return image.data[index * 4 + 3];\n        }\n\n        var imageData = texture.image.data !== void 0 ? texture.image : createImageData(texture.image);\n        var group = geometry.groups[groupIndex];\n\n        if (detectImageTransparency(imageData, geometry.attributes.uv.array, geometry.index.array.slice(group.start, group.start + group.count))) {\n          map.transparent = true;\n        }\n      });\n    }\n  }]);\n\n  return MaterialBuilder;\n}();\n\nvar AnimationBuilder = /*#__PURE__*/function () {\n  function AnimationBuilder() {\n    _classCallCheck(this, AnimationBuilder);\n  }\n\n  _createClass(AnimationBuilder, [{\n    key: \"build\",\n    value:\n    /**\n     * @param {Object} vmd - parsed VMD data\n     * @param {SkinnedMesh} mesh - tracks will be fitting to mesh\n     * @return {AnimationClip}\n     */\n    function build(vmd, mesh) {\n      var tracks = this.buildSkeletalAnimation(vmd, mesh).tracks;\n      var tracks2 = this.buildMorphAnimation(vmd, mesh).tracks;\n\n      for (var i = 0, il = tracks2.length; i < il; i++) {\n        tracks.push(tracks2[i]);\n      }\n\n      return new AnimationClip(\"\", -1, tracks);\n    }\n    /**\n     * @param {Object} vmd - parsed VMD data\n     * @param {SkinnedMesh} mesh - tracks will be fitting to mesh\n     * @return {AnimationClip}\n     */\n\n  }, {\n    key: \"buildSkeletalAnimation\",\n    value: function buildSkeletalAnimation(vmd, mesh) {\n      function pushInterpolation(array, interpolation, index) {\n        array.push(interpolation[index + 0] / 127);\n        array.push(interpolation[index + 8] / 127);\n        array.push(interpolation[index + 4] / 127);\n        array.push(interpolation[index + 12] / 127);\n      }\n\n      var tracks = [];\n      var motions = {};\n      var bones = mesh.skeleton.bones;\n      var boneNameDictionary = {};\n\n      for (var i = 0, il = bones.length; i < il; i++) {\n        boneNameDictionary[bones[i].name] = true;\n      }\n\n      for (var _i17 = 0; _i17 < vmd.metadata.motionCount; _i17++) {\n        var motion = vmd.motions[_i17];\n        var boneName = motion.boneName;\n        if (boneNameDictionary[boneName] === void 0) continue;\n        motions[boneName] = motions[boneName] || [];\n        motions[boneName].push(motion);\n      }\n\n      for (var key in motions) {\n        var array = motions[key];\n        array.sort(function (a, b) {\n          return a.frameNum - b.frameNum;\n        });\n        var times = [];\n        var positions = [];\n        var rotations = [];\n        var pInterpolations = [];\n        var rInterpolations = [];\n        var basePosition = mesh.skeleton.getBoneByName(key).position.toArray();\n\n        for (var _i18 = 0, _il2 = array.length; _i18 < _il2; _i18++) {\n          var time = array[_i18].frameNum / 30;\n          var position = array[_i18].position;\n          var rotation = array[_i18].rotation;\n          var interpolation = array[_i18].interpolation;\n          times.push(time);\n\n          for (var j = 0; j < 3; j++) {\n            positions.push(basePosition[j] + position[j]);\n          }\n\n          for (var _j10 = 0; _j10 < 4; _j10++) {\n            rotations.push(rotation[_j10]);\n          }\n\n          for (var _j11 = 0; _j11 < 3; _j11++) {\n            pushInterpolation(pInterpolations, interpolation, _j11);\n          }\n\n          pushInterpolation(rInterpolations, interpolation, 3);\n        }\n\n        var targetName = \".bones[\" + key + \"]\";\n        tracks.push(this._createTrack(targetName + \".position\", VectorKeyframeTrack, times, positions, pInterpolations));\n        tracks.push(this._createTrack(targetName + \".quaternion\", QuaternionKeyframeTrack, times, rotations, rInterpolations));\n      }\n\n      return new AnimationClip(\"\", -1, tracks);\n    }\n    /**\n     * @param {Object} vmd - parsed VMD data\n     * @param {SkinnedMesh} mesh - tracks will be fitting to mesh\n     * @return {AnimationClip}\n     */\n\n  }, {\n    key: \"buildMorphAnimation\",\n    value: function buildMorphAnimation(vmd, mesh) {\n      var tracks = [];\n      var morphs = {};\n      var morphTargetDictionary = mesh.morphTargetDictionary;\n\n      for (var i = 0; i < vmd.metadata.morphCount; i++) {\n        var morph = vmd.morphs[i];\n        var morphName = morph.morphName;\n        if (morphTargetDictionary[morphName] === void 0) continue;\n        morphs[morphName] = morphs[morphName] || [];\n        morphs[morphName].push(morph);\n      }\n\n      for (var key in morphs) {\n        var array = morphs[key];\n        array.sort(function (a, b) {\n          return a.frameNum - b.frameNum;\n        });\n        var times = [];\n        var values = [];\n\n        for (var _i19 = 0, il = array.length; _i19 < il; _i19++) {\n          times.push(array[_i19].frameNum / 30);\n          values.push(array[_i19].weight);\n        }\n\n        tracks.push(new NumberKeyframeTrack(\".morphTargetInfluences[\" + morphTargetDictionary[key] + \"]\", times, values));\n      }\n\n      return new AnimationClip(\"\", -1, tracks);\n    }\n    /**\n     * @param {Object} vmd - parsed VMD data\n     * @return {AnimationClip}\n     */\n\n  }, {\n    key: \"buildCameraAnimation\",\n    value: function buildCameraAnimation(vmd) {\n      function pushVector3(array, vec) {\n        array.push(vec.x);\n        array.push(vec.y);\n        array.push(vec.z);\n      }\n\n      function pushQuaternion(array, q) {\n        array.push(q.x);\n        array.push(q.y);\n        array.push(q.z);\n        array.push(q.w);\n      }\n\n      function pushInterpolation(array, interpolation, index) {\n        array.push(interpolation[index * 4 + 0] / 127);\n        array.push(interpolation[index * 4 + 1] / 127);\n        array.push(interpolation[index * 4 + 2] / 127);\n        array.push(interpolation[index * 4 + 3] / 127);\n      }\n\n      var cameras = vmd.cameras === void 0 ? [] : vmd.cameras.slice();\n      cameras.sort(function (a, b) {\n        return a.frameNum - b.frameNum;\n      });\n      var times = [];\n      var centers = [];\n      var quaternions = [];\n      var positions = [];\n      var fovs = [];\n      var cInterpolations = [];\n      var qInterpolations = [];\n      var pInterpolations = [];\n      var fInterpolations = [];\n      var quaternion = new Quaternion();\n      var euler = new Euler();\n      var position = new Vector3();\n      var center = new Vector3();\n\n      for (var i = 0, il = cameras.length; i < il; i++) {\n        var motion = cameras[i];\n        var time = motion.frameNum / 30;\n        var pos = motion.position;\n        var rot = motion.rotation;\n        var distance = motion.distance;\n        var fov = motion.fov;\n        var interpolation = motion.interpolation;\n        times.push(time);\n        position.set(0, 0, -distance);\n        center.set(pos[0], pos[1], pos[2]);\n        euler.set(-rot[0], -rot[1], -rot[2]);\n        quaternion.setFromEuler(euler);\n        position.add(center);\n        position.applyQuaternion(quaternion);\n        pushVector3(centers, center);\n        pushQuaternion(quaternions, quaternion);\n        pushVector3(positions, position);\n        fovs.push(fov);\n\n        for (var j = 0; j < 3; j++) {\n          pushInterpolation(cInterpolations, interpolation, j);\n        }\n\n        pushInterpolation(qInterpolations, interpolation, 3);\n\n        for (var _j12 = 0; _j12 < 3; _j12++) {\n          pushInterpolation(pInterpolations, interpolation, 4);\n        }\n\n        pushInterpolation(fInterpolations, interpolation, 5);\n      }\n\n      var tracks = [];\n      tracks.push(this._createTrack(\"target.position\", VectorKeyframeTrack, times, centers, cInterpolations));\n      tracks.push(this._createTrack(\".quaternion\", QuaternionKeyframeTrack, times, quaternions, qInterpolations));\n      tracks.push(this._createTrack(\".position\", VectorKeyframeTrack, times, positions, pInterpolations));\n      tracks.push(this._createTrack(\".fov\", NumberKeyframeTrack, times, fovs, fInterpolations));\n      return new AnimationClip(\"\", -1, tracks);\n    } // private method\n\n  }, {\n    key: \"_createTrack\",\n    value: function _createTrack(node, typedKeyframeTrack, times, values, interpolations) {\n      if (times.length > 2) {\n        times = times.slice();\n        values = values.slice();\n        interpolations = interpolations.slice();\n        var stride = values.length / times.length;\n        var interpolateStride = interpolations.length / times.length;\n        var index = 1;\n\n        for (var aheadIndex = 2, endIndex = times.length; aheadIndex < endIndex; aheadIndex++) {\n          for (var i = 0; i < stride; i++) {\n            if (values[index * stride + i] !== values[(index - 1) * stride + i] || values[index * stride + i] !== values[aheadIndex * stride + i]) {\n              index++;\n              break;\n            }\n          }\n\n          if (aheadIndex > index) {\n            times[index] = times[aheadIndex];\n\n            for (var _i20 = 0; _i20 < stride; _i20++) {\n              values[index * stride + _i20] = values[aheadIndex * stride + _i20];\n            }\n\n            for (var _i21 = 0; _i21 < interpolateStride; _i21++) {\n              interpolations[index * interpolateStride + _i21] = interpolations[aheadIndex * interpolateStride + _i21];\n            }\n          }\n        }\n\n        times.length = index + 1;\n        values.length = (index + 1) * stride;\n        interpolations.length = (index + 1) * interpolateStride;\n      }\n\n      var track = new typedKeyframeTrack(node, times, values);\n\n      track.createInterpolant = function InterpolantFactoryMethodCubicBezier(result) {\n        return new CubicBezierInterpolation(this.times, this.values, this.getValueSize(), result, new Float32Array(interpolations));\n      };\n\n      return track;\n    }\n  }]);\n\n  return AnimationBuilder;\n}();\n\nvar CubicBezierInterpolation = /*#__PURE__*/function (_Interpolant) {\n  _inherits(CubicBezierInterpolation, _Interpolant);\n\n  var _super2 = _createSuper(CubicBezierInterpolation);\n\n  function CubicBezierInterpolation(parameterPositions, sampleValues, sampleSize, resultBuffer, params) {\n    var _this2;\n\n    _classCallCheck(this, CubicBezierInterpolation);\n\n    _this2 = _super2.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);\n    _this2.interpolationParams = params;\n    return _this2;\n  }\n\n  _createClass(CubicBezierInterpolation, [{\n    key: \"interpolate_\",\n    value: function interpolate_(i1, t0, t, t1) {\n      var result = this.resultBuffer;\n      var values = this.sampleValues;\n      var stride = this.valueSize;\n      var params = this.interpolationParams;\n      var offset1 = i1 * stride;\n      var offset0 = offset1 - stride;\n      var weight1 = t1 - t0 < 1 / 30 * 1.5 ? 0 : (t - t0) / (t1 - t0);\n\n      if (stride === 4) {\n        var x1 = params[i1 * 4 + 0];\n        var x2 = params[i1 * 4 + 1];\n        var y1 = params[i1 * 4 + 2];\n        var y2 = params[i1 * 4 + 3];\n\n        var ratio = this._calculate(x1, x2, y1, y2, weight1);\n\n        Quaternion.slerpFlat(result, 0, values, offset0, values, offset1, ratio);\n      } else if (stride === 3) {\n        for (var i = 0; i !== stride; ++i) {\n          var _x = params[i1 * 12 + i * 4 + 0];\n          var _x2 = params[i1 * 12 + i * 4 + 1];\n          var _y = params[i1 * 12 + i * 4 + 2];\n          var _y2 = params[i1 * 12 + i * 4 + 3];\n\n          var _ratio = this._calculate(_x, _x2, _y, _y2, weight1);\n\n          result[i] = values[offset0 + i] * (1 - _ratio) + values[offset1 + i] * _ratio;\n        }\n      } else {\n        var _x3 = params[i1 * 4 + 0];\n        var _x4 = params[i1 * 4 + 1];\n        var _y3 = params[i1 * 4 + 2];\n        var _y4 = params[i1 * 4 + 3];\n\n        var _ratio2 = this._calculate(_x3, _x4, _y3, _y4, weight1);\n\n        result[0] = values[offset0] * (1 - _ratio2) + values[offset1] * _ratio2;\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_calculate\",\n    value: function _calculate(x1, x2, y1, y2, x) {\n      var c = 0.5;\n      var t = c;\n      var s = 1 - t;\n      var loop = 15;\n      var eps = 1e-5;\n      var math = Math;\n      var sst3, stt3, ttt;\n\n      for (var i = 0; i < loop; i++) {\n        sst3 = 3 * s * s * t;\n        stt3 = 3 * s * t * t;\n        ttt = t * t * t;\n        var ft = sst3 * x1 + stt3 * x2 + ttt - x;\n        if (math.abs(ft) < eps) break;\n        c /= 2;\n        t += ft < 0 ? c : -c;\n        s = 1 - t;\n      }\n\n      return sst3 * y1 + stt3 * y2 + ttt;\n    }\n  }]);\n\n  return CubicBezierInterpolation;\n}(Interpolant);\n\nexport { MMDLoader };","map":{"version":3,"sources":["/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/three-stdlib/loaders/MMDLoader.js"],"names":["Loader","FileLoader","LoaderUtils","SkinnedMesh","Skeleton","Bone","Vector3","Float32BufferAttribute","BufferGeometry","Uint16BufferAttribute","TextureLoader","Color","CustomBlending","SrcAlphaFactor","OneMinusSrcAlphaFactor","DstAlphaFactor","DoubleSide","FrontSide","MultiplyOperation","AddOperation","MeshToonMaterial","NearestFilter","RepeatWrapping","AnimationClip","VectorKeyframeTrack","QuaternionKeyframeTrack","NumberKeyframeTrack","Quaternion","Euler","Interpolant","TGALoader","Parser","MMDLoader","manager","loader","parser","meshBuilder","MeshBuilder","animationBuilder","AnimationBuilder","animationPath","url","onLoad","onProgress","onError","builder","setCrossOrigin","crossOrigin","resourcePath","path","extractUrlBase","modelExtension","_extractExtension","toLowerCase","Error","data","build","object","loadVMD","vmd","isCamera","buildCameraAnimation","modelUrl","vmdUrl","scope","load","mesh","loadAnimation","animation","_getParser","setMimeType","setPath","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","buffer","parsePmd","parsePmx","urls","Array","isArray","vmds","vmdNum","length","i","il","push","parseVmd","mergeVmds","isUnicode","text","parseVpd","index","lastIndexOf","slice","DEFAULT_TOON_TEXTURES","geometryBuilder","GeometryBuilder","materialBuilder","MaterialBuilder","geometry","material","setResourcePath","skeleton","initBones","bind","bones","gbone","bone","name","position","fromArray","pos","quaternion","rotq","scl","scale","parent","add","updateMatrixWorld","positions","uvs","normals","indices","groups","skinIndices","skinWeights","morphTargets","morphPositions","iks","grants","rigidBodies","constraints","offset","boneTypeTable","metadata","vertexCount","v","vertices","j","jl","normal","uv","faceCount","face","faces","materialCount","materials","count","rigidBodyCount","body","value","boneIndex","type","Math","max","boneCount","boneData","transformationClass","parentIndex","rigidBodyType","format","ikCount","ik","param","target","effector","iteration","maxAngle","links","link","enabled","indexOf","limitation","angleLimitation","rotationMin","lowerLimitationAngle","rotationMax","upperLimitationAngle","tmp1","tmp2","traverse","entry","grant","visited","children","child","grantEntryMap","ratio","isLocal","affectRotation","affectPosition","rootEntry","grantEntry","parentGrantEntry","updateAttributes","attribute","morph","elementCount","element","elements","morphs","array","morphCount","params","morph2","rigidBody","key","constraintCount","constraint","bodyA","rigidBodyIndex1","bodyB","rigidBodyIndex2","setAttribute","setIndex","addGroup","morphAttributes","morphTargetsRelative","userData","MMD","computeBoundingSphere","textureLoader","tgaLoader","textures","color","diffuse","opacity","emissive","ambient","transparent","skinning","fog","blending","blendSrc","blendDst","blendSrcAlpha","blendDstAlpha","flag","side","fileName","fileNames","split","map","_loadTexture","extension","envMap","combine","toonFileName","toonIndex","toonTextures","gradientMap","isToonTexture","isDefaultToonTexture","_isDefaultToonTexture","outlineParameters","thickness","edgeFlag","alpha","visible","textureIndex","envTextureIndex","envFlag","isDefaultToon","toonFlag","edgeSize","edgeColor","_checkImageTransparency","multiplyScalar","checkAlphaMorph","materials2","test","filePath","fullPath","parseInt","match","e","console","warn","getHandler","_getTGALoader","texture","t","image","_getRotatedImage","magFilter","minFilter","flipY","wrapS","wrapT","readyCallbacks","canvas","document","createElement","context","getContext","width","height","clearRect","translate","rotate","PI","drawImage","getImageData","groupIndex","createImageData","detectImageTransparency","threshold","centerUV","x","y","getAlphaByUv","round","imageData","group","attributes","start","tracks","buildSkeletalAnimation","tracks2","buildMorphAnimation","pushInterpolation","interpolation","motions","boneNameDictionary","motionCount","motion","boneName","sort","a","b","frameNum","times","rotations","pInterpolations","rInterpolations","basePosition","getBoneByName","toArray","time","rotation","targetName","_createTrack","morphTargetDictionary","morphName","values","weight","pushVector3","vec","z","pushQuaternion","q","w","cameras","centers","quaternions","fovs","cInterpolations","qInterpolations","fInterpolations","euler","center","rot","distance","fov","set","setFromEuler","applyQuaternion","node","typedKeyframeTrack","interpolations","stride","interpolateStride","aheadIndex","endIndex","track","createInterpolant","InterpolantFactoryMethodCubicBezier","result","CubicBezierInterpolation","getValueSize","Float32Array","parameterPositions","sampleValues","sampleSize","resultBuffer","interpolationParams","i1","t0","t1","valueSize","offset1","offset0","weight1","x1","x2","y1","y2","_calculate","slerpFlat","c","s","loop","eps","math","sst3","stt3","ttt","ft","abs"],"mappings":"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","sourcesContent":["import { Loader, FileLoader, LoaderUtils, SkinnedMesh, Skeleton, Bone, Vector3, Float32BufferAttribute, BufferGeometry, Uint16BufferAttribute, TextureLoader, Color, CustomBlending, SrcAlphaFactor, OneMinusSrcAlphaFactor, DstAlphaFactor, DoubleSide, FrontSide, MultiplyOperation, AddOperation, MeshToonMaterial, NearestFilter, RepeatWrapping, AnimationClip, VectorKeyframeTrack, QuaternionKeyframeTrack, NumberKeyframeTrack, Quaternion, Euler, Interpolant } from \"three\";\nimport { TGALoader } from \"./TGALoader.js\";\nimport { Parser } from \"mmd-parser\";\nclass MMDLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.loader = new FileLoader(this.manager);\n    this.parser = null;\n    this.meshBuilder = new MeshBuilder(this.manager);\n    this.animationBuilder = new AnimationBuilder();\n  }\n  /**\n   * @param {string} animationPath\n   * @return {MMDLoader}\n   */\n  setAnimationPath(animationPath) {\n    this.animationPath = animationPath;\n    return this;\n  }\n  // Load MMD assets as Three.js Object\n  /**\n   * Loads Model file (.pmd or .pmx) as a SkinnedMesh.\n   *\n   * @param {string} url - url to Model(.pmd or .pmx) file\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n  load(url, onLoad, onProgress, onError) {\n    const builder = this.meshBuilder.setCrossOrigin(this.crossOrigin);\n    let resourcePath;\n    if (this.resourcePath !== \"\") {\n      resourcePath = this.resourcePath;\n    } else if (this.path !== \"\") {\n      resourcePath = this.path;\n    } else {\n      resourcePath = LoaderUtils.extractUrlBase(url);\n    }\n    const modelExtension = this._extractExtension(url).toLowerCase();\n    if (modelExtension !== \"pmd\" && modelExtension !== \"pmx\") {\n      if (onError)\n        onError(new Error(\"THREE.MMDLoader: Unknown model file extension .\" + modelExtension + \".\"));\n      return;\n    }\n    this[modelExtension === \"pmd\" ? \"loadPMD\" : \"loadPMX\"](\n      url,\n      function(data) {\n        onLoad(builder.build(data, resourcePath, onProgress, onError));\n      },\n      onProgress,\n      onError\n    );\n  }\n  /**\n   * Loads Motion file(s) (.vmd) as a AnimationClip.\n   * If two or more files are specified, they'll be merged.\n   *\n   * @param {string|Array<string>} url - url(s) to animation(.vmd) file(s)\n   * @param {SkinnedMesh|THREE.Camera} object - tracks will be fitting to this object\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n  loadAnimation(url, object, onLoad, onProgress, onError) {\n    const builder = this.animationBuilder;\n    this.loadVMD(\n      url,\n      function(vmd) {\n        onLoad(object.isCamera ? builder.buildCameraAnimation(vmd) : builder.build(vmd, object));\n      },\n      onProgress,\n      onError\n    );\n  }\n  /**\n   * Loads mode file and motion file(s) as an object containing\n   * a SkinnedMesh and a AnimationClip.\n   * Tracks of AnimationClip are fitting to the model.\n   *\n   * @param {string} modelUrl - url to Model(.pmd or .pmx) file\n   * @param {string|Array{string}} vmdUrl - url(s) to animation(.vmd) file\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n  loadWithAnimation(modelUrl, vmdUrl, onLoad, onProgress, onError) {\n    const scope = this;\n    this.load(\n      modelUrl,\n      function(mesh) {\n        scope.loadAnimation(\n          vmdUrl,\n          mesh,\n          function(animation) {\n            onLoad({\n              mesh,\n              animation\n            });\n          },\n          onProgress,\n          onError\n        );\n      },\n      onProgress,\n      onError\n    );\n  }\n  // Load MMD assets as Object data parsed by MMDParser\n  /**\n   * Loads .pmd file as an Object.\n   *\n   * @param {string} url - url to .pmd file\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n  loadPMD(url, onLoad, onProgress, onError) {\n    const parser = this._getParser();\n    this.loader.setMimeType(void 0).setPath(this.path).setResponseType(\"arraybuffer\").setRequestHeader(this.requestHeader).setWithCredentials(this.withCredentials).load(\n      url,\n      function(buffer) {\n        onLoad(parser.parsePmd(buffer, true));\n      },\n      onProgress,\n      onError\n    );\n  }\n  /**\n   * Loads .pmx file as an Object.\n   *\n   * @param {string} url - url to .pmx file\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n  loadPMX(url, onLoad, onProgress, onError) {\n    const parser = this._getParser();\n    this.loader.setMimeType(void 0).setPath(this.path).setResponseType(\"arraybuffer\").setRequestHeader(this.requestHeader).setWithCredentials(this.withCredentials).load(\n      url,\n      function(buffer) {\n        onLoad(parser.parsePmx(buffer, true));\n      },\n      onProgress,\n      onError\n    );\n  }\n  /**\n   * Loads .vmd file as an Object. If two or more files are specified\n   * they'll be merged.\n   *\n   * @param {string|Array<string>} url - url(s) to .vmd file(s)\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n  loadVMD(url, onLoad, onProgress, onError) {\n    const urls = Array.isArray(url) ? url : [url];\n    const vmds = [];\n    const vmdNum = urls.length;\n    const parser = this._getParser();\n    this.loader.setMimeType(void 0).setPath(this.animationPath).setResponseType(\"arraybuffer\").setRequestHeader(this.requestHeader).setWithCredentials(this.withCredentials);\n    for (let i = 0, il = urls.length; i < il; i++) {\n      this.loader.load(\n        urls[i],\n        function(buffer) {\n          vmds.push(parser.parseVmd(buffer, true));\n          if (vmds.length === vmdNum)\n            onLoad(parser.mergeVmds(vmds));\n        },\n        onProgress,\n        onError\n      );\n    }\n  }\n  /**\n   * Loads .vpd file as an Object.\n   *\n   * @param {string} url - url to .vpd file\n   * @param {boolean} isUnicode\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n  loadVPD(url, isUnicode, onLoad, onProgress, onError) {\n    const parser = this._getParser();\n    this.loader.setMimeType(isUnicode ? void 0 : \"text/plain; charset=shift_jis\").setPath(this.animationPath).setResponseType(\"text\").setRequestHeader(this.requestHeader).setWithCredentials(this.withCredentials).load(\n      url,\n      function(text) {\n        onLoad(parser.parseVpd(text, true));\n      },\n      onProgress,\n      onError\n    );\n  }\n  // private methods\n  _extractExtension(url) {\n    const index = url.lastIndexOf(\".\");\n    return index < 0 ? \"\" : url.slice(index + 1);\n  }\n  _getParser() {\n    if (this.parser === null) {\n      this.parser = new Parser();\n    }\n    return this.parser;\n  }\n}\nconst DEFAULT_TOON_TEXTURES = [\n  \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=\",\n  \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAN0lEQVRYR+3WQREAMBACsZ5/bWiiMvgEBTt5cW37hjsBBAgQIECAwFwgyfYPCCBAgAABAgTWAh8aBHZBl14e8wAAAABJRU5ErkJggg==\",\n  \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAOUlEQVRYR+3WMREAMAwDsYY/yoDI7MLwIiP40+RJklfcCCBAgAABAgTqArfb/QMCCBAgQIAAgbbAB3z/e0F3js2cAAAAAElFTkSuQmCC\",\n  \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAN0lEQVRYR+3WQREAMBACsZ5/B5ilMvgEBTt5cW37hjsBBAgQIECAwFwgyfYPCCBAgAABAgTWAh81dWyx0gFwKAAAAABJRU5ErkJggg==\",\n  \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAOklEQVRYR+3WoREAMAwDsWb/UQtCy9wxTOQJ/oQ8SXKKGwEECBAgQIBAXeDt7f4BAQQIECBAgEBb4AOz8Hzx7WLY4wAAAABJRU5ErkJggg==\",\n  \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABPUlEQVRYR+1XwW7CMAy1+f9fZOMysSEOEweEOPRNdm3HbdOyIhAcklPrOs/PLy9RygBALxzcCDQFmgJNgaZAU6Ap0BR4PwX8gsRMVLssMRH5HcpzJEaWL7EVg9F1IHRlyqQohgVr4FGUlUcMJSjcUlDw0zvjeun70cLWmneoyf7NgBTQSniBTQQSuJAZsOnnaczjIMb5hCiuHKxokCrJfVnrctyZL0PkJAJe1HMil4nxeyi3Ypfn1kX51jpPvo/JeCNC4PhVdHdJw2XjBR8brF8PEIhNVn12AgP7uHsTBguBn53MUZCqv7Lp07Pn5k1Ro+uWmUNn7D+M57rtk7aG0Vo73xyF/fbFf0bPJjDXngnGocDTdFhygZjwUQrMNrDcmZlQT50VJ/g/UwNyHpu778+yW+/ksOz/BFo54P4AsUXMfRq7XWsAAAAASUVORK5CYII=\",\n  \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAACMElEQVRYR+2Xv4pTQRTGf2dubhLdICiii2KnYKHVolhauKWPoGAnNr6BD6CvIVaihYuI2i1ia0BY0MZGRHQXjZj/mSPnnskfNWiWZUlzJ5k7M2cm833nO5Mziej2DWWJRUoCpQKlAntSQCqgw39/iUWAGmh37jrRnVsKlgpiqmkoGVABA7E57fvY+pJDdgKqF6HzFCSADkDq+F6AHABtQ+UMVE5D7zXod7fFNhTEckTbj5XQgHzNN+5tQvc5NG7C6BNkp6D3EmpXHDR+dQAjFLchW3VS9rlw3JBh+B7ys5Cf9z0GW1C/7P32AyBAOAz1q4jGliIH3YPuBnSfQX4OGreTIgEYQb/pBDtPnEQ4CivXYPAWBk13oHrB54yA9QuSn2H4AcKRpEILDt0BUzj+RLR1V5EqjD66NPRBVpLcQwjHoHYJOhsQv6U4mnzmrIXJCFr4LDwm/xBUoboG9XX4cc9VKdYoSA2yk5NQLJaKDUjTBoveG3Z2TElTxwjNK4M3LEZgUdDdruvcXzKBpStgp2NPiWi3ks9ZXxIoFVi+AvHLdc9TqtjL3/aYjpPlrzOcEnK62Szhimdd7xX232zFDTgtxezOu3WNMRLjiKgjtOhHVMd1loynVHvOgjuIIJMaELEqhJAV/RCSLbWTcfPFakFgFlALTRRvx+ok6Hlp/Q+v3fmx90bMyUzaEAhmM3KvHlXTL5DxnbGf/1M8RNNACLL5MNtPxP/mypJAqcDSFfgFhpYqWUzhTEAAAAAASUVORK5CYII=\",\n  \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=\",\n  \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=\",\n  \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=\",\n  \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=\"\n];\nclass MeshBuilder {\n  constructor(manager) {\n    this.crossOrigin = \"anonymous\";\n    this.geometryBuilder = new GeometryBuilder();\n    this.materialBuilder = new MaterialBuilder(manager);\n  }\n  /**\n   * @param {string} crossOrigin\n   * @return {MeshBuilder}\n   */\n  setCrossOrigin(crossOrigin) {\n    this.crossOrigin = crossOrigin;\n    return this;\n  }\n  /**\n   * @param {Object} data - parsed PMD/PMX data\n   * @param {string} resourcePath\n   * @param {function} onProgress\n   * @param {function} onError\n   * @return {SkinnedMesh}\n   */\n  build(data, resourcePath, onProgress, onError) {\n    const geometry = this.geometryBuilder.build(data);\n    const material = this.materialBuilder.setCrossOrigin(this.crossOrigin).setResourcePath(resourcePath).build(data, geometry, onProgress, onError);\n    const mesh = new SkinnedMesh(geometry, material);\n    const skeleton = new Skeleton(initBones(mesh));\n    mesh.bind(skeleton);\n    return mesh;\n  }\n}\nfunction initBones(mesh) {\n  const geometry = mesh.geometry;\n  const bones = [];\n  if (geometry && geometry.bones !== void 0) {\n    for (let i = 0, il = geometry.bones.length; i < il; i++) {\n      const gbone = geometry.bones[i];\n      const bone = new Bone();\n      bones.push(bone);\n      bone.name = gbone.name;\n      bone.position.fromArray(gbone.pos);\n      bone.quaternion.fromArray(gbone.rotq);\n      if (gbone.scl !== void 0)\n        bone.scale.fromArray(gbone.scl);\n    }\n    for (let i = 0, il = geometry.bones.length; i < il; i++) {\n      const gbone = geometry.bones[i];\n      if (gbone.parent !== -1 && gbone.parent !== null && bones[gbone.parent] !== void 0) {\n        bones[gbone.parent].add(bones[i]);\n      } else {\n        mesh.add(bones[i]);\n      }\n    }\n  }\n  mesh.updateMatrixWorld(true);\n  return bones;\n}\nclass GeometryBuilder {\n  /**\n   * @param {Object} data - parsed PMD/PMX data\n   * @return {BufferGeometry}\n   */\n  build(data) {\n    const positions = [];\n    const uvs = [];\n    const normals = [];\n    const indices = [];\n    const groups = [];\n    const bones = [];\n    const skinIndices = [];\n    const skinWeights = [];\n    const morphTargets = [];\n    const morphPositions = [];\n    const iks = [];\n    const grants = [];\n    const rigidBodies = [];\n    const constraints = [];\n    let offset = 0;\n    const boneTypeTable = {};\n    for (let i = 0; i < data.metadata.vertexCount; i++) {\n      const v = data.vertices[i];\n      for (let j = 0, jl = v.position.length; j < jl; j++) {\n        positions.push(v.position[j]);\n      }\n      for (let j = 0, jl = v.normal.length; j < jl; j++) {\n        normals.push(v.normal[j]);\n      }\n      for (let j = 0, jl = v.uv.length; j < jl; j++) {\n        uvs.push(v.uv[j]);\n      }\n      for (let j = 0; j < 4; j++) {\n        skinIndices.push(v.skinIndices.length - 1 >= j ? v.skinIndices[j] : 0);\n      }\n      for (let j = 0; j < 4; j++) {\n        skinWeights.push(v.skinWeights.length - 1 >= j ? v.skinWeights[j] : 0);\n      }\n    }\n    for (let i = 0; i < data.metadata.faceCount; i++) {\n      const face = data.faces[i];\n      for (let j = 0, jl = face.indices.length; j < jl; j++) {\n        indices.push(face.indices[j]);\n      }\n    }\n    for (let i = 0; i < data.metadata.materialCount; i++) {\n      const material = data.materials[i];\n      groups.push({\n        offset: offset * 3,\n        count: material.faceCount * 3\n      });\n      offset += material.faceCount;\n    }\n    for (let i = 0; i < data.metadata.rigidBodyCount; i++) {\n      const body = data.rigidBodies[i];\n      let value = boneTypeTable[body.boneIndex];\n      value = value === void 0 ? body.type : Math.max(body.type, value);\n      boneTypeTable[body.boneIndex] = value;\n    }\n    for (let i = 0; i < data.metadata.boneCount; i++) {\n      const boneData = data.bones[i];\n      const bone = {\n        index: i,\n        transformationClass: boneData.transformationClass,\n        parent: boneData.parentIndex,\n        name: boneData.name,\n        pos: boneData.position.slice(0, 3),\n        rotq: [0, 0, 0, 1],\n        scl: [1, 1, 1],\n        rigidBodyType: boneTypeTable[i] !== void 0 ? boneTypeTable[i] : -1\n      };\n      if (bone.parent !== -1) {\n        bone.pos[0] -= data.bones[bone.parent].position[0];\n        bone.pos[1] -= data.bones[bone.parent].position[1];\n        bone.pos[2] -= data.bones[bone.parent].position[2];\n      }\n      bones.push(bone);\n    }\n    if (data.metadata.format === \"pmd\") {\n      for (let i = 0; i < data.metadata.ikCount; i++) {\n        const ik = data.iks[i];\n        const param = {\n          target: ik.target,\n          effector: ik.effector,\n          iteration: ik.iteration,\n          maxAngle: ik.maxAngle * 4,\n          links: []\n        };\n        for (let j = 0, jl = ik.links.length; j < jl; j++) {\n          const link = {};\n          link.index = ik.links[j].index;\n          link.enabled = true;\n          if (data.bones[link.index].name.indexOf(\"ひざ\") >= 0) {\n            link.limitation = new Vector3(1, 0, 0);\n          }\n          param.links.push(link);\n        }\n        iks.push(param);\n      }\n    } else {\n      for (let i = 0; i < data.metadata.boneCount; i++) {\n        const ik = data.bones[i].ik;\n        if (ik === void 0)\n          continue;\n        const param = {\n          target: i,\n          effector: ik.effector,\n          iteration: ik.iteration,\n          maxAngle: ik.maxAngle,\n          links: []\n        };\n        for (let j = 0, jl = ik.links.length; j < jl; j++) {\n          const link = {};\n          link.index = ik.links[j].index;\n          link.enabled = true;\n          if (ik.links[j].angleLimitation === 1) {\n            const rotationMin = ik.links[j].lowerLimitationAngle;\n            const rotationMax = ik.links[j].upperLimitationAngle;\n            const tmp1 = -rotationMax[0];\n            const tmp2 = -rotationMax[1];\n            rotationMax[0] = -rotationMin[0];\n            rotationMax[1] = -rotationMin[1];\n            rotationMin[0] = tmp1;\n            rotationMin[1] = tmp2;\n            link.rotationMin = new Vector3().fromArray(rotationMin);\n            link.rotationMax = new Vector3().fromArray(rotationMax);\n          }\n          param.links.push(link);\n        }\n        iks.push(param);\n        bones[i].ik = param;\n      }\n    }\n    if (data.metadata.format === \"pmx\") {\n      let traverse = function(entry) {\n        if (entry.param) {\n          grants.push(entry.param);\n          bones[entry.param.index].grant = entry.param;\n        }\n        entry.visited = true;\n        for (let i = 0, il = entry.children.length; i < il; i++) {\n          const child = entry.children[i];\n          if (!child.visited)\n            traverse(child);\n        }\n      };\n      const grantEntryMap = {};\n      for (let i = 0; i < data.metadata.boneCount; i++) {\n        const boneData = data.bones[i];\n        const grant = boneData.grant;\n        if (grant === void 0)\n          continue;\n        const param = {\n          index: i,\n          parentIndex: grant.parentIndex,\n          ratio: grant.ratio,\n          isLocal: grant.isLocal,\n          affectRotation: grant.affectRotation,\n          affectPosition: grant.affectPosition,\n          transformationClass: boneData.transformationClass\n        };\n        grantEntryMap[i] = { parent: null, children: [], param, visited: false };\n      }\n      const rootEntry = { parent: null, children: [], param: null, visited: false };\n      for (const boneIndex in grantEntryMap) {\n        const grantEntry = grantEntryMap[boneIndex];\n        const parentGrantEntry = grantEntryMap[grantEntry.parentIndex] || rootEntry;\n        grantEntry.parent = parentGrantEntry;\n        parentGrantEntry.children.push(grantEntry);\n      }\n      traverse(rootEntry);\n    }\n    function updateAttributes(attribute, morph, ratio) {\n      for (let i = 0; i < morph.elementCount; i++) {\n        const element = morph.elements[i];\n        let index;\n        if (data.metadata.format === \"pmd\") {\n          index = data.morphs[0].elements[element.index].index;\n        } else {\n          index = element.index;\n        }\n        attribute.array[index * 3 + 0] += element.position[0] * ratio;\n        attribute.array[index * 3 + 1] += element.position[1] * ratio;\n        attribute.array[index * 3 + 2] += element.position[2] * ratio;\n      }\n    }\n    for (let i = 0; i < data.metadata.morphCount; i++) {\n      const morph = data.morphs[i];\n      const params = { name: morph.name };\n      const attribute = new Float32BufferAttribute(data.metadata.vertexCount * 3, 3);\n      attribute.name = morph.name;\n      for (let j = 0; j < data.metadata.vertexCount * 3; j++) {\n        attribute.array[j] = positions[j];\n      }\n      if (data.metadata.format === \"pmd\") {\n        if (i !== 0) {\n          updateAttributes(attribute, morph, 1);\n        }\n      } else {\n        if (morph.type === 0) {\n          for (let j = 0; j < morph.elementCount; j++) {\n            const morph2 = data.morphs[morph.elements[j].index];\n            const ratio = morph.elements[j].ratio;\n            if (morph2.type === 1) {\n              updateAttributes(attribute, morph2, ratio);\n            } else {\n            }\n          }\n        } else if (morph.type === 1) {\n          updateAttributes(attribute, morph, 1);\n        } else if (morph.type === 2) {\n        } else if (morph.type === 3) {\n        } else if (morph.type === 4) {\n        } else if (morph.type === 5) {\n        } else if (morph.type === 6) {\n        } else if (morph.type === 7) {\n        } else if (morph.type === 8) {\n        }\n      }\n      morphTargets.push(params);\n      morphPositions.push(attribute);\n    }\n    for (let i = 0; i < data.metadata.rigidBodyCount; i++) {\n      const rigidBody = data.rigidBodies[i];\n      const params = {};\n      for (const key in rigidBody) {\n        params[key] = rigidBody[key];\n      }\n      if (data.metadata.format === \"pmx\") {\n        if (params.boneIndex !== -1) {\n          const bone = data.bones[params.boneIndex];\n          params.position[0] -= bone.position[0];\n          params.position[1] -= bone.position[1];\n          params.position[2] -= bone.position[2];\n        }\n      }\n      rigidBodies.push(params);\n    }\n    for (let i = 0; i < data.metadata.constraintCount; i++) {\n      const constraint = data.constraints[i];\n      const params = {};\n      for (const key in constraint) {\n        params[key] = constraint[key];\n      }\n      const bodyA = rigidBodies[params.rigidBodyIndex1];\n      const bodyB = rigidBodies[params.rigidBodyIndex2];\n      if (bodyA.type !== 0 && bodyB.type === 2) {\n        if (bodyA.boneIndex !== -1 && bodyB.boneIndex !== -1 && data.bones[bodyB.boneIndex].parentIndex === bodyA.boneIndex) {\n          bodyB.type = 1;\n        }\n      }\n      constraints.push(params);\n    }\n    const geometry = new BufferGeometry();\n    geometry.setAttribute(\"position\", new Float32BufferAttribute(positions, 3));\n    geometry.setAttribute(\"normal\", new Float32BufferAttribute(normals, 3));\n    geometry.setAttribute(\"uv\", new Float32BufferAttribute(uvs, 2));\n    geometry.setAttribute(\"skinIndex\", new Uint16BufferAttribute(skinIndices, 4));\n    geometry.setAttribute(\"skinWeight\", new Float32BufferAttribute(skinWeights, 4));\n    geometry.setIndex(indices);\n    for (let i = 0, il = groups.length; i < il; i++) {\n      geometry.addGroup(groups[i].offset, groups[i].count, i);\n    }\n    geometry.bones = bones;\n    geometry.morphTargets = morphTargets;\n    geometry.morphAttributes.position = morphPositions;\n    geometry.morphTargetsRelative = false;\n    geometry.userData.MMD = {\n      bones,\n      iks,\n      grants,\n      rigidBodies,\n      constraints,\n      format: data.metadata.format\n    };\n    geometry.computeBoundingSphere();\n    return geometry;\n  }\n}\nclass MaterialBuilder {\n  constructor(manager) {\n    this.manager = manager;\n    this.textureLoader = new TextureLoader(this.manager);\n    this.tgaLoader = null;\n    this.crossOrigin = \"anonymous\";\n    this.resourcePath = void 0;\n  }\n  /**\n   * @param {string} crossOrigin\n   * @return {MaterialBuilder}\n   */\n  setCrossOrigin(crossOrigin) {\n    this.crossOrigin = crossOrigin;\n    return this;\n  }\n  /**\n   * @param {string} resourcePath\n   * @return {MaterialBuilder}\n   */\n  setResourcePath(resourcePath) {\n    this.resourcePath = resourcePath;\n    return this;\n  }\n  /**\n   * @param {Object} data - parsed PMD/PMX data\n   * @param {BufferGeometry} geometry - some properties are dependend on geometry\n   * @param {function} onProgress\n   * @param {function} onError\n   * @return {Array<MeshToonMaterial>}\n   */\n  build(data, geometry) {\n    const materials = [];\n    const textures = {};\n    this.textureLoader.setCrossOrigin(this.crossOrigin);\n    for (let i = 0; i < data.metadata.materialCount; i++) {\n      const material = data.materials[i];\n      const params = { userData: {} };\n      if (material.name !== void 0)\n        params.name = material.name;\n      params.color = new Color().fromArray(material.diffuse);\n      params.opacity = material.diffuse[3];\n      params.emissive = new Color().fromArray(material.ambient);\n      params.transparent = params.opacity !== 1;\n      params.skinning = geometry.bones.length > 0 ? true : false;\n      params.morphTargets = geometry.morphTargets.length > 0 ? true : false;\n      params.fog = true;\n      params.blending = CustomBlending;\n      params.blendSrc = SrcAlphaFactor;\n      params.blendDst = OneMinusSrcAlphaFactor;\n      params.blendSrcAlpha = SrcAlphaFactor;\n      params.blendDstAlpha = DstAlphaFactor;\n      if (data.metadata.format === \"pmx\" && (material.flag & 1) === 1) {\n        params.side = DoubleSide;\n      } else {\n        params.side = params.opacity === 1 ? FrontSide : DoubleSide;\n      }\n      if (data.metadata.format === \"pmd\") {\n        if (material.fileName) {\n          const fileName = material.fileName;\n          const fileNames = fileName.split(\"*\");\n          params.map = this._loadTexture(fileNames[0], textures);\n          if (fileNames.length > 1) {\n            const extension = fileNames[1].slice(-4).toLowerCase();\n            params.envMap = this._loadTexture(fileNames[1], textures);\n            params.combine = extension === \".sph\" ? MultiplyOperation : AddOperation;\n          }\n        }\n        const toonFileName = material.toonIndex === -1 ? \"toon00.bmp\" : data.toonTextures[material.toonIndex].fileName;\n        params.gradientMap = this._loadTexture(toonFileName, textures, {\n          isToonTexture: true,\n          isDefaultToonTexture: this._isDefaultToonTexture(toonFileName)\n        });\n        params.userData.outlineParameters = {\n          thickness: material.edgeFlag === 1 ? 3e-3 : 0,\n          color: [0, 0, 0],\n          alpha: 1,\n          visible: material.edgeFlag === 1\n        };\n      } else {\n        if (material.textureIndex !== -1) {\n          params.map = this._loadTexture(data.textures[material.textureIndex], textures);\n        }\n        if (material.envTextureIndex !== -1 && (material.envFlag === 1 || material.envFlag == 2)) {\n          params.envMap = this._loadTexture(data.textures[material.envTextureIndex], textures);\n          params.combine = material.envFlag === 1 ? MultiplyOperation : AddOperation;\n        }\n        let toonFileName, isDefaultToon;\n        if (material.toonIndex === -1 || material.toonFlag !== 0) {\n          toonFileName = \"toon\" + (\"0\" + (material.toonIndex + 1)).slice(-2) + \".bmp\";\n          isDefaultToon = true;\n        } else {\n          toonFileName = data.textures[material.toonIndex];\n          isDefaultToon = false;\n        }\n        params.gradientMap = this._loadTexture(toonFileName, textures, {\n          isToonTexture: true,\n          isDefaultToonTexture: isDefaultToon\n        });\n        params.userData.outlineParameters = {\n          thickness: material.edgeSize / 300,\n          // TODO: better calculation?\n          color: material.edgeColor.slice(0, 3),\n          alpha: material.edgeColor[3],\n          visible: (material.flag & 16) !== 0 && material.edgeSize > 0\n        };\n      }\n      if (params.map !== void 0) {\n        if (!params.transparent) {\n          this._checkImageTransparency(params.map, geometry, i);\n        }\n        params.emissive.multiplyScalar(0.2);\n      }\n      materials.push(new MeshToonMaterial(params));\n    }\n    if (data.metadata.format === \"pmx\") {\n      let checkAlphaMorph = function(elements, materials2) {\n        for (let i = 0, il = elements.length; i < il; i++) {\n          const element = elements[i];\n          if (element.index === -1)\n            continue;\n          const material = materials2[element.index];\n          if (material.opacity !== element.diffuse[3]) {\n            material.transparent = true;\n          }\n        }\n      };\n      for (let i = 0, il = data.morphs.length; i < il; i++) {\n        const morph = data.morphs[i];\n        const elements = morph.elements;\n        if (morph.type === 0) {\n          for (let j = 0, jl = elements.length; j < jl; j++) {\n            const morph2 = data.morphs[elements[j].index];\n            if (morph2.type !== 8)\n              continue;\n            checkAlphaMorph(morph2.elements, materials);\n          }\n        } else if (morph.type === 8) {\n          checkAlphaMorph(elements, materials);\n        }\n      }\n    }\n    return materials;\n  }\n  // private methods\n  _getTGALoader() {\n    if (this.tgaLoader === null) {\n      if (TGALoader === void 0) {\n        throw new Error(\"THREE.MMDLoader: Import TGALoader\");\n      }\n      this.tgaLoader = new TGALoader(this.manager);\n    }\n    return this.tgaLoader;\n  }\n  _isDefaultToonTexture(name) {\n    if (name.length !== 10)\n      return false;\n    return /toon(10|0[0-9])\\.bmp/.test(name);\n  }\n  _loadTexture(filePath, textures, params, onProgress, onError) {\n    params = params || {};\n    const scope = this;\n    let fullPath;\n    if (params.isDefaultToonTexture === true) {\n      let index;\n      try {\n        index = parseInt(filePath.match(/toon([0-9]{2})\\.bmp$/)[1]);\n      } catch (e) {\n        console.warn(\n          \"THREE.MMDLoader: \" + filePath + \" seems like a not right default texture path. Using toon00.bmp instead.\"\n        );\n        index = 0;\n      }\n      fullPath = DEFAULT_TOON_TEXTURES[index];\n    } else {\n      fullPath = this.resourcePath + filePath;\n    }\n    if (textures[fullPath] !== void 0)\n      return textures[fullPath];\n    let loader = this.manager.getHandler(fullPath);\n    if (loader === null) {\n      loader = filePath.slice(-4).toLowerCase() === \".tga\" ? this._getTGALoader() : this.textureLoader;\n    }\n    const texture = loader.load(\n      fullPath,\n      function(t) {\n        if (params.isToonTexture === true) {\n          t.image = scope._getRotatedImage(t.image);\n          t.magFilter = NearestFilter;\n          t.minFilter = NearestFilter;\n        }\n        t.flipY = false;\n        t.wrapS = RepeatWrapping;\n        t.wrapT = RepeatWrapping;\n        for (let i = 0; i < texture.readyCallbacks.length; i++) {\n          texture.readyCallbacks[i](texture);\n        }\n        delete texture.readyCallbacks;\n      },\n      onProgress,\n      onError\n    );\n    texture.readyCallbacks = [];\n    textures[fullPath] = texture;\n    return texture;\n  }\n  _getRotatedImage(image) {\n    const canvas = document.createElement(\"canvas\");\n    const context = canvas.getContext(\"2d\");\n    const width = image.width;\n    const height = image.height;\n    canvas.width = width;\n    canvas.height = height;\n    context.clearRect(0, 0, width, height);\n    context.translate(width / 2, height / 2);\n    context.rotate(0.5 * Math.PI);\n    context.translate(-width / 2, -height / 2);\n    context.drawImage(image, 0, 0);\n    return context.getImageData(0, 0, width, height);\n  }\n  // Check if the partial image area used by the texture is transparent.\n  _checkImageTransparency(map, geometry, groupIndex) {\n    map.readyCallbacks.push(function(texture) {\n      function createImageData(image) {\n        const canvas = document.createElement(\"canvas\");\n        canvas.width = image.width;\n        canvas.height = image.height;\n        const context = canvas.getContext(\"2d\");\n        context.drawImage(image, 0, 0);\n        return context.getImageData(0, 0, canvas.width, canvas.height);\n      }\n      function detectImageTransparency(image, uvs, indices) {\n        const width = image.width;\n        const height = image.height;\n        const data = image.data;\n        const threshold = 253;\n        if (data.length / (width * height) !== 4)\n          return false;\n        for (let i = 0; i < indices.length; i += 3) {\n          const centerUV = { x: 0, y: 0 };\n          for (let j = 0; j < 3; j++) {\n            const index = indices[i * 3 + j];\n            const uv = { x: uvs[index * 2 + 0], y: uvs[index * 2 + 1] };\n            if (getAlphaByUv(image, uv) < threshold)\n              return true;\n            centerUV.x += uv.x;\n            centerUV.y += uv.y;\n          }\n          centerUV.x /= 3;\n          centerUV.y /= 3;\n          if (getAlphaByUv(image, centerUV) < threshold)\n            return true;\n        }\n        return false;\n      }\n      function getAlphaByUv(image, uv) {\n        const width = image.width;\n        const height = image.height;\n        let x = Math.round(uv.x * width) % width;\n        let y = Math.round(uv.y * height) % height;\n        if (x < 0)\n          x += width;\n        if (y < 0)\n          y += height;\n        const index = y * width + x;\n        return image.data[index * 4 + 3];\n      }\n      const imageData = texture.image.data !== void 0 ? texture.image : createImageData(texture.image);\n      const group = geometry.groups[groupIndex];\n      if (detectImageTransparency(\n        imageData,\n        geometry.attributes.uv.array,\n        geometry.index.array.slice(group.start, group.start + group.count)\n      )) {\n        map.transparent = true;\n      }\n    });\n  }\n}\nclass AnimationBuilder {\n  /**\n   * @param {Object} vmd - parsed VMD data\n   * @param {SkinnedMesh} mesh - tracks will be fitting to mesh\n   * @return {AnimationClip}\n   */\n  build(vmd, mesh) {\n    const tracks = this.buildSkeletalAnimation(vmd, mesh).tracks;\n    const tracks2 = this.buildMorphAnimation(vmd, mesh).tracks;\n    for (let i = 0, il = tracks2.length; i < il; i++) {\n      tracks.push(tracks2[i]);\n    }\n    return new AnimationClip(\"\", -1, tracks);\n  }\n  /**\n   * @param {Object} vmd - parsed VMD data\n   * @param {SkinnedMesh} mesh - tracks will be fitting to mesh\n   * @return {AnimationClip}\n   */\n  buildSkeletalAnimation(vmd, mesh) {\n    function pushInterpolation(array, interpolation, index) {\n      array.push(interpolation[index + 0] / 127);\n      array.push(interpolation[index + 8] / 127);\n      array.push(interpolation[index + 4] / 127);\n      array.push(interpolation[index + 12] / 127);\n    }\n    const tracks = [];\n    const motions = {};\n    const bones = mesh.skeleton.bones;\n    const boneNameDictionary = {};\n    for (let i = 0, il = bones.length; i < il; i++) {\n      boneNameDictionary[bones[i].name] = true;\n    }\n    for (let i = 0; i < vmd.metadata.motionCount; i++) {\n      const motion = vmd.motions[i];\n      const boneName = motion.boneName;\n      if (boneNameDictionary[boneName] === void 0)\n        continue;\n      motions[boneName] = motions[boneName] || [];\n      motions[boneName].push(motion);\n    }\n    for (const key in motions) {\n      const array = motions[key];\n      array.sort(function(a, b) {\n        return a.frameNum - b.frameNum;\n      });\n      const times = [];\n      const positions = [];\n      const rotations = [];\n      const pInterpolations = [];\n      const rInterpolations = [];\n      const basePosition = mesh.skeleton.getBoneByName(key).position.toArray();\n      for (let i = 0, il = array.length; i < il; i++) {\n        const time = array[i].frameNum / 30;\n        const position = array[i].position;\n        const rotation = array[i].rotation;\n        const interpolation = array[i].interpolation;\n        times.push(time);\n        for (let j = 0; j < 3; j++)\n          positions.push(basePosition[j] + position[j]);\n        for (let j = 0; j < 4; j++)\n          rotations.push(rotation[j]);\n        for (let j = 0; j < 3; j++)\n          pushInterpolation(pInterpolations, interpolation, j);\n        pushInterpolation(rInterpolations, interpolation, 3);\n      }\n      const targetName = \".bones[\" + key + \"]\";\n      tracks.push(this._createTrack(targetName + \".position\", VectorKeyframeTrack, times, positions, pInterpolations));\n      tracks.push(\n        this._createTrack(targetName + \".quaternion\", QuaternionKeyframeTrack, times, rotations, rInterpolations)\n      );\n    }\n    return new AnimationClip(\"\", -1, tracks);\n  }\n  /**\n   * @param {Object} vmd - parsed VMD data\n   * @param {SkinnedMesh} mesh - tracks will be fitting to mesh\n   * @return {AnimationClip}\n   */\n  buildMorphAnimation(vmd, mesh) {\n    const tracks = [];\n    const morphs = {};\n    const morphTargetDictionary = mesh.morphTargetDictionary;\n    for (let i = 0; i < vmd.metadata.morphCount; i++) {\n      const morph = vmd.morphs[i];\n      const morphName = morph.morphName;\n      if (morphTargetDictionary[morphName] === void 0)\n        continue;\n      morphs[morphName] = morphs[morphName] || [];\n      morphs[morphName].push(morph);\n    }\n    for (const key in morphs) {\n      const array = morphs[key];\n      array.sort(function(a, b) {\n        return a.frameNum - b.frameNum;\n      });\n      const times = [];\n      const values = [];\n      for (let i = 0, il = array.length; i < il; i++) {\n        times.push(array[i].frameNum / 30);\n        values.push(array[i].weight);\n      }\n      tracks.push(new NumberKeyframeTrack(\".morphTargetInfluences[\" + morphTargetDictionary[key] + \"]\", times, values));\n    }\n    return new AnimationClip(\"\", -1, tracks);\n  }\n  /**\n   * @param {Object} vmd - parsed VMD data\n   * @return {AnimationClip}\n   */\n  buildCameraAnimation(vmd) {\n    function pushVector3(array, vec) {\n      array.push(vec.x);\n      array.push(vec.y);\n      array.push(vec.z);\n    }\n    function pushQuaternion(array, q) {\n      array.push(q.x);\n      array.push(q.y);\n      array.push(q.z);\n      array.push(q.w);\n    }\n    function pushInterpolation(array, interpolation, index) {\n      array.push(interpolation[index * 4 + 0] / 127);\n      array.push(interpolation[index * 4 + 1] / 127);\n      array.push(interpolation[index * 4 + 2] / 127);\n      array.push(interpolation[index * 4 + 3] / 127);\n    }\n    const cameras = vmd.cameras === void 0 ? [] : vmd.cameras.slice();\n    cameras.sort(function(a, b) {\n      return a.frameNum - b.frameNum;\n    });\n    const times = [];\n    const centers = [];\n    const quaternions = [];\n    const positions = [];\n    const fovs = [];\n    const cInterpolations = [];\n    const qInterpolations = [];\n    const pInterpolations = [];\n    const fInterpolations = [];\n    const quaternion = new Quaternion();\n    const euler = new Euler();\n    const position = new Vector3();\n    const center = new Vector3();\n    for (let i = 0, il = cameras.length; i < il; i++) {\n      const motion = cameras[i];\n      const time = motion.frameNum / 30;\n      const pos = motion.position;\n      const rot = motion.rotation;\n      const distance = motion.distance;\n      const fov = motion.fov;\n      const interpolation = motion.interpolation;\n      times.push(time);\n      position.set(0, 0, -distance);\n      center.set(pos[0], pos[1], pos[2]);\n      euler.set(-rot[0], -rot[1], -rot[2]);\n      quaternion.setFromEuler(euler);\n      position.add(center);\n      position.applyQuaternion(quaternion);\n      pushVector3(centers, center);\n      pushQuaternion(quaternions, quaternion);\n      pushVector3(positions, position);\n      fovs.push(fov);\n      for (let j = 0; j < 3; j++) {\n        pushInterpolation(cInterpolations, interpolation, j);\n      }\n      pushInterpolation(qInterpolations, interpolation, 3);\n      for (let j = 0; j < 3; j++) {\n        pushInterpolation(pInterpolations, interpolation, 4);\n      }\n      pushInterpolation(fInterpolations, interpolation, 5);\n    }\n    const tracks = [];\n    tracks.push(this._createTrack(\"target.position\", VectorKeyframeTrack, times, centers, cInterpolations));\n    tracks.push(this._createTrack(\".quaternion\", QuaternionKeyframeTrack, times, quaternions, qInterpolations));\n    tracks.push(this._createTrack(\".position\", VectorKeyframeTrack, times, positions, pInterpolations));\n    tracks.push(this._createTrack(\".fov\", NumberKeyframeTrack, times, fovs, fInterpolations));\n    return new AnimationClip(\"\", -1, tracks);\n  }\n  // private method\n  _createTrack(node, typedKeyframeTrack, times, values, interpolations) {\n    if (times.length > 2) {\n      times = times.slice();\n      values = values.slice();\n      interpolations = interpolations.slice();\n      const stride = values.length / times.length;\n      const interpolateStride = interpolations.length / times.length;\n      let index = 1;\n      for (let aheadIndex = 2, endIndex = times.length; aheadIndex < endIndex; aheadIndex++) {\n        for (let i = 0; i < stride; i++) {\n          if (values[index * stride + i] !== values[(index - 1) * stride + i] || values[index * stride + i] !== values[aheadIndex * stride + i]) {\n            index++;\n            break;\n          }\n        }\n        if (aheadIndex > index) {\n          times[index] = times[aheadIndex];\n          for (let i = 0; i < stride; i++) {\n            values[index * stride + i] = values[aheadIndex * stride + i];\n          }\n          for (let i = 0; i < interpolateStride; i++) {\n            interpolations[index * interpolateStride + i] = interpolations[aheadIndex * interpolateStride + i];\n          }\n        }\n      }\n      times.length = index + 1;\n      values.length = (index + 1) * stride;\n      interpolations.length = (index + 1) * interpolateStride;\n    }\n    const track = new typedKeyframeTrack(node, times, values);\n    track.createInterpolant = function InterpolantFactoryMethodCubicBezier(result) {\n      return new CubicBezierInterpolation(\n        this.times,\n        this.values,\n        this.getValueSize(),\n        result,\n        new Float32Array(interpolations)\n      );\n    };\n    return track;\n  }\n}\nclass CubicBezierInterpolation extends Interpolant {\n  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer, params) {\n    super(parameterPositions, sampleValues, sampleSize, resultBuffer);\n    this.interpolationParams = params;\n  }\n  interpolate_(i1, t0, t, t1) {\n    const result = this.resultBuffer;\n    const values = this.sampleValues;\n    const stride = this.valueSize;\n    const params = this.interpolationParams;\n    const offset1 = i1 * stride;\n    const offset0 = offset1 - stride;\n    const weight1 = t1 - t0 < 1 / 30 * 1.5 ? 0 : (t - t0) / (t1 - t0);\n    if (stride === 4) {\n      const x1 = params[i1 * 4 + 0];\n      const x2 = params[i1 * 4 + 1];\n      const y1 = params[i1 * 4 + 2];\n      const y2 = params[i1 * 4 + 3];\n      const ratio = this._calculate(x1, x2, y1, y2, weight1);\n      Quaternion.slerpFlat(result, 0, values, offset0, values, offset1, ratio);\n    } else if (stride === 3) {\n      for (let i = 0; i !== stride; ++i) {\n        const x1 = params[i1 * 12 + i * 4 + 0];\n        const x2 = params[i1 * 12 + i * 4 + 1];\n        const y1 = params[i1 * 12 + i * 4 + 2];\n        const y2 = params[i1 * 12 + i * 4 + 3];\n        const ratio = this._calculate(x1, x2, y1, y2, weight1);\n        result[i] = values[offset0 + i] * (1 - ratio) + values[offset1 + i] * ratio;\n      }\n    } else {\n      const x1 = params[i1 * 4 + 0];\n      const x2 = params[i1 * 4 + 1];\n      const y1 = params[i1 * 4 + 2];\n      const y2 = params[i1 * 4 + 3];\n      const ratio = this._calculate(x1, x2, y1, y2, weight1);\n      result[0] = values[offset0] * (1 - ratio) + values[offset1] * ratio;\n    }\n    return result;\n  }\n  _calculate(x1, x2, y1, y2, x) {\n    let c = 0.5;\n    let t = c;\n    let s = 1 - t;\n    const loop = 15;\n    const eps = 1e-5;\n    const math = Math;\n    let sst3, stt3, ttt;\n    for (let i = 0; i < loop; i++) {\n      sst3 = 3 * s * s * t;\n      stt3 = 3 * s * t * t;\n      ttt = t * t * t;\n      const ft = sst3 * x1 + stt3 * x2 + ttt - x;\n      if (math.abs(ft) < eps)\n        break;\n      c /= 2;\n      t += ft < 0 ? c : -c;\n      s = 1 - t;\n    }\n    return sst3 * y1 + stt3 * y2 + ttt;\n  }\n}\nexport {\n  MMDLoader\n};\n"]},"metadata":{},"sourceType":"module"}