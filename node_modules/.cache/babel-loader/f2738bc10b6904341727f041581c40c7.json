{"ast":null,"code":"import _classCallCheck from \"/Users/theodaguier/Repositories/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/theodaguier/Repositories/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { Texture, LinearFilter, ClampToEdgeWrapping, MeshBasicMaterial, DoubleSide, Mesh, PlaneGeometry } from \"three\";\n\nvar VolumeSlice = /*#__PURE__*/function () {\n  function VolumeSlice(volume, index, axis) {\n    _classCallCheck(this, VolumeSlice);\n\n    var slice = this;\n    this.volume = volume;\n    index = index || 0;\n    Object.defineProperty(this, \"index\", {\n      get: function get() {\n        return index;\n      },\n      set: function set(value) {\n        index = value;\n        slice.geometryNeedsUpdate = true;\n        return index;\n      }\n    });\n    this.axis = axis || \"z\";\n    this.canvas = document.createElement(\"canvas\");\n    this.canvasBuffer = document.createElement(\"canvas\");\n    this.updateGeometry();\n    var canvasMap = new Texture(this.canvas);\n    canvasMap.minFilter = LinearFilter;\n    canvasMap.wrapS = canvasMap.wrapT = ClampToEdgeWrapping;\n    if (\"colorSpace\" in canvasMap) canvasMap.colorSpace = \"srgb\";else canvasMap.encoding = 3001;\n    var material = new MeshBasicMaterial({\n      map: canvasMap,\n      side: DoubleSide,\n      transparent: true\n    });\n    this.mesh = new Mesh(this.geometry, material);\n    this.mesh.matrixAutoUpdate = false;\n    this.geometryNeedsUpdate = true;\n    this.repaint();\n  }\n  /**\n   * @member {Function} repaint Refresh the texture and the geometry if geometryNeedsUpdate is set to true\n   * @memberof VolumeSlice\n   */\n\n\n  _createClass(VolumeSlice, [{\n    key: \"repaint\",\n    value: function repaint() {\n      if (this.geometryNeedsUpdate) {\n        this.updateGeometry();\n      }\n\n      var iLength = this.iLength,\n          jLength = this.jLength,\n          sliceAccess = this.sliceAccess,\n          volume = this.volume,\n          canvas = this.canvasBuffer,\n          ctx = this.ctxBuffer;\n      var imgData = ctx.getImageData(0, 0, iLength, jLength);\n      var data = imgData.data;\n      var volumeData = volume.data;\n      var upperThreshold = volume.upperThreshold;\n      var lowerThreshold = volume.lowerThreshold;\n      var windowLow = volume.windowLow;\n      var windowHigh = volume.windowHigh;\n      var pixelCount = 0;\n\n      if (volume.dataType === \"label\") {\n        for (var j = 0; j < jLength; j++) {\n          for (var i = 0; i < iLength; i++) {\n            var label = volumeData[sliceAccess(i, j)];\n            label = label >= this.colorMap.length ? label % this.colorMap.length + 1 : label;\n            var color = this.colorMap[label];\n            data[4 * pixelCount] = color >> 24 & 255;\n            data[4 * pixelCount + 1] = color >> 16 & 255;\n            data[4 * pixelCount + 2] = color >> 8 & 255;\n            data[4 * pixelCount + 3] = color & 255;\n            pixelCount++;\n          }\n        }\n      } else {\n        for (var _j = 0; _j < jLength; _j++) {\n          for (var _i = 0; _i < iLength; _i++) {\n            var value = volumeData[sliceAccess(_i, _j)];\n            var alpha = 255;\n            alpha = upperThreshold >= value ? lowerThreshold <= value ? alpha : 0 : 0;\n            value = Math.floor(255 * (value - windowLow) / (windowHigh - windowLow));\n            value = value > 255 ? 255 : value < 0 ? 0 : value | 0;\n            data[4 * pixelCount] = value;\n            data[4 * pixelCount + 1] = value;\n            data[4 * pixelCount + 2] = value;\n            data[4 * pixelCount + 3] = alpha;\n            pixelCount++;\n          }\n        }\n      }\n\n      ctx.putImageData(imgData, 0, 0);\n      this.ctx.drawImage(canvas, 0, 0, iLength, jLength, 0, 0, this.canvas.width, this.canvas.height);\n      this.mesh.material.map.needsUpdate = true;\n    }\n    /**\n     * @member {Function} Refresh the geometry according to axis and index\n     * @see Volume.extractPerpendicularPlane\n     * @memberof VolumeSlice\n     */\n\n  }, {\n    key: \"updateGeometry\",\n    value: function updateGeometry() {\n      var extracted = this.volume.extractPerpendicularPlane(this.axis, this.index);\n      this.sliceAccess = extracted.sliceAccess;\n      this.jLength = extracted.jLength;\n      this.iLength = extracted.iLength;\n      this.matrix = extracted.matrix;\n      this.canvas.width = extracted.planeWidth;\n      this.canvas.height = extracted.planeHeight;\n      this.canvasBuffer.width = this.iLength;\n      this.canvasBuffer.height = this.jLength;\n      this.ctx = this.canvas.getContext(\"2d\");\n      this.ctxBuffer = this.canvasBuffer.getContext(\"2d\");\n      if (this.geometry) this.geometry.dispose();\n      this.geometry = new PlaneGeometry(extracted.planeWidth, extracted.planeHeight);\n\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry;\n        this.mesh.matrix.identity();\n        this.mesh.applyMatrix4(this.matrix);\n      }\n\n      this.geometryNeedsUpdate = false;\n    }\n  }]);\n\n  return VolumeSlice;\n}();\n\nexport { VolumeSlice };","map":{"version":3,"sources":["/Users/theodaguier/Repositories/E-Do-Studio/node_modules/three-stdlib/misc/VolumeSlice.js"],"names":["Texture","LinearFilter","ClampToEdgeWrapping","MeshBasicMaterial","DoubleSide","Mesh","PlaneGeometry","VolumeSlice","volume","index","axis","slice","Object","defineProperty","get","set","value","geometryNeedsUpdate","canvas","document","createElement","canvasBuffer","updateGeometry","canvasMap","minFilter","wrapS","wrapT","colorSpace","encoding","material","map","side","transparent","mesh","geometry","matrixAutoUpdate","repaint","iLength","jLength","sliceAccess","ctx","ctxBuffer","imgData","getImageData","data","volumeData","upperThreshold","lowerThreshold","windowLow","windowHigh","pixelCount","dataType","j","i","label","colorMap","length","color","alpha","Math","floor","putImageData","drawImage","width","height","needsUpdate","extracted","extractPerpendicularPlane","matrix","planeWidth","planeHeight","getContext","dispose","identity","applyMatrix4"],"mappings":"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","sourcesContent":["import { Texture, LinearFilter, ClampToEdgeWrapping, MeshBasicMaterial, DoubleSide, Mesh, PlaneGeometry } from \"three\";\nclass VolumeSlice {\n  constructor(volume, index, axis) {\n    const slice = this;\n    this.volume = volume;\n    index = index || 0;\n    Object.defineProperty(this, \"index\", {\n      get: function() {\n        return index;\n      },\n      set: function(value) {\n        index = value;\n        slice.geometryNeedsUpdate = true;\n        return index;\n      }\n    });\n    this.axis = axis || \"z\";\n    this.canvas = document.createElement(\"canvas\");\n    this.canvasBuffer = document.createElement(\"canvas\");\n    this.updateGeometry();\n    const canvasMap = new Texture(this.canvas);\n    canvasMap.minFilter = LinearFilter;\n    canvasMap.wrapS = canvasMap.wrapT = ClampToEdgeWrapping;\n    if (\"colorSpace\" in canvasMap)\n      canvasMap.colorSpace = \"srgb\";\n    else\n      canvasMap.encoding = 3001;\n    const material = new MeshBasicMaterial({ map: canvasMap, side: DoubleSide, transparent: true });\n    this.mesh = new Mesh(this.geometry, material);\n    this.mesh.matrixAutoUpdate = false;\n    this.geometryNeedsUpdate = true;\n    this.repaint();\n  }\n  /**\n   * @member {Function} repaint Refresh the texture and the geometry if geometryNeedsUpdate is set to true\n   * @memberof VolumeSlice\n   */\n  repaint() {\n    if (this.geometryNeedsUpdate) {\n      this.updateGeometry();\n    }\n    const iLength = this.iLength, jLength = this.jLength, sliceAccess = this.sliceAccess, volume = this.volume, canvas = this.canvasBuffer, ctx = this.ctxBuffer;\n    const imgData = ctx.getImageData(0, 0, iLength, jLength);\n    const data = imgData.data;\n    const volumeData = volume.data;\n    const upperThreshold = volume.upperThreshold;\n    const lowerThreshold = volume.lowerThreshold;\n    const windowLow = volume.windowLow;\n    const windowHigh = volume.windowHigh;\n    let pixelCount = 0;\n    if (volume.dataType === \"label\") {\n      for (let j = 0; j < jLength; j++) {\n        for (let i = 0; i < iLength; i++) {\n          let label = volumeData[sliceAccess(i, j)];\n          label = label >= this.colorMap.length ? label % this.colorMap.length + 1 : label;\n          const color = this.colorMap[label];\n          data[4 * pixelCount] = color >> 24 & 255;\n          data[4 * pixelCount + 1] = color >> 16 & 255;\n          data[4 * pixelCount + 2] = color >> 8 & 255;\n          data[4 * pixelCount + 3] = color & 255;\n          pixelCount++;\n        }\n      }\n    } else {\n      for (let j = 0; j < jLength; j++) {\n        for (let i = 0; i < iLength; i++) {\n          let value = volumeData[sliceAccess(i, j)];\n          let alpha = 255;\n          alpha = upperThreshold >= value ? lowerThreshold <= value ? alpha : 0 : 0;\n          value = Math.floor(255 * (value - windowLow) / (windowHigh - windowLow));\n          value = value > 255 ? 255 : value < 0 ? 0 : value | 0;\n          data[4 * pixelCount] = value;\n          data[4 * pixelCount + 1] = value;\n          data[4 * pixelCount + 2] = value;\n          data[4 * pixelCount + 3] = alpha;\n          pixelCount++;\n        }\n      }\n    }\n    ctx.putImageData(imgData, 0, 0);\n    this.ctx.drawImage(canvas, 0, 0, iLength, jLength, 0, 0, this.canvas.width, this.canvas.height);\n    this.mesh.material.map.needsUpdate = true;\n  }\n  /**\n   * @member {Function} Refresh the geometry according to axis and index\n   * @see Volume.extractPerpendicularPlane\n   * @memberof VolumeSlice\n   */\n  updateGeometry() {\n    const extracted = this.volume.extractPerpendicularPlane(this.axis, this.index);\n    this.sliceAccess = extracted.sliceAccess;\n    this.jLength = extracted.jLength;\n    this.iLength = extracted.iLength;\n    this.matrix = extracted.matrix;\n    this.canvas.width = extracted.planeWidth;\n    this.canvas.height = extracted.planeHeight;\n    this.canvasBuffer.width = this.iLength;\n    this.canvasBuffer.height = this.jLength;\n    this.ctx = this.canvas.getContext(\"2d\");\n    this.ctxBuffer = this.canvasBuffer.getContext(\"2d\");\n    if (this.geometry)\n      this.geometry.dispose();\n    this.geometry = new PlaneGeometry(extracted.planeWidth, extracted.planeHeight);\n    if (this.mesh) {\n      this.mesh.geometry = this.geometry;\n      this.mesh.matrix.identity();\n      this.mesh.applyMatrix4(this.matrix);\n    }\n    this.geometryNeedsUpdate = false;\n  }\n}\nexport {\n  VolumeSlice\n};\n"]},"metadata":{},"sourceType":"module"}