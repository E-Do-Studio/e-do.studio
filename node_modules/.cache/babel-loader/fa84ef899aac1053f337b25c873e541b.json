{"ast":null,"code":"import { Loader, FileLoader, BufferGeometry, BufferAttribute } from \"three\";\n\nconst _taskCache = /* @__PURE__ */new WeakMap();\n\nclass DRACOLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.decoderPath = \"\";\n    this.decoderConfig = {};\n    this.decoderBinary = null;\n    this.decoderPending = null;\n    this.workerLimit = 4;\n    this.workerPool = [];\n    this.workerNextTaskID = 1;\n    this.workerSourceURL = \"\";\n    this.defaultAttributeIDs = {\n      position: \"POSITION\",\n      normal: \"NORMAL\",\n      color: \"COLOR\",\n      uv: \"TEX_COORD\"\n    };\n    this.defaultAttributeTypes = {\n      position: \"Float32Array\",\n      normal: \"Float32Array\",\n      color: \"Float32Array\",\n      uv: \"Float32Array\"\n    };\n  }\n\n  setDecoderPath(path) {\n    this.decoderPath = path;\n    return this;\n  }\n\n  setDecoderConfig(config) {\n    this.decoderConfig = config;\n    return this;\n  }\n\n  setWorkerLimit(workerLimit) {\n    this.workerLimit = workerLimit;\n    return this;\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType(\"arraybuffer\");\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, buffer => {\n      const taskConfig = {\n        attributeIDs: this.defaultAttributeIDs,\n        attributeTypes: this.defaultAttributeTypes,\n        useUniqueIDs: false\n      };\n      this.decodeGeometry(buffer, taskConfig).then(onLoad).catch(onError);\n    }, onProgress, onError);\n  }\n  /** @deprecated Kept for backward-compatibility with previous DRACOLoader versions. */\n\n\n  decodeDracoFile(buffer, callback, attributeIDs, attributeTypes) {\n    const taskConfig = {\n      attributeIDs: attributeIDs || this.defaultAttributeIDs,\n      attributeTypes: attributeTypes || this.defaultAttributeTypes,\n      useUniqueIDs: !!attributeIDs\n    };\n    this.decodeGeometry(buffer, taskConfig).then(callback);\n  }\n\n  decodeGeometry(buffer, taskConfig) {\n    for (const attribute in taskConfig.attributeTypes) {\n      const type = taskConfig.attributeTypes[attribute];\n\n      if (type.BYTES_PER_ELEMENT !== void 0) {\n        taskConfig.attributeTypes[attribute] = type.name;\n      }\n    }\n\n    const taskKey = JSON.stringify(taskConfig);\n\n    if (_taskCache.has(buffer)) {\n      const cachedTask = _taskCache.get(buffer);\n\n      if (cachedTask.key === taskKey) {\n        return cachedTask.promise;\n      } else if (buffer.byteLength === 0) {\n        throw new Error(\"THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.\");\n      }\n    }\n\n    let worker;\n    const taskID = this.workerNextTaskID++;\n    const taskCost = buffer.byteLength;\n\n    const geometryPending = this._getWorker(taskID, taskCost).then(_worker => {\n      worker = _worker;\n      return new Promise((resolve, reject) => {\n        worker._callbacks[taskID] = {\n          resolve,\n          reject\n        };\n        worker.postMessage({\n          type: \"decode\",\n          id: taskID,\n          taskConfig,\n          buffer\n        }, [buffer]);\n      });\n    }).then(message => this._createGeometry(message.geometry));\n\n    geometryPending.catch(() => true).then(() => {\n      if (worker && taskID) {\n        this._releaseTask(worker, taskID);\n      }\n    });\n\n    _taskCache.set(buffer, {\n      key: taskKey,\n      promise: geometryPending\n    });\n\n    return geometryPending;\n  }\n\n  _createGeometry(geometryData) {\n    const geometry = new BufferGeometry();\n\n    if (geometryData.index) {\n      geometry.setIndex(new BufferAttribute(geometryData.index.array, 1));\n    }\n\n    for (let i = 0; i < geometryData.attributes.length; i++) {\n      const attribute = geometryData.attributes[i];\n      const name = attribute.name;\n      const array = attribute.array;\n      const itemSize = attribute.itemSize;\n      geometry.setAttribute(name, new BufferAttribute(array, itemSize));\n    }\n\n    return geometry;\n  }\n\n  _loadLibrary(url, responseType) {\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.decoderPath);\n    loader.setResponseType(responseType);\n    loader.setWithCredentials(this.withCredentials);\n    return new Promise((resolve, reject) => {\n      loader.load(url, resolve, void 0, reject);\n    });\n  }\n\n  preload() {\n    this._initDecoder();\n\n    return this;\n  }\n\n  _initDecoder() {\n    if (this.decoderPending) return this.decoderPending;\n    const useJS = typeof WebAssembly !== \"object\" || this.decoderConfig.type === \"js\";\n    const librariesPending = [];\n\n    if (useJS) {\n      librariesPending.push(this._loadLibrary(\"draco_decoder.js\", \"text\"));\n    } else {\n      librariesPending.push(this._loadLibrary(\"draco_wasm_wrapper.js\", \"text\"));\n      librariesPending.push(this._loadLibrary(\"draco_decoder.wasm\", \"arraybuffer\"));\n    }\n\n    this.decoderPending = Promise.all(librariesPending).then(libraries => {\n      const jsContent = libraries[0];\n\n      if (!useJS) {\n        this.decoderConfig.wasmBinary = libraries[1];\n      }\n\n      const fn = DRACOWorker.toString();\n      const body = [\"/* draco decoder */\", jsContent, \"\", \"/* worker */\", fn.substring(fn.indexOf(\"{\") + 1, fn.lastIndexOf(\"}\"))].join(\"\\n\");\n      this.workerSourceURL = URL.createObjectURL(new Blob([body]));\n    });\n    return this.decoderPending;\n  }\n\n  _getWorker(taskID, taskCost) {\n    return this._initDecoder().then(() => {\n      if (this.workerPool.length < this.workerLimit) {\n        const worker2 = new Worker(this.workerSourceURL);\n        worker2._callbacks = {};\n        worker2._taskCosts = {};\n        worker2._taskLoad = 0;\n        worker2.postMessage({\n          type: \"init\",\n          decoderConfig: this.decoderConfig\n        });\n\n        worker2.onmessage = function (e) {\n          const message = e.data;\n\n          switch (message.type) {\n            case \"decode\":\n              worker2._callbacks[message.id].resolve(message);\n\n              break;\n\n            case \"error\":\n              worker2._callbacks[message.id].reject(message);\n\n              break;\n\n            default:\n              console.error('THREE.DRACOLoader: Unexpected message, \"' + message.type + '\"');\n          }\n        };\n\n        this.workerPool.push(worker2);\n      } else {\n        this.workerPool.sort(function (a, b) {\n          return a._taskLoad > b._taskLoad ? -1 : 1;\n        });\n      }\n\n      const worker = this.workerPool[this.workerPool.length - 1];\n      worker._taskCosts[taskID] = taskCost;\n      worker._taskLoad += taskCost;\n      return worker;\n    });\n  }\n\n  _releaseTask(worker, taskID) {\n    worker._taskLoad -= worker._taskCosts[taskID];\n    delete worker._callbacks[taskID];\n    delete worker._taskCosts[taskID];\n  }\n\n  debug() {\n    console.log(\"Task load: \", this.workerPool.map(worker => worker._taskLoad));\n  }\n\n  dispose() {\n    for (let i = 0; i < this.workerPool.length; ++i) {\n      this.workerPool[i].terminate();\n    }\n\n    this.workerPool.length = 0;\n    return this;\n  }\n\n}\n\nfunction DRACOWorker() {\n  let decoderConfig;\n  let decoderPending;\n\n  onmessage = function (e) {\n    const message = e.data;\n\n    switch (message.type) {\n      case \"init\":\n        decoderConfig = message.decoderConfig;\n        decoderPending = new Promise(function (resolve) {\n          decoderConfig.onModuleLoaded = function (draco) {\n            resolve({\n              draco\n            });\n          };\n\n          DracoDecoderModule(decoderConfig);\n        });\n        break;\n\n      case \"decode\":\n        const buffer = message.buffer;\n        const taskConfig = message.taskConfig;\n        decoderPending.then(module => {\n          const draco = module.draco;\n          const decoder = new draco.Decoder();\n          const decoderBuffer = new draco.DecoderBuffer();\n          decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength);\n\n          try {\n            const geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig);\n            const buffers = geometry.attributes.map(attr => attr.array.buffer);\n            if (geometry.index) buffers.push(geometry.index.array.buffer);\n            self.postMessage({\n              type: \"decode\",\n              id: message.id,\n              geometry\n            }, buffers);\n          } catch (error) {\n            console.error(error);\n            self.postMessage({\n              type: \"error\",\n              id: message.id,\n              error: error.message\n            });\n          } finally {\n            draco.destroy(decoderBuffer);\n            draco.destroy(decoder);\n          }\n        });\n        break;\n    }\n  };\n\n  function decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {\n    const attributeIDs = taskConfig.attributeIDs;\n    const attributeTypes = taskConfig.attributeTypes;\n    let dracoGeometry;\n    let decodingStatus;\n    const geometryType = decoder.GetEncodedGeometryType(decoderBuffer);\n\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      dracoGeometry = new draco.Mesh();\n      decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry);\n    } else if (geometryType === draco.POINT_CLOUD) {\n      dracoGeometry = new draco.PointCloud();\n      decodingStatus = decoder.DecodeBufferToPointCloud(decoderBuffer, dracoGeometry);\n    } else {\n      throw new Error(\"THREE.DRACOLoader: Unexpected geometry type.\");\n    }\n\n    if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {\n      throw new Error(\"THREE.DRACOLoader: Decoding failed: \" + decodingStatus.error_msg());\n    }\n\n    const geometry = {\n      index: null,\n      attributes: []\n    };\n\n    for (const attributeName in attributeIDs) {\n      const attributeType = self[attributeTypes[attributeName]];\n      let attribute;\n      let attributeID;\n\n      if (taskConfig.useUniqueIDs) {\n        attributeID = attributeIDs[attributeName];\n        attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);\n      } else {\n        attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);\n        if (attributeID === -1) continue;\n        attribute = decoder.GetAttribute(dracoGeometry, attributeID);\n      }\n\n      geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute));\n    }\n\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      geometry.index = decodeIndex(draco, decoder, dracoGeometry);\n    }\n\n    draco.destroy(dracoGeometry);\n    return geometry;\n  }\n\n  function decodeIndex(draco, decoder, dracoGeometry) {\n    const numFaces = dracoGeometry.num_faces();\n    const numIndices = numFaces * 3;\n    const byteLength = numIndices * 4;\n\n    const ptr = draco._malloc(byteLength);\n\n    decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);\n    const index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice();\n\n    draco._free(ptr);\n\n    return {\n      array: index,\n      itemSize: 1\n    };\n  }\n\n  function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {\n    const numComponents = attribute.num_components();\n    const numPoints = dracoGeometry.num_points();\n    const numValues = numPoints * numComponents;\n    const byteLength = numValues * attributeType.BYTES_PER_ELEMENT;\n    const dataType = getDracoDataType(draco, attributeType);\n\n    const ptr = draco._malloc(byteLength);\n\n    decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr);\n    const array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice();\n\n    draco._free(ptr);\n\n    return {\n      name: attributeName,\n      array,\n      itemSize: numComponents\n    };\n  }\n\n  function getDracoDataType(draco, attributeType) {\n    switch (attributeType) {\n      case Float32Array:\n        return draco.DT_FLOAT32;\n\n      case Int8Array:\n        return draco.DT_INT8;\n\n      case Int16Array:\n        return draco.DT_INT16;\n\n      case Int32Array:\n        return draco.DT_INT32;\n\n      case Uint8Array:\n        return draco.DT_UINT8;\n\n      case Uint16Array:\n        return draco.DT_UINT16;\n\n      case Uint32Array:\n        return draco.DT_UINT32;\n    }\n  }\n}\n\nexport { DRACOLoader };","map":{"version":3,"sources":["/Users/theodaguier/_workdir/dev/pro/e-do/E-Do-Studio/node_modules/three-stdlib/loaders/DRACOLoader.js"],"names":["Loader","FileLoader","BufferGeometry","BufferAttribute","_taskCache","WeakMap","DRACOLoader","constructor","manager","decoderPath","decoderConfig","decoderBinary","decoderPending","workerLimit","workerPool","workerNextTaskID","workerSourceURL","defaultAttributeIDs","position","normal","color","uv","defaultAttributeTypes","setDecoderPath","path","setDecoderConfig","config","setWorkerLimit","load","url","onLoad","onProgress","onError","loader","setPath","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","buffer","taskConfig","attributeIDs","attributeTypes","useUniqueIDs","decodeGeometry","then","catch","decodeDracoFile","callback","attribute","type","BYTES_PER_ELEMENT","name","taskKey","JSON","stringify","has","cachedTask","get","key","promise","byteLength","Error","worker","taskID","taskCost","geometryPending","_getWorker","_worker","Promise","resolve","reject","_callbacks","postMessage","id","message","_createGeometry","geometry","_releaseTask","set","geometryData","index","setIndex","array","i","attributes","length","itemSize","setAttribute","_loadLibrary","responseType","preload","_initDecoder","useJS","WebAssembly","librariesPending","push","all","libraries","jsContent","wasmBinary","fn","DRACOWorker","toString","body","substring","indexOf","lastIndexOf","join","URL","createObjectURL","Blob","worker2","Worker","_taskCosts","_taskLoad","onmessage","e","data","console","error","sort","a","b","debug","log","map","dispose","terminate","onModuleLoaded","draco","DracoDecoderModule","module","decoder","Decoder","decoderBuffer","DecoderBuffer","Init","Int8Array","buffers","attr","self","destroy","dracoGeometry","decodingStatus","geometryType","GetEncodedGeometryType","TRIANGULAR_MESH","Mesh","DecodeBufferToMesh","POINT_CLOUD","PointCloud","DecodeBufferToPointCloud","ok","ptr","error_msg","attributeName","attributeType","attributeID","GetAttributeByUniqueId","GetAttributeId","GetAttribute","decodeAttribute","decodeIndex","numFaces","num_faces","numIndices","_malloc","GetTrianglesUInt32Array","Uint32Array","HEAPF32","slice","_free","numComponents","num_components","numPoints","num_points","numValues","dataType","getDracoDataType","GetAttributeDataArrayForAllPoints","Float32Array","DT_FLOAT32","DT_INT8","Int16Array","DT_INT16","Int32Array","DT_INT32","Uint8Array","DT_UINT8","Uint16Array","DT_UINT16","DT_UINT32"],"mappings":"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","sourcesContent":["import { Loader, FileLoader, BufferGeometry, BufferAttribute } from \"three\";\nconst _taskCache = /* @__PURE__ */ new WeakMap();\nclass DRACOLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.decoderPath = \"\";\n    this.decoderConfig = {};\n    this.decoderBinary = null;\n    this.decoderPending = null;\n    this.workerLimit = 4;\n    this.workerPool = [];\n    this.workerNextTaskID = 1;\n    this.workerSourceURL = \"\";\n    this.defaultAttributeIDs = {\n      position: \"POSITION\",\n      normal: \"NORMAL\",\n      color: \"COLOR\",\n      uv: \"TEX_COORD\"\n    };\n    this.defaultAttributeTypes = {\n      position: \"Float32Array\",\n      normal: \"Float32Array\",\n      color: \"Float32Array\",\n      uv: \"Float32Array\"\n    };\n  }\n  setDecoderPath(path) {\n    this.decoderPath = path;\n    return this;\n  }\n  setDecoderConfig(config) {\n    this.decoderConfig = config;\n    return this;\n  }\n  setWorkerLimit(workerLimit) {\n    this.workerLimit = workerLimit;\n    return this;\n  }\n  load(url, onLoad, onProgress, onError) {\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType(\"arraybuffer\");\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(\n      url,\n      (buffer) => {\n        const taskConfig = {\n          attributeIDs: this.defaultAttributeIDs,\n          attributeTypes: this.defaultAttributeTypes,\n          useUniqueIDs: false\n        };\n        this.decodeGeometry(buffer, taskConfig).then(onLoad).catch(onError);\n      },\n      onProgress,\n      onError\n    );\n  }\n  /** @deprecated Kept for backward-compatibility with previous DRACOLoader versions. */\n  decodeDracoFile(buffer, callback, attributeIDs, attributeTypes) {\n    const taskConfig = {\n      attributeIDs: attributeIDs || this.defaultAttributeIDs,\n      attributeTypes: attributeTypes || this.defaultAttributeTypes,\n      useUniqueIDs: !!attributeIDs\n    };\n    this.decodeGeometry(buffer, taskConfig).then(callback);\n  }\n  decodeGeometry(buffer, taskConfig) {\n    for (const attribute in taskConfig.attributeTypes) {\n      const type = taskConfig.attributeTypes[attribute];\n      if (type.BYTES_PER_ELEMENT !== void 0) {\n        taskConfig.attributeTypes[attribute] = type.name;\n      }\n    }\n    const taskKey = JSON.stringify(taskConfig);\n    if (_taskCache.has(buffer)) {\n      const cachedTask = _taskCache.get(buffer);\n      if (cachedTask.key === taskKey) {\n        return cachedTask.promise;\n      } else if (buffer.byteLength === 0) {\n        throw new Error(\n          \"THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.\"\n        );\n      }\n    }\n    let worker;\n    const taskID = this.workerNextTaskID++;\n    const taskCost = buffer.byteLength;\n    const geometryPending = this._getWorker(taskID, taskCost).then((_worker) => {\n      worker = _worker;\n      return new Promise((resolve, reject) => {\n        worker._callbacks[taskID] = { resolve, reject };\n        worker.postMessage({ type: \"decode\", id: taskID, taskConfig, buffer }, [buffer]);\n      });\n    }).then((message) => this._createGeometry(message.geometry));\n    geometryPending.catch(() => true).then(() => {\n      if (worker && taskID) {\n        this._releaseTask(worker, taskID);\n      }\n    });\n    _taskCache.set(buffer, {\n      key: taskKey,\n      promise: geometryPending\n    });\n    return geometryPending;\n  }\n  _createGeometry(geometryData) {\n    const geometry = new BufferGeometry();\n    if (geometryData.index) {\n      geometry.setIndex(new BufferAttribute(geometryData.index.array, 1));\n    }\n    for (let i = 0; i < geometryData.attributes.length; i++) {\n      const attribute = geometryData.attributes[i];\n      const name = attribute.name;\n      const array = attribute.array;\n      const itemSize = attribute.itemSize;\n      geometry.setAttribute(name, new BufferAttribute(array, itemSize));\n    }\n    return geometry;\n  }\n  _loadLibrary(url, responseType) {\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.decoderPath);\n    loader.setResponseType(responseType);\n    loader.setWithCredentials(this.withCredentials);\n    return new Promise((resolve, reject) => {\n      loader.load(url, resolve, void 0, reject);\n    });\n  }\n  preload() {\n    this._initDecoder();\n    return this;\n  }\n  _initDecoder() {\n    if (this.decoderPending)\n      return this.decoderPending;\n    const useJS = typeof WebAssembly !== \"object\" || this.decoderConfig.type === \"js\";\n    const librariesPending = [];\n    if (useJS) {\n      librariesPending.push(this._loadLibrary(\"draco_decoder.js\", \"text\"));\n    } else {\n      librariesPending.push(this._loadLibrary(\"draco_wasm_wrapper.js\", \"text\"));\n      librariesPending.push(this._loadLibrary(\"draco_decoder.wasm\", \"arraybuffer\"));\n    }\n    this.decoderPending = Promise.all(librariesPending).then((libraries) => {\n      const jsContent = libraries[0];\n      if (!useJS) {\n        this.decoderConfig.wasmBinary = libraries[1];\n      }\n      const fn = DRACOWorker.toString();\n      const body = [\n        \"/* draco decoder */\",\n        jsContent,\n        \"\",\n        \"/* worker */\",\n        fn.substring(fn.indexOf(\"{\") + 1, fn.lastIndexOf(\"}\"))\n      ].join(\"\\n\");\n      this.workerSourceURL = URL.createObjectURL(new Blob([body]));\n    });\n    return this.decoderPending;\n  }\n  _getWorker(taskID, taskCost) {\n    return this._initDecoder().then(() => {\n      if (this.workerPool.length < this.workerLimit) {\n        const worker2 = new Worker(this.workerSourceURL);\n        worker2._callbacks = {};\n        worker2._taskCosts = {};\n        worker2._taskLoad = 0;\n        worker2.postMessage({ type: \"init\", decoderConfig: this.decoderConfig });\n        worker2.onmessage = function(e) {\n          const message = e.data;\n          switch (message.type) {\n            case \"decode\":\n              worker2._callbacks[message.id].resolve(message);\n              break;\n            case \"error\":\n              worker2._callbacks[message.id].reject(message);\n              break;\n            default:\n              console.error('THREE.DRACOLoader: Unexpected message, \"' + message.type + '\"');\n          }\n        };\n        this.workerPool.push(worker2);\n      } else {\n        this.workerPool.sort(function(a, b) {\n          return a._taskLoad > b._taskLoad ? -1 : 1;\n        });\n      }\n      const worker = this.workerPool[this.workerPool.length - 1];\n      worker._taskCosts[taskID] = taskCost;\n      worker._taskLoad += taskCost;\n      return worker;\n    });\n  }\n  _releaseTask(worker, taskID) {\n    worker._taskLoad -= worker._taskCosts[taskID];\n    delete worker._callbacks[taskID];\n    delete worker._taskCosts[taskID];\n  }\n  debug() {\n    console.log(\n      \"Task load: \",\n      this.workerPool.map((worker) => worker._taskLoad)\n    );\n  }\n  dispose() {\n    for (let i = 0; i < this.workerPool.length; ++i) {\n      this.workerPool[i].terminate();\n    }\n    this.workerPool.length = 0;\n    return this;\n  }\n}\nfunction DRACOWorker() {\n  let decoderConfig;\n  let decoderPending;\n  onmessage = function(e) {\n    const message = e.data;\n    switch (message.type) {\n      case \"init\":\n        decoderConfig = message.decoderConfig;\n        decoderPending = new Promise(function(resolve) {\n          decoderConfig.onModuleLoaded = function(draco) {\n            resolve({ draco });\n          };\n          DracoDecoderModule(decoderConfig);\n        });\n        break;\n      case \"decode\":\n        const buffer = message.buffer;\n        const taskConfig = message.taskConfig;\n        decoderPending.then((module) => {\n          const draco = module.draco;\n          const decoder = new draco.Decoder();\n          const decoderBuffer = new draco.DecoderBuffer();\n          decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength);\n          try {\n            const geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig);\n            const buffers = geometry.attributes.map((attr) => attr.array.buffer);\n            if (geometry.index)\n              buffers.push(geometry.index.array.buffer);\n            self.postMessage({ type: \"decode\", id: message.id, geometry }, buffers);\n          } catch (error) {\n            console.error(error);\n            self.postMessage({ type: \"error\", id: message.id, error: error.message });\n          } finally {\n            draco.destroy(decoderBuffer);\n            draco.destroy(decoder);\n          }\n        });\n        break;\n    }\n  };\n  function decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {\n    const attributeIDs = taskConfig.attributeIDs;\n    const attributeTypes = taskConfig.attributeTypes;\n    let dracoGeometry;\n    let decodingStatus;\n    const geometryType = decoder.GetEncodedGeometryType(decoderBuffer);\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      dracoGeometry = new draco.Mesh();\n      decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry);\n    } else if (geometryType === draco.POINT_CLOUD) {\n      dracoGeometry = new draco.PointCloud();\n      decodingStatus = decoder.DecodeBufferToPointCloud(decoderBuffer, dracoGeometry);\n    } else {\n      throw new Error(\"THREE.DRACOLoader: Unexpected geometry type.\");\n    }\n    if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {\n      throw new Error(\"THREE.DRACOLoader: Decoding failed: \" + decodingStatus.error_msg());\n    }\n    const geometry = { index: null, attributes: [] };\n    for (const attributeName in attributeIDs) {\n      const attributeType = self[attributeTypes[attributeName]];\n      let attribute;\n      let attributeID;\n      if (taskConfig.useUniqueIDs) {\n        attributeID = attributeIDs[attributeName];\n        attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);\n      } else {\n        attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);\n        if (attributeID === -1)\n          continue;\n        attribute = decoder.GetAttribute(dracoGeometry, attributeID);\n      }\n      geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute));\n    }\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      geometry.index = decodeIndex(draco, decoder, dracoGeometry);\n    }\n    draco.destroy(dracoGeometry);\n    return geometry;\n  }\n  function decodeIndex(draco, decoder, dracoGeometry) {\n    const numFaces = dracoGeometry.num_faces();\n    const numIndices = numFaces * 3;\n    const byteLength = numIndices * 4;\n    const ptr = draco._malloc(byteLength);\n    decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);\n    const index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice();\n    draco._free(ptr);\n    return { array: index, itemSize: 1 };\n  }\n  function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {\n    const numComponents = attribute.num_components();\n    const numPoints = dracoGeometry.num_points();\n    const numValues = numPoints * numComponents;\n    const byteLength = numValues * attributeType.BYTES_PER_ELEMENT;\n    const dataType = getDracoDataType(draco, attributeType);\n    const ptr = draco._malloc(byteLength);\n    decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr);\n    const array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice();\n    draco._free(ptr);\n    return {\n      name: attributeName,\n      array,\n      itemSize: numComponents\n    };\n  }\n  function getDracoDataType(draco, attributeType) {\n    switch (attributeType) {\n      case Float32Array:\n        return draco.DT_FLOAT32;\n      case Int8Array:\n        return draco.DT_INT8;\n      case Int16Array:\n        return draco.DT_INT16;\n      case Int32Array:\n        return draco.DT_INT32;\n      case Uint8Array:\n        return draco.DT_UINT8;\n      case Uint16Array:\n        return draco.DT_UINT16;\n      case Uint32Array:\n        return draco.DT_UINT32;\n    }\n  }\n}\nexport {\n  DRACOLoader\n};\n"]},"metadata":{},"sourceType":"module"}