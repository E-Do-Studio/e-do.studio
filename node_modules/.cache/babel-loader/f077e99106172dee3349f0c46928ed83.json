{"ast":null,"code":"import { ShaderChunk, UniformsUtils, ShaderLib, Color } from \"three\";\n\nvar _SubsurfaceScatteringShader;\n\nfunction get() {\n  if (_SubsurfaceScatteringShader) return _SubsurfaceScatteringShader;\n  var meshphong_frag_head = ShaderChunk[\"meshphong_frag\"].slice(0, ShaderChunk[\"meshphong_frag\"].indexOf(\"void main() {\"));\n  var meshphong_frag_body = ShaderChunk[\"meshphong_frag\"].slice(ShaderChunk[\"meshphong_frag\"].indexOf(\"void main() {\"));\n  _SubsurfaceScatteringShader = {\n    uniforms: /* @__PURE__ */UniformsUtils.merge([ShaderLib[\"phong\"].uniforms, {\n      thicknessMap: {\n        value: null\n      },\n      thicknessColor: {\n        value: /* @__PURE__ */new Color(16777215)\n      },\n      thicknessDistortion: {\n        value: 0.1\n      },\n      thicknessAmbient: {\n        value: 0\n      },\n      thicknessAttenuation: {\n        value: 0.1\n      },\n      thicknessPower: {\n        value: 2\n      },\n      thicknessScale: {\n        value: 10\n      }\n    }]),\n    vertexShader:\n    /* glsl */\n    \"\\n    #define USE_UV\\n    \".concat(ShaderChunk[\"meshphong_vert\"], \"\\n  \"),\n    fragmentShader:\n    /* glsl */\n    \"\\n    #define USE_UV',\\n    #define SUBSURFACE',\\n\\n    \".concat(meshphong_frag_head, \"\\n\\n    uniform sampler2D thicknessMap;\\n    uniform float thicknessPower;\\n    uniform float thicknessScale;\\n    uniform float thicknessDistortion;\\n    uniform float thicknessAmbient;\\n    uniform float thicknessAttenuation;\\n    uniform vec3 thicknessColor;\\n\\n    void RE_Direct_Scattering(const in IncidentLight directLight, const in vec2 uv, const in GeometricContext geometry, inout ReflectedLight reflectedLight) {\\n    \\tvec3 thickness = thicknessColor * texture2D(thicknessMap, uv).r;\\n    \\tvec3 scatteringHalf = normalize(directLight.direction + (geometry.normal * thicknessDistortion));\\n    \\tfloat scatteringDot = pow(saturate(dot(geometry.viewDir, -scatteringHalf)), thicknessPower) * thicknessScale;\\n    \\tvec3 scatteringIllu = (scatteringDot + thicknessAmbient) * thickness;\\n    \\treflectedLight.directDiffuse += scatteringIllu * thicknessAttenuation * directLight.color;\\n    }\\n\\n    \").concat(meshphong_frag_body.replace(\"#include <lights_fragment_begin>\", ShaderChunk[\"lights_fragment_begin\"].replace(/RE_Direct\\( directLight, geometry, material, reflectedLight \\);/g,\n    /* glsl */\n    \"\\n        RE_Direct( directLight, geometry, material, reflectedLight );\\n\\n        #if defined( SUBSURFACE ) && defined( USE_UV )\\n          RE_Direct_Scattering(directLight, vUv, geometry, reflectedLight);\\n        #endif\\n      \")), \"\\n  \")\n  };\n  return _SubsurfaceScatteringShader;\n}\n\nvar SubsurfaceScatteringShader = {\n  get uniforms() {\n    return get().uniforms;\n  },\n\n  set uniforms(value) {\n    get().uniforms = value;\n  },\n\n  get vertexShader() {\n    return get().vertexShader;\n  },\n\n  set vertexShader(value) {\n    get().vertexShader = value;\n  },\n\n  get fragmentShader() {\n    return get().vertexShader;\n  },\n\n  set fragmentShader(value) {\n    get().vertexShader = value;\n  }\n\n};\nexport { SubsurfaceScatteringShader };","map":{"version":3,"sources":["/Users/theodaguier/Repositories/E-Do-Studio/node_modules/three-stdlib/shaders/SubsurfaceScatteringShader.js"],"names":["ShaderChunk","UniformsUtils","ShaderLib","Color","_SubsurfaceScatteringShader","get","meshphong_frag_head","slice","indexOf","meshphong_frag_body","uniforms","merge","thicknessMap","value","thicknessColor","thicknessDistortion","thicknessAmbient","thicknessAttenuation","thicknessPower","thicknessScale","vertexShader","fragmentShader","replace","SubsurfaceScatteringShader"],"mappings":"AAAA,SAASA,WAAT,EAAsBC,aAAtB,EAAqCC,SAArC,EAAgDC,KAAhD,QAA6D,OAA7D;;AACA,IAAIC,2BAAJ;;AACA,SAASC,GAAT,GAAe;AACb,MAAID,2BAAJ,EACE,OAAOA,2BAAP;AACF,MAAME,mBAAmB,GAAGN,WAAW,CAAC,gBAAD,CAAX,CAA8BO,KAA9B,CAC1B,CAD0B,EAE1BP,WAAW,CAAC,gBAAD,CAAX,CAA8BQ,OAA9B,CAAsC,eAAtC,CAF0B,CAA5B;AAIA,MAAMC,mBAAmB,GAAGT,WAAW,CAAC,gBAAD,CAAX,CAA8BO,KAA9B,CAC1BP,WAAW,CAAC,gBAAD,CAAX,CAA8BQ,OAA9B,CAAsC,eAAtC,CAD0B,CAA5B;AAGAJ,EAAAA,2BAA2B,GAAG;AAC5BM,IAAAA,QAAQ,EAAE,eAAgBT,aAAa,CAACU,KAAd,CAAoB,CAC5CT,SAAS,CAAC,OAAD,CAAT,CAAmBQ,QADyB,EAE5C;AACEE,MAAAA,YAAY,EAAE;AAAEC,QAAAA,KAAK,EAAE;AAAT,OADhB;AAEEC,MAAAA,cAAc,EAAE;AAAED,QAAAA,KAAK,EAAE,eAAgB,IAAIV,KAAJ,CAAU,QAAV;AAAzB,OAFlB;AAGEY,MAAAA,mBAAmB,EAAE;AAAEF,QAAAA,KAAK,EAAE;AAAT,OAHvB;AAIEG,MAAAA,gBAAgB,EAAE;AAAEH,QAAAA,KAAK,EAAE;AAAT,OAJpB;AAKEI,MAAAA,oBAAoB,EAAE;AAAEJ,QAAAA,KAAK,EAAE;AAAT,OALxB;AAMEK,MAAAA,cAAc,EAAE;AAAEL,QAAAA,KAAK,EAAE;AAAT,OANlB;AAOEM,MAAAA,cAAc,EAAE;AAAEN,QAAAA,KAAK,EAAE;AAAT;AAPlB,KAF4C,CAApB,CADE;AAa5BO,IAAAA,YAAY;AACV;AADU,wCAIVpB,WAAW,CAAC,gBAAD,CAJD,SAbgB;AAoB5BqB,IAAAA,cAAc;AACZ;AADY,sEAMZf,mBANY,w5BAwBZG,mBAAmB,CAACa,OAApB,CACE,kCADF,EAEEtB,WAAW,CAAC,uBAAD,CAAX,CAAqCsB,OAArC,CACE,kEADF;AAEE;AAFF,6OAFF,CAxBY;AApBc,GAA9B;AA6DA,SAAOlB,2BAAP;AACD;;AACD,IAAMmB,0BAA0B,GAAG;AACjC,MAAIb,QAAJ,GAAe;AACb,WAAOL,GAAG,GAAGK,QAAb;AACD,GAHgC;;AAIjC,MAAIA,QAAJ,CAAaG,KAAb,EAAoB;AAClBR,IAAAA,GAAG,GAAGK,QAAN,GAAiBG,KAAjB;AACD,GANgC;;AAOjC,MAAIO,YAAJ,GAAmB;AACjB,WAAOf,GAAG,GAAGe,YAAb;AACD,GATgC;;AAUjC,MAAIA,YAAJ,CAAiBP,KAAjB,EAAwB;AACtBR,IAAAA,GAAG,GAAGe,YAAN,GAAqBP,KAArB;AACD,GAZgC;;AAajC,MAAIQ,cAAJ,GAAqB;AACnB,WAAOhB,GAAG,GAAGe,YAAb;AACD,GAfgC;;AAgBjC,MAAIC,cAAJ,CAAmBR,KAAnB,EAA0B;AACxBR,IAAAA,GAAG,GAAGe,YAAN,GAAqBP,KAArB;AACD;;AAlBgC,CAAnC;AAoBA,SACEU,0BADF","sourcesContent":["import { ShaderChunk, UniformsUtils, ShaderLib, Color } from \"three\";\nlet _SubsurfaceScatteringShader;\nfunction get() {\n  if (_SubsurfaceScatteringShader)\n    return _SubsurfaceScatteringShader;\n  const meshphong_frag_head = ShaderChunk[\"meshphong_frag\"].slice(\n    0,\n    ShaderChunk[\"meshphong_frag\"].indexOf(\"void main() {\")\n  );\n  const meshphong_frag_body = ShaderChunk[\"meshphong_frag\"].slice(\n    ShaderChunk[\"meshphong_frag\"].indexOf(\"void main() {\")\n  );\n  _SubsurfaceScatteringShader = {\n    uniforms: /* @__PURE__ */ UniformsUtils.merge([\n      ShaderLib[\"phong\"].uniforms,\n      {\n        thicknessMap: { value: null },\n        thicknessColor: { value: /* @__PURE__ */ new Color(16777215) },\n        thicknessDistortion: { value: 0.1 },\n        thicknessAmbient: { value: 0 },\n        thicknessAttenuation: { value: 0.1 },\n        thicknessPower: { value: 2 },\n        thicknessScale: { value: 10 }\n      }\n    ]),\n    vertexShader: (\n      /* glsl */\n      `\n    #define USE_UV\n    ${ShaderChunk[\"meshphong_vert\"]}\n  `\n    ),\n    fragmentShader: (\n      /* glsl */\n      `\n    #define USE_UV',\n    #define SUBSURFACE',\n\n    ${meshphong_frag_head}\n\n    uniform sampler2D thicknessMap;\n    uniform float thicknessPower;\n    uniform float thicknessScale;\n    uniform float thicknessDistortion;\n    uniform float thicknessAmbient;\n    uniform float thicknessAttenuation;\n    uniform vec3 thicknessColor;\n\n    void RE_Direct_Scattering(const in IncidentLight directLight, const in vec2 uv, const in GeometricContext geometry, inout ReflectedLight reflectedLight) {\n    \tvec3 thickness = thicknessColor * texture2D(thicknessMap, uv).r;\n    \tvec3 scatteringHalf = normalize(directLight.direction + (geometry.normal * thicknessDistortion));\n    \tfloat scatteringDot = pow(saturate(dot(geometry.viewDir, -scatteringHalf)), thicknessPower) * thicknessScale;\n    \tvec3 scatteringIllu = (scatteringDot + thicknessAmbient) * thickness;\n    \treflectedLight.directDiffuse += scatteringIllu * thicknessAttenuation * directLight.color;\n    }\n\n    ${meshphong_frag_body.replace(\n        \"#include <lights_fragment_begin>\",\n        ShaderChunk[\"lights_fragment_begin\"].replace(\n          /RE_Direct\\( directLight, geometry, material, reflectedLight \\);/g,\n          /* glsl */\n          `\n        RE_Direct( directLight, geometry, material, reflectedLight );\n\n        #if defined( SUBSURFACE ) && defined( USE_UV )\n          RE_Direct_Scattering(directLight, vUv, geometry, reflectedLight);\n        #endif\n      `\n        )\n      )}\n  `\n    )\n  };\n  return _SubsurfaceScatteringShader;\n}\nconst SubsurfaceScatteringShader = {\n  get uniforms() {\n    return get().uniforms;\n  },\n  set uniforms(value) {\n    get().uniforms = value;\n  },\n  get vertexShader() {\n    return get().vertexShader;\n  },\n  set vertexShader(value) {\n    get().vertexShader = value;\n  },\n  get fragmentShader() {\n    return get().vertexShader;\n  },\n  set fragmentShader(value) {\n    get().vertexShader = value;\n  }\n};\nexport {\n  SubsurfaceScatteringShader\n};\n"]},"metadata":{},"sourceType":"module"}