{"ast":null,"code":"import { Color, MathUtils } from \"three\";\n\nclass Lut {\n  constructor(colormap, count = 32) {\n    this.isLut = true;\n    this.lut = [];\n    this.map = [];\n    this.n = 0;\n    this.minV = 0;\n    this.maxV = 1;\n    this.setColorMap(colormap, count);\n  }\n\n  set(value) {\n    if (value.isLut === true) {\n      this.copy(value);\n    }\n\n    return this;\n  }\n\n  setMin(min) {\n    this.minV = min;\n    return this;\n  }\n\n  setMax(max) {\n    this.maxV = max;\n    return this;\n  }\n\n  setColorMap(colormap, count = 32) {\n    this.map = ColorMapKeywords[colormap] || ColorMapKeywords.rainbow;\n    this.n = count;\n    const step = 1 / this.n;\n    const minColor = new Color();\n    const maxColor = new Color();\n    this.lut.length = 0;\n    this.lut.push(new Color(this.map[0][1]));\n\n    for (let i = 1; i < count; i++) {\n      const alpha = i * step;\n\n      for (let j = 0; j < this.map.length - 1; j++) {\n        if (alpha > this.map[j][0] && alpha <= this.map[j + 1][0]) {\n          const min = this.map[j][0];\n          const max = this.map[j + 1][0];\n          minColor.setHex(this.map[j][1], \"linear-srgb\");\n          maxColor.setHex(this.map[j + 1][1], \"linear-srgb\");\n          const color = new Color().lerpColors(minColor, maxColor, (alpha - min) / (max - min));\n          this.lut.push(color);\n        }\n      }\n    }\n\n    this.lut.push(new Color(this.map[this.map.length - 1][1]));\n    return this;\n  }\n\n  copy(lut) {\n    this.lut = lut.lut;\n    this.map = lut.map;\n    this.n = lut.n;\n    this.minV = lut.minV;\n    this.maxV = lut.maxV;\n    return this;\n  }\n\n  getColor(alpha) {\n    alpha = MathUtils.clamp(alpha, this.minV, this.maxV);\n    alpha = (alpha - this.minV) / (this.maxV - this.minV);\n    const colorPosition = Math.round(alpha * this.n);\n    return this.lut[colorPosition];\n  }\n\n  addColorMap(name, arrayOfColors) {\n    ColorMapKeywords[name] = arrayOfColors;\n    return this;\n  }\n\n  createCanvas() {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = 1;\n    canvas.height = this.n;\n    this.updateCanvas(canvas);\n    return canvas;\n  }\n\n  updateCanvas(canvas) {\n    const ctx = canvas.getContext(\"2d\", {\n      alpha: false\n    });\n    const imageData = ctx.getImageData(0, 0, 1, this.n);\n    const data = imageData.data;\n    let k = 0;\n    const step = 1 / this.n;\n    const minColor = new Color();\n    const maxColor = new Color();\n    const finalColor = new Color();\n\n    for (let i = 1; i >= 0; i -= step) {\n      for (let j = this.map.length - 1; j >= 0; j--) {\n        if (i < this.map[j][0] && i >= this.map[j - 1][0]) {\n          const min = this.map[j - 1][0];\n          const max = this.map[j][0];\n          minColor.setHex(this.map[j - 1][1], \"linear-srgb\");\n          maxColor.setHex(this.map[j][1], \"linear-srgb\");\n          finalColor.lerpColors(minColor, maxColor, (i - min) / (max - min));\n          data[k * 4] = Math.round(finalColor.r * 255);\n          data[k * 4 + 1] = Math.round(finalColor.g * 255);\n          data[k * 4 + 2] = Math.round(finalColor.b * 255);\n          data[k * 4 + 3] = 255;\n          k += 1;\n        }\n      }\n    }\n\n    ctx.putImageData(imageData, 0, 0);\n    return canvas;\n  }\n\n}\n\nconst ColorMapKeywords = {\n  rainbow: [[0, 255], [0.2, 65535], [0.5, 65280], [0.8, 16776960], [1, 16711680]],\n  cooltowarm: [[0, 3952322], [0.2, 10206463], [0.5, 14474460], [0.8, 16163717], [1, 11797542]],\n  blackbody: [[0, 0], [0.2, 7864320], [0.5, 15086080], [0.8, 16776960], [1, 16777215]],\n  grayscale: [[0, 0], [0.2, 4210752], [0.5, 8355712], [0.8, 12566463], [1, 16777215]]\n};\nexport { ColorMapKeywords, Lut };","map":{"version":3,"sources":["/Users/theodaguier/Developer/old/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/three-stdlib/math/Lut.js"],"names":["Color","MathUtils","Lut","constructor","colormap","count","isLut","lut","map","n","minV","maxV","setColorMap","set","value","copy","setMin","min","setMax","max","ColorMapKeywords","rainbow","step","minColor","maxColor","length","push","i","alpha","j","setHex","color","lerpColors","getColor","clamp","colorPosition","Math","round","addColorMap","name","arrayOfColors","createCanvas","canvas","document","createElement","width","height","updateCanvas","ctx","getContext","imageData","getImageData","data","k","finalColor","r","g","b","putImageData","cooltowarm","blackbody","grayscale"],"mappings":"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","sourcesContent":["import { Color, MathUtils } from \"three\";\nclass Lut {\n  constructor(colormap, count = 32) {\n    this.isLut = true;\n    this.lut = [];\n    this.map = [];\n    this.n = 0;\n    this.minV = 0;\n    this.maxV = 1;\n    this.setColorMap(colormap, count);\n  }\n  set(value) {\n    if (value.isLut === true) {\n      this.copy(value);\n    }\n    return this;\n  }\n  setMin(min) {\n    this.minV = min;\n    return this;\n  }\n  setMax(max) {\n    this.maxV = max;\n    return this;\n  }\n  setColorMap(colormap, count = 32) {\n    this.map = ColorMapKeywords[colormap] || ColorMapKeywords.rainbow;\n    this.n = count;\n    const step = 1 / this.n;\n    const minColor = new Color();\n    const maxColor = new Color();\n    this.lut.length = 0;\n    this.lut.push(new Color(this.map[0][1]));\n    for (let i = 1; i < count; i++) {\n      const alpha = i * step;\n      for (let j = 0; j < this.map.length - 1; j++) {\n        if (alpha > this.map[j][0] && alpha <= this.map[j + 1][0]) {\n          const min = this.map[j][0];\n          const max = this.map[j + 1][0];\n          minColor.setHex(this.map[j][1], \"linear-srgb\");\n          maxColor.setHex(this.map[j + 1][1], \"linear-srgb\");\n          const color = new Color().lerpColors(minColor, maxColor, (alpha - min) / (max - min));\n          this.lut.push(color);\n        }\n      }\n    }\n    this.lut.push(new Color(this.map[this.map.length - 1][1]));\n    return this;\n  }\n  copy(lut) {\n    this.lut = lut.lut;\n    this.map = lut.map;\n    this.n = lut.n;\n    this.minV = lut.minV;\n    this.maxV = lut.maxV;\n    return this;\n  }\n  getColor(alpha) {\n    alpha = MathUtils.clamp(alpha, this.minV, this.maxV);\n    alpha = (alpha - this.minV) / (this.maxV - this.minV);\n    const colorPosition = Math.round(alpha * this.n);\n    return this.lut[colorPosition];\n  }\n  addColorMap(name, arrayOfColors) {\n    ColorMapKeywords[name] = arrayOfColors;\n    return this;\n  }\n  createCanvas() {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = 1;\n    canvas.height = this.n;\n    this.updateCanvas(canvas);\n    return canvas;\n  }\n  updateCanvas(canvas) {\n    const ctx = canvas.getContext(\"2d\", { alpha: false });\n    const imageData = ctx.getImageData(0, 0, 1, this.n);\n    const data = imageData.data;\n    let k = 0;\n    const step = 1 / this.n;\n    const minColor = new Color();\n    const maxColor = new Color();\n    const finalColor = new Color();\n    for (let i = 1; i >= 0; i -= step) {\n      for (let j = this.map.length - 1; j >= 0; j--) {\n        if (i < this.map[j][0] && i >= this.map[j - 1][0]) {\n          const min = this.map[j - 1][0];\n          const max = this.map[j][0];\n          minColor.setHex(this.map[j - 1][1], \"linear-srgb\");\n          maxColor.setHex(this.map[j][1], \"linear-srgb\");\n          finalColor.lerpColors(minColor, maxColor, (i - min) / (max - min));\n          data[k * 4] = Math.round(finalColor.r * 255);\n          data[k * 4 + 1] = Math.round(finalColor.g * 255);\n          data[k * 4 + 2] = Math.round(finalColor.b * 255);\n          data[k * 4 + 3] = 255;\n          k += 1;\n        }\n      }\n    }\n    ctx.putImageData(imageData, 0, 0);\n    return canvas;\n  }\n}\nconst ColorMapKeywords = {\n  rainbow: [\n    [0, 255],\n    [0.2, 65535],\n    [0.5, 65280],\n    [0.8, 16776960],\n    [1, 16711680]\n  ],\n  cooltowarm: [\n    [0, 3952322],\n    [0.2, 10206463],\n    [0.5, 14474460],\n    [0.8, 16163717],\n    [1, 11797542]\n  ],\n  blackbody: [\n    [0, 0],\n    [0.2, 7864320],\n    [0.5, 15086080],\n    [0.8, 16776960],\n    [1, 16777215]\n  ],\n  grayscale: [\n    [0, 0],\n    [0.2, 4210752],\n    [0.5, 8355712],\n    [0.8, 12566463],\n    [1, 16777215]\n  ]\n};\nexport {\n  ColorMapKeywords,\n  Lut\n};\n"]},"metadata":{},"sourceType":"module"}