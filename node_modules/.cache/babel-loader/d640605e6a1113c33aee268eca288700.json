{"ast":null,"code":"'use strict';\n\nvar urllib = require('url');\n\nvar util = require('util');\n\nvar fs = require('fs');\n\nvar fetch = require('nodemailer-fetch');\n/**\n * Parses connection url to a structured configuration object\n *\n * @param {String} str Connection url\n * @return {Object} Configuration object\n */\n\n\nmodule.exports.parseConnectionUrl = function (str) {\n  str = str || '';\n  var options = {};\n  [urllib.parse(str, true)].forEach(function (url) {\n    var auth;\n\n    switch (url.protocol) {\n      case 'smtp:':\n        options.secure = false;\n        break;\n\n      case 'smtps:':\n        options.secure = true;\n        break;\n\n      case 'direct:':\n        options.direct = true;\n        break;\n    }\n\n    if (!isNaN(url.port) && Number(url.port)) {\n      options.port = Number(url.port);\n    }\n\n    if (url.hostname) {\n      options.host = url.hostname;\n    }\n\n    if (url.auth) {\n      auth = url.auth.split(':');\n\n      if (!options.auth) {\n        options.auth = {};\n      }\n\n      options.auth.user = decodeURIComponent(auth[0]);\n      options.auth.pass = decodeURIComponent(auth[1]);\n    }\n\n    Object.keys(url.query || {}).forEach(function (key) {\n      var obj = options;\n      var lKey = key;\n      var value = url.query[key];\n\n      if (!isNaN(value)) {\n        value = Number(value);\n      }\n\n      switch (value) {\n        case 'true':\n          value = true;\n          break;\n\n        case 'false':\n          value = false;\n          break;\n      } // tls is nested object\n\n\n      if (key.indexOf('tls.') === 0) {\n        lKey = key.substr(4);\n\n        if (!options.tls) {\n          options.tls = {};\n        }\n\n        obj = options.tls;\n      } else if (key.indexOf('.') >= 0) {\n        // ignore nested properties besides tls\n        return;\n      }\n\n      if (!(lKey in obj)) {\n        obj[lKey] = value;\n      }\n    });\n  });\n  return options;\n};\n/**\n * Returns a bunyan-compatible logger interface. Uses either provided logger or\n * creates a default console logger\n *\n * @param {Object} [options] Options object that might include 'logger' value\n * @return {Object} bunyan compatible logger\n */\n\n\nmodule.exports.getLogger = function (options) {\n  options = options || {};\n\n  if (!options.logger) {\n    // use vanity logger\n    return {\n      info: function () {},\n      debug: function () {},\n      error: function () {}\n    };\n  }\n\n  if (options.logger === true) {\n    // create console logger\n    return createDefaultLogger();\n  } // return whatever was passed\n\n\n  return options.logger;\n};\n/**\n * Wrapper for creating a callback than either resolves or rejects a promise\n * based on input\n *\n * @param {Function} resolve Function to run if callback is called\n * @param {Function} reject Function to run if callback ends with an error\n */\n\n\nmodule.exports.callbackPromise = function (resolve, reject) {\n  return function () {\n    var args = Array.prototype.slice.call(arguments);\n    var err = args.shift();\n\n    if (err) {\n      reject(err);\n    } else {\n      resolve.apply(null, args);\n    }\n  };\n};\n/**\n * Resolves a String or a Buffer value for content value. Useful if the value\n * is a Stream or a file or an URL. If the value is a Stream, overwrites\n * the stream object with the resolved value (you can't stream a value twice).\n *\n * This is useful when you want to create a plugin that needs a content value,\n * for example the `html` or `text` value as a String or a Buffer but not as\n * a file path or an URL.\n *\n * @param {Object} data An object or an Array you want to resolve an element for\n * @param {String|Number} key Property name or an Array index\n * @param {Function} callback Callback function with (err, value)\n */\n\n\nmodule.exports.resolveContent = function (data, key, callback) {\n  var promise;\n\n  if (!callback && typeof Promise === 'function') {\n    promise = new Promise(function (resolve, reject) {\n      callback = module.exports.callbackPromise(resolve, reject);\n    });\n  }\n\n  var content = data && data[key] && data[key].content || data[key];\n  var contentStream;\n  var encoding = (typeof data[key] === 'object' && data[key].encoding || 'utf8').toString().toLowerCase().replace(/[-_\\s]/g, '');\n\n  if (!content) {\n    return callback(null, content);\n  }\n\n  if (typeof content === 'object') {\n    if (typeof content.pipe === 'function') {\n      return resolveStream(content, function (err, value) {\n        if (err) {\n          return callback(err);\n        } // we can't stream twice the same content, so we need\n        // to replace the stream object with the streaming result\n\n\n        data[key] = value;\n        callback(null, value);\n      });\n    } else if (/^https?:\\/\\//i.test(content.path || content.href)) {\n      contentStream = fetch(content.path || content.href);\n      return resolveStream(contentStream, callback);\n    } else if (/^data:/i.test(content.path || content.href)) {\n      var parts = (content.path || content.href).match(/^data:((?:[^;]*;)*(?:[^,]*)),(.*)$/i);\n\n      if (!parts) {\n        return callback(null, new Buffer(0));\n      }\n\n      return callback(null, /\\bbase64$/i.test(parts[1]) ? new Buffer(parts[2], 'base64') : new Buffer(decodeURIComponent(parts[2])));\n    } else if (content.path) {\n      return resolveStream(fs.createReadStream(content.path), callback);\n    }\n  }\n\n  if (typeof data[key].content === 'string' && ['utf8', 'usascii', 'ascii'].indexOf(encoding) < 0) {\n    content = new Buffer(data[key].content, encoding);\n  } // default action, return as is\n\n\n  setImmediate(callback.bind(null, null, content));\n  return promise;\n};\n/**\n * Streams a stream value into a Buffer\n *\n * @param {Object} stream Readable stream\n * @param {Function} callback Callback function with (err, value)\n */\n\n\nfunction resolveStream(stream, callback) {\n  var responded = false;\n  var chunks = [];\n  var chunklen = 0;\n  stream.on('error', function (err) {\n    if (responded) {\n      return;\n    }\n\n    responded = true;\n    callback(err);\n  });\n  stream.on('readable', function () {\n    var chunk;\n\n    while ((chunk = stream.read()) !== null) {\n      chunks.push(chunk);\n      chunklen += chunk.length;\n    }\n  });\n  stream.on('end', function () {\n    if (responded) {\n      return;\n    }\n\n    responded = true;\n    var value;\n\n    try {\n      value = Buffer.concat(chunks, chunklen);\n    } catch (E) {\n      return callback(E);\n    }\n\n    callback(null, value);\n  });\n}\n/**\n * Generates a bunyan-like logger that prints to console\n *\n * @returns {Object} Bunyan logger instance\n */\n\n\nfunction createDefaultLogger() {\n  var logger = {\n    _print: function () {\n      var args = Array.prototype.slice.call(arguments);\n      var level = args.shift();\n      var message;\n\n      if (args.length > 1) {\n        message = util.format.apply(util, args);\n      } else {\n        message = args.shift();\n      }\n\n      console.log('[%s] %s: %s', new Date().toISOString().substr(0, 19).replace(/T/, ' '), level.toUpperCase(), message);\n    }\n  };\n  logger.info = logger._print.bind(null, 'info');\n  logger.debug = logger._print.bind(null, 'debug');\n  logger.error = logger._print.bind(null, 'error');\n  return logger;\n}","map":{"version":3,"sources":["/Users/theodaguier/e-do/node_modules/nodemailer-shared/lib/shared.js"],"names":["urllib","require","util","fs","fetch","module","exports","parseConnectionUrl","str","options","parse","forEach","url","auth","protocol","secure","direct","isNaN","port","Number","hostname","host","split","user","decodeURIComponent","pass","Object","keys","query","key","obj","lKey","value","indexOf","substr","tls","getLogger","logger","info","debug","error","createDefaultLogger","callbackPromise","resolve","reject","args","Array","prototype","slice","call","arguments","err","shift","apply","resolveContent","data","callback","promise","Promise","content","contentStream","encoding","toString","toLowerCase","replace","pipe","resolveStream","test","path","href","parts","match","Buffer","createReadStream","setImmediate","bind","stream","responded","chunks","chunklen","on","chunk","read","push","length","concat","E","_print","level","message","format","console","log","Date","toISOString","toUpperCase"],"mappings":"AAAA;;AAEA,IAAIA,MAAM,GAAGC,OAAO,CAAC,KAAD,CAApB;;AACA,IAAIC,IAAI,GAAGD,OAAO,CAAC,MAAD,CAAlB;;AACA,IAAIE,EAAE,GAAGF,OAAO,CAAC,IAAD,CAAhB;;AACA,IAAIG,KAAK,GAAGH,OAAO,CAAC,kBAAD,CAAnB;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACAI,MAAM,CAACC,OAAP,CAAeC,kBAAf,GAAoC,UAAUC,GAAV,EAAe;AAC/CA,EAAAA,GAAG,GAAGA,GAAG,IAAI,EAAb;AACA,MAAIC,OAAO,GAAG,EAAd;AAEA,GAACT,MAAM,CAACU,KAAP,CAAaF,GAAb,EAAkB,IAAlB,CAAD,EAA0BG,OAA1B,CAAkC,UAAUC,GAAV,EAAe;AAC7C,QAAIC,IAAJ;;AAEA,YAAQD,GAAG,CAACE,QAAZ;AACI,WAAK,OAAL;AACIL,QAAAA,OAAO,CAACM,MAAR,GAAiB,KAAjB;AACA;;AACJ,WAAK,QAAL;AACIN,QAAAA,OAAO,CAACM,MAAR,GAAiB,IAAjB;AACA;;AACJ,WAAK,SAAL;AACIN,QAAAA,OAAO,CAACO,MAAR,GAAiB,IAAjB;AACA;AATR;;AAYA,QAAI,CAACC,KAAK,CAACL,GAAG,CAACM,IAAL,CAAN,IAAoBC,MAAM,CAACP,GAAG,CAACM,IAAL,CAA9B,EAA0C;AACtCT,MAAAA,OAAO,CAACS,IAAR,GAAeC,MAAM,CAACP,GAAG,CAACM,IAAL,CAArB;AACH;;AAED,QAAIN,GAAG,CAACQ,QAAR,EAAkB;AACdX,MAAAA,OAAO,CAACY,IAAR,GAAeT,GAAG,CAACQ,QAAnB;AACH;;AAED,QAAIR,GAAG,CAACC,IAAR,EAAc;AACVA,MAAAA,IAAI,GAAGD,GAAG,CAACC,IAAJ,CAASS,KAAT,CAAe,GAAf,CAAP;;AAEA,UAAI,CAACb,OAAO,CAACI,IAAb,EAAmB;AACfJ,QAAAA,OAAO,CAACI,IAAR,GAAe,EAAf;AACH;;AAEDJ,MAAAA,OAAO,CAACI,IAAR,CAAaU,IAAb,GAAoBC,kBAAkB,CAACX,IAAI,CAAC,CAAD,CAAL,CAAtC;AACAJ,MAAAA,OAAO,CAACI,IAAR,CAAaY,IAAb,GAAoBD,kBAAkB,CAACX,IAAI,CAAC,CAAD,CAAL,CAAtC;AACH;;AAEDa,IAAAA,MAAM,CAACC,IAAP,CAAYf,GAAG,CAACgB,KAAJ,IAAa,EAAzB,EAA6BjB,OAA7B,CAAqC,UAAUkB,GAAV,EAAe;AAChD,UAAIC,GAAG,GAAGrB,OAAV;AACA,UAAIsB,IAAI,GAAGF,GAAX;AACA,UAAIG,KAAK,GAAGpB,GAAG,CAACgB,KAAJ,CAAUC,GAAV,CAAZ;;AAEA,UAAI,CAACZ,KAAK,CAACe,KAAD,CAAV,EAAmB;AACfA,QAAAA,KAAK,GAAGb,MAAM,CAACa,KAAD,CAAd;AACH;;AAED,cAAQA,KAAR;AACI,aAAK,MAAL;AACIA,UAAAA,KAAK,GAAG,IAAR;AACA;;AACJ,aAAK,OAAL;AACIA,UAAAA,KAAK,GAAG,KAAR;AACA;AANR,OATgD,CAkBhD;;;AACA,UAAIH,GAAG,CAACI,OAAJ,CAAY,MAAZ,MAAwB,CAA5B,EAA+B;AAC3BF,QAAAA,IAAI,GAAGF,GAAG,CAACK,MAAJ,CAAW,CAAX,CAAP;;AACA,YAAI,CAACzB,OAAO,CAAC0B,GAAb,EAAkB;AACd1B,UAAAA,OAAO,CAAC0B,GAAR,GAAc,EAAd;AACH;;AACDL,QAAAA,GAAG,GAAGrB,OAAO,CAAC0B,GAAd;AACH,OAND,MAMO,IAAIN,GAAG,CAACI,OAAJ,CAAY,GAAZ,KAAoB,CAAxB,EAA2B;AAC9B;AACA;AACH;;AAED,UAAI,EAAEF,IAAI,IAAID,GAAV,CAAJ,EAAoB;AAChBA,QAAAA,GAAG,CAACC,IAAD,CAAH,GAAYC,KAAZ;AACH;AACJ,KAjCD;AAkCH,GApED;AAsEA,SAAOvB,OAAP;AACH,CA3ED;AA6EA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAJ,MAAM,CAACC,OAAP,CAAe8B,SAAf,GAA2B,UAAU3B,OAAV,EAAmB;AAC1CA,EAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;;AAEA,MAAI,CAACA,OAAO,CAAC4B,MAAb,EAAqB;AACjB;AACA,WAAO;AACHC,MAAAA,IAAI,EAAE,YAAY,CAAE,CADjB;AAEHC,MAAAA,KAAK,EAAE,YAAY,CAAE,CAFlB;AAGHC,MAAAA,KAAK,EAAE,YAAY,CAAE;AAHlB,KAAP;AAKH;;AAED,MAAI/B,OAAO,CAAC4B,MAAR,KAAmB,IAAvB,EAA6B;AACzB;AACA,WAAOI,mBAAmB,EAA1B;AACH,GAfyC,CAiB1C;;;AACA,SAAOhC,OAAO,CAAC4B,MAAf;AACH,CAnBD;AAqBA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAhC,MAAM,CAACC,OAAP,CAAeoC,eAAf,GAAiC,UAAUC,OAAV,EAAmBC,MAAnB,EAA2B;AACxD,SAAO,YAAY;AACf,QAAIC,IAAI,GAAGC,KAAK,CAACC,SAAN,CAAgBC,KAAhB,CAAsBC,IAAtB,CAA2BC,SAA3B,CAAX;AACA,QAAIC,GAAG,GAAGN,IAAI,CAACO,KAAL,EAAV;;AACA,QAAID,GAAJ,EAAS;AACLP,MAAAA,MAAM,CAACO,GAAD,CAAN;AACH,KAFD,MAEO;AACHR,MAAAA,OAAO,CAACU,KAAR,CAAc,IAAd,EAAoBR,IAApB;AACH;AACJ,GARD;AASH,CAVD;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAxC,MAAM,CAACC,OAAP,CAAegD,cAAf,GAAgC,UAAUC,IAAV,EAAgB1B,GAAhB,EAAqB2B,QAArB,EAA+B;AAC3D,MAAIC,OAAJ;;AAEA,MAAI,CAACD,QAAD,IAAa,OAAOE,OAAP,KAAmB,UAApC,EAAgD;AAC5CD,IAAAA,OAAO,GAAG,IAAIC,OAAJ,CAAY,UAAUf,OAAV,EAAmBC,MAAnB,EAA2B;AAC7CY,MAAAA,QAAQ,GAAGnD,MAAM,CAACC,OAAP,CAAeoC,eAAf,CAA+BC,OAA/B,EAAwCC,MAAxC,CAAX;AACH,KAFS,CAAV;AAGH;;AAED,MAAIe,OAAO,GAAGJ,IAAI,IAAIA,IAAI,CAAC1B,GAAD,CAAZ,IAAqB0B,IAAI,CAAC1B,GAAD,CAAJ,CAAU8B,OAA/B,IAA0CJ,IAAI,CAAC1B,GAAD,CAA5D;AACA,MAAI+B,aAAJ;AACA,MAAIC,QAAQ,GAAG,CAAC,OAAON,IAAI,CAAC1B,GAAD,CAAX,KAAqB,QAArB,IAAiC0B,IAAI,CAAC1B,GAAD,CAAJ,CAAUgC,QAA3C,IAAuD,MAAxD,EACVC,QADU,GAEVC,WAFU,GAGVC,OAHU,CAGF,SAHE,EAGS,EAHT,CAAf;;AAKA,MAAI,CAACL,OAAL,EAAc;AACV,WAAOH,QAAQ,CAAC,IAAD,EAAOG,OAAP,CAAf;AACH;;AAED,MAAI,OAAOA,OAAP,KAAmB,QAAvB,EAAiC;AAC7B,QAAI,OAAOA,OAAO,CAACM,IAAf,KAAwB,UAA5B,EAAwC;AACpC,aAAOC,aAAa,CAACP,OAAD,EAAU,UAAUR,GAAV,EAAenB,KAAf,EAAsB;AAChD,YAAImB,GAAJ,EAAS;AACL,iBAAOK,QAAQ,CAACL,GAAD,CAAf;AACH,SAH+C,CAIhD;AACA;;;AACAI,QAAAA,IAAI,CAAC1B,GAAD,CAAJ,GAAYG,KAAZ;AACAwB,QAAAA,QAAQ,CAAC,IAAD,EAAOxB,KAAP,CAAR;AACH,OARmB,CAApB;AASH,KAVD,MAUO,IAAI,gBAAgBmC,IAAhB,CAAqBR,OAAO,CAACS,IAAR,IAAgBT,OAAO,CAACU,IAA7C,CAAJ,EAAwD;AAC3DT,MAAAA,aAAa,GAAGxD,KAAK,CAACuD,OAAO,CAACS,IAAR,IAAgBT,OAAO,CAACU,IAAzB,CAArB;AACA,aAAOH,aAAa,CAACN,aAAD,EAAgBJ,QAAhB,CAApB;AACH,KAHM,MAGA,IAAI,UAAUW,IAAV,CAAeR,OAAO,CAACS,IAAR,IAAgBT,OAAO,CAACU,IAAvC,CAAJ,EAAkD;AACrD,UAAIC,KAAK,GAAG,CAACX,OAAO,CAACS,IAAR,IAAgBT,OAAO,CAACU,IAAzB,EAA+BE,KAA/B,CAAqC,qCAArC,CAAZ;;AACA,UAAI,CAACD,KAAL,EAAY;AACR,eAAOd,QAAQ,CAAC,IAAD,EAAO,IAAIgB,MAAJ,CAAW,CAAX,CAAP,CAAf;AACH;;AACD,aAAOhB,QAAQ,CAAC,IAAD,EAAO,aAAaW,IAAb,CAAkBG,KAAK,CAAC,CAAD,CAAvB,IAA8B,IAAIE,MAAJ,CAAWF,KAAK,CAAC,CAAD,CAAhB,EAAqB,QAArB,CAA9B,GAA+D,IAAIE,MAAJ,CAAWhD,kBAAkB,CAAC8C,KAAK,CAAC,CAAD,CAAN,CAA7B,CAAtE,CAAf;AACH,KANM,MAMA,IAAIX,OAAO,CAACS,IAAZ,EAAkB;AACrB,aAAOF,aAAa,CAAC/D,EAAE,CAACsE,gBAAH,CAAoBd,OAAO,CAACS,IAA5B,CAAD,EAAoCZ,QAApC,CAApB;AACH;AACJ;;AAED,MAAI,OAAOD,IAAI,CAAC1B,GAAD,CAAJ,CAAU8B,OAAjB,KAA6B,QAA7B,IAAyC,CAAC,MAAD,EAAS,SAAT,EAAoB,OAApB,EAA6B1B,OAA7B,CAAqC4B,QAArC,IAAiD,CAA9F,EAAiG;AAC7FF,IAAAA,OAAO,GAAG,IAAIa,MAAJ,CAAWjB,IAAI,CAAC1B,GAAD,CAAJ,CAAU8B,OAArB,EAA8BE,QAA9B,CAAV;AACH,GA/C0D,CAiD3D;;;AACAa,EAAAA,YAAY,CAAClB,QAAQ,CAACmB,IAAT,CAAc,IAAd,EAAoB,IAApB,EAA0BhB,OAA1B,CAAD,CAAZ;AAEA,SAAOF,OAAP;AACH,CArDD;AAuDA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASS,aAAT,CAAuBU,MAAvB,EAA+BpB,QAA/B,EAAyC;AACrC,MAAIqB,SAAS,GAAG,KAAhB;AACA,MAAIC,MAAM,GAAG,EAAb;AACA,MAAIC,QAAQ,GAAG,CAAf;AAEAH,EAAAA,MAAM,CAACI,EAAP,CAAU,OAAV,EAAmB,UAAU7B,GAAV,EAAe;AAC9B,QAAI0B,SAAJ,EAAe;AACX;AACH;;AAEDA,IAAAA,SAAS,GAAG,IAAZ;AACArB,IAAAA,QAAQ,CAACL,GAAD,CAAR;AACH,GAPD;AASAyB,EAAAA,MAAM,CAACI,EAAP,CAAU,UAAV,EAAsB,YAAY;AAC9B,QAAIC,KAAJ;;AACA,WAAO,CAACA,KAAK,GAAGL,MAAM,CAACM,IAAP,EAAT,MAA4B,IAAnC,EAAyC;AACrCJ,MAAAA,MAAM,CAACK,IAAP,CAAYF,KAAZ;AACAF,MAAAA,QAAQ,IAAIE,KAAK,CAACG,MAAlB;AACH;AACJ,GAND;AAQAR,EAAAA,MAAM,CAACI,EAAP,CAAU,KAAV,EAAiB,YAAY;AACzB,QAAIH,SAAJ,EAAe;AACX;AACH;;AACDA,IAAAA,SAAS,GAAG,IAAZ;AAEA,QAAI7C,KAAJ;;AAEA,QAAI;AACAA,MAAAA,KAAK,GAAGwC,MAAM,CAACa,MAAP,CAAcP,MAAd,EAAsBC,QAAtB,CAAR;AACH,KAFD,CAEE,OAAOO,CAAP,EAAU;AACR,aAAO9B,QAAQ,CAAC8B,CAAD,CAAf;AACH;;AACD9B,IAAAA,QAAQ,CAAC,IAAD,EAAOxB,KAAP,CAAR;AACH,GAdD;AAeH;AAED;AACA;AACA;AACA;AACA;;;AACA,SAASS,mBAAT,GAA+B;AAE3B,MAAIJ,MAAM,GAAG;AACTkD,IAAAA,MAAM,EAAE,YAAkC;AACtC,UAAI1C,IAAI,GAAGC,KAAK,CAACC,SAAN,CAAgBC,KAAhB,CAAsBC,IAAtB,CAA2BC,SAA3B,CAAX;AACA,UAAIsC,KAAK,GAAG3C,IAAI,CAACO,KAAL,EAAZ;AACA,UAAIqC,OAAJ;;AAEA,UAAI5C,IAAI,CAACuC,MAAL,GAAc,CAAlB,EAAqB;AACjBK,QAAAA,OAAO,GAAGvF,IAAI,CAACwF,MAAL,CAAYrC,KAAZ,CAAkBnD,IAAlB,EAAwB2C,IAAxB,CAAV;AACH,OAFD,MAEO;AACH4C,QAAAA,OAAO,GAAG5C,IAAI,CAACO,KAAL,EAAV;AACH;;AAEDuC,MAAAA,OAAO,CAACC,GAAR,CAAY,aAAZ,EACI,IAAIC,IAAJ,GAAWC,WAAX,GAAyB5D,MAAzB,CAAgC,CAAhC,EAAmC,EAAnC,EAAuC8B,OAAvC,CAA+C,GAA/C,EAAoD,GAApD,CADJ,EAEIwB,KAAK,CAACO,WAAN,EAFJ,EAGIN,OAHJ;AAIH;AAhBQ,GAAb;AAmBApD,EAAAA,MAAM,CAACC,IAAP,GAAcD,MAAM,CAACkD,MAAP,CAAcZ,IAAd,CAAmB,IAAnB,EAAyB,MAAzB,CAAd;AACAtC,EAAAA,MAAM,CAACE,KAAP,GAAeF,MAAM,CAACkD,MAAP,CAAcZ,IAAd,CAAmB,IAAnB,EAAyB,OAAzB,CAAf;AACAtC,EAAAA,MAAM,CAACG,KAAP,GAAeH,MAAM,CAACkD,MAAP,CAAcZ,IAAd,CAAmB,IAAnB,EAAyB,OAAzB,CAAf;AAEA,SAAOtC,MAAP;AACH","sourcesContent":["'use strict';\n\nvar urllib = require('url');\nvar util = require('util');\nvar fs = require('fs');\nvar fetch = require('nodemailer-fetch');\n\n/**\n * Parses connection url to a structured configuration object\n *\n * @param {String} str Connection url\n * @return {Object} Configuration object\n */\nmodule.exports.parseConnectionUrl = function (str) {\n    str = str || '';\n    var options = {};\n\n    [urllib.parse(str, true)].forEach(function (url) {\n        var auth;\n\n        switch (url.protocol) {\n            case 'smtp:':\n                options.secure = false;\n                break;\n            case 'smtps:':\n                options.secure = true;\n                break;\n            case 'direct:':\n                options.direct = true;\n                break;\n        }\n\n        if (!isNaN(url.port) && Number(url.port)) {\n            options.port = Number(url.port);\n        }\n\n        if (url.hostname) {\n            options.host = url.hostname;\n        }\n\n        if (url.auth) {\n            auth = url.auth.split(':');\n\n            if (!options.auth) {\n                options.auth = {};\n            }\n\n            options.auth.user = decodeURIComponent(auth[0]);\n            options.auth.pass = decodeURIComponent(auth[1]);\n        }\n\n        Object.keys(url.query || {}).forEach(function (key) {\n            var obj = options;\n            var lKey = key;\n            var value = url.query[key];\n\n            if (!isNaN(value)) {\n                value = Number(value);\n            }\n\n            switch (value) {\n                case 'true':\n                    value = true;\n                    break;\n                case 'false':\n                    value = false;\n                    break;\n            }\n\n            // tls is nested object\n            if (key.indexOf('tls.') === 0) {\n                lKey = key.substr(4);\n                if (!options.tls) {\n                    options.tls = {};\n                }\n                obj = options.tls;\n            } else if (key.indexOf('.') >= 0) {\n                // ignore nested properties besides tls\n                return;\n            }\n\n            if (!(lKey in obj)) {\n                obj[lKey] = value;\n            }\n        });\n    });\n\n    return options;\n};\n\n/**\n * Returns a bunyan-compatible logger interface. Uses either provided logger or\n * creates a default console logger\n *\n * @param {Object} [options] Options object that might include 'logger' value\n * @return {Object} bunyan compatible logger\n */\nmodule.exports.getLogger = function (options) {\n    options = options || {};\n\n    if (!options.logger) {\n        // use vanity logger\n        return {\n            info: function () {},\n            debug: function () {},\n            error: function () {}\n        };\n    }\n\n    if (options.logger === true) {\n        // create console logger\n        return createDefaultLogger();\n    }\n\n    // return whatever was passed\n    return options.logger;\n};\n\n/**\n * Wrapper for creating a callback than either resolves or rejects a promise\n * based on input\n *\n * @param {Function} resolve Function to run if callback is called\n * @param {Function} reject Function to run if callback ends with an error\n */\nmodule.exports.callbackPromise = function (resolve, reject) {\n    return function () {\n        var args = Array.prototype.slice.call(arguments);\n        var err = args.shift();\n        if (err) {\n            reject(err);\n        } else {\n            resolve.apply(null, args);\n        }\n    };\n};\n\n/**\n * Resolves a String or a Buffer value for content value. Useful if the value\n * is a Stream or a file or an URL. If the value is a Stream, overwrites\n * the stream object with the resolved value (you can't stream a value twice).\n *\n * This is useful when you want to create a plugin that needs a content value,\n * for example the `html` or `text` value as a String or a Buffer but not as\n * a file path or an URL.\n *\n * @param {Object} data An object or an Array you want to resolve an element for\n * @param {String|Number} key Property name or an Array index\n * @param {Function} callback Callback function with (err, value)\n */\nmodule.exports.resolveContent = function (data, key, callback) {\n    var promise;\n\n    if (!callback && typeof Promise === 'function') {\n        promise = new Promise(function (resolve, reject) {\n            callback = module.exports.callbackPromise(resolve, reject);\n        });\n    }\n\n    var content = data && data[key] && data[key].content || data[key];\n    var contentStream;\n    var encoding = (typeof data[key] === 'object' && data[key].encoding || 'utf8')\n        .toString()\n        .toLowerCase()\n        .replace(/[-_\\s]/g, '');\n\n    if (!content) {\n        return callback(null, content);\n    }\n\n    if (typeof content === 'object') {\n        if (typeof content.pipe === 'function') {\n            return resolveStream(content, function (err, value) {\n                if (err) {\n                    return callback(err);\n                }\n                // we can't stream twice the same content, so we need\n                // to replace the stream object with the streaming result\n                data[key] = value;\n                callback(null, value);\n            });\n        } else if (/^https?:\\/\\//i.test(content.path || content.href)) {\n            contentStream = fetch(content.path || content.href);\n            return resolveStream(contentStream, callback);\n        } else if (/^data:/i.test(content.path || content.href)) {\n            var parts = (content.path || content.href).match(/^data:((?:[^;]*;)*(?:[^,]*)),(.*)$/i);\n            if (!parts) {\n                return callback(null, new Buffer(0));\n            }\n            return callback(null, /\\bbase64$/i.test(parts[1]) ? new Buffer(parts[2], 'base64') : new Buffer(decodeURIComponent(parts[2])));\n        } else if (content.path) {\n            return resolveStream(fs.createReadStream(content.path), callback);\n        }\n    }\n\n    if (typeof data[key].content === 'string' && ['utf8', 'usascii', 'ascii'].indexOf(encoding) < 0) {\n        content = new Buffer(data[key].content, encoding);\n    }\n\n    // default action, return as is\n    setImmediate(callback.bind(null, null, content));\n\n    return promise;\n};\n\n/**\n * Streams a stream value into a Buffer\n *\n * @param {Object} stream Readable stream\n * @param {Function} callback Callback function with (err, value)\n */\nfunction resolveStream(stream, callback) {\n    var responded = false;\n    var chunks = [];\n    var chunklen = 0;\n\n    stream.on('error', function (err) {\n        if (responded) {\n            return;\n        }\n\n        responded = true;\n        callback(err);\n    });\n\n    stream.on('readable', function () {\n        var chunk;\n        while ((chunk = stream.read()) !== null) {\n            chunks.push(chunk);\n            chunklen += chunk.length;\n        }\n    });\n\n    stream.on('end', function () {\n        if (responded) {\n            return;\n        }\n        responded = true;\n\n        var value;\n\n        try {\n            value = Buffer.concat(chunks, chunklen);\n        } catch (E) {\n            return callback(E);\n        }\n        callback(null, value);\n    });\n}\n\n/**\n * Generates a bunyan-like logger that prints to console\n *\n * @returns {Object} Bunyan logger instance\n */\nfunction createDefaultLogger() {\n\n    var logger = {\n        _print: function ( /* level, message */ ) {\n            var args = Array.prototype.slice.call(arguments);\n            var level = args.shift();\n            var message;\n\n            if (args.length > 1) {\n                message = util.format.apply(util, args);\n            } else {\n                message = args.shift();\n            }\n\n            console.log('[%s] %s: %s',\n                new Date().toISOString().substr(0, 19).replace(/T/, ' '),\n                level.toUpperCase(),\n                message);\n        }\n    };\n\n    logger.info = logger._print.bind(null, 'info');\n    logger.debug = logger._print.bind(null, 'debug');\n    logger.error = logger._print.bind(null, 'error');\n\n    return logger;\n}\n"]},"metadata":{},"sourceType":"script"}