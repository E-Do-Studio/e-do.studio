{"ast":null,"code":"var __defProp = Object.defineProperty;\n\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\n\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n\n  return value;\n};\n\nimport { BufferGeometry, Vector3, Uint32BufferAttribute, Float32BufferAttribute, DynamicDrawUsage, MathUtils } from \"three\";\nimport { SimplexNoise } from \"../math/SimplexNoise.js\";\n\nconst _LightningStrike = class extends BufferGeometry {\n  constructor(rayParameters = {}) {\n    super();\n    this.isLightningStrike = true;\n    this.type = \"LightningStrike\";\n    this.init(_LightningStrike.copyParameters(rayParameters, rayParameters));\n    this.createMesh();\n  }\n\n  static createRandomGenerator() {\n    const numSeeds = 2053;\n    const seeds = [];\n\n    for (let i = 0; i < numSeeds; i++) {\n      seeds.push(Math.random());\n    }\n\n    const generator = {\n      currentSeed: 0,\n      random: function () {\n        const value = seeds[generator.currentSeed];\n        generator.currentSeed = (generator.currentSeed + 1) % numSeeds;\n        return value;\n      },\n      getSeed: function () {\n        return generator.currentSeed / numSeeds;\n      },\n      setSeed: function (seed) {\n        generator.currentSeed = Math.floor(seed * numSeeds) % numSeeds;\n      }\n    };\n    return generator;\n  }\n\n  static copyParameters(dest = {}, source = {}) {\n    const vecCopy = function (v) {\n      if (source === dest) {\n        return v;\n      } else {\n        return v.clone();\n      }\n    };\n\n    dest.sourceOffset = source.sourceOffset !== void 0 ? vecCopy(source.sourceOffset) : new Vector3(0, 100, 0), dest.destOffset = source.destOffset !== void 0 ? vecCopy(source.destOffset) : new Vector3(0, 0, 0), dest.timeScale = source.timeScale !== void 0 ? source.timeScale : 1, dest.roughness = source.roughness !== void 0 ? source.roughness : 0.9, dest.straightness = source.straightness !== void 0 ? source.straightness : 0.7, dest.up0 = source.up0 !== void 0 ? vecCopy(source.up0) : new Vector3(0, 0, 1);\n    dest.up1 = source.up1 !== void 0 ? vecCopy(source.up1) : new Vector3(0, 0, 1), dest.radius0 = source.radius0 !== void 0 ? source.radius0 : 1, dest.radius1 = source.radius1 !== void 0 ? source.radius1 : 1, dest.radius0Factor = source.radius0Factor !== void 0 ? source.radius0Factor : 0.5, dest.radius1Factor = source.radius1Factor !== void 0 ? source.radius1Factor : 0.2, dest.minRadius = source.minRadius !== void 0 ? source.minRadius : 0.2, // These parameters should not be changed after lightning creation. They can be changed but the ray will change its form abruptly:\n    dest.isEternal = source.isEternal !== void 0 ? source.isEternal : source.birthTime === void 0 || source.deathTime === void 0, dest.birthTime = source.birthTime, dest.deathTime = source.deathTime, dest.propagationTimeFactor = source.propagationTimeFactor !== void 0 ? source.propagationTimeFactor : 0.1, dest.vanishingTimeFactor = source.vanishingTimeFactor !== void 0 ? source.vanishingTimeFactor : 0.9, dest.subrayPeriod = source.subrayPeriod !== void 0 ? source.subrayPeriod : 4, dest.subrayDutyCycle = source.subrayDutyCycle !== void 0 ? source.subrayDutyCycle : 0.6;\n    dest.maxIterations = source.maxIterations !== void 0 ? source.maxIterations : 9;\n    dest.isStatic = source.isStatic !== void 0 ? source.isStatic : false;\n    dest.ramification = source.ramification !== void 0 ? source.ramification : 5;\n    dest.maxSubrayRecursion = source.maxSubrayRecursion !== void 0 ? source.maxSubrayRecursion : 3;\n    dest.recursionProbability = source.recursionProbability !== void 0 ? source.recursionProbability : 0.6;\n    dest.generateUVs = source.generateUVs !== void 0 ? source.generateUVs : false;\n    dest.randomGenerator = source.randomGenerator, dest.noiseSeed = source.noiseSeed, dest.onDecideSubrayCreation = source.onDecideSubrayCreation, dest.onSubrayCreation = source.onSubrayCreation;\n    return dest;\n  }\n\n  update(time) {\n    if (this.isStatic) return;\n\n    if (this.rayParameters.isEternal || this.rayParameters.birthTime <= time && time <= this.rayParameters.deathTime) {\n      this.updateMesh(time);\n\n      if (time < this.subrays[0].endPropagationTime) {\n        this.state = _LightningStrike.RAY_PROPAGATING;\n      } else if (time > this.subrays[0].beginVanishingTime) {\n        this.state = _LightningStrike.RAY_VANISHING;\n      } else {\n        this.state = _LightningStrike.RAY_STEADY;\n      }\n\n      this.visible = true;\n    } else {\n      this.visible = false;\n\n      if (time < this.rayParameters.birthTime) {\n        this.state = _LightningStrike.RAY_UNBORN;\n      } else {\n        this.state = _LightningStrike.RAY_EXTINGUISHED;\n      }\n    }\n  }\n\n  init(rayParameters) {\n    this.rayParameters = rayParameters;\n    this.maxIterations = rayParameters.maxIterations !== void 0 ? Math.floor(rayParameters.maxIterations) : 9;\n    rayParameters.maxIterations = this.maxIterations;\n    this.isStatic = rayParameters.isStatic !== void 0 ? rayParameters.isStatic : false;\n    rayParameters.isStatic = this.isStatic;\n    this.ramification = rayParameters.ramification !== void 0 ? Math.floor(rayParameters.ramification) : 5;\n    rayParameters.ramification = this.ramification;\n    this.maxSubrayRecursion = rayParameters.maxSubrayRecursion !== void 0 ? Math.floor(rayParameters.maxSubrayRecursion) : 3;\n    rayParameters.maxSubrayRecursion = this.maxSubrayRecursion;\n    this.recursionProbability = rayParameters.recursionProbability !== void 0 ? rayParameters.recursionProbability : 0.6;\n    rayParameters.recursionProbability = this.recursionProbability;\n    this.generateUVs = rayParameters.generateUVs !== void 0 ? rayParameters.generateUVs : false;\n    rayParameters.generateUVs = this.generateUVs;\n\n    if (rayParameters.randomGenerator !== void 0) {\n      this.randomGenerator = rayParameters.randomGenerator;\n      this.seedGenerator = rayParameters.randomGenerator;\n\n      if (rayParameters.noiseSeed !== void 0) {\n        this.seedGenerator.setSeed(rayParameters.noiseSeed);\n      }\n    } else {\n      this.randomGenerator = _LightningStrike.createRandomGenerator();\n      this.seedGenerator = Math;\n    }\n\n    if (rayParameters.onDecideSubrayCreation !== void 0) {\n      this.onDecideSubrayCreation = rayParameters.onDecideSubrayCreation;\n    } else {\n      this.createDefaultSubrayCreationCallbacks();\n\n      if (rayParameters.onSubrayCreation !== void 0) {\n        this.onSubrayCreation = rayParameters.onSubrayCreation;\n      }\n    }\n\n    this.state = _LightningStrike.RAY_INITIALIZED;\n    this.maxSubrays = Math.ceil(1 + Math.pow(this.ramification, Math.max(0, this.maxSubrayRecursion - 1)));\n    rayParameters.maxSubrays = this.maxSubrays;\n    this.maxRaySegments = 2 * (1 << this.maxIterations);\n    this.subrays = [];\n\n    for (let i = 0; i < this.maxSubrays; i++) {\n      this.subrays.push(this.createSubray());\n    }\n\n    this.raySegments = [];\n\n    for (let i = 0; i < this.maxRaySegments; i++) {\n      this.raySegments.push(this.createSegment());\n    }\n\n    this.time = 0;\n    this.timeFraction = 0;\n    this.currentSegmentCallback = null;\n    this.currentCreateTriangleVertices = this.generateUVs ? this.createTriangleVerticesWithUVs : this.createTriangleVerticesWithoutUVs;\n    this.numSubrays = 0;\n    this.currentSubray = null;\n    this.currentSegmentIndex = 0;\n    this.isInitialSegment = false;\n    this.subrayProbability = 0;\n    this.currentVertex = 0;\n    this.currentIndex = 0;\n    this.currentCoordinate = 0;\n    this.currentUVCoordinate = 0;\n    this.vertices = null;\n    this.uvs = null;\n    this.indices = null;\n    this.positionAttribute = null;\n    this.uvsAttribute = null;\n    this.simplexX = new SimplexNoise(this.seedGenerator);\n    this.simplexY = new SimplexNoise(this.seedGenerator);\n    this.simplexZ = new SimplexNoise(this.seedGenerator);\n    this.forwards = new Vector3();\n    this.forwardsFill = new Vector3();\n    this.side = new Vector3();\n    this.down = new Vector3();\n    this.middlePos = new Vector3();\n    this.middleLinPos = new Vector3();\n    this.newPos = new Vector3();\n    this.vPos = new Vector3();\n    this.cross1 = new Vector3();\n  }\n\n  createMesh() {\n    const maxDrawableSegmentsPerSubRay = 1 << this.maxIterations;\n    const maxVerts = 3 * (maxDrawableSegmentsPerSubRay + 1) * this.maxSubrays;\n    const maxIndices = 18 * maxDrawableSegmentsPerSubRay * this.maxSubrays;\n    this.vertices = new Float32Array(maxVerts * 3);\n    this.indices = new Uint32Array(maxIndices);\n\n    if (this.generateUVs) {\n      this.uvs = new Float32Array(maxVerts * 2);\n    }\n\n    this.fillMesh(0);\n    this.setIndex(new Uint32BufferAttribute(this.indices, 1));\n    this.positionAttribute = new Float32BufferAttribute(this.vertices, 3);\n    this.setAttribute(\"position\", this.positionAttribute);\n\n    if (this.generateUVs) {\n      this.uvsAttribute = new Float32BufferAttribute(new Float32Array(this.uvs), 2);\n      this.setAttribute(\"uv\", this.uvsAttribute);\n    }\n\n    if (!this.isStatic) {\n      this.index.usage = DynamicDrawUsage;\n      this.positionAttribute.usage = DynamicDrawUsage;\n\n      if (this.generateUVs) {\n        this.uvsAttribute.usage = DynamicDrawUsage;\n      }\n    }\n\n    this.vertices = this.positionAttribute.array;\n    this.indices = this.index.array;\n\n    if (this.generateUVs) {\n      this.uvs = this.uvsAttribute.array;\n    }\n  }\n\n  updateMesh(time) {\n    this.fillMesh(time);\n    this.drawRange.count = this.currentIndex;\n    this.index.needsUpdate = true;\n    this.positionAttribute.needsUpdate = true;\n\n    if (this.generateUVs) {\n      this.uvsAttribute.needsUpdate = true;\n    }\n  }\n\n  fillMesh(time) {\n    const scope = this;\n    this.currentVertex = 0;\n    this.currentIndex = 0;\n    this.currentCoordinate = 0;\n    this.currentUVCoordinate = 0;\n    this.fractalRay(time, function fillVertices(segment) {\n      const subray = scope.currentSubray;\n\n      if (time < subray.birthTime) {\n        return;\n      } else if (this.rayParameters.isEternal && scope.currentSubray.recursion == 0) {\n        scope.createPrism(segment);\n        scope.onDecideSubrayCreation(segment, scope);\n      } else if (time < subray.endPropagationTime) {\n        if (scope.timeFraction >= segment.fraction0 * subray.propagationTimeFactor) {\n          scope.createPrism(segment);\n          scope.onDecideSubrayCreation(segment, scope);\n        }\n      } else if (time < subray.beginVanishingTime) {\n        scope.createPrism(segment);\n        scope.onDecideSubrayCreation(segment, scope);\n      } else {\n        if (scope.timeFraction <= subray.vanishingTimeFactor + segment.fraction1 * (1 - subray.vanishingTimeFactor)) {\n          scope.createPrism(segment);\n        }\n\n        scope.onDecideSubrayCreation(segment, scope);\n      }\n    });\n  }\n\n  addNewSubray() {\n    return this.subrays[this.numSubrays++];\n  }\n\n  initSubray(subray, rayParameters) {\n    subray.pos0.copy(rayParameters.sourceOffset);\n    subray.pos1.copy(rayParameters.destOffset);\n    subray.up0.copy(rayParameters.up0);\n    subray.up1.copy(rayParameters.up1);\n    subray.radius0 = rayParameters.radius0;\n    subray.radius1 = rayParameters.radius1;\n    subray.birthTime = rayParameters.birthTime;\n    subray.deathTime = rayParameters.deathTime;\n    subray.timeScale = rayParameters.timeScale;\n    subray.roughness = rayParameters.roughness;\n    subray.straightness = rayParameters.straightness;\n    subray.propagationTimeFactor = rayParameters.propagationTimeFactor;\n    subray.vanishingTimeFactor = rayParameters.vanishingTimeFactor;\n    subray.maxIterations = this.maxIterations;\n    subray.seed = rayParameters.noiseSeed !== void 0 ? rayParameters.noiseSeed : 0;\n    subray.recursion = 0;\n  }\n\n  fractalRay(time, segmentCallback) {\n    this.time = time;\n    this.currentSegmentCallback = segmentCallback;\n    this.numSubrays = 0;\n    this.initSubray(this.addNewSubray(), this.rayParameters);\n\n    for (let subrayIndex = 0; subrayIndex < this.numSubrays; subrayIndex++) {\n      const subray = this.subrays[subrayIndex];\n      this.currentSubray = subray;\n      this.randomGenerator.setSeed(subray.seed);\n      subray.endPropagationTime = MathUtils.lerp(subray.birthTime, subray.deathTime, subray.propagationTimeFactor);\n      subray.beginVanishingTime = MathUtils.lerp(subray.deathTime, subray.birthTime, 1 - subray.vanishingTimeFactor);\n      const random1 = this.randomGenerator.random;\n      subray.linPos0.set(random1(), random1(), random1()).multiplyScalar(1e3);\n      subray.linPos1.set(random1(), random1(), random1()).multiplyScalar(1e3);\n      this.timeFraction = (time - subray.birthTime) / (subray.deathTime - subray.birthTime);\n      this.currentSegmentIndex = 0;\n      this.isInitialSegment = true;\n      const segment = this.getNewSegment();\n      segment.iteration = 0;\n      segment.pos0.copy(subray.pos0);\n      segment.pos1.copy(subray.pos1);\n      segment.linPos0.copy(subray.linPos0);\n      segment.linPos1.copy(subray.linPos1);\n      segment.up0.copy(subray.up0);\n      segment.up1.copy(subray.up1);\n      segment.radius0 = subray.radius0;\n      segment.radius1 = subray.radius1;\n      segment.fraction0 = 0;\n      segment.fraction1 = 1;\n      segment.positionVariationFactor = 1 - subray.straightness;\n      this.subrayProbability = this.ramification * Math.pow(this.recursionProbability, subray.recursion) / (1 << subray.maxIterations);\n      this.fractalRayRecursive(segment);\n    }\n\n    this.currentSegmentCallback = null;\n    this.currentSubray = null;\n  }\n\n  fractalRayRecursive(segment) {\n    if (segment.iteration >= this.currentSubray.maxIterations) {\n      this.currentSegmentCallback(segment);\n      return;\n    }\n\n    this.forwards.subVectors(segment.pos1, segment.pos0);\n    let lForwards = this.forwards.length();\n\n    if (lForwards < 1e-6) {\n      this.forwards.set(0, 0, 0.01);\n      lForwards = this.forwards.length();\n    }\n\n    const middleRadius = (segment.radius0 + segment.radius1) * 0.5;\n    const middleFraction = (segment.fraction0 + segment.fraction1) * 0.5;\n    const timeDimension = this.time * this.currentSubray.timeScale * Math.pow(2, segment.iteration);\n    this.middlePos.lerpVectors(segment.pos0, segment.pos1, 0.5);\n    this.middleLinPos.lerpVectors(segment.linPos0, segment.linPos1, 0.5);\n    const p = this.middleLinPos;\n    this.newPos.set(this.simplexX.noise4d(p.x, p.y, p.z, timeDimension), this.simplexY.noise4d(p.x, p.y, p.z, timeDimension), this.simplexZ.noise4d(p.x, p.y, p.z, timeDimension));\n    this.newPos.multiplyScalar(segment.positionVariationFactor * lForwards);\n    this.newPos.add(this.middlePos);\n    const newSegment1 = this.getNewSegment();\n    newSegment1.pos0.copy(segment.pos0);\n    newSegment1.pos1.copy(this.newPos);\n    newSegment1.linPos0.copy(segment.linPos0);\n    newSegment1.linPos1.copy(this.middleLinPos);\n    newSegment1.up0.copy(segment.up0);\n    newSegment1.up1.copy(segment.up1);\n    newSegment1.radius0 = segment.radius0;\n    newSegment1.radius1 = middleRadius;\n    newSegment1.fraction0 = segment.fraction0;\n    newSegment1.fraction1 = middleFraction;\n    newSegment1.positionVariationFactor = segment.positionVariationFactor * this.currentSubray.roughness;\n    newSegment1.iteration = segment.iteration + 1;\n    const newSegment2 = this.getNewSegment();\n    newSegment2.pos0.copy(this.newPos);\n    newSegment2.pos1.copy(segment.pos1);\n    newSegment2.linPos0.copy(this.middleLinPos);\n    newSegment2.linPos1.copy(segment.linPos1);\n    this.cross1.crossVectors(segment.up0, this.forwards.normalize());\n    newSegment2.up0.crossVectors(this.forwards, this.cross1).normalize();\n    newSegment2.up1.copy(segment.up1);\n    newSegment2.radius0 = middleRadius;\n    newSegment2.radius1 = segment.radius1;\n    newSegment2.fraction0 = middleFraction;\n    newSegment2.fraction1 = segment.fraction1;\n    newSegment2.positionVariationFactor = segment.positionVariationFactor * this.currentSubray.roughness;\n    newSegment2.iteration = segment.iteration + 1;\n    this.fractalRayRecursive(newSegment1);\n    this.fractalRayRecursive(newSegment2);\n  }\n\n  createPrism(segment) {\n    this.forwardsFill.subVectors(segment.pos1, segment.pos0).normalize();\n\n    if (this.isInitialSegment) {\n      this.currentCreateTriangleVertices(segment.pos0, segment.up0, this.forwardsFill, segment.radius0, 0);\n      this.isInitialSegment = false;\n    }\n\n    this.currentCreateTriangleVertices(segment.pos1, segment.up0, this.forwardsFill, segment.radius1, segment.fraction1);\n    this.createPrismFaces();\n  }\n\n  createTriangleVerticesWithoutUVs(pos, up, forwards, radius) {\n    this.side.crossVectors(up, forwards).multiplyScalar(radius * _LightningStrike.COS30DEG);\n    this.down.copy(up).multiplyScalar(-radius * _LightningStrike.SIN30DEG);\n    const p = this.vPos;\n    const v = this.vertices;\n    p.copy(pos).sub(this.side).add(this.down);\n    v[this.currentCoordinate++] = p.x;\n    v[this.currentCoordinate++] = p.y;\n    v[this.currentCoordinate++] = p.z;\n    p.copy(pos).add(this.side).add(this.down);\n    v[this.currentCoordinate++] = p.x;\n    v[this.currentCoordinate++] = p.y;\n    v[this.currentCoordinate++] = p.z;\n    p.copy(up).multiplyScalar(radius).add(pos);\n    v[this.currentCoordinate++] = p.x;\n    v[this.currentCoordinate++] = p.y;\n    v[this.currentCoordinate++] = p.z;\n    this.currentVertex += 3;\n  }\n\n  createTriangleVerticesWithUVs(pos, up, forwards, radius, u) {\n    this.side.crossVectors(up, forwards).multiplyScalar(radius * _LightningStrike.COS30DEG);\n    this.down.copy(up).multiplyScalar(-radius * _LightningStrike.SIN30DEG);\n    const p = this.vPos;\n    const v = this.vertices;\n    const uv = this.uvs;\n    p.copy(pos).sub(this.side).add(this.down);\n    v[this.currentCoordinate++] = p.x;\n    v[this.currentCoordinate++] = p.y;\n    v[this.currentCoordinate++] = p.z;\n    uv[this.currentUVCoordinate++] = u;\n    uv[this.currentUVCoordinate++] = 0;\n    p.copy(pos).add(this.side).add(this.down);\n    v[this.currentCoordinate++] = p.x;\n    v[this.currentCoordinate++] = p.y;\n    v[this.currentCoordinate++] = p.z;\n    uv[this.currentUVCoordinate++] = u;\n    uv[this.currentUVCoordinate++] = 0.5;\n    p.copy(up).multiplyScalar(radius).add(pos);\n    v[this.currentCoordinate++] = p.x;\n    v[this.currentCoordinate++] = p.y;\n    v[this.currentCoordinate++] = p.z;\n    uv[this.currentUVCoordinate++] = u;\n    uv[this.currentUVCoordinate++] = 1;\n    this.currentVertex += 3;\n  }\n\n  createPrismFaces(vertex) {\n    const indices = this.indices;\n    vertex = this.currentVertex - 6;\n    indices[this.currentIndex++] = vertex + 1;\n    indices[this.currentIndex++] = vertex + 2;\n    indices[this.currentIndex++] = vertex + 5;\n    indices[this.currentIndex++] = vertex + 1;\n    indices[this.currentIndex++] = vertex + 5;\n    indices[this.currentIndex++] = vertex + 4;\n    indices[this.currentIndex++] = vertex + 0;\n    indices[this.currentIndex++] = vertex + 1;\n    indices[this.currentIndex++] = vertex + 4;\n    indices[this.currentIndex++] = vertex + 0;\n    indices[this.currentIndex++] = vertex + 4;\n    indices[this.currentIndex++] = vertex + 3;\n    indices[this.currentIndex++] = vertex + 2;\n    indices[this.currentIndex++] = vertex + 0;\n    indices[this.currentIndex++] = vertex + 3;\n    indices[this.currentIndex++] = vertex + 2;\n    indices[this.currentIndex++] = vertex + 3;\n    indices[this.currentIndex++] = vertex + 5;\n  }\n\n  createDefaultSubrayCreationCallbacks() {\n    const random1 = this.randomGenerator.random;\n\n    this.onDecideSubrayCreation = function (segment, lightningStrike) {\n      const subray = lightningStrike.currentSubray;\n      const period = lightningStrike.rayParameters.subrayPeriod;\n      const dutyCycle = lightningStrike.rayParameters.subrayDutyCycle;\n      const phase0 = lightningStrike.rayParameters.isEternal && subray.recursion == 0 ? -random1() * period : MathUtils.lerp(subray.birthTime, subray.endPropagationTime, segment.fraction0) - random1() * period;\n      const phase = lightningStrike.time - phase0;\n      const currentCycle = Math.floor(phase / period);\n      const childSubraySeed = random1() * (currentCycle + 1);\n      const isActive = phase % period <= dutyCycle * period;\n      let probability = 0;\n\n      if (isActive) {\n        probability = lightningStrike.subrayProbability;\n      }\n\n      if (subray.recursion < lightningStrike.maxSubrayRecursion && lightningStrike.numSubrays < lightningStrike.maxSubrays && random1() < probability) {\n        const childSubray = lightningStrike.addNewSubray();\n        const parentSeed = lightningStrike.randomGenerator.getSeed();\n        childSubray.seed = childSubraySeed;\n        lightningStrike.randomGenerator.setSeed(childSubraySeed);\n        childSubray.recursion = subray.recursion + 1;\n        childSubray.maxIterations = Math.max(1, subray.maxIterations - 1);\n        childSubray.linPos0.set(random1(), random1(), random1()).multiplyScalar(1e3);\n        childSubray.linPos1.set(random1(), random1(), random1()).multiplyScalar(1e3);\n        childSubray.up0.copy(subray.up0);\n        childSubray.up1.copy(subray.up1);\n        childSubray.radius0 = segment.radius0 * lightningStrike.rayParameters.radius0Factor;\n        childSubray.radius1 = Math.min(lightningStrike.rayParameters.minRadius, segment.radius1 * lightningStrike.rayParameters.radius1Factor);\n        childSubray.birthTime = phase0 + currentCycle * period;\n        childSubray.deathTime = childSubray.birthTime + period * dutyCycle;\n\n        if (!lightningStrike.rayParameters.isEternal && subray.recursion == 0) {\n          childSubray.birthTime = Math.max(childSubray.birthTime, subray.birthTime);\n          childSubray.deathTime = Math.min(childSubray.deathTime, subray.deathTime);\n        }\n\n        childSubray.timeScale = subray.timeScale * 2;\n        childSubray.roughness = subray.roughness;\n        childSubray.straightness = subray.straightness;\n        childSubray.propagationTimeFactor = subray.propagationTimeFactor;\n        childSubray.vanishingTimeFactor = subray.vanishingTimeFactor;\n        lightningStrike.onSubrayCreation(segment, subray, childSubray, lightningStrike);\n        lightningStrike.randomGenerator.setSeed(parentSeed);\n      }\n    };\n\n    const vec1Pos = new Vector3();\n    const vec2Forward = new Vector3();\n    const vec3Side = new Vector3();\n    const vec4Up = new Vector3();\n\n    this.onSubrayCreation = function (segment, parentSubray, childSubray, lightningStrike) {\n      lightningStrike.subrayCylinderPosition(segment, parentSubray, childSubray, 0.5, 0.6, 0.2);\n    };\n\n    this.subrayConePosition = function (segment, parentSubray, childSubray, heightFactor, sideWidthFactor, minSideWidthFactor) {\n      childSubray.pos0.copy(segment.pos0);\n      vec1Pos.subVectors(parentSubray.pos1, parentSubray.pos0);\n      vec2Forward.copy(vec1Pos).normalize();\n      vec1Pos.multiplyScalar(segment.fraction0 + (1 - segment.fraction0) * (random1() * heightFactor));\n      const length = vec1Pos.length();\n      vec3Side.crossVectors(parentSubray.up0, vec2Forward);\n      const angle = 2 * Math.PI * random1();\n      vec3Side.multiplyScalar(Math.cos(angle));\n      vec4Up.copy(parentSubray.up0).multiplyScalar(Math.sin(angle));\n      childSubray.pos1.copy(vec3Side).add(vec4Up).multiplyScalar(length * sideWidthFactor * (minSideWidthFactor + random1() * (1 - minSideWidthFactor))).add(vec1Pos).add(parentSubray.pos0);\n    };\n\n    this.subrayCylinderPosition = function (segment, parentSubray, childSubray, heightFactor, sideWidthFactor, minSideWidthFactor) {\n      childSubray.pos0.copy(segment.pos0);\n      vec1Pos.subVectors(parentSubray.pos1, parentSubray.pos0);\n      vec2Forward.copy(vec1Pos).normalize();\n      vec1Pos.multiplyScalar(segment.fraction0 + (1 - segment.fraction0) * ((2 * random1() - 1) * heightFactor));\n      const length = vec1Pos.length();\n      vec3Side.crossVectors(parentSubray.up0, vec2Forward);\n      const angle = 2 * Math.PI * random1();\n      vec3Side.multiplyScalar(Math.cos(angle));\n      vec4Up.copy(parentSubray.up0).multiplyScalar(Math.sin(angle));\n      childSubray.pos1.copy(vec3Side).add(vec4Up).multiplyScalar(length * sideWidthFactor * (minSideWidthFactor + random1() * (1 - minSideWidthFactor))).add(vec1Pos).add(parentSubray.pos0);\n    };\n  }\n\n  createSubray() {\n    return {\n      seed: 0,\n      maxIterations: 0,\n      recursion: 0,\n      pos0: new Vector3(),\n      pos1: new Vector3(),\n      linPos0: new Vector3(),\n      linPos1: new Vector3(),\n      up0: new Vector3(),\n      up1: new Vector3(),\n      radius0: 0,\n      radius1: 0,\n      birthTime: 0,\n      deathTime: 0,\n      timeScale: 0,\n      roughness: 0,\n      straightness: 0,\n      propagationTimeFactor: 0,\n      vanishingTimeFactor: 0,\n      endPropagationTime: 0,\n      beginVanishingTime: 0\n    };\n  }\n\n  createSegment() {\n    return {\n      iteration: 0,\n      pos0: new Vector3(),\n      pos1: new Vector3(),\n      linPos0: new Vector3(),\n      linPos1: new Vector3(),\n      up0: new Vector3(),\n      up1: new Vector3(),\n      radius0: 0,\n      radius1: 0,\n      fraction0: 0,\n      fraction1: 0,\n      positionVariationFactor: 0\n    };\n  }\n\n  getNewSegment() {\n    return this.raySegments[this.currentSegmentIndex++];\n  }\n\n  copy(source) {\n    super.copy(source);\n    this.init(_LightningStrike.copyParameters({}, source.rayParameters));\n    return this;\n  }\n\n  clone() {\n    return new this.constructor(_LightningStrike.copyParameters({}, this.rayParameters));\n  }\n\n};\n\nlet LightningStrike = _LightningStrike; // Ray states\n\n__publicField(LightningStrike, \"RAY_INITIALIZED\", 0);\n\n__publicField(LightningStrike, \"RAY_UNBORN\", 1);\n\n__publicField(LightningStrike, \"RAY_PROPAGATING\", 2);\n\n__publicField(LightningStrike, \"RAY_STEADY\", 3);\n\n__publicField(LightningStrike, \"RAY_VANISHING\", 4);\n\n__publicField(LightningStrike, \"RAY_EXTINGUISHED\", 5);\n\n__publicField(LightningStrike, \"COS30DEG\", Math.cos(30 * Math.PI / 180));\n\n__publicField(LightningStrike, \"SIN30DEG\", Math.sin(30 * Math.PI / 180));\n\nexport { LightningStrike };","map":{"version":3,"sources":["/Users/theodaguier/Repositories/E-Do-Studio/node_modules/three-stdlib/geometries/LightningStrike.js"],"names":["__defProp","Object","defineProperty","__defNormalProp","obj","key","value","enumerable","configurable","writable","__publicField","BufferGeometry","Vector3","Uint32BufferAttribute","Float32BufferAttribute","DynamicDrawUsage","MathUtils","SimplexNoise","_LightningStrike","constructor","rayParameters","isLightningStrike","type","init","copyParameters","createMesh","createRandomGenerator","numSeeds","seeds","i","push","Math","random","generator","currentSeed","getSeed","setSeed","seed","floor","dest","source","vecCopy","v","clone","sourceOffset","destOffset","timeScale","roughness","straightness","up0","up1","radius0","radius1","radius0Factor","radius1Factor","minRadius","isEternal","birthTime","deathTime","propagationTimeFactor","vanishingTimeFactor","subrayPeriod","subrayDutyCycle","maxIterations","isStatic","ramification","maxSubrayRecursion","recursionProbability","generateUVs","randomGenerator","noiseSeed","onDecideSubrayCreation","onSubrayCreation","update","time","updateMesh","subrays","endPropagationTime","state","RAY_PROPAGATING","beginVanishingTime","RAY_VANISHING","RAY_STEADY","visible","RAY_UNBORN","RAY_EXTINGUISHED","seedGenerator","createDefaultSubrayCreationCallbacks","RAY_INITIALIZED","maxSubrays","ceil","pow","max","maxRaySegments","createSubray","raySegments","createSegment","timeFraction","currentSegmentCallback","currentCreateTriangleVertices","createTriangleVerticesWithUVs","createTriangleVerticesWithoutUVs","numSubrays","currentSubray","currentSegmentIndex","isInitialSegment","subrayProbability","currentVertex","currentIndex","currentCoordinate","currentUVCoordinate","vertices","uvs","indices","positionAttribute","uvsAttribute","simplexX","simplexY","simplexZ","forwards","forwardsFill","side","down","middlePos","middleLinPos","newPos","vPos","cross1","maxDrawableSegmentsPerSubRay","maxVerts","maxIndices","Float32Array","Uint32Array","fillMesh","setIndex","setAttribute","index","usage","array","drawRange","count","needsUpdate","scope","fractalRay","fillVertices","segment","subray","recursion","createPrism","fraction0","fraction1","addNewSubray","initSubray","pos0","copy","pos1","segmentCallback","subrayIndex","lerp","random1","linPos0","set","multiplyScalar","linPos1","getNewSegment","iteration","positionVariationFactor","fractalRayRecursive","subVectors","lForwards","length","middleRadius","middleFraction","timeDimension","lerpVectors","p","noise4d","x","y","z","add","newSegment1","newSegment2","crossVectors","normalize","createPrismFaces","pos","up","radius","COS30DEG","SIN30DEG","sub","u","uv","vertex","lightningStrike","period","dutyCycle","phase0","phase","currentCycle","childSubraySeed","isActive","probability","childSubray","parentSeed","min","vec1Pos","vec2Forward","vec3Side","vec4Up","parentSubray","subrayCylinderPosition","subrayConePosition","heightFactor","sideWidthFactor","minSideWidthFactor","angle","PI","cos","sin","LightningStrike"],"mappings":"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","sourcesContent":["var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { BufferGeometry, Vector3, Uint32BufferAttribute, Float32BufferAttribute, DynamicDrawUsage, MathUtils } from \"three\";\nimport { SimplexNoise } from \"../math/SimplexNoise.js\";\nconst _LightningStrike = class extends BufferGeometry {\n  constructor(rayParameters = {}) {\n    super();\n    this.isLightningStrike = true;\n    this.type = \"LightningStrike\";\n    this.init(_LightningStrike.copyParameters(rayParameters, rayParameters));\n    this.createMesh();\n  }\n  static createRandomGenerator() {\n    const numSeeds = 2053;\n    const seeds = [];\n    for (let i = 0; i < numSeeds; i++) {\n      seeds.push(Math.random());\n    }\n    const generator = {\n      currentSeed: 0,\n      random: function() {\n        const value = seeds[generator.currentSeed];\n        generator.currentSeed = (generator.currentSeed + 1) % numSeeds;\n        return value;\n      },\n      getSeed: function() {\n        return generator.currentSeed / numSeeds;\n      },\n      setSeed: function(seed) {\n        generator.currentSeed = Math.floor(seed * numSeeds) % numSeeds;\n      }\n    };\n    return generator;\n  }\n  static copyParameters(dest = {}, source = {}) {\n    const vecCopy = function(v) {\n      if (source === dest) {\n        return v;\n      } else {\n        return v.clone();\n      }\n    };\n    dest.sourceOffset = source.sourceOffset !== void 0 ? vecCopy(source.sourceOffset) : new Vector3(0, 100, 0), dest.destOffset = source.destOffset !== void 0 ? vecCopy(source.destOffset) : new Vector3(0, 0, 0), dest.timeScale = source.timeScale !== void 0 ? source.timeScale : 1, dest.roughness = source.roughness !== void 0 ? source.roughness : 0.9, dest.straightness = source.straightness !== void 0 ? source.straightness : 0.7, dest.up0 = source.up0 !== void 0 ? vecCopy(source.up0) : new Vector3(0, 0, 1);\n    dest.up1 = source.up1 !== void 0 ? vecCopy(source.up1) : new Vector3(0, 0, 1), dest.radius0 = source.radius0 !== void 0 ? source.radius0 : 1, dest.radius1 = source.radius1 !== void 0 ? source.radius1 : 1, dest.radius0Factor = source.radius0Factor !== void 0 ? source.radius0Factor : 0.5, dest.radius1Factor = source.radius1Factor !== void 0 ? source.radius1Factor : 0.2, dest.minRadius = source.minRadius !== void 0 ? source.minRadius : 0.2, // These parameters should not be changed after lightning creation. They can be changed but the ray will change its form abruptly:\n    dest.isEternal = source.isEternal !== void 0 ? source.isEternal : source.birthTime === void 0 || source.deathTime === void 0, dest.birthTime = source.birthTime, dest.deathTime = source.deathTime, dest.propagationTimeFactor = source.propagationTimeFactor !== void 0 ? source.propagationTimeFactor : 0.1, dest.vanishingTimeFactor = source.vanishingTimeFactor !== void 0 ? source.vanishingTimeFactor : 0.9, dest.subrayPeriod = source.subrayPeriod !== void 0 ? source.subrayPeriod : 4, dest.subrayDutyCycle = source.subrayDutyCycle !== void 0 ? source.subrayDutyCycle : 0.6;\n    dest.maxIterations = source.maxIterations !== void 0 ? source.maxIterations : 9;\n    dest.isStatic = source.isStatic !== void 0 ? source.isStatic : false;\n    dest.ramification = source.ramification !== void 0 ? source.ramification : 5;\n    dest.maxSubrayRecursion = source.maxSubrayRecursion !== void 0 ? source.maxSubrayRecursion : 3;\n    dest.recursionProbability = source.recursionProbability !== void 0 ? source.recursionProbability : 0.6;\n    dest.generateUVs = source.generateUVs !== void 0 ? source.generateUVs : false;\n    dest.randomGenerator = source.randomGenerator, dest.noiseSeed = source.noiseSeed, dest.onDecideSubrayCreation = source.onDecideSubrayCreation, dest.onSubrayCreation = source.onSubrayCreation;\n    return dest;\n  }\n  update(time) {\n    if (this.isStatic)\n      return;\n    if (this.rayParameters.isEternal || this.rayParameters.birthTime <= time && time <= this.rayParameters.deathTime) {\n      this.updateMesh(time);\n      if (time < this.subrays[0].endPropagationTime) {\n        this.state = _LightningStrike.RAY_PROPAGATING;\n      } else if (time > this.subrays[0].beginVanishingTime) {\n        this.state = _LightningStrike.RAY_VANISHING;\n      } else {\n        this.state = _LightningStrike.RAY_STEADY;\n      }\n      this.visible = true;\n    } else {\n      this.visible = false;\n      if (time < this.rayParameters.birthTime) {\n        this.state = _LightningStrike.RAY_UNBORN;\n      } else {\n        this.state = _LightningStrike.RAY_EXTINGUISHED;\n      }\n    }\n  }\n  init(rayParameters) {\n    this.rayParameters = rayParameters;\n    this.maxIterations = rayParameters.maxIterations !== void 0 ? Math.floor(rayParameters.maxIterations) : 9;\n    rayParameters.maxIterations = this.maxIterations;\n    this.isStatic = rayParameters.isStatic !== void 0 ? rayParameters.isStatic : false;\n    rayParameters.isStatic = this.isStatic;\n    this.ramification = rayParameters.ramification !== void 0 ? Math.floor(rayParameters.ramification) : 5;\n    rayParameters.ramification = this.ramification;\n    this.maxSubrayRecursion = rayParameters.maxSubrayRecursion !== void 0 ? Math.floor(rayParameters.maxSubrayRecursion) : 3;\n    rayParameters.maxSubrayRecursion = this.maxSubrayRecursion;\n    this.recursionProbability = rayParameters.recursionProbability !== void 0 ? rayParameters.recursionProbability : 0.6;\n    rayParameters.recursionProbability = this.recursionProbability;\n    this.generateUVs = rayParameters.generateUVs !== void 0 ? rayParameters.generateUVs : false;\n    rayParameters.generateUVs = this.generateUVs;\n    if (rayParameters.randomGenerator !== void 0) {\n      this.randomGenerator = rayParameters.randomGenerator;\n      this.seedGenerator = rayParameters.randomGenerator;\n      if (rayParameters.noiseSeed !== void 0) {\n        this.seedGenerator.setSeed(rayParameters.noiseSeed);\n      }\n    } else {\n      this.randomGenerator = _LightningStrike.createRandomGenerator();\n      this.seedGenerator = Math;\n    }\n    if (rayParameters.onDecideSubrayCreation !== void 0) {\n      this.onDecideSubrayCreation = rayParameters.onDecideSubrayCreation;\n    } else {\n      this.createDefaultSubrayCreationCallbacks();\n      if (rayParameters.onSubrayCreation !== void 0) {\n        this.onSubrayCreation = rayParameters.onSubrayCreation;\n      }\n    }\n    this.state = _LightningStrike.RAY_INITIALIZED;\n    this.maxSubrays = Math.ceil(1 + Math.pow(this.ramification, Math.max(0, this.maxSubrayRecursion - 1)));\n    rayParameters.maxSubrays = this.maxSubrays;\n    this.maxRaySegments = 2 * (1 << this.maxIterations);\n    this.subrays = [];\n    for (let i = 0; i < this.maxSubrays; i++) {\n      this.subrays.push(this.createSubray());\n    }\n    this.raySegments = [];\n    for (let i = 0; i < this.maxRaySegments; i++) {\n      this.raySegments.push(this.createSegment());\n    }\n    this.time = 0;\n    this.timeFraction = 0;\n    this.currentSegmentCallback = null;\n    this.currentCreateTriangleVertices = this.generateUVs ? this.createTriangleVerticesWithUVs : this.createTriangleVerticesWithoutUVs;\n    this.numSubrays = 0;\n    this.currentSubray = null;\n    this.currentSegmentIndex = 0;\n    this.isInitialSegment = false;\n    this.subrayProbability = 0;\n    this.currentVertex = 0;\n    this.currentIndex = 0;\n    this.currentCoordinate = 0;\n    this.currentUVCoordinate = 0;\n    this.vertices = null;\n    this.uvs = null;\n    this.indices = null;\n    this.positionAttribute = null;\n    this.uvsAttribute = null;\n    this.simplexX = new SimplexNoise(this.seedGenerator);\n    this.simplexY = new SimplexNoise(this.seedGenerator);\n    this.simplexZ = new SimplexNoise(this.seedGenerator);\n    this.forwards = new Vector3();\n    this.forwardsFill = new Vector3();\n    this.side = new Vector3();\n    this.down = new Vector3();\n    this.middlePos = new Vector3();\n    this.middleLinPos = new Vector3();\n    this.newPos = new Vector3();\n    this.vPos = new Vector3();\n    this.cross1 = new Vector3();\n  }\n  createMesh() {\n    const maxDrawableSegmentsPerSubRay = 1 << this.maxIterations;\n    const maxVerts = 3 * (maxDrawableSegmentsPerSubRay + 1) * this.maxSubrays;\n    const maxIndices = 18 * maxDrawableSegmentsPerSubRay * this.maxSubrays;\n    this.vertices = new Float32Array(maxVerts * 3);\n    this.indices = new Uint32Array(maxIndices);\n    if (this.generateUVs) {\n      this.uvs = new Float32Array(maxVerts * 2);\n    }\n    this.fillMesh(0);\n    this.setIndex(new Uint32BufferAttribute(this.indices, 1));\n    this.positionAttribute = new Float32BufferAttribute(this.vertices, 3);\n    this.setAttribute(\"position\", this.positionAttribute);\n    if (this.generateUVs) {\n      this.uvsAttribute = new Float32BufferAttribute(new Float32Array(this.uvs), 2);\n      this.setAttribute(\"uv\", this.uvsAttribute);\n    }\n    if (!this.isStatic) {\n      this.index.usage = DynamicDrawUsage;\n      this.positionAttribute.usage = DynamicDrawUsage;\n      if (this.generateUVs) {\n        this.uvsAttribute.usage = DynamicDrawUsage;\n      }\n    }\n    this.vertices = this.positionAttribute.array;\n    this.indices = this.index.array;\n    if (this.generateUVs) {\n      this.uvs = this.uvsAttribute.array;\n    }\n  }\n  updateMesh(time) {\n    this.fillMesh(time);\n    this.drawRange.count = this.currentIndex;\n    this.index.needsUpdate = true;\n    this.positionAttribute.needsUpdate = true;\n    if (this.generateUVs) {\n      this.uvsAttribute.needsUpdate = true;\n    }\n  }\n  fillMesh(time) {\n    const scope = this;\n    this.currentVertex = 0;\n    this.currentIndex = 0;\n    this.currentCoordinate = 0;\n    this.currentUVCoordinate = 0;\n    this.fractalRay(time, function fillVertices(segment) {\n      const subray = scope.currentSubray;\n      if (time < subray.birthTime) {\n        return;\n      } else if (this.rayParameters.isEternal && scope.currentSubray.recursion == 0) {\n        scope.createPrism(segment);\n        scope.onDecideSubrayCreation(segment, scope);\n      } else if (time < subray.endPropagationTime) {\n        if (scope.timeFraction >= segment.fraction0 * subray.propagationTimeFactor) {\n          scope.createPrism(segment);\n          scope.onDecideSubrayCreation(segment, scope);\n        }\n      } else if (time < subray.beginVanishingTime) {\n        scope.createPrism(segment);\n        scope.onDecideSubrayCreation(segment, scope);\n      } else {\n        if (scope.timeFraction <= subray.vanishingTimeFactor + segment.fraction1 * (1 - subray.vanishingTimeFactor)) {\n          scope.createPrism(segment);\n        }\n        scope.onDecideSubrayCreation(segment, scope);\n      }\n    });\n  }\n  addNewSubray() {\n    return this.subrays[this.numSubrays++];\n  }\n  initSubray(subray, rayParameters) {\n    subray.pos0.copy(rayParameters.sourceOffset);\n    subray.pos1.copy(rayParameters.destOffset);\n    subray.up0.copy(rayParameters.up0);\n    subray.up1.copy(rayParameters.up1);\n    subray.radius0 = rayParameters.radius0;\n    subray.radius1 = rayParameters.radius1;\n    subray.birthTime = rayParameters.birthTime;\n    subray.deathTime = rayParameters.deathTime;\n    subray.timeScale = rayParameters.timeScale;\n    subray.roughness = rayParameters.roughness;\n    subray.straightness = rayParameters.straightness;\n    subray.propagationTimeFactor = rayParameters.propagationTimeFactor;\n    subray.vanishingTimeFactor = rayParameters.vanishingTimeFactor;\n    subray.maxIterations = this.maxIterations;\n    subray.seed = rayParameters.noiseSeed !== void 0 ? rayParameters.noiseSeed : 0;\n    subray.recursion = 0;\n  }\n  fractalRay(time, segmentCallback) {\n    this.time = time;\n    this.currentSegmentCallback = segmentCallback;\n    this.numSubrays = 0;\n    this.initSubray(this.addNewSubray(), this.rayParameters);\n    for (let subrayIndex = 0; subrayIndex < this.numSubrays; subrayIndex++) {\n      const subray = this.subrays[subrayIndex];\n      this.currentSubray = subray;\n      this.randomGenerator.setSeed(subray.seed);\n      subray.endPropagationTime = MathUtils.lerp(subray.birthTime, subray.deathTime, subray.propagationTimeFactor);\n      subray.beginVanishingTime = MathUtils.lerp(subray.deathTime, subray.birthTime, 1 - subray.vanishingTimeFactor);\n      const random1 = this.randomGenerator.random;\n      subray.linPos0.set(random1(), random1(), random1()).multiplyScalar(1e3);\n      subray.linPos1.set(random1(), random1(), random1()).multiplyScalar(1e3);\n      this.timeFraction = (time - subray.birthTime) / (subray.deathTime - subray.birthTime);\n      this.currentSegmentIndex = 0;\n      this.isInitialSegment = true;\n      const segment = this.getNewSegment();\n      segment.iteration = 0;\n      segment.pos0.copy(subray.pos0);\n      segment.pos1.copy(subray.pos1);\n      segment.linPos0.copy(subray.linPos0);\n      segment.linPos1.copy(subray.linPos1);\n      segment.up0.copy(subray.up0);\n      segment.up1.copy(subray.up1);\n      segment.radius0 = subray.radius0;\n      segment.radius1 = subray.radius1;\n      segment.fraction0 = 0;\n      segment.fraction1 = 1;\n      segment.positionVariationFactor = 1 - subray.straightness;\n      this.subrayProbability = this.ramification * Math.pow(this.recursionProbability, subray.recursion) / (1 << subray.maxIterations);\n      this.fractalRayRecursive(segment);\n    }\n    this.currentSegmentCallback = null;\n    this.currentSubray = null;\n  }\n  fractalRayRecursive(segment) {\n    if (segment.iteration >= this.currentSubray.maxIterations) {\n      this.currentSegmentCallback(segment);\n      return;\n    }\n    this.forwards.subVectors(segment.pos1, segment.pos0);\n    let lForwards = this.forwards.length();\n    if (lForwards < 1e-6) {\n      this.forwards.set(0, 0, 0.01);\n      lForwards = this.forwards.length();\n    }\n    const middleRadius = (segment.radius0 + segment.radius1) * 0.5;\n    const middleFraction = (segment.fraction0 + segment.fraction1) * 0.5;\n    const timeDimension = this.time * this.currentSubray.timeScale * Math.pow(2, segment.iteration);\n    this.middlePos.lerpVectors(segment.pos0, segment.pos1, 0.5);\n    this.middleLinPos.lerpVectors(segment.linPos0, segment.linPos1, 0.5);\n    const p = this.middleLinPos;\n    this.newPos.set(\n      this.simplexX.noise4d(p.x, p.y, p.z, timeDimension),\n      this.simplexY.noise4d(p.x, p.y, p.z, timeDimension),\n      this.simplexZ.noise4d(p.x, p.y, p.z, timeDimension)\n    );\n    this.newPos.multiplyScalar(segment.positionVariationFactor * lForwards);\n    this.newPos.add(this.middlePos);\n    const newSegment1 = this.getNewSegment();\n    newSegment1.pos0.copy(segment.pos0);\n    newSegment1.pos1.copy(this.newPos);\n    newSegment1.linPos0.copy(segment.linPos0);\n    newSegment1.linPos1.copy(this.middleLinPos);\n    newSegment1.up0.copy(segment.up0);\n    newSegment1.up1.copy(segment.up1);\n    newSegment1.radius0 = segment.radius0;\n    newSegment1.radius1 = middleRadius;\n    newSegment1.fraction0 = segment.fraction0;\n    newSegment1.fraction1 = middleFraction;\n    newSegment1.positionVariationFactor = segment.positionVariationFactor * this.currentSubray.roughness;\n    newSegment1.iteration = segment.iteration + 1;\n    const newSegment2 = this.getNewSegment();\n    newSegment2.pos0.copy(this.newPos);\n    newSegment2.pos1.copy(segment.pos1);\n    newSegment2.linPos0.copy(this.middleLinPos);\n    newSegment2.linPos1.copy(segment.linPos1);\n    this.cross1.crossVectors(segment.up0, this.forwards.normalize());\n    newSegment2.up0.crossVectors(this.forwards, this.cross1).normalize();\n    newSegment2.up1.copy(segment.up1);\n    newSegment2.radius0 = middleRadius;\n    newSegment2.radius1 = segment.radius1;\n    newSegment2.fraction0 = middleFraction;\n    newSegment2.fraction1 = segment.fraction1;\n    newSegment2.positionVariationFactor = segment.positionVariationFactor * this.currentSubray.roughness;\n    newSegment2.iteration = segment.iteration + 1;\n    this.fractalRayRecursive(newSegment1);\n    this.fractalRayRecursive(newSegment2);\n  }\n  createPrism(segment) {\n    this.forwardsFill.subVectors(segment.pos1, segment.pos0).normalize();\n    if (this.isInitialSegment) {\n      this.currentCreateTriangleVertices(segment.pos0, segment.up0, this.forwardsFill, segment.radius0, 0);\n      this.isInitialSegment = false;\n    }\n    this.currentCreateTriangleVertices(segment.pos1, segment.up0, this.forwardsFill, segment.radius1, segment.fraction1);\n    this.createPrismFaces();\n  }\n  createTriangleVerticesWithoutUVs(pos, up, forwards, radius) {\n    this.side.crossVectors(up, forwards).multiplyScalar(radius * _LightningStrike.COS30DEG);\n    this.down.copy(up).multiplyScalar(-radius * _LightningStrike.SIN30DEG);\n    const p = this.vPos;\n    const v = this.vertices;\n    p.copy(pos).sub(this.side).add(this.down);\n    v[this.currentCoordinate++] = p.x;\n    v[this.currentCoordinate++] = p.y;\n    v[this.currentCoordinate++] = p.z;\n    p.copy(pos).add(this.side).add(this.down);\n    v[this.currentCoordinate++] = p.x;\n    v[this.currentCoordinate++] = p.y;\n    v[this.currentCoordinate++] = p.z;\n    p.copy(up).multiplyScalar(radius).add(pos);\n    v[this.currentCoordinate++] = p.x;\n    v[this.currentCoordinate++] = p.y;\n    v[this.currentCoordinate++] = p.z;\n    this.currentVertex += 3;\n  }\n  createTriangleVerticesWithUVs(pos, up, forwards, radius, u) {\n    this.side.crossVectors(up, forwards).multiplyScalar(radius * _LightningStrike.COS30DEG);\n    this.down.copy(up).multiplyScalar(-radius * _LightningStrike.SIN30DEG);\n    const p = this.vPos;\n    const v = this.vertices;\n    const uv = this.uvs;\n    p.copy(pos).sub(this.side).add(this.down);\n    v[this.currentCoordinate++] = p.x;\n    v[this.currentCoordinate++] = p.y;\n    v[this.currentCoordinate++] = p.z;\n    uv[this.currentUVCoordinate++] = u;\n    uv[this.currentUVCoordinate++] = 0;\n    p.copy(pos).add(this.side).add(this.down);\n    v[this.currentCoordinate++] = p.x;\n    v[this.currentCoordinate++] = p.y;\n    v[this.currentCoordinate++] = p.z;\n    uv[this.currentUVCoordinate++] = u;\n    uv[this.currentUVCoordinate++] = 0.5;\n    p.copy(up).multiplyScalar(radius).add(pos);\n    v[this.currentCoordinate++] = p.x;\n    v[this.currentCoordinate++] = p.y;\n    v[this.currentCoordinate++] = p.z;\n    uv[this.currentUVCoordinate++] = u;\n    uv[this.currentUVCoordinate++] = 1;\n    this.currentVertex += 3;\n  }\n  createPrismFaces(vertex) {\n    const indices = this.indices;\n    vertex = this.currentVertex - 6;\n    indices[this.currentIndex++] = vertex + 1;\n    indices[this.currentIndex++] = vertex + 2;\n    indices[this.currentIndex++] = vertex + 5;\n    indices[this.currentIndex++] = vertex + 1;\n    indices[this.currentIndex++] = vertex + 5;\n    indices[this.currentIndex++] = vertex + 4;\n    indices[this.currentIndex++] = vertex + 0;\n    indices[this.currentIndex++] = vertex + 1;\n    indices[this.currentIndex++] = vertex + 4;\n    indices[this.currentIndex++] = vertex + 0;\n    indices[this.currentIndex++] = vertex + 4;\n    indices[this.currentIndex++] = vertex + 3;\n    indices[this.currentIndex++] = vertex + 2;\n    indices[this.currentIndex++] = vertex + 0;\n    indices[this.currentIndex++] = vertex + 3;\n    indices[this.currentIndex++] = vertex + 2;\n    indices[this.currentIndex++] = vertex + 3;\n    indices[this.currentIndex++] = vertex + 5;\n  }\n  createDefaultSubrayCreationCallbacks() {\n    const random1 = this.randomGenerator.random;\n    this.onDecideSubrayCreation = function(segment, lightningStrike) {\n      const subray = lightningStrike.currentSubray;\n      const period = lightningStrike.rayParameters.subrayPeriod;\n      const dutyCycle = lightningStrike.rayParameters.subrayDutyCycle;\n      const phase0 = lightningStrike.rayParameters.isEternal && subray.recursion == 0 ? -random1() * period : MathUtils.lerp(subray.birthTime, subray.endPropagationTime, segment.fraction0) - random1() * period;\n      const phase = lightningStrike.time - phase0;\n      const currentCycle = Math.floor(phase / period);\n      const childSubraySeed = random1() * (currentCycle + 1);\n      const isActive = phase % period <= dutyCycle * period;\n      let probability = 0;\n      if (isActive) {\n        probability = lightningStrike.subrayProbability;\n      }\n      if (subray.recursion < lightningStrike.maxSubrayRecursion && lightningStrike.numSubrays < lightningStrike.maxSubrays && random1() < probability) {\n        const childSubray = lightningStrike.addNewSubray();\n        const parentSeed = lightningStrike.randomGenerator.getSeed();\n        childSubray.seed = childSubraySeed;\n        lightningStrike.randomGenerator.setSeed(childSubraySeed);\n        childSubray.recursion = subray.recursion + 1;\n        childSubray.maxIterations = Math.max(1, subray.maxIterations - 1);\n        childSubray.linPos0.set(random1(), random1(), random1()).multiplyScalar(1e3);\n        childSubray.linPos1.set(random1(), random1(), random1()).multiplyScalar(1e3);\n        childSubray.up0.copy(subray.up0);\n        childSubray.up1.copy(subray.up1);\n        childSubray.radius0 = segment.radius0 * lightningStrike.rayParameters.radius0Factor;\n        childSubray.radius1 = Math.min(\n          lightningStrike.rayParameters.minRadius,\n          segment.radius1 * lightningStrike.rayParameters.radius1Factor\n        );\n        childSubray.birthTime = phase0 + currentCycle * period;\n        childSubray.deathTime = childSubray.birthTime + period * dutyCycle;\n        if (!lightningStrike.rayParameters.isEternal && subray.recursion == 0) {\n          childSubray.birthTime = Math.max(childSubray.birthTime, subray.birthTime);\n          childSubray.deathTime = Math.min(childSubray.deathTime, subray.deathTime);\n        }\n        childSubray.timeScale = subray.timeScale * 2;\n        childSubray.roughness = subray.roughness;\n        childSubray.straightness = subray.straightness;\n        childSubray.propagationTimeFactor = subray.propagationTimeFactor;\n        childSubray.vanishingTimeFactor = subray.vanishingTimeFactor;\n        lightningStrike.onSubrayCreation(segment, subray, childSubray, lightningStrike);\n        lightningStrike.randomGenerator.setSeed(parentSeed);\n      }\n    };\n    const vec1Pos = new Vector3();\n    const vec2Forward = new Vector3();\n    const vec3Side = new Vector3();\n    const vec4Up = new Vector3();\n    this.onSubrayCreation = function(segment, parentSubray, childSubray, lightningStrike) {\n      lightningStrike.subrayCylinderPosition(segment, parentSubray, childSubray, 0.5, 0.6, 0.2);\n    };\n    this.subrayConePosition = function(segment, parentSubray, childSubray, heightFactor, sideWidthFactor, minSideWidthFactor) {\n      childSubray.pos0.copy(segment.pos0);\n      vec1Pos.subVectors(parentSubray.pos1, parentSubray.pos0);\n      vec2Forward.copy(vec1Pos).normalize();\n      vec1Pos.multiplyScalar(segment.fraction0 + (1 - segment.fraction0) * (random1() * heightFactor));\n      const length = vec1Pos.length();\n      vec3Side.crossVectors(parentSubray.up0, vec2Forward);\n      const angle = 2 * Math.PI * random1();\n      vec3Side.multiplyScalar(Math.cos(angle));\n      vec4Up.copy(parentSubray.up0).multiplyScalar(Math.sin(angle));\n      childSubray.pos1.copy(vec3Side).add(vec4Up).multiplyScalar(length * sideWidthFactor * (minSideWidthFactor + random1() * (1 - minSideWidthFactor))).add(vec1Pos).add(parentSubray.pos0);\n    };\n    this.subrayCylinderPosition = function(segment, parentSubray, childSubray, heightFactor, sideWidthFactor, minSideWidthFactor) {\n      childSubray.pos0.copy(segment.pos0);\n      vec1Pos.subVectors(parentSubray.pos1, parentSubray.pos0);\n      vec2Forward.copy(vec1Pos).normalize();\n      vec1Pos.multiplyScalar(segment.fraction0 + (1 - segment.fraction0) * ((2 * random1() - 1) * heightFactor));\n      const length = vec1Pos.length();\n      vec3Side.crossVectors(parentSubray.up0, vec2Forward);\n      const angle = 2 * Math.PI * random1();\n      vec3Side.multiplyScalar(Math.cos(angle));\n      vec4Up.copy(parentSubray.up0).multiplyScalar(Math.sin(angle));\n      childSubray.pos1.copy(vec3Side).add(vec4Up).multiplyScalar(length * sideWidthFactor * (minSideWidthFactor + random1() * (1 - minSideWidthFactor))).add(vec1Pos).add(parentSubray.pos0);\n    };\n  }\n  createSubray() {\n    return {\n      seed: 0,\n      maxIterations: 0,\n      recursion: 0,\n      pos0: new Vector3(),\n      pos1: new Vector3(),\n      linPos0: new Vector3(),\n      linPos1: new Vector3(),\n      up0: new Vector3(),\n      up1: new Vector3(),\n      radius0: 0,\n      radius1: 0,\n      birthTime: 0,\n      deathTime: 0,\n      timeScale: 0,\n      roughness: 0,\n      straightness: 0,\n      propagationTimeFactor: 0,\n      vanishingTimeFactor: 0,\n      endPropagationTime: 0,\n      beginVanishingTime: 0\n    };\n  }\n  createSegment() {\n    return {\n      iteration: 0,\n      pos0: new Vector3(),\n      pos1: new Vector3(),\n      linPos0: new Vector3(),\n      linPos1: new Vector3(),\n      up0: new Vector3(),\n      up1: new Vector3(),\n      radius0: 0,\n      radius1: 0,\n      fraction0: 0,\n      fraction1: 0,\n      positionVariationFactor: 0\n    };\n  }\n  getNewSegment() {\n    return this.raySegments[this.currentSegmentIndex++];\n  }\n  copy(source) {\n    super.copy(source);\n    this.init(_LightningStrike.copyParameters({}, source.rayParameters));\n    return this;\n  }\n  clone() {\n    return new this.constructor(_LightningStrike.copyParameters({}, this.rayParameters));\n  }\n};\nlet LightningStrike = _LightningStrike;\n// Ray states\n__publicField(LightningStrike, \"RAY_INITIALIZED\", 0);\n__publicField(LightningStrike, \"RAY_UNBORN\", 1);\n__publicField(LightningStrike, \"RAY_PROPAGATING\", 2);\n__publicField(LightningStrike, \"RAY_STEADY\", 3);\n__publicField(LightningStrike, \"RAY_VANISHING\", 4);\n__publicField(LightningStrike, \"RAY_EXTINGUISHED\", 5);\n__publicField(LightningStrike, \"COS30DEG\", Math.cos(30 * Math.PI / 180));\n__publicField(LightningStrike, \"SIN30DEG\", Math.sin(30 * Math.PI / 180));\nexport {\n  LightningStrike\n};\n"]},"metadata":{},"sourceType":"module"}