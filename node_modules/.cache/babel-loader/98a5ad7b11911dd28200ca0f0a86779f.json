{"ast":null,"code":"'use strict';\n\nvar libcharset = require('./charset');\n\nvar libbase64 = require('libbase64');\n\nvar libqp = require('libqp');\n\nvar mimetypes = require('./mimetypes');\n\nvar libmime = module.exports = {\n  /**\n   * Checks if a value is plaintext string (uses only printable 7bit chars)\n   *\n   * @param {String} value String to be tested\n   * @returns {Boolean} true if it is a plaintext string\n   */\n  isPlainText: function (value) {\n    if (typeof value !== 'string' || /[\\x00-\\x08\\x0b\\x0c\\x0e-\\x1f\\u0080-\\uFFFF]/.test(value)) {\n      return false;\n    } else {\n      return true;\n    }\n  },\n\n  /**\n   * Checks if a multi line string containes lines longer than the selected value.\n   *\n   * Useful when detecting if a mail message needs any processing at all –\n   * if only plaintext characters are used and lines are short, then there is\n   * no need to encode the values in any way. If the value is plaintext but has\n   * longer lines then allowed, then use format=flowed\n   *\n   * @param {Number} lineLength Max line length to check for\n   * @returns {Boolean} Returns true if there is at least one line longer than lineLength chars\n   */\n  hasLongerLines: function (str, lineLength) {\n    return new RegExp('^.{' + (lineLength + 1) + ',}', 'm').test(str);\n  },\n\n  /**\n   * Decodes a string from a format=flowed soft wrapping.\n   *\n   * @param {String} str Plaintext string with format=flowed to decode\n   * @param {Boolean} [delSp] If true, delete leading spaces (delsp=yes)\n   * @return {String} Mime decoded string\n   */\n  decodeFlowed: function (str, delSp) {\n    str = (str || '').toString();\n    return str.split(/\\r?\\n/). // remove soft linebreaks\n    // soft linebreaks are added after space symbols\n    reduce(function (previousValue, currentValue, index) {\n      var body = previousValue;\n\n      if (delSp) {\n        // delsp adds spaces to text to be able to fold it\n        // these spaces can be removed once the text is unfolded\n        body = body.replace(/[ ]+$/, '');\n      }\n\n      if (/ $/.test(previousValue) && !/(^|\\n)\\-\\- $/.test(previousValue) || index === 1) {\n        return body + currentValue;\n      } else {\n        return body + '\\n' + currentValue;\n      }\n    }). // remove whitespace stuffing\n    // http://tools.ietf.org/html/rfc3676#section-4.4\n    replace(/^ /gm, '');\n  },\n\n  /**\n   * Adds soft line breaks to content marked with format=flowed to\n   * ensure that no line in the message is never longer than lineLength\n   *\n   * @param {String} str Plaintext string that requires wrapping\n   * @param {Number} [lineLength=76] Maximum length of a line\n   * @return {String} String with forced line breaks\n   */\n  encodeFlowed: function (str, lineLength) {\n    lineLength = lineLength || 76;\n    var flowed = [];\n    str.split(/\\r?\\n/).forEach(function (line) {\n      flowed.push(libmime.foldLines(line. // space stuffing http://tools.ietf.org/html/rfc3676#section-4.2\n      replace(/^( |From|>)/igm, ' $1'), lineLength, true));\n    });\n    return flowed.join('\\r\\n');\n  },\n\n  /**\n   * Encodes a string or an Buffer to an UTF-8 MIME Word (rfc2047)\n   *\n   * @param {String|Buffer} data String to be encoded\n   * @param {String} mimeWordEncoding='Q' Encoding for the mime word, either Q or B\n   * @param {Number} [maxLength=0] If set, split mime words into several chunks if needed\n   * @return {String} Single or several mime words joined together\n   */\n  encodeWord: function (data, mimeWordEncoding, maxLength) {\n    mimeWordEncoding = (mimeWordEncoding || 'Q').toString().toUpperCase().trim().charAt(0);\n    maxLength = maxLength || 0;\n    var encodedStr,\n        toCharset = 'UTF-8',\n        i,\n        len,\n        parts;\n\n    if (maxLength && maxLength > 7 + toCharset.length) {\n      maxLength -= 7 + toCharset.length;\n    }\n\n    if (mimeWordEncoding === 'Q') {\n      // https://tools.ietf.org/html/rfc2047#section-5 rule (3)\n      encodedStr = libqp.encode(data).replace(/[^a-z0-9!*+\\-\\/=]/ig, function (chr) {\n        var ord = chr.charCodeAt(0).toString(16).toUpperCase();\n\n        if (chr === ' ') {\n          return '_';\n        } else {\n          return '=' + (ord.length === 1 ? '0' + ord : ord);\n        }\n      });\n    } else if (mimeWordEncoding === 'B') {\n      encodedStr = typeof data === 'string' ? data : libbase64.encode(data);\n      maxLength = Math.max(3, (maxLength - maxLength % 4) / 4 * 3);\n    }\n\n    if (maxLength && encodedStr.length > maxLength) {\n      if (mimeWordEncoding === 'Q') {\n        encodedStr = splitMimeEncodedString(encodedStr, maxLength).join('?= =?' + toCharset + '?' + mimeWordEncoding + '?');\n      } else {\n        // RFC2047 6.3 (2) states that encoded-word must include an integral number of characters, so no chopping unicode sequences\n        parts = [];\n\n        for (i = 0, len = encodedStr.length; i < len; i += maxLength) {\n          parts.push(libbase64.encode(encodedStr.substr(i, maxLength)));\n        }\n\n        if (parts.length > 1) {\n          encodedStr = parts.join('?= =?' + toCharset + '?' + mimeWordEncoding + '?');\n        } else {\n          encodedStr = parts.join('');\n        }\n      }\n    } else if (mimeWordEncoding === 'B') {\n      encodedStr = libbase64.encode(data);\n    }\n\n    return '=?' + toCharset + '?' + mimeWordEncoding + '?' + encodedStr + (encodedStr.substr(-2) === '?=' ? '' : '?=');\n  },\n\n  /**\n   * Decode a complete mime word encoded string\n   *\n   * @param {String} str Mime word encoded string\n   * @return {String} Decoded unicode string\n   */\n  decodeWord: function (str) {\n    str = (str || '').toString().trim();\n    var fromCharset, encoding, match;\n    match = str.match(/^\\=\\?([\\w_\\-\\*]+)\\?([QqBb])\\?([^\\?]+)\\?\\=$/i);\n\n    if (!match) {\n      return str;\n    } // RFC2231 added language tag to the encoding\n    // see: https://tools.ietf.org/html/rfc2231#section-5\n    // this implementation silently ignores this tag\n\n\n    fromCharset = match[1].split('*').shift();\n    encoding = (match[2] || 'Q').toString().toUpperCase();\n    str = (match[3] || '').replace(/_/g, ' ').replace(/ $/, '=20');\n\n    if (encoding === 'B') {\n      return libcharset.decode(libbase64.decode(str), fromCharset);\n    } else if (encoding === 'Q') {\n      return libcharset.decode(libqp.decode(str), fromCharset);\n    } else {\n      return str;\n    }\n  },\n\n  /**\n   * Finds word sequences with non ascii text and converts these to mime words\n   *\n   * @param {String|Buffer} data String to be encoded\n   * @param {String} mimeWordEncoding='Q' Encoding for the mime word, either Q or B\n   * @param {Number} [maxLength=0] If set, split mime words into several chunks if needed\n   * @param {String} [fromCharset='UTF-8'] Source sharacter set\n   * @return {String} String with possible mime words\n   */\n  encodeWords: function (data, mimeWordEncoding, maxLength, fromCharset) {\n    if (!fromCharset && typeof maxLength === 'string' && !maxLength.match(/^[0-9]+$/)) {\n      fromCharset = maxLength;\n      maxLength = undefined;\n    }\n\n    maxLength = maxLength || 0;\n    var decodedValue = libcharset.decode(libcharset.convert(data || '', fromCharset)),\n        encodedValue;\n    encodedValue = decodedValue.replace(/([^\\s\\u0080-\\uFFFF]*[\\u0080-\\uFFFF]+[^\\s\\u0080-\\uFFFF]*(?:\\s+[^\\s\\u0080-\\uFFFF]*[\\u0080-\\uFFFF]+[^\\s\\u0080-\\uFFFF]*\\s*)?)+(?=\\s|$)/g, function (match) {\n      return match.length ? libmime.encodeWord(match, mimeWordEncoding || 'Q', maxLength) : '';\n    });\n    return encodedValue;\n  },\n\n  /**\n   * Decode a string that might include one or several mime words\n   *\n   * @param {String} str String including some mime words that will be encoded\n   * @return {String} Decoded unicode string\n   */\n  decodeWords: function (str) {\n    str = (str || '').toString();\n    str = str.replace(/(=\\?[^?]+\\?[QqBb]\\?[^?]+\\?=)\\s+(?==\\?[^?]+\\?[QqBb]\\?[^?]+\\?=)/g, '$1').replace(/\\=\\?([\\w_\\-\\*]+)\\?([QqBb])\\?[^\\?]+\\?\\=/g, function (mimeWord) {\n      return libmime.decodeWord(mimeWord);\n    });\n    return str;\n  },\n\n  /**\n   * Splits a string by :\n   * The result is not mime word decoded, you need to do your own decoding based\n   * on the rules for the specific header key\n   *\n   * @param {String} headerLine Single header line, might include linebreaks as well if folded\n   * @return {Object} And object of {key, value}\n   */\n  decodeHeader: function (headerLine) {\n    var line = (headerLine || '').toString().replace(/(?:\\r?\\n|\\r)[ \\t]*/g, ' ').trim(),\n        match = line.match(/^\\s*([^:]+):(.*)$/),\n        key = (match && match[1] || '').trim().toLowerCase(),\n        value = (match && match[2] || '').trim();\n    return {\n      key: key,\n      value: value\n    };\n  },\n\n  /**\n   * Parses a block of header lines. Does not decode mime words as every\n   * header might have its own rules (eg. formatted email addresses and such)\n   *\n   * @param {String} headers Headers string\n   * @return {Object} An object of headers, where header keys are object keys. NB! Several values with the same key make up an Array\n   */\n  decodeHeaders: function (headers) {\n    var lines = headers.split(/\\r?\\n|\\r/),\n        headersObj = {},\n        header,\n        i,\n        len;\n\n    for (i = lines.length - 1; i >= 0; i--) {\n      if (i && lines[i].match(/^\\s/)) {\n        lines[i - 1] += '\\r\\n' + lines[i];\n        lines.splice(i, 1);\n      }\n    }\n\n    for (i = 0, len = lines.length; i < len; i++) {\n      header = libmime.decodeHeader(lines[i]);\n\n      if (!headersObj[header.key]) {\n        headersObj[header.key] = [header.value];\n      } else {\n        headersObj[header.key].push(header.value);\n      }\n    }\n\n    return headersObj;\n  },\n\n  /**\n   * Joins parsed header value together as 'value; param1=value1; param2=value2'\n   *\n   * @param {Object} structured Parsed header value\n   * @return {String} joined header value\n   */\n  buildHeaderValue: function (structured) {\n    var paramsArray = [];\n    Object.keys(structured.params || {}).forEach(function (param) {\n      // filename might include unicode characters so it is a special case\n      var value = structured.params[param];\n\n      if (!libmime.isPlainText(value) || value.length >= 75) {\n        libmime.buildHeaderParam(param, value, 50).forEach(function (encodedParam) {\n          if (!/[\\s\"\\\\;\\/=]|^[\\-']|'$/.test(encodedParam.value)) {\n            paramsArray.push(encodedParam.key + '=' + encodedParam.value);\n          } else {\n            paramsArray.push(encodedParam.key + '=' + JSON.stringify(encodedParam.value));\n          }\n        });\n      } else if (/[\\s'\"\\\\;\\/=]|^\\-/.test(value)) {\n        paramsArray.push(param + '=' + JSON.stringify(value));\n      } else {\n        paramsArray.push(param + '=' + value);\n      }\n    }.bind(this));\n    return structured.value + (paramsArray.length ? '; ' + paramsArray.join('; ') : '');\n  },\n\n  /**\n   * Parses a header value with key=value arguments into a structured\n   * object.\n   *\n   *   parseHeaderValue('content-type: text/plain; CHARSET='UTF-8'') ->\n   *   {\n   *     'value': 'text/plain',\n   *     'params': {\n   *       'charset': 'UTF-8'\n   *     }\n   *   }\n   *\n   * @param {String} str Header value\n   * @return {Object} Header value as a parsed structure\n   */\n  parseHeaderValue: function (str) {\n    var response = {\n      value: false,\n      params: {}\n    },\n        key = false,\n        value = '',\n        type = 'value',\n        quote = false,\n        escaped = false,\n        chr;\n\n    for (var i = 0, len = str.length; i < len; i++) {\n      chr = str.charAt(i);\n\n      if (type === 'key') {\n        if (chr === '=') {\n          key = value.trim().toLowerCase();\n          type = 'value';\n          value = '';\n          continue;\n        }\n\n        value += chr;\n      } else {\n        if (escaped) {\n          value += chr;\n        } else if (chr === '\\\\') {\n          escaped = true;\n          continue;\n        } else if (quote && chr === quote) {\n          quote = false;\n        } else if (!quote && chr === '\"') {\n          quote = chr;\n        } else if (!quote && chr === ';') {\n          if (key === false) {\n            response.value = value.trim();\n          } else {\n            response.params[key] = value.trim();\n          }\n\n          type = 'key';\n          value = '';\n        } else {\n          value += chr;\n        }\n\n        escaped = false;\n      }\n    }\n\n    if (type === 'value') {\n      if (key === false) {\n        response.value = value.trim();\n      } else {\n        response.params[key] = value.trim();\n      }\n    } else if (value.trim()) {\n      response.params[value.trim().toLowerCase()] = '';\n    } // handle parameter value continuations\n    // https://tools.ietf.org/html/rfc2231#section-3\n    // preprocess values\n\n\n    Object.keys(response.params).forEach(function (key) {\n      var actualKey, nr, match, value;\n\n      if (match = key.match(/(\\*(\\d+)|\\*(\\d+)\\*|\\*)$/)) {\n        actualKey = key.substr(0, match.index);\n        nr = Number(match[2] || match[3]) || 0;\n\n        if (!response.params[actualKey] || typeof response.params[actualKey] !== 'object') {\n          response.params[actualKey] = {\n            charset: false,\n            values: []\n          };\n        }\n\n        value = response.params[key];\n\n        if (nr === 0 && match[0].substr(-1) === '*' && (match = value.match(/^([^']*)'[^']*'(.*)$/))) {\n          response.params[actualKey].charset = match[1] || 'iso-8859-1';\n          value = match[2];\n        }\n\n        response.params[actualKey].values[nr] = value; // remove the old reference\n\n        delete response.params[key];\n      }\n    }); // concatenate split rfc2231 strings and convert encoded strings to mime encoded words\n\n    Object.keys(response.params).forEach(function (key) {\n      var value;\n\n      if (response.params[key] && Array.isArray(response.params[key].values)) {\n        value = response.params[key].values.map(function (val) {\n          return val || '';\n        }).join('');\n\n        if (response.params[key].charset) {\n          // convert \"%AB\" to \"=?charset?Q?=AB?=\"\n          response.params[key] = '=?' + response.params[key].charset + '?Q?' + value. // fix invalidly encoded chars\n          replace(/[=\\?_\\s]/g, function (s) {\n            var c = s.charCodeAt(0).toString(16);\n\n            if (s === ' ') {\n              return '_';\n            } else {\n              return '%' + (c.length < 2 ? '0' : '') + c;\n            }\n          }). // change from urlencoding to percent encoding\n          replace(/%/g, '=') + '?=';\n        } else {\n          response.params[key] = value;\n        }\n      }\n    }.bind(this));\n    return response;\n  },\n\n  /**\n   * Encodes a string or an Buffer to an UTF-8 Parameter Value Continuation encoding (rfc2231)\n   * Useful for splitting long parameter values.\n   *\n   * For example\n   *      title=\"unicode string\"\n   * becomes\n   *     title*0*=utf-8''unicode\n   *     title*1*=%20string\n   *\n   * @param {String|Buffer} data String to be encoded\n   * @param {Number} [maxLength=50] Max length for generated chunks\n   * @param {String} [fromCharset='UTF-8'] Source sharacter set\n   * @return {Array} A list of encoded keys and headers\n   */\n  buildHeaderParam: function (key, data, maxLength, fromCharset) {\n    var list = [];\n    var encodedStr = typeof data === 'string' ? data : libmime.decode(data, fromCharset);\n    var encodedStrArr;\n    var chr, ord;\n    var line;\n    var startPos = 0;\n    var isEncoded = false;\n    var i, len;\n    maxLength = maxLength || 50; // process ascii only text\n\n    if (libmime.isPlainText(data)) {\n      // check if conversion is even needed\n      if (encodedStr.length <= maxLength) {\n        return [{\n          key: key,\n          value: encodedStr\n        }];\n      }\n\n      encodedStr = encodedStr.replace(new RegExp('.{' + maxLength + '}', 'g'), function (str) {\n        list.push({\n          line: str\n        });\n        return '';\n      });\n\n      if (encodedStr) {\n        list.push({\n          line: encodedStr\n        });\n      }\n    } else {\n      if (/[\\uD800-\\uDBFF]/.test(encodedStr)) {\n        // string containts surrogate pairs, so normalize it to an array of bytes\n        encodedStrArr = [];\n\n        for (i = 0, len = encodedStr.length; i < len; i++) {\n          chr = encodedStr.charAt(i);\n          ord = chr.charCodeAt(0);\n\n          if (ord >= 0xD800 && ord <= 0xDBFF && i < len - 1) {\n            chr += encodedStr.charAt(i + 1);\n            encodedStrArr.push(chr);\n            i++;\n          } else {\n            encodedStrArr.push(chr);\n          }\n        }\n\n        encodedStr = encodedStrArr;\n      } // first line includes the charset and language info and needs to be encoded\n      // even if it does not contain any unicode characters\n\n\n      line = 'utf-8\\'\\'';\n      isEncoded = true;\n      startPos = 0; // process text with unicode or special chars\n\n      for (i = 0, len = encodedStr.length; i < len; i++) {\n        chr = encodedStr[i];\n\n        if (isEncoded) {\n          chr = safeEncodeURIComponent(chr);\n        } else {\n          // try to urlencode current char\n          chr = chr === ' ' ? chr : safeEncodeURIComponent(chr); // By default it is not required to encode a line, the need\n          // only appears when the string contains unicode or special chars\n          // in this case we start processing the line over and encode all chars\n\n          if (chr !== encodedStr[i]) {\n            // Check if it is even possible to add the encoded char to the line\n            // If not, there is no reason to use this line, just push it to the list\n            // and start a new line with the char that needs encoding\n            if ((safeEncodeURIComponent(line) + chr).length >= maxLength) {\n              list.push({\n                line: line,\n                encoded: isEncoded\n              });\n              line = '';\n              startPos = i - 1;\n            } else {\n              isEncoded = true;\n              i = startPos;\n              line = '';\n              continue;\n            }\n          }\n        } // if the line is already too long, push it to the list and start a new one\n\n\n        if ((line + chr).length >= maxLength) {\n          list.push({\n            line: line,\n            encoded: isEncoded\n          });\n          line = chr = encodedStr[i] === ' ' ? ' ' : safeEncodeURIComponent(encodedStr[i]);\n\n          if (chr === encodedStr[i]) {\n            isEncoded = false;\n            startPos = i - 1;\n          } else {\n            isEncoded = true;\n          }\n        } else {\n          line += chr;\n        }\n      }\n\n      if (line) {\n        list.push({\n          line: line,\n          encoded: isEncoded\n        });\n      }\n    }\n\n    return list.map(function (item, i) {\n      return {\n        // encoded lines: {name}*{part}*\n        // unencoded lines: {name}*{part}\n        // if any line needs to be encoded then the first line (part==0) is always encoded\n        key: key + '*' + i + (item.encoded ? '*' : ''),\n        value: item.line\n      };\n    });\n  },\n\n  /**\n   * Returns file extension for a content type string. If no suitable extensions\n   * are found, 'bin' is used as the default extension\n   *\n   * @param {String} mimeType Content type to be checked for\n   * @return {String} File extension\n   */\n  detectExtension: function (mimeType) {\n    mimeType = (mimeType || '').toString().toLowerCase().replace(/\\s/g, '');\n\n    if (!(mimeType in mimetypes.list)) {\n      return 'bin';\n    }\n\n    if (typeof mimetypes.list[mimeType] === 'string') {\n      return mimetypes.list[mimeType];\n    }\n\n    var mimeParts = mimeType.split('/'); // search for name match\n\n    for (var i = 0, len = mimetypes.list[mimeType].length; i < len; i++) {\n      if (mimeParts[1] === mimetypes.list[mimeType][i]) {\n        return mimetypes.list[mimeType][i];\n      }\n    } // use the first one\n\n\n    return mimetypes.list[mimeType][0] !== '*' ? mimetypes.list[mimeType][0] : 'bin';\n  },\n\n  /**\n   * Returns content type for a file extension. If no suitable content types\n   * are found, 'application/octet-stream' is used as the default content type\n   *\n   * @param {String} extension Extension to be checked for\n   * @return {String} File extension\n   */\n  detectMimeType: function (extension) {\n    extension = (extension || '').toString().toLowerCase().replace(/\\s/g, '').replace(/^\\./g, '').split('.').pop();\n\n    if (!(extension in mimetypes.extensions)) {\n      return 'application/octet-stream';\n    }\n\n    if (typeof mimetypes.extensions[extension] === 'string') {\n      return mimetypes.extensions[extension];\n    }\n\n    var mimeParts; // search for name match\n\n    for (var i = 0, len = mimetypes.extensions[extension].length; i < len; i++) {\n      mimeParts = mimetypes.extensions[extension][i].split('/');\n\n      if (mimeParts[1] === extension) {\n        return mimetypes.extensions[extension][i];\n      }\n    } // use the first one\n\n\n    return mimetypes.extensions[extension][0];\n  },\n\n  /**\n   * Folds long lines, useful for folding header lines (afterSpace=false) and\n   * flowed text (afterSpace=true)\n   *\n   * @param {String} str String to be folded\n   * @param {Number} [lineLength=76] Maximum length of a line\n   * @param {Boolean} afterSpace If true, leave a space in th end of a line\n   * @return {String} String with folded lines\n   */\n  foldLines: function (str, lineLength, afterSpace) {\n    str = (str || '').toString();\n    lineLength = lineLength || 76;\n    var pos = 0,\n        len = str.length,\n        result = '',\n        line,\n        match;\n\n    while (pos < len) {\n      line = str.substr(pos, lineLength);\n\n      if (line.length < lineLength) {\n        result += line;\n        break;\n      }\n\n      if (match = line.match(/^[^\\n\\r]*(\\r?\\n|\\r)/)) {\n        line = match[0];\n        result += line;\n        pos += line.length;\n        continue;\n      } else if ((match = line.match(/(\\s+)[^\\s]*$/)) && match[0].length - (afterSpace ? (match[1] || '').length : 0) < line.length) {\n        line = line.substr(0, line.length - (match[0].length - (afterSpace ? (match[1] || '').length : 0)));\n      } else if (match = str.substr(pos + line.length).match(/^[^\\s]+(\\s*)/)) {\n        line = line + match[0].substr(0, match[0].length - (!afterSpace ? (match[1] || '').length : 0));\n      }\n\n      result += line;\n      pos += line.length;\n\n      if (pos < len) {\n        result += '\\r\\n';\n      }\n    }\n\n    return result;\n  }\n};\n/**\n * Splits a mime encoded string. Needed for dividing mime words into smaller chunks\n *\n * @param {String} str Mime encoded string to be split up\n * @param {Number} maxlen Maximum length of characters for one part (minimum 12)\n * @return {Array} Split string\n */\n\nfunction splitMimeEncodedString(str, maxlen) {\n  var curLine,\n      match,\n      chr,\n      done,\n      lines = []; // require at least 12 symbols to fit possible 4 octet UTF-8 sequences\n\n  maxlen = Math.max(maxlen || 0, 12);\n\n  while (str.length) {\n    curLine = str.substr(0, maxlen); // move incomplete escaped char back to main\n\n    if (match = curLine.match(/\\=[0-9A-F]?$/i)) {\n      curLine = curLine.substr(0, match.index);\n    }\n\n    done = false;\n\n    while (!done) {\n      done = true; // check if not middle of a unicode char sequence\n\n      if (match = str.substr(curLine.length).match(/^\\=([0-9A-F]{2})/i)) {\n        chr = parseInt(match[1], 16); // invalid sequence, move one char back anc recheck\n\n        if (chr < 0xC2 && chr > 0x7F) {\n          curLine = curLine.substr(0, curLine.length - 3);\n          done = false;\n        }\n      }\n    }\n\n    if (curLine.length) {\n      lines.push(curLine);\n    }\n\n    str = str.substr(curLine.length);\n  }\n\n  return lines;\n}\n\nfunction encodeURICharComponent(chr) {\n  var i, len, ord;\n  var res = '';\n  ord = chr.charCodeAt(0).toString(16).toUpperCase();\n\n  if (ord.length % 2) {\n    ord = '0' + ord;\n  }\n\n  if (ord.length > 2) {\n    for (i = 0, len = ord.length / 2; i < len; i++) {\n      res += '%' + ord.substr(i, 2);\n    }\n  } else {\n    res += '%' + ord;\n  }\n\n  return res;\n}\n\nfunction safeEncodeURIComponent(str) {\n  str = (str || '').toString();\n\n  try {\n    // might throw if we try to encode invalid sequences, eg. partial emoji\n    str = encodeURIComponent(str);\n  } catch (E) {\n    // should never run\n    return str.replace(/[^\\x00-\\x1F *'()<>@,;:\\\\\"\\[\\]?=\\u007F-\\uFFFF]+/g, '');\n  } // ensure chars that are not handled by encodeURICompent are converted as well\n\n\n  return str.replace(/[\\x00-\\x1F *'()<>@,;:\\\\\"\\[\\]?=\\u007F-\\uFFFF]/g, encodeURICharComponent);\n}","map":{"version":3,"sources":["/Users/theodaguier/e-do/node_modules/libmime/lib/libmime.js"],"names":["libcharset","require","libbase64","libqp","mimetypes","libmime","module","exports","isPlainText","value","test","hasLongerLines","str","lineLength","RegExp","decodeFlowed","delSp","toString","split","reduce","previousValue","currentValue","index","body","replace","encodeFlowed","flowed","forEach","line","push","foldLines","join","encodeWord","data","mimeWordEncoding","maxLength","toUpperCase","trim","charAt","encodedStr","toCharset","i","len","parts","length","encode","chr","ord","charCodeAt","Math","max","splitMimeEncodedString","substr","decodeWord","fromCharset","encoding","match","shift","decode","encodeWords","undefined","decodedValue","convert","encodedValue","decodeWords","mimeWord","decodeHeader","headerLine","key","toLowerCase","decodeHeaders","headers","lines","headersObj","header","splice","buildHeaderValue","structured","paramsArray","Object","keys","params","param","buildHeaderParam","encodedParam","JSON","stringify","bind","parseHeaderValue","response","type","quote","escaped","actualKey","nr","Number","charset","values","Array","isArray","map","val","s","c","list","encodedStrArr","startPos","isEncoded","safeEncodeURIComponent","encoded","item","detectExtension","mimeType","mimeParts","detectMimeType","extension","pop","extensions","afterSpace","pos","result","maxlen","curLine","done","parseInt","encodeURICharComponent","res","encodeURIComponent","E"],"mappings":"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","sourcesContent":["'use strict';\n\nvar libcharset = require('./charset');\nvar libbase64 = require('libbase64');\nvar libqp = require('libqp');\nvar mimetypes = require('./mimetypes');\n\nvar libmime = module.exports = {\n\n    /**\n     * Checks if a value is plaintext string (uses only printable 7bit chars)\n     *\n     * @param {String} value String to be tested\n     * @returns {Boolean} true if it is a plaintext string\n     */\n    isPlainText: function (value) {\n        if (typeof value !== 'string' || /[\\x00-\\x08\\x0b\\x0c\\x0e-\\x1f\\u0080-\\uFFFF]/.test(value)) {\n            return false;\n        } else {\n            return true;\n        }\n    },\n\n    /**\n     * Checks if a multi line string containes lines longer than the selected value.\n     *\n     * Useful when detecting if a mail message needs any processing at all –\n     * if only plaintext characters are used and lines are short, then there is\n     * no need to encode the values in any way. If the value is plaintext but has\n     * longer lines then allowed, then use format=flowed\n     *\n     * @param {Number} lineLength Max line length to check for\n     * @returns {Boolean} Returns true if there is at least one line longer than lineLength chars\n     */\n    hasLongerLines: function (str, lineLength) {\n        return new RegExp('^.{' + (lineLength + 1) + ',}', 'm').test(str);\n    },\n\n    /**\n     * Decodes a string from a format=flowed soft wrapping.\n     *\n     * @param {String} str Plaintext string with format=flowed to decode\n     * @param {Boolean} [delSp] If true, delete leading spaces (delsp=yes)\n     * @return {String} Mime decoded string\n     */\n    decodeFlowed: function (str, delSp) {\n        str = (str || '').toString();\n\n        return str.\n        split(/\\r?\\n/).\n            // remove soft linebreaks\n            // soft linebreaks are added after space symbols\n        reduce(\n                function (previousValue, currentValue, index) {\n                    var body = previousValue;\n                    if (delSp) {\n                        // delsp adds spaces to text to be able to fold it\n                        // these spaces can be removed once the text is unfolded\n                        body = body.replace(/[ ]+$/, '');\n                    }\n                    if (/ $/.test(previousValue) && !/(^|\\n)\\-\\- $/.test(previousValue) || index === 1) {\n                        return body + currentValue;\n                    } else {\n                        return body + '\\n' + currentValue;\n                    }\n                }\n            ).\n            // remove whitespace stuffing\n            // http://tools.ietf.org/html/rfc3676#section-4.4\n        replace(/^ /gm, '');\n    },\n\n    /**\n     * Adds soft line breaks to content marked with format=flowed to\n     * ensure that no line in the message is never longer than lineLength\n     *\n     * @param {String} str Plaintext string that requires wrapping\n     * @param {Number} [lineLength=76] Maximum length of a line\n     * @return {String} String with forced line breaks\n     */\n    encodeFlowed: function (str, lineLength) {\n        lineLength = lineLength || 76;\n\n        var flowed = [];\n        str.split(/\\r?\\n/).forEach(function (line) {\n            flowed.push(libmime.foldLines(line.\n                // space stuffing http://tools.ietf.org/html/rfc3676#section-4.2\n                replace(/^( |From|>)/igm, ' $1'),\n                lineLength, true));\n        });\n        return flowed.join('\\r\\n');\n    },\n\n    /**\n     * Encodes a string or an Buffer to an UTF-8 MIME Word (rfc2047)\n     *\n     * @param {String|Buffer} data String to be encoded\n     * @param {String} mimeWordEncoding='Q' Encoding for the mime word, either Q or B\n     * @param {Number} [maxLength=0] If set, split mime words into several chunks if needed\n     * @return {String} Single or several mime words joined together\n     */\n    encodeWord: function (data, mimeWordEncoding, maxLength) {\n        mimeWordEncoding = (mimeWordEncoding || 'Q').toString().toUpperCase().trim().charAt(0);\n        maxLength = maxLength || 0;\n\n        var encodedStr,\n            toCharset = 'UTF-8',\n            i, len, parts;\n\n        if (maxLength && maxLength > 7 + toCharset.length) {\n            maxLength -= (7 + toCharset.length);\n        }\n\n        if (mimeWordEncoding === 'Q') {\n            // https://tools.ietf.org/html/rfc2047#section-5 rule (3)\n            encodedStr = libqp.encode(data).replace(/[^a-z0-9!*+\\-\\/=]/ig, function (chr) {\n                var ord = chr.charCodeAt(0).toString(16).toUpperCase();\n                if (chr === ' ') {\n                    return '_';\n                } else {\n                    return '=' + (ord.length === 1 ? '0' + ord : ord);\n                }\n            });\n        } else if (mimeWordEncoding === 'B') {\n            encodedStr = typeof data === 'string' ? data : libbase64.encode(data);\n            maxLength = Math.max(3, (maxLength - maxLength % 4) / 4 * 3);\n        }\n\n        if (maxLength && encodedStr.length > maxLength) {\n            if (mimeWordEncoding === 'Q') {\n                encodedStr = splitMimeEncodedString(encodedStr, maxLength).join('?= =?' + toCharset + '?' + mimeWordEncoding + '?');\n            } else {\n\n                // RFC2047 6.3 (2) states that encoded-word must include an integral number of characters, so no chopping unicode sequences\n                parts = [];\n                for (i = 0, len = encodedStr.length; i < len; i += maxLength) {\n                    parts.push(libbase64.encode(encodedStr.substr(i, maxLength)));\n                }\n\n                if (parts.length > 1) {\n                    encodedStr = parts.join('?= =?' + toCharset + '?' + mimeWordEncoding + '?');\n                } else {\n                    encodedStr = parts.join('');\n                }\n            }\n        } else if (mimeWordEncoding === 'B') {\n            encodedStr = libbase64.encode(data);\n        }\n\n        return '=?' + toCharset + '?' + mimeWordEncoding + '?' + encodedStr + (encodedStr.substr(-2) === '?=' ? '' : '?=');\n    },\n\n    /**\n     * Decode a complete mime word encoded string\n     *\n     * @param {String} str Mime word encoded string\n     * @return {String} Decoded unicode string\n     */\n    decodeWord: function (str) {\n        str = (str || '').toString().trim();\n\n        var fromCharset, encoding, match;\n\n        match = str.match(/^\\=\\?([\\w_\\-\\*]+)\\?([QqBb])\\?([^\\?]+)\\?\\=$/i);\n        if (!match) {\n            return str;\n        }\n\n        // RFC2231 added language tag to the encoding\n        // see: https://tools.ietf.org/html/rfc2231#section-5\n        // this implementation silently ignores this tag\n        fromCharset = match[1].split('*').shift();\n\n        encoding = (match[2] || 'Q').toString().toUpperCase();\n        str = (match[3] || '').replace(/_/g, ' ').replace(/ $/, '=20');\n\n        if (encoding === 'B') {\n            return libcharset.decode(libbase64.decode(str), fromCharset);\n        } else if (encoding === 'Q') {\n            return libcharset.decode(libqp.decode(str), fromCharset);\n        } else {\n            return str;\n        }\n    },\n\n    /**\n     * Finds word sequences with non ascii text and converts these to mime words\n     *\n     * @param {String|Buffer} data String to be encoded\n     * @param {String} mimeWordEncoding='Q' Encoding for the mime word, either Q or B\n     * @param {Number} [maxLength=0] If set, split mime words into several chunks if needed\n     * @param {String} [fromCharset='UTF-8'] Source sharacter set\n     * @return {String} String with possible mime words\n     */\n    encodeWords: function (data, mimeWordEncoding, maxLength, fromCharset) {\n        if (!fromCharset && typeof maxLength === 'string' && !maxLength.match(/^[0-9]+$/)) {\n            fromCharset = maxLength;\n            maxLength = undefined;\n        }\n\n        maxLength = maxLength || 0;\n\n        var decodedValue = libcharset.decode(libcharset.convert((data || ''), fromCharset)),\n            encodedValue;\n\n        encodedValue = decodedValue.replace(/([^\\s\\u0080-\\uFFFF]*[\\u0080-\\uFFFF]+[^\\s\\u0080-\\uFFFF]*(?:\\s+[^\\s\\u0080-\\uFFFF]*[\\u0080-\\uFFFF]+[^\\s\\u0080-\\uFFFF]*\\s*)?)+(?=\\s|$)/g, function (match) {\n            return match.length ? libmime.encodeWord(match, mimeWordEncoding || 'Q', maxLength) : '';\n        });\n\n        return encodedValue;\n    },\n\n    /**\n     * Decode a string that might include one or several mime words\n     *\n     * @param {String} str String including some mime words that will be encoded\n     * @return {String} Decoded unicode string\n     */\n    decodeWords: function (str) {\n        str = (str || '').toString();\n        str = str.\n        replace(/(=\\?[^?]+\\?[QqBb]\\?[^?]+\\?=)\\s+(?==\\?[^?]+\\?[QqBb]\\?[^?]+\\?=)/g, '$1').\n        replace(/\\=\\?([\\w_\\-\\*]+)\\?([QqBb])\\?[^\\?]+\\?\\=/g, function (mimeWord) {\n            return libmime.decodeWord(mimeWord);\n        });\n\n        return str;\n    },\n\n    /**\n     * Splits a string by :\n     * The result is not mime word decoded, you need to do your own decoding based\n     * on the rules for the specific header key\n     *\n     * @param {String} headerLine Single header line, might include linebreaks as well if folded\n     * @return {Object} And object of {key, value}\n     */\n    decodeHeader: function (headerLine) {\n        var line = (headerLine || '').toString().replace(/(?:\\r?\\n|\\r)[ \\t]*/g, ' ').trim(),\n            match = line.match(/^\\s*([^:]+):(.*)$/),\n            key = (match && match[1] || '').trim().toLowerCase(),\n            value = (match && match[2] || '').trim();\n\n        return {\n            key: key,\n            value: value\n        };\n    },\n\n    /**\n     * Parses a block of header lines. Does not decode mime words as every\n     * header might have its own rules (eg. formatted email addresses and such)\n     *\n     * @param {String} headers Headers string\n     * @return {Object} An object of headers, where header keys are object keys. NB! Several values with the same key make up an Array\n     */\n    decodeHeaders: function (headers) {\n        var lines = headers.split(/\\r?\\n|\\r/),\n            headersObj = {},\n            header,\n            i, len;\n\n        for (i = lines.length - 1; i >= 0; i--) {\n            if (i && lines[i].match(/^\\s/)) {\n                lines[i - 1] += '\\r\\n' + lines[i];\n                lines.splice(i, 1);\n            }\n        }\n\n        for (i = 0, len = lines.length; i < len; i++) {\n            header = libmime.decodeHeader(lines[i]);\n            if (!headersObj[header.key]) {\n                headersObj[header.key] = [header.value];\n            } else {\n                headersObj[header.key].push(header.value);\n            }\n        }\n\n        return headersObj;\n    },\n\n    /**\n     * Joins parsed header value together as 'value; param1=value1; param2=value2'\n     *\n     * @param {Object} structured Parsed header value\n     * @return {String} joined header value\n     */\n    buildHeaderValue: function (structured) {\n        var paramsArray = [];\n\n        Object.keys(structured.params || {}).forEach(function (param) {\n            // filename might include unicode characters so it is a special case\n            var value = structured.params[param];\n            if (!libmime.isPlainText(value) || value.length >= 75) {\n                libmime.buildHeaderParam(param, value, 50).forEach(function (encodedParam) {\n                    if (!/[\\s\"\\\\;\\/=]|^[\\-']|'$/.test(encodedParam.value)) {\n                        paramsArray.push(encodedParam.key + '=' + encodedParam.value);\n                    } else {\n                        paramsArray.push(encodedParam.key + '=' + JSON.stringify(encodedParam.value));\n                    }\n                });\n            } else if (/[\\s'\"\\\\;\\/=]|^\\-/.test(value)) {\n                paramsArray.push(param + '=' + JSON.stringify(value));\n            } else {\n                paramsArray.push(param + '=' + value);\n            }\n        }.bind(this));\n\n        return structured.value + (paramsArray.length ? '; ' + paramsArray.join('; ') : '');\n    },\n\n    /**\n     * Parses a header value with key=value arguments into a structured\n     * object.\n     *\n     *   parseHeaderValue('content-type: text/plain; CHARSET='UTF-8'') ->\n     *   {\n     *     'value': 'text/plain',\n     *     'params': {\n     *       'charset': 'UTF-8'\n     *     }\n     *   }\n     *\n     * @param {String} str Header value\n     * @return {Object} Header value as a parsed structure\n     */\n    parseHeaderValue: function (str) {\n        var response = {\n                value: false,\n                params: {}\n            },\n            key = false,\n            value = '',\n            type = 'value',\n            quote = false,\n            escaped = false,\n            chr;\n\n        for (var i = 0, len = str.length; i < len; i++) {\n            chr = str.charAt(i);\n            if (type === 'key') {\n                if (chr === '=') {\n                    key = value.trim().toLowerCase();\n                    type = 'value';\n                    value = '';\n                    continue;\n                }\n                value += chr;\n            } else {\n                if (escaped) {\n                    value += chr;\n                } else if (chr === '\\\\') {\n                    escaped = true;\n                    continue;\n                } else if (quote && chr === quote) {\n                    quote = false;\n                } else if (!quote && chr === '\"') {\n                    quote = chr;\n                } else if (!quote && chr === ';') {\n                    if (key === false) {\n                        response.value = value.trim();\n                    } else {\n                        response.params[key] = value.trim();\n                    }\n                    type = 'key';\n                    value = '';\n                } else {\n                    value += chr;\n                }\n                escaped = false;\n\n            }\n        }\n\n        if (type === 'value') {\n            if (key === false) {\n                response.value = value.trim();\n            } else {\n                response.params[key] = value.trim();\n            }\n        } else if (value.trim()) {\n            response.params[value.trim().toLowerCase()] = '';\n        }\n\n        // handle parameter value continuations\n        // https://tools.ietf.org/html/rfc2231#section-3\n\n        // preprocess values\n        Object.keys(response.params).forEach(function (key) {\n            var actualKey, nr, match, value;\n            if ((match = key.match(/(\\*(\\d+)|\\*(\\d+)\\*|\\*)$/))) {\n                actualKey = key.substr(0, match.index);\n                nr = Number(match[2] || match[3]) || 0;\n\n                if (!response.params[actualKey] || typeof response.params[actualKey] !== 'object') {\n                    response.params[actualKey] = {\n                        charset: false,\n                        values: []\n                    };\n                }\n\n                value = response.params[key];\n\n                if (nr === 0 && match[0].substr(-1) === '*' && (match = value.match(/^([^']*)'[^']*'(.*)$/))) {\n                    response.params[actualKey].charset = match[1] || 'iso-8859-1';\n                    value = match[2];\n                }\n\n                response.params[actualKey].values[nr] = value;\n\n                // remove the old reference\n                delete response.params[key];\n            }\n        });\n\n        // concatenate split rfc2231 strings and convert encoded strings to mime encoded words\n        Object.keys(response.params).forEach(function (key) {\n            var value;\n            if (response.params[key] && Array.isArray(response.params[key].values)) {\n                value = response.params[key].values.map(function (val) {\n                    return val || '';\n                }).join('');\n\n                if (response.params[key].charset) {\n                    // convert \"%AB\" to \"=?charset?Q?=AB?=\"\n                    response.params[key] = '=?' +\n                        response.params[key].charset +\n                        '?Q?' +\n                        value.\n                        // fix invalidly encoded chars\n                    replace(/[=\\?_\\s]/g,\n                            function (s) {\n                                var c = s.charCodeAt(0).toString(16);\n                                if (s === ' ') {\n                                    return '_';\n                                } else {\n                                    return '%' + (c.length < 2 ? '0' : '') + c;\n                                }\n                            }\n                        ).\n                        // change from urlencoding to percent encoding\n                    replace(/%/g, '=') +\n                        '?=';\n                } else {\n                    response.params[key] = value;\n                }\n            }\n        }.bind(this));\n\n        return response;\n    },\n\n    /**\n     * Encodes a string or an Buffer to an UTF-8 Parameter Value Continuation encoding (rfc2231)\n     * Useful for splitting long parameter values.\n     *\n     * For example\n     *      title=\"unicode string\"\n     * becomes\n     *     title*0*=utf-8''unicode\n     *     title*1*=%20string\n     *\n     * @param {String|Buffer} data String to be encoded\n     * @param {Number} [maxLength=50] Max length for generated chunks\n     * @param {String} [fromCharset='UTF-8'] Source sharacter set\n     * @return {Array} A list of encoded keys and headers\n     */\n    buildHeaderParam: function (key, data, maxLength, fromCharset) {\n        var list = [];\n        var encodedStr = typeof data === 'string' ? data : libmime.decode(data, fromCharset);\n        var encodedStrArr;\n        var chr, ord;\n        var line;\n        var startPos = 0;\n        var isEncoded = false;\n        var i, len;\n\n        maxLength = maxLength || 50;\n\n        // process ascii only text\n        if (libmime.isPlainText(data)) {\n\n            // check if conversion is even needed\n            if (encodedStr.length <= maxLength) {\n                return [{\n                    key: key,\n                    value: encodedStr\n                }];\n            }\n\n            encodedStr = encodedStr.replace(new RegExp('.{' + maxLength + '}', 'g'), function (str) {\n                list.push({\n                    line: str\n                });\n                return '';\n            });\n\n            if (encodedStr) {\n                list.push({\n                    line: encodedStr\n                });\n            }\n\n        } else {\n\n            if (/[\\uD800-\\uDBFF]/.test(encodedStr)) {\n                // string containts surrogate pairs, so normalize it to an array of bytes\n                encodedStrArr = [];\n                for (i = 0, len = encodedStr.length; i < len; i++) {\n                    chr = encodedStr.charAt(i);\n                    ord = chr.charCodeAt(0);\n                    if (ord >= 0xD800 && ord <= 0xDBFF && i < len - 1) {\n                        chr += encodedStr.charAt(i + 1);\n                        encodedStrArr.push(chr);\n                        i++;\n                    } else {\n                        encodedStrArr.push(chr);\n                    }\n                }\n                encodedStr = encodedStrArr;\n            }\n\n            // first line includes the charset and language info and needs to be encoded\n            // even if it does not contain any unicode characters\n            line = 'utf-8\\'\\'';\n            isEncoded = true;\n            startPos = 0;\n\n            // process text with unicode or special chars\n            for (i = 0, len = encodedStr.length; i < len; i++) {\n\n                chr = encodedStr[i];\n\n                if (isEncoded) {\n                    chr = safeEncodeURIComponent(chr);\n                } else {\n                    // try to urlencode current char\n                    chr = chr === ' ' ? chr : safeEncodeURIComponent(chr);\n                    // By default it is not required to encode a line, the need\n                    // only appears when the string contains unicode or special chars\n                    // in this case we start processing the line over and encode all chars\n                    if (chr !== encodedStr[i]) {\n                        // Check if it is even possible to add the encoded char to the line\n                        // If not, there is no reason to use this line, just push it to the list\n                        // and start a new line with the char that needs encoding\n                        if ((safeEncodeURIComponent(line) + chr).length >= maxLength) {\n                            list.push({\n                                line: line,\n                                encoded: isEncoded\n                            });\n                            line = '';\n                            startPos = i - 1;\n                        } else {\n                            isEncoded = true;\n                            i = startPos;\n                            line = '';\n                            continue;\n                        }\n                    }\n                }\n\n                // if the line is already too long, push it to the list and start a new one\n                if ((line + chr).length >= maxLength) {\n                    list.push({\n                        line: line,\n                        encoded: isEncoded\n                    });\n                    line = chr = encodedStr[i] === ' ' ? ' ' : safeEncodeURIComponent(encodedStr[i]);\n                    if (chr === encodedStr[i]) {\n                        isEncoded = false;\n                        startPos = i - 1;\n                    } else {\n                        isEncoded = true;\n                    }\n                } else {\n                    line += chr;\n                }\n            }\n\n            if (line) {\n                list.push({\n                    line: line,\n                    encoded: isEncoded\n                });\n            }\n        }\n\n        return list.map(function (item, i) {\n            return {\n                // encoded lines: {name}*{part}*\n                // unencoded lines: {name}*{part}\n                // if any line needs to be encoded then the first line (part==0) is always encoded\n                key: key + '*' + i + (item.encoded ? '*' : ''),\n                value: item.line\n            };\n        });\n    },\n\n\n    /**\n     * Returns file extension for a content type string. If no suitable extensions\n     * are found, 'bin' is used as the default extension\n     *\n     * @param {String} mimeType Content type to be checked for\n     * @return {String} File extension\n     */\n    detectExtension: function (mimeType) {\n        mimeType = (mimeType || '').toString().toLowerCase().replace(/\\s/g, '');\n        if (!(mimeType in mimetypes.list)) {\n            return 'bin';\n        }\n\n        if (typeof mimetypes.list[mimeType] === 'string') {\n            return mimetypes.list[mimeType];\n        }\n\n        var mimeParts = mimeType.split('/');\n\n        // search for name match\n        for (var i = 0, len = mimetypes.list[mimeType].length; i < len; i++) {\n            if (mimeParts[1] === mimetypes.list[mimeType][i]) {\n                return mimetypes.list[mimeType][i];\n            }\n        }\n\n        // use the first one\n        return mimetypes.list[mimeType][0] !== '*' ? mimetypes.list[mimeType][0] : 'bin';\n    },\n\n    /**\n     * Returns content type for a file extension. If no suitable content types\n     * are found, 'application/octet-stream' is used as the default content type\n     *\n     * @param {String} extension Extension to be checked for\n     * @return {String} File extension\n     */\n    detectMimeType: function (extension) {\n        extension = (extension || '').toString().toLowerCase().replace(/\\s/g, '').replace(/^\\./g, '').split('.').pop();\n\n        if (!(extension in mimetypes.extensions)) {\n            return 'application/octet-stream';\n        }\n\n        if (typeof mimetypes.extensions[extension] === 'string') {\n            return mimetypes.extensions[extension];\n        }\n\n        var mimeParts;\n\n        // search for name match\n        for (var i = 0, len = mimetypes.extensions[extension].length; i < len; i++) {\n            mimeParts = mimetypes.extensions[extension][i].split('/');\n            if (mimeParts[1] === extension) {\n                return mimetypes.extensions[extension][i];\n            }\n        }\n\n        // use the first one\n        return mimetypes.extensions[extension][0];\n    },\n\n    /**\n     * Folds long lines, useful for folding header lines (afterSpace=false) and\n     * flowed text (afterSpace=true)\n     *\n     * @param {String} str String to be folded\n     * @param {Number} [lineLength=76] Maximum length of a line\n     * @param {Boolean} afterSpace If true, leave a space in th end of a line\n     * @return {String} String with folded lines\n     */\n    foldLines: function (str, lineLength, afterSpace) {\n        str = (str || '').toString();\n        lineLength = lineLength || 76;\n\n        var pos = 0,\n            len = str.length,\n            result = '',\n            line, match;\n\n        while (pos < len) {\n            line = str.substr(pos, lineLength);\n            if (line.length < lineLength) {\n                result += line;\n                break;\n            }\n            if ((match = line.match(/^[^\\n\\r]*(\\r?\\n|\\r)/))) {\n                line = match[0];\n                result += line;\n                pos += line.length;\n                continue;\n            } else if ((match = line.match(/(\\s+)[^\\s]*$/)) && match[0].length - (afterSpace ? (match[1] || '').length : 0) < line.length) {\n                line = line.substr(0, line.length - (match[0].length - (afterSpace ? (match[1] || '').length : 0)));\n            } else if ((match = str.substr(pos + line.length).match(/^[^\\s]+(\\s*)/))) {\n                line = line + match[0].substr(0, match[0].length - (!afterSpace ? (match[1] || '').length : 0));\n            }\n\n            result += line;\n            pos += line.length;\n            if (pos < len) {\n                result += '\\r\\n';\n            }\n        }\n\n        return result;\n    }\n};\n\n/**\n * Splits a mime encoded string. Needed for dividing mime words into smaller chunks\n *\n * @param {String} str Mime encoded string to be split up\n * @param {Number} maxlen Maximum length of characters for one part (minimum 12)\n * @return {Array} Split string\n */\nfunction splitMimeEncodedString(str, maxlen) {\n    var curLine, match, chr, done,\n        lines = [];\n\n    // require at least 12 symbols to fit possible 4 octet UTF-8 sequences\n    maxlen = Math.max(maxlen || 0, 12);\n\n    while (str.length) {\n        curLine = str.substr(0, maxlen);\n\n        // move incomplete escaped char back to main\n        if ((match = curLine.match(/\\=[0-9A-F]?$/i))) {\n            curLine = curLine.substr(0, match.index);\n        }\n\n        done = false;\n        while (!done) {\n            done = true;\n            // check if not middle of a unicode char sequence\n            if ((match = str.substr(curLine.length).match(/^\\=([0-9A-F]{2})/i))) {\n                chr = parseInt(match[1], 16);\n                // invalid sequence, move one char back anc recheck\n                if (chr < 0xC2 && chr > 0x7F) {\n                    curLine = curLine.substr(0, curLine.length - 3);\n                    done = false;\n                }\n            }\n        }\n\n        if (curLine.length) {\n            lines.push(curLine);\n        }\n        str = str.substr(curLine.length);\n    }\n\n    return lines;\n}\n\nfunction encodeURICharComponent(chr) {\n    var i, len, ord;\n    var res = '';\n\n    ord = chr.charCodeAt(0).toString(16).toUpperCase();\n    if (ord.length % 2) {\n        ord = '0' + ord;\n    }\n    if (ord.length > 2) {\n        for (i = 0, len = ord.length / 2; i < len; i++) {\n            res += '%' + ord.substr(i, 2);\n        }\n    } else {\n        res += '%' + ord;\n    }\n\n    return res;\n}\n\nfunction safeEncodeURIComponent(str) {\n    str = (str || '').toString();\n\n    try {\n        // might throw if we try to encode invalid sequences, eg. partial emoji\n        str = encodeURIComponent(str);\n    } catch (E) {\n        // should never run\n        return str.replace(/[^\\x00-\\x1F *'()<>@,;:\\\\\"\\[\\]?=\\u007F-\\uFFFF]+/g, '');\n    }\n\n    // ensure chars that are not handled by encodeURICompent are converted as well\n    return str.replace(/[\\x00-\\x1F *'()<>@,;:\\\\\"\\[\\]?=\\u007F-\\uFFFF]/g, encodeURICharComponent);\n}\n"]},"metadata":{},"sourceType":"script"}