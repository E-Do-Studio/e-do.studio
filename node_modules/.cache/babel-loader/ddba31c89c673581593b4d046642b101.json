{"ast":null,"code":"import { Loader, FileLoader, TextureLoader, Points, LineSegments, Mesh, PointsMaterial, LineBasicMaterial, BufferAttribute, MeshPhongMaterial, BackSide, DoubleSide, FrontSide, Vector2, Color, AddOperation, EquirectangularRefractionMapping, EquirectangularReflectionMapping, ClampToEdgeWrapping, MirroredRepeatWrapping, RepeatWrapping, MeshPhysicalMaterial, MeshStandardMaterial, BufferGeometry, Float32BufferAttribute } from \"three\";\nimport { IFFParser } from \"./lwo/IFFParser.js\";\n\nlet _lwoTree;\n\nclass LWOLoader extends Loader {\n  constructor(manager, parameters = {}) {\n    super(manager);\n    this.resourcePath = parameters.resourcePath !== void 0 ? parameters.resourcePath : \"\";\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const path = scope.path === \"\" ? extractParentUrl(url, \"Objects\") : scope.path;\n    const modelName = url.split(path).pop().split(\".\")[0];\n    const loader = new FileLoader(this.manager);\n    loader.setPath(scope.path);\n    loader.setResponseType(\"arraybuffer\");\n    loader.load(url, function (buffer) {\n      try {\n        onLoad(scope.parse(buffer, path, modelName));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n\n  parse(iffBuffer, path, modelName) {\n    _lwoTree = new IFFParser().parse(iffBuffer);\n    const textureLoader = new TextureLoader(this.manager).setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n    return new LWOTreeParser(textureLoader).parse(modelName);\n  }\n\n}\n\nclass LWOTreeParser {\n  constructor(textureLoader) {\n    this.textureLoader = textureLoader;\n  }\n\n  parse(modelName) {\n    this.materials = new MaterialParser(this.textureLoader).parse();\n    this.defaultLayerName = modelName;\n    this.meshes = this.parseLayers();\n    return {\n      materials: this.materials,\n      meshes: this.meshes\n    };\n  }\n\n  parseLayers() {\n    const meshes = [];\n    const finalMeshes = [];\n    const geometryParser = new GeometryParser();\n    const scope = this;\n\n    _lwoTree.layers.forEach(function (layer) {\n      const geometry = geometryParser.parse(layer.geometry, layer);\n      const mesh = scope.parseMesh(geometry, layer);\n      meshes[layer.number] = mesh;\n      if (layer.parent === -1) finalMeshes.push(mesh);else meshes[layer.parent].add(mesh);\n    });\n\n    this.applyPivots(finalMeshes);\n    return finalMeshes;\n  }\n\n  parseMesh(geometry, layer) {\n    let mesh;\n    const materials = this.getMaterials(geometry.userData.matNames, layer.geometry.type);\n    this.duplicateUVs(geometry, materials);\n    if (layer.geometry.type === \"points\") mesh = new Points(geometry, materials);else if (layer.geometry.type === \"lines\") mesh = new LineSegments(geometry, materials);else mesh = new Mesh(geometry, materials);\n    if (layer.name) mesh.name = layer.name;else mesh.name = this.defaultLayerName + \"_layer_\" + layer.number;\n    mesh.userData.pivot = layer.pivot;\n    return mesh;\n  } // TODO: may need to be reversed in z to convert LWO to three.js coordinates\n\n\n  applyPivots(meshes) {\n    meshes.forEach(function (mesh) {\n      mesh.traverse(function (child) {\n        const pivot = child.userData.pivot;\n        child.position.x += pivot[0];\n        child.position.y += pivot[1];\n        child.position.z += pivot[2];\n\n        if (child.parent) {\n          const parentPivot = child.parent.userData.pivot;\n          child.position.x -= parentPivot[0];\n          child.position.y -= parentPivot[1];\n          child.position.z -= parentPivot[2];\n        }\n      });\n    });\n  }\n\n  getMaterials(namesArray, type) {\n    const materials = [];\n    const scope = this;\n    namesArray.forEach(function (name, i) {\n      materials[i] = scope.getMaterialByName(name);\n    });\n\n    if (type === \"points\" || type === \"lines\") {\n      materials.forEach(function (mat, i) {\n        const spec = {\n          color: mat.color\n        };\n\n        if (type === \"points\") {\n          spec.size = 0.1;\n          spec.map = mat.map;\n          spec.morphTargets = mat.morphTargets;\n          materials[i] = new PointsMaterial(spec);\n        } else if (type === \"lines\") {\n          materials[i] = new LineBasicMaterial(spec);\n        }\n      });\n    }\n\n    const filtered = materials.filter(Boolean);\n    if (filtered.length === 1) return filtered[0];\n    return materials;\n  }\n\n  getMaterialByName(name) {\n    return this.materials.filter(function (m) {\n      return m.name === name;\n    })[0];\n  } // If the material has an aoMap, duplicate UVs\n\n\n  duplicateUVs(geometry, materials) {\n    let duplicateUVs = false;\n\n    if (!Array.isArray(materials)) {\n      if (materials.aoMap) duplicateUVs = true;\n    } else {\n      materials.forEach(function (material) {\n        if (material.aoMap) duplicateUVs = true;\n      });\n    }\n\n    if (!duplicateUVs) return;\n    geometry.setAttribute(\"uv2\", new BufferAttribute(geometry.attributes.uv.array, 2));\n  }\n\n}\n\nclass MaterialParser {\n  constructor(textureLoader) {\n    this.textureLoader = textureLoader;\n  }\n\n  parse() {\n    const materials = [];\n    this.textures = {};\n\n    for (const name in _lwoTree.materials) {\n      if (_lwoTree.format === \"LWO3\") {\n        materials.push(this.parseMaterial(_lwoTree.materials[name], name, _lwoTree.textures));\n      } else if (_lwoTree.format === \"LWO2\") {\n        materials.push(this.parseMaterialLwo2(_lwoTree.materials[name], name, _lwoTree.textures));\n      }\n    }\n\n    return materials;\n  }\n\n  parseMaterial(materialData, name, textures) {\n    let params = {\n      name,\n      side: this.getSide(materialData.attributes),\n      flatShading: this.getSmooth(materialData.attributes)\n    };\n    const connections = this.parseConnections(materialData.connections, materialData.nodes);\n    const maps = this.parseTextureNodes(connections.maps);\n    this.parseAttributeImageMaps(connections.attributes, textures, maps, materialData.maps);\n    const attributes = this.parseAttributes(connections.attributes, maps);\n    this.parseEnvMap(connections, maps, attributes);\n    params = Object.assign(maps, params);\n    params = Object.assign(params, attributes);\n    const materialType = this.getMaterialType(connections.attributes);\n    return new materialType(params);\n  }\n\n  parseMaterialLwo2(materialData, name) {\n    let params = {\n      name,\n      side: this.getSide(materialData.attributes),\n      flatShading: this.getSmooth(materialData.attributes)\n    };\n    const attributes = this.parseAttributes(materialData.attributes, {});\n    params = Object.assign(params, attributes);\n    return new MeshPhongMaterial(params);\n  } // Note: converting from left to right handed coords by switching x -> -x in vertices, and\n  // then switching mat FrontSide -> BackSide\n  // NB: this means that FrontSide and BackSide have been switched!\n\n\n  getSide(attributes) {\n    if (!attributes.side) return BackSide;\n\n    switch (attributes.side) {\n      case 0:\n      case 1:\n        return BackSide;\n\n      case 2:\n        return FrontSide;\n\n      case 3:\n        return DoubleSide;\n    }\n  }\n\n  getSmooth(attributes) {\n    if (!attributes.smooth) return true;\n    return !attributes.smooth;\n  }\n\n  parseConnections(connections, nodes) {\n    const materialConnections = {\n      maps: {}\n    };\n    const inputName = connections.inputName;\n    const inputNodeName = connections.inputNodeName;\n    const nodeName = connections.nodeName;\n    const scope = this;\n    inputName.forEach(function (name, index) {\n      if (name === \"Material\") {\n        const matNode = scope.getNodeByRefName(inputNodeName[index], nodes);\n        materialConnections.attributes = matNode.attributes;\n        materialConnections.envMap = matNode.fileName;\n        materialConnections.name = inputNodeName[index];\n      }\n    });\n    nodeName.forEach(function (name, index) {\n      if (name === materialConnections.name) {\n        materialConnections.maps[inputName[index]] = scope.getNodeByRefName(inputNodeName[index], nodes);\n      }\n    });\n    return materialConnections;\n  }\n\n  getNodeByRefName(refName, nodes) {\n    for (const name in nodes) {\n      if (nodes[name].refName === refName) return nodes[name];\n    }\n  }\n\n  parseTextureNodes(textureNodes) {\n    const maps = {};\n\n    for (const name in textureNodes) {\n      const node = textureNodes[name];\n      const path = node.fileName;\n      if (!path) return;\n      const texture = this.loadTexture(path);\n      if (node.widthWrappingMode !== void 0) texture.wrapS = this.getWrappingType(node.widthWrappingMode);\n      if (node.heightWrappingMode !== void 0) texture.wrapT = this.getWrappingType(node.heightWrappingMode);\n\n      switch (name) {\n        case \"Color\":\n          maps.map = texture;\n          break;\n\n        case \"Roughness\":\n          maps.roughnessMap = texture;\n          maps.roughness = 0.5;\n          break;\n\n        case \"Specular\":\n          maps.specularMap = texture;\n          maps.specular = 16777215;\n          break;\n\n        case \"Luminous\":\n          maps.emissiveMap = texture;\n          maps.emissive = 8421504;\n          break;\n\n        case \"Luminous Color\":\n          maps.emissive = 8421504;\n          break;\n\n        case \"Metallic\":\n          maps.metalnessMap = texture;\n          maps.metalness = 0.5;\n          break;\n\n        case \"Transparency\":\n        case \"Alpha\":\n          maps.alphaMap = texture;\n          maps.transparent = true;\n          break;\n\n        case \"Normal\":\n          maps.normalMap = texture;\n          if (node.amplitude !== void 0) maps.normalScale = new Vector2(node.amplitude, node.amplitude);\n          break;\n\n        case \"Bump\":\n          maps.bumpMap = texture;\n          break;\n      }\n    }\n\n    if (maps.roughnessMap && maps.specularMap) delete maps.specularMap;\n    return maps;\n  } // maps can also be defined on individual material attributes, parse those here\n  // This occurs on Standard (Phong) surfaces\n\n\n  parseAttributeImageMaps(attributes, textures, maps) {\n    for (const name in attributes) {\n      const attribute = attributes[name];\n\n      if (attribute.maps) {\n        const mapData = attribute.maps[0];\n        const path = this.getTexturePathByIndex(mapData.imageIndex, textures);\n        if (!path) return;\n        const texture = this.loadTexture(path);\n        if (mapData.wrap !== void 0) texture.wrapS = this.getWrappingType(mapData.wrap.w);\n        if (mapData.wrap !== void 0) texture.wrapT = this.getWrappingType(mapData.wrap.h);\n\n        switch (name) {\n          case \"Color\":\n            maps.map = texture;\n            break;\n\n          case \"Diffuse\":\n            maps.aoMap = texture;\n            break;\n\n          case \"Roughness\":\n            maps.roughnessMap = texture;\n            maps.roughness = 1;\n            break;\n\n          case \"Specular\":\n            maps.specularMap = texture;\n            maps.specular = 16777215;\n            break;\n\n          case \"Luminosity\":\n            maps.emissiveMap = texture;\n            maps.emissive = 8421504;\n            break;\n\n          case \"Metallic\":\n            maps.metalnessMap = texture;\n            maps.metalness = 1;\n            break;\n\n          case \"Transparency\":\n          case \"Alpha\":\n            maps.alphaMap = texture;\n            maps.transparent = true;\n            break;\n\n          case \"Normal\":\n            maps.normalMap = texture;\n            break;\n\n          case \"Bump\":\n            maps.bumpMap = texture;\n            break;\n        }\n      }\n    }\n  }\n\n  parseAttributes(attributes, maps) {\n    const params = {};\n\n    if (attributes.Color && !maps.map) {\n      params.color = new Color().fromArray(attributes.Color.value);\n    } else {\n      params.color = new Color();\n    }\n\n    if (attributes.Transparency && attributes.Transparency.value !== 0) {\n      params.opacity = 1 - attributes.Transparency.value;\n      params.transparent = true;\n    }\n\n    if (attributes[\"Bump Height\"]) params.bumpScale = attributes[\"Bump Height\"].value * 0.1;\n    if (attributes[\"Refraction Index\"]) params.refractionRatio = 1 / attributes[\"Refraction Index\"].value;\n    this.parsePhysicalAttributes(params, attributes, maps);\n    this.parseStandardAttributes(params, attributes, maps);\n    this.parsePhongAttributes(params, attributes, maps);\n    return params;\n  }\n\n  parsePhysicalAttributes(params, attributes) {\n    if (attributes.Clearcoat && attributes.Clearcoat.value > 0) {\n      params.clearcoat = attributes.Clearcoat.value;\n\n      if (attributes[\"Clearcoat Gloss\"]) {\n        params.clearcoatRoughness = 0.5 * (1 - attributes[\"Clearcoat Gloss\"].value);\n      }\n    }\n  }\n\n  parseStandardAttributes(params, attributes, maps) {\n    if (attributes.Luminous) {\n      params.emissiveIntensity = attributes.Luminous.value;\n\n      if (attributes[\"Luminous Color\"] && !maps.emissive) {\n        params.emissive = new Color().fromArray(attributes[\"Luminous Color\"].value);\n      } else {\n        params.emissive = new Color(8421504);\n      }\n    }\n\n    if (attributes.Roughness && !maps.roughnessMap) params.roughness = attributes.Roughness.value;\n    if (attributes.Metallic && !maps.metalnessMap) params.metalness = attributes.Metallic.value;\n  }\n\n  parsePhongAttributes(params, attributes, maps) {\n    if (attributes.Diffuse) params.color.multiplyScalar(attributes.Diffuse.value);\n\n    if (attributes.Reflection) {\n      params.reflectivity = attributes.Reflection.value;\n      params.combine = AddOperation;\n    }\n\n    if (attributes.Luminosity) {\n      params.emissiveIntensity = attributes.Luminosity.value;\n\n      if (!maps.emissiveMap && !maps.map) {\n        params.emissive = params.color;\n      } else {\n        params.emissive = new Color(8421504);\n      }\n    }\n\n    if (!attributes.Roughness && attributes.Specular && !maps.specularMap) {\n      if (attributes[\"Color Highlight\"]) {\n        params.specular = new Color().setScalar(attributes.Specular.value).lerp(params.color.clone().multiplyScalar(attributes.Specular.value), attributes[\"Color Highlight\"].value);\n      } else {\n        params.specular = new Color().setScalar(attributes.Specular.value);\n      }\n    }\n\n    if (params.specular && attributes.Glossiness) {\n      params.shininess = 7 + Math.pow(2, attributes.Glossiness.value * 12 + 2);\n    }\n  }\n\n  parseEnvMap(connections, maps, attributes) {\n    if (connections.envMap) {\n      const envMap = this.loadTexture(connections.envMap);\n\n      if (attributes.transparent && attributes.opacity < 0.999) {\n        envMap.mapping = EquirectangularRefractionMapping;\n\n        if (attributes.reflectivity !== void 0) {\n          delete attributes.reflectivity;\n          delete attributes.combine;\n        }\n\n        if (attributes.metalness !== void 0) {\n          delete attributes.metalness;\n        }\n      } else {\n        envMap.mapping = EquirectangularReflectionMapping;\n      }\n\n      maps.envMap = envMap;\n    }\n  } // get texture defined at top level by its index\n\n\n  getTexturePathByIndex(index) {\n    let fileName = \"\";\n    if (!_lwoTree.textures) return fileName;\n\n    _lwoTree.textures.forEach(function (texture) {\n      if (texture.index === index) fileName = texture.fileName;\n    });\n\n    return fileName;\n  }\n\n  loadTexture(path) {\n    if (!path) return null;\n    const texture = this.textureLoader.load(path, void 0, void 0, function () {\n      console.warn(\"LWOLoader: non-standard resource hierarchy. Use `resourcePath` parameter to specify root content directory.\");\n    });\n    return texture;\n  } // 0 = Reset, 1 = Repeat, 2 = Mirror, 3 = Edge\n\n\n  getWrappingType(num) {\n    switch (num) {\n      case 0:\n        console.warn('LWOLoader: \"Reset\" texture wrapping type is not supported in three.js');\n        return ClampToEdgeWrapping;\n\n      case 1:\n        return RepeatWrapping;\n\n      case 2:\n        return MirroredRepeatWrapping;\n\n      case 3:\n        return ClampToEdgeWrapping;\n    }\n  }\n\n  getMaterialType(nodeData) {\n    if (nodeData.Clearcoat && nodeData.Clearcoat.value > 0) return MeshPhysicalMaterial;\n    if (nodeData.Roughness) return MeshStandardMaterial;\n    return MeshPhongMaterial;\n  }\n\n}\n\nclass GeometryParser {\n  parse(geoData, layer) {\n    const geometry = new BufferGeometry();\n    geometry.setAttribute(\"position\", new Float32BufferAttribute(geoData.points, 3));\n    const indices = this.splitIndices(geoData.vertexIndices, geoData.polygonDimensions);\n    geometry.setIndex(indices);\n    this.parseGroups(geometry, geoData);\n    geometry.computeVertexNormals();\n    this.parseUVs(geometry, layer, indices);\n    this.parseMorphTargets(geometry, layer, indices);\n    geometry.translate(-layer.pivot[0], -layer.pivot[1], -layer.pivot[2]);\n    return geometry;\n  } // split quads into tris\n\n\n  splitIndices(indices, polygonDimensions) {\n    const remappedIndices = [];\n    let i = 0;\n    polygonDimensions.forEach(function (dim) {\n      if (dim < 4) {\n        for (let k = 0; k < dim; k++) remappedIndices.push(indices[i + k]);\n      } else if (dim === 4) {\n        remappedIndices.push(indices[i], indices[i + 1], indices[i + 2], indices[i], indices[i + 2], indices[i + 3]);\n      } else if (dim > 4) {\n        for (let k = 1; k < dim - 1; k++) {\n          remappedIndices.push(indices[i], indices[i + k], indices[i + k + 1]);\n        }\n\n        console.warn(\"LWOLoader: polygons with greater than 4 sides are not supported\");\n      }\n\n      i += dim;\n    });\n    return remappedIndices;\n  } // NOTE: currently ignoring poly indices and assuming that they are intelligently ordered\n\n\n  parseGroups(geometry, geoData) {\n    const tags = _lwoTree.tags;\n    const matNames = [];\n    let elemSize = 3;\n    if (geoData.type === \"lines\") elemSize = 2;\n    if (geoData.type === \"points\") elemSize = 1;\n    const remappedIndices = this.splitMaterialIndices(geoData.polygonDimensions, geoData.materialIndices);\n    let indexNum = 0;\n    const indexPairs = {};\n    let prevMaterialIndex;\n    let materialIndex;\n    let prevStart = 0;\n    let currentCount = 0;\n\n    for (let i = 0; i < remappedIndices.length; i += 2) {\n      materialIndex = remappedIndices[i + 1];\n      if (i === 0) matNames[indexNum] = tags[materialIndex];\n      if (prevMaterialIndex === void 0) prevMaterialIndex = materialIndex;\n\n      if (materialIndex !== prevMaterialIndex) {\n        let currentIndex;\n\n        if (indexPairs[tags[prevMaterialIndex]]) {\n          currentIndex = indexPairs[tags[prevMaterialIndex]];\n        } else {\n          currentIndex = indexNum;\n          indexPairs[tags[prevMaterialIndex]] = indexNum;\n          matNames[indexNum] = tags[prevMaterialIndex];\n          indexNum++;\n        }\n\n        geometry.addGroup(prevStart, currentCount, currentIndex);\n        prevStart += currentCount;\n        prevMaterialIndex = materialIndex;\n        currentCount = 0;\n      }\n\n      currentCount += elemSize;\n    }\n\n    if (geometry.groups.length > 0) {\n      let currentIndex;\n\n      if (indexPairs[tags[materialIndex]]) {\n        currentIndex = indexPairs[tags[materialIndex]];\n      } else {\n        currentIndex = indexNum;\n        indexPairs[tags[materialIndex]] = indexNum;\n        matNames[indexNum] = tags[materialIndex];\n      }\n\n      geometry.addGroup(prevStart, currentCount, currentIndex);\n    }\n\n    geometry.userData.matNames = matNames;\n  }\n\n  splitMaterialIndices(polygonDimensions, indices) {\n    const remappedIndices = [];\n    polygonDimensions.forEach(function (dim, i) {\n      if (dim <= 3) {\n        remappedIndices.push(indices[i * 2], indices[i * 2 + 1]);\n      } else if (dim === 4) {\n        remappedIndices.push(indices[i * 2], indices[i * 2 + 1], indices[i * 2], indices[i * 2 + 1]);\n      } else {\n        for (let k = 0; k < dim - 2; k++) {\n          remappedIndices.push(indices[i * 2], indices[i * 2 + 1]);\n        }\n      }\n    });\n    return remappedIndices;\n  } // UV maps:\n  // 1: are defined via index into an array of points, not into a geometry\n  // - the geometry is also defined by an index into this array, but the indexes may not match\n  // 2: there can be any number of UV maps for a single geometry. Here these are combined,\n  // \twith preference given to the first map encountered\n  // 3: UV maps can be partial - that is, defined for only a part of the geometry\n  // 4: UV maps can be VMAP or VMAD (discontinuous, to allow for seams). In practice, most\n  // UV maps are defined as partially VMAP and partially VMAD\n  // VMADs are currently not supported\n\n\n  parseUVs(geometry, layer) {\n    const remappedUVs = Array.from(Array(geometry.attributes.position.count * 2), function () {\n      return 0;\n    });\n\n    for (const name in layer.uvs) {\n      const uvs = layer.uvs[name].uvs;\n      const uvIndices = layer.uvs[name].uvIndices;\n      uvIndices.forEach(function (i, j) {\n        remappedUVs[i * 2] = uvs[j * 2];\n        remappedUVs[i * 2 + 1] = uvs[j * 2 + 1];\n      });\n    }\n\n    geometry.setAttribute(\"uv\", new Float32BufferAttribute(remappedUVs, 2));\n  }\n\n  parseMorphTargets(geometry, layer) {\n    let num = 0;\n\n    for (const name in layer.morphTargets) {\n      const remappedPoints = geometry.attributes.position.array.slice();\n      if (!geometry.morphAttributes.position) geometry.morphAttributes.position = [];\n      const morphPoints = layer.morphTargets[name].points;\n      const morphIndices = layer.morphTargets[name].indices;\n      const type = layer.morphTargets[name].type;\n      morphIndices.forEach(function (i, j) {\n        if (type === \"relative\") {\n          remappedPoints[i * 3] += morphPoints[j * 3];\n          remappedPoints[i * 3 + 1] += morphPoints[j * 3 + 1];\n          remappedPoints[i * 3 + 2] += morphPoints[j * 3 + 2];\n        } else {\n          remappedPoints[i * 3] = morphPoints[j * 3];\n          remappedPoints[i * 3 + 1] = morphPoints[j * 3 + 1];\n          remappedPoints[i * 3 + 2] = morphPoints[j * 3 + 2];\n        }\n      });\n      geometry.morphAttributes.position[num] = new Float32BufferAttribute(remappedPoints, 3);\n      geometry.morphAttributes.position[num].name = name;\n      num++;\n    }\n\n    geometry.morphTargetsRelative = false;\n  }\n\n}\n\nfunction extractParentUrl(url, dir) {\n  const index = url.indexOf(dir);\n  if (index === -1) return \"./\";\n  return url.substr(0, index);\n}\n\nexport { LWOLoader };","map":{"version":3,"sources":["/Users/theodaguier/Developer/old/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/three-stdlib/loaders/LWOLoader.js"],"names":["Loader","FileLoader","TextureLoader","Points","LineSegments","Mesh","PointsMaterial","LineBasicMaterial","BufferAttribute","MeshPhongMaterial","BackSide","DoubleSide","FrontSide","Vector2","Color","AddOperation","EquirectangularRefractionMapping","EquirectangularReflectionMapping","ClampToEdgeWrapping","MirroredRepeatWrapping","RepeatWrapping","MeshPhysicalMaterial","MeshStandardMaterial","BufferGeometry","Float32BufferAttribute","IFFParser","_lwoTree","LWOLoader","constructor","manager","parameters","resourcePath","load","url","onLoad","onProgress","onError","scope","path","extractParentUrl","modelName","split","pop","loader","setPath","setResponseType","buffer","parse","e","console","error","itemError","iffBuffer","textureLoader","setCrossOrigin","crossOrigin","LWOTreeParser","materials","MaterialParser","defaultLayerName","meshes","parseLayers","finalMeshes","geometryParser","GeometryParser","layers","forEach","layer","geometry","mesh","parseMesh","number","parent","push","add","applyPivots","getMaterials","userData","matNames","type","duplicateUVs","name","pivot","traverse","child","position","x","y","z","parentPivot","namesArray","i","getMaterialByName","mat","spec","color","size","map","morphTargets","filtered","filter","Boolean","length","m","Array","isArray","aoMap","material","setAttribute","attributes","uv","array","textures","format","parseMaterial","parseMaterialLwo2","materialData","params","side","getSide","flatShading","getSmooth","connections","parseConnections","nodes","maps","parseTextureNodes","parseAttributeImageMaps","parseAttributes","parseEnvMap","Object","assign","materialType","getMaterialType","smooth","materialConnections","inputName","inputNodeName","nodeName","index","matNode","getNodeByRefName","envMap","fileName","refName","textureNodes","node","texture","loadTexture","widthWrappingMode","wrapS","getWrappingType","heightWrappingMode","wrapT","roughnessMap","roughness","specularMap","specular","emissiveMap","emissive","metalnessMap","metalness","alphaMap","transparent","normalMap","amplitude","normalScale","bumpMap","attribute","mapData","getTexturePathByIndex","imageIndex","wrap","w","h","fromArray","value","Transparency","opacity","bumpScale","refractionRatio","parsePhysicalAttributes","parseStandardAttributes","parsePhongAttributes","Clearcoat","clearcoat","clearcoatRoughness","Luminous","emissiveIntensity","Roughness","Metallic","Diffuse","multiplyScalar","Reflection","reflectivity","combine","Luminosity","Specular","setScalar","lerp","clone","Glossiness","shininess","Math","pow","mapping","warn","num","nodeData","geoData","points","indices","splitIndices","vertexIndices","polygonDimensions","setIndex","parseGroups","computeVertexNormals","parseUVs","parseMorphTargets","translate","remappedIndices","dim","k","tags","elemSize","splitMaterialIndices","materialIndices","indexNum","indexPairs","prevMaterialIndex","materialIndex","prevStart","currentCount","currentIndex","addGroup","groups","remappedUVs","from","count","uvs","uvIndices","j","remappedPoints","slice","morphAttributes","morphPoints","morphIndices","morphTargetsRelative","dir","indexOf","substr"],"mappings":"AAAA,SAASA,MAAT,EAAiBC,UAAjB,EAA6BC,aAA7B,EAA4CC,MAA5C,EAAoDC,YAApD,EAAkEC,IAAlE,EAAwEC,cAAxE,EAAwFC,iBAAxF,EAA2GC,eAA3G,EAA4HC,iBAA5H,EAA+IC,QAA/I,EAAyJC,UAAzJ,EAAqKC,SAArK,EAAgLC,OAAhL,EAAyLC,KAAzL,EAAgMC,YAAhM,EAA8MC,gCAA9M,EAAgPC,gCAAhP,EAAkRC,mBAAlR,EAAuSC,sBAAvS,EAA+TC,cAA/T,EAA+UC,oBAA/U,EAAqWC,oBAArW,EAA2XC,cAA3X,EAA2YC,sBAA3Y,QAAya,OAAza;AACA,SAASC,SAAT,QAA0B,oBAA1B;;AACA,IAAIC,QAAJ;;AACA,MAAMC,SAAN,SAAwB3B,MAAxB,CAA+B;AAC7B4B,EAAAA,WAAW,CAACC,OAAD,EAAUC,UAAU,GAAG,EAAvB,EAA2B;AACpC,UAAMD,OAAN;AACA,SAAKE,YAAL,GAAoBD,UAAU,CAACC,YAAX,KAA4B,KAAK,CAAjC,GAAqCD,UAAU,CAACC,YAAhD,GAA+D,EAAnF;AACD;;AACDC,EAAAA,IAAI,CAACC,GAAD,EAAMC,MAAN,EAAcC,UAAd,EAA0BC,OAA1B,EAAmC;AACrC,UAAMC,KAAK,GAAG,IAAd;AACA,UAAMC,IAAI,GAAGD,KAAK,CAACC,IAAN,KAAe,EAAf,GAAoBC,gBAAgB,CAACN,GAAD,EAAM,SAAN,CAApC,GAAuDI,KAAK,CAACC,IAA1E;AACA,UAAME,SAAS,GAAGP,GAAG,CAACQ,KAAJ,CAAUH,IAAV,EAAgBI,GAAhB,GAAsBD,KAAtB,CAA4B,GAA5B,EAAiC,CAAjC,CAAlB;AACA,UAAME,MAAM,GAAG,IAAI1C,UAAJ,CAAe,KAAK4B,OAApB,CAAf;AACAc,IAAAA,MAAM,CAACC,OAAP,CAAeP,KAAK,CAACC,IAArB;AACAK,IAAAA,MAAM,CAACE,eAAP,CAAuB,aAAvB;AACAF,IAAAA,MAAM,CAACX,IAAP,CACEC,GADF,EAEE,UAASa,MAAT,EAAiB;AACf,UAAI;AACFZ,QAAAA,MAAM,CAACG,KAAK,CAACU,KAAN,CAAYD,MAAZ,EAAoBR,IAApB,EAA0BE,SAA1B,CAAD,CAAN;AACD,OAFD,CAEE,OAAOQ,CAAP,EAAU;AACV,YAAIZ,OAAJ,EAAa;AACXA,UAAAA,OAAO,CAACY,CAAD,CAAP;AACD,SAFD,MAEO;AACLC,UAAAA,OAAO,CAACC,KAAR,CAAcF,CAAd;AACD;;AACDX,QAAAA,KAAK,CAACR,OAAN,CAAcsB,SAAd,CAAwBlB,GAAxB;AACD;AACF,KAbH,EAcEE,UAdF,EAeEC,OAfF;AAiBD;;AACDW,EAAAA,KAAK,CAACK,SAAD,EAAYd,IAAZ,EAAkBE,SAAlB,EAA6B;AAChCd,IAAAA,QAAQ,GAAG,IAAID,SAAJ,GAAgBsB,KAAhB,CAAsBK,SAAtB,CAAX;AACA,UAAMC,aAAa,GAAG,IAAInD,aAAJ,CAAkB,KAAK2B,OAAvB,EAAgCe,OAAhC,CAAwC,KAAKb,YAAL,IAAqBO,IAA7D,EAAmEgB,cAAnE,CAAkF,KAAKC,WAAvF,CAAtB;AACA,WAAO,IAAIC,aAAJ,CAAkBH,aAAlB,EAAiCN,KAAjC,CAAuCP,SAAvC,CAAP;AACD;;AAlC4B;;AAoC/B,MAAMgB,aAAN,CAAoB;AAClB5B,EAAAA,WAAW,CAACyB,aAAD,EAAgB;AACzB,SAAKA,aAAL,GAAqBA,aAArB;AACD;;AACDN,EAAAA,KAAK,CAACP,SAAD,EAAY;AACf,SAAKiB,SAAL,GAAiB,IAAIC,cAAJ,CAAmB,KAAKL,aAAxB,EAAuCN,KAAvC,EAAjB;AACA,SAAKY,gBAAL,GAAwBnB,SAAxB;AACA,SAAKoB,MAAL,GAAc,KAAKC,WAAL,EAAd;AACA,WAAO;AACLJ,MAAAA,SAAS,EAAE,KAAKA,SADX;AAELG,MAAAA,MAAM,EAAE,KAAKA;AAFR,KAAP;AAID;;AACDC,EAAAA,WAAW,GAAG;AACZ,UAAMD,MAAM,GAAG,EAAf;AACA,UAAME,WAAW,GAAG,EAApB;AACA,UAAMC,cAAc,GAAG,IAAIC,cAAJ,EAAvB;AACA,UAAM3B,KAAK,GAAG,IAAd;;AACAX,IAAAA,QAAQ,CAACuC,MAAT,CAAgBC,OAAhB,CAAwB,UAASC,KAAT,EAAgB;AACtC,YAAMC,QAAQ,GAAGL,cAAc,CAAChB,KAAf,CAAqBoB,KAAK,CAACC,QAA3B,EAAqCD,KAArC,CAAjB;AACA,YAAME,IAAI,GAAGhC,KAAK,CAACiC,SAAN,CAAgBF,QAAhB,EAA0BD,KAA1B,CAAb;AACAP,MAAAA,MAAM,CAACO,KAAK,CAACI,MAAP,CAAN,GAAuBF,IAAvB;AACA,UAAIF,KAAK,CAACK,MAAN,KAAiB,CAAC,CAAtB,EACEV,WAAW,CAACW,IAAZ,CAAiBJ,IAAjB,EADF,KAGET,MAAM,CAACO,KAAK,CAACK,MAAP,CAAN,CAAqBE,GAArB,CAAyBL,IAAzB;AACH,KARD;;AASA,SAAKM,WAAL,CAAiBb,WAAjB;AACA,WAAOA,WAAP;AACD;;AACDQ,EAAAA,SAAS,CAACF,QAAD,EAAWD,KAAX,EAAkB;AACzB,QAAIE,IAAJ;AACA,UAAMZ,SAAS,GAAG,KAAKmB,YAAL,CAAkBR,QAAQ,CAACS,QAAT,CAAkBC,QAApC,EAA8CX,KAAK,CAACC,QAAN,CAAeW,IAA7D,CAAlB;AACA,SAAKC,YAAL,CAAkBZ,QAAlB,EAA4BX,SAA5B;AACA,QAAIU,KAAK,CAACC,QAAN,CAAeW,IAAf,KAAwB,QAA5B,EACEV,IAAI,GAAG,IAAIlE,MAAJ,CAAWiE,QAAX,EAAqBX,SAArB,CAAP,CADF,KAEK,IAAIU,KAAK,CAACC,QAAN,CAAeW,IAAf,KAAwB,OAA5B,EACHV,IAAI,GAAG,IAAIjE,YAAJ,CAAiBgE,QAAjB,EAA2BX,SAA3B,CAAP,CADG,KAGHY,IAAI,GAAG,IAAIhE,IAAJ,CAAS+D,QAAT,EAAmBX,SAAnB,CAAP;AACF,QAAIU,KAAK,CAACc,IAAV,EACEZ,IAAI,CAACY,IAAL,GAAYd,KAAK,CAACc,IAAlB,CADF,KAGEZ,IAAI,CAACY,IAAL,GAAY,KAAKtB,gBAAL,GAAwB,SAAxB,GAAoCQ,KAAK,CAACI,MAAtD;AACFF,IAAAA,IAAI,CAACQ,QAAL,CAAcK,KAAd,GAAsBf,KAAK,CAACe,KAA5B;AACA,WAAOb,IAAP;AACD,GA9CiB,CA+ClB;;;AACAM,EAAAA,WAAW,CAACf,MAAD,EAAS;AAClBA,IAAAA,MAAM,CAACM,OAAP,CAAe,UAASG,IAAT,EAAe;AAC5BA,MAAAA,IAAI,CAACc,QAAL,CAAc,UAASC,KAAT,EAAgB;AAC5B,cAAMF,KAAK,GAAGE,KAAK,CAACP,QAAN,CAAeK,KAA7B;AACAE,QAAAA,KAAK,CAACC,QAAN,CAAeC,CAAf,IAAoBJ,KAAK,CAAC,CAAD,CAAzB;AACAE,QAAAA,KAAK,CAACC,QAAN,CAAeE,CAAf,IAAoBL,KAAK,CAAC,CAAD,CAAzB;AACAE,QAAAA,KAAK,CAACC,QAAN,CAAeG,CAAf,IAAoBN,KAAK,CAAC,CAAD,CAAzB;;AACA,YAAIE,KAAK,CAACZ,MAAV,EAAkB;AAChB,gBAAMiB,WAAW,GAAGL,KAAK,CAACZ,MAAN,CAAaK,QAAb,CAAsBK,KAA1C;AACAE,UAAAA,KAAK,CAACC,QAAN,CAAeC,CAAf,IAAoBG,WAAW,CAAC,CAAD,CAA/B;AACAL,UAAAA,KAAK,CAACC,QAAN,CAAeE,CAAf,IAAoBE,WAAW,CAAC,CAAD,CAA/B;AACAL,UAAAA,KAAK,CAACC,QAAN,CAAeG,CAAf,IAAoBC,WAAW,CAAC,CAAD,CAA/B;AACD;AACF,OAXD;AAYD,KAbD;AAcD;;AACDb,EAAAA,YAAY,CAACc,UAAD,EAAaX,IAAb,EAAmB;AAC7B,UAAMtB,SAAS,GAAG,EAAlB;AACA,UAAMpB,KAAK,GAAG,IAAd;AACAqD,IAAAA,UAAU,CAACxB,OAAX,CAAmB,UAASe,IAAT,EAAeU,CAAf,EAAkB;AACnClC,MAAAA,SAAS,CAACkC,CAAD,CAAT,GAAetD,KAAK,CAACuD,iBAAN,CAAwBX,IAAxB,CAAf;AACD,KAFD;;AAGA,QAAIF,IAAI,KAAK,QAAT,IAAqBA,IAAI,KAAK,OAAlC,EAA2C;AACzCtB,MAAAA,SAAS,CAACS,OAAV,CAAkB,UAAS2B,GAAT,EAAcF,CAAd,EAAiB;AACjC,cAAMG,IAAI,GAAG;AACXC,UAAAA,KAAK,EAAEF,GAAG,CAACE;AADA,SAAb;;AAGA,YAAIhB,IAAI,KAAK,QAAb,EAAuB;AACrBe,UAAAA,IAAI,CAACE,IAAL,GAAY,GAAZ;AACAF,UAAAA,IAAI,CAACG,GAAL,GAAWJ,GAAG,CAACI,GAAf;AACAH,UAAAA,IAAI,CAACI,YAAL,GAAoBL,GAAG,CAACK,YAAxB;AACAzC,UAAAA,SAAS,CAACkC,CAAD,CAAT,GAAe,IAAIrF,cAAJ,CAAmBwF,IAAnB,CAAf;AACD,SALD,MAKO,IAAIf,IAAI,KAAK,OAAb,EAAsB;AAC3BtB,UAAAA,SAAS,CAACkC,CAAD,CAAT,GAAe,IAAIpF,iBAAJ,CAAsBuF,IAAtB,CAAf;AACD;AACF,OAZD;AAaD;;AACD,UAAMK,QAAQ,GAAG1C,SAAS,CAAC2C,MAAV,CAAiBC,OAAjB,CAAjB;AACA,QAAIF,QAAQ,CAACG,MAAT,KAAoB,CAAxB,EACE,OAAOH,QAAQ,CAAC,CAAD,CAAf;AACF,WAAO1C,SAAP;AACD;;AACDmC,EAAAA,iBAAiB,CAACX,IAAD,EAAO;AACtB,WAAO,KAAKxB,SAAL,CAAe2C,MAAf,CAAsB,UAASG,CAAT,EAAY;AACvC,aAAOA,CAAC,CAACtB,IAAF,KAAWA,IAAlB;AACD,KAFM,EAEJ,CAFI,CAAP;AAGD,GA9FiB,CA+FlB;;;AACAD,EAAAA,YAAY,CAACZ,QAAD,EAAWX,SAAX,EAAsB;AAChC,QAAIuB,YAAY,GAAG,KAAnB;;AACA,QAAI,CAACwB,KAAK,CAACC,OAAN,CAAchD,SAAd,CAAL,EAA+B;AAC7B,UAAIA,SAAS,CAACiD,KAAd,EACE1B,YAAY,GAAG,IAAf;AACH,KAHD,MAGO;AACLvB,MAAAA,SAAS,CAACS,OAAV,CAAkB,UAASyC,QAAT,EAAmB;AACnC,YAAIA,QAAQ,CAACD,KAAb,EACE1B,YAAY,GAAG,IAAf;AACH,OAHD;AAID;;AACD,QAAI,CAACA,YAAL,EACE;AACFZ,IAAAA,QAAQ,CAACwC,YAAT,CAAsB,KAAtB,EAA6B,IAAIpG,eAAJ,CAAoB4D,QAAQ,CAACyC,UAAT,CAAoBC,EAApB,CAAuBC,KAA3C,EAAkD,CAAlD,CAA7B;AACD;;AA9GiB;;AAgHpB,MAAMrD,cAAN,CAAqB;AACnB9B,EAAAA,WAAW,CAACyB,aAAD,EAAgB;AACzB,SAAKA,aAAL,GAAqBA,aAArB;AACD;;AACDN,EAAAA,KAAK,GAAG;AACN,UAAMU,SAAS,GAAG,EAAlB;AACA,SAAKuD,QAAL,GAAgB,EAAhB;;AACA,SAAK,MAAM/B,IAAX,IAAmBvD,QAAQ,CAAC+B,SAA5B,EAAuC;AACrC,UAAI/B,QAAQ,CAACuF,MAAT,KAAoB,MAAxB,EAAgC;AAC9BxD,QAAAA,SAAS,CAACgB,IAAV,CAAe,KAAKyC,aAAL,CAAmBxF,QAAQ,CAAC+B,SAAT,CAAmBwB,IAAnB,CAAnB,EAA6CA,IAA7C,EAAmDvD,QAAQ,CAACsF,QAA5D,CAAf;AACD,OAFD,MAEO,IAAItF,QAAQ,CAACuF,MAAT,KAAoB,MAAxB,EAAgC;AACrCxD,QAAAA,SAAS,CAACgB,IAAV,CAAe,KAAK0C,iBAAL,CAAuBzF,QAAQ,CAAC+B,SAAT,CAAmBwB,IAAnB,CAAvB,EAAiDA,IAAjD,EAAuDvD,QAAQ,CAACsF,QAAhE,CAAf;AACD;AACF;;AACD,WAAOvD,SAAP;AACD;;AACDyD,EAAAA,aAAa,CAACE,YAAD,EAAenC,IAAf,EAAqB+B,QAArB,EAA+B;AAC1C,QAAIK,MAAM,GAAG;AACXpC,MAAAA,IADW;AAEXqC,MAAAA,IAAI,EAAE,KAAKC,OAAL,CAAaH,YAAY,CAACP,UAA1B,CAFK;AAGXW,MAAAA,WAAW,EAAE,KAAKC,SAAL,CAAeL,YAAY,CAACP,UAA5B;AAHF,KAAb;AAKA,UAAMa,WAAW,GAAG,KAAKC,gBAAL,CAAsBP,YAAY,CAACM,WAAnC,EAAgDN,YAAY,CAACQ,KAA7D,CAApB;AACA,UAAMC,IAAI,GAAG,KAAKC,iBAAL,CAAuBJ,WAAW,CAACG,IAAnC,CAAb;AACA,SAAKE,uBAAL,CAA6BL,WAAW,CAACb,UAAzC,EAAqDG,QAArD,EAA+Da,IAA/D,EAAqET,YAAY,CAACS,IAAlF;AACA,UAAMhB,UAAU,GAAG,KAAKmB,eAAL,CAAqBN,WAAW,CAACb,UAAjC,EAA6CgB,IAA7C,CAAnB;AACA,SAAKI,WAAL,CAAiBP,WAAjB,EAA8BG,IAA9B,EAAoChB,UAApC;AACAQ,IAAAA,MAAM,GAAGa,MAAM,CAACC,MAAP,CAAcN,IAAd,EAAoBR,MAApB,CAAT;AACAA,IAAAA,MAAM,GAAGa,MAAM,CAACC,MAAP,CAAcd,MAAd,EAAsBR,UAAtB,CAAT;AACA,UAAMuB,YAAY,GAAG,KAAKC,eAAL,CAAqBX,WAAW,CAACb,UAAjC,CAArB;AACA,WAAO,IAAIuB,YAAJ,CAAiBf,MAAjB,CAAP;AACD;;AACDF,EAAAA,iBAAiB,CAACC,YAAD,EAAenC,IAAf,EAAqB;AACpC,QAAIoC,MAAM,GAAG;AACXpC,MAAAA,IADW;AAEXqC,MAAAA,IAAI,EAAE,KAAKC,OAAL,CAAaH,YAAY,CAACP,UAA1B,CAFK;AAGXW,MAAAA,WAAW,EAAE,KAAKC,SAAL,CAAeL,YAAY,CAACP,UAA5B;AAHF,KAAb;AAKA,UAAMA,UAAU,GAAG,KAAKmB,eAAL,CAAqBZ,YAAY,CAACP,UAAlC,EAA8C,EAA9C,CAAnB;AACAQ,IAAAA,MAAM,GAAGa,MAAM,CAACC,MAAP,CAAcd,MAAd,EAAsBR,UAAtB,CAAT;AACA,WAAO,IAAIpG,iBAAJ,CAAsB4G,MAAtB,CAAP;AACD,GAzCkB,CA0CnB;AACA;AACA;;;AACAE,EAAAA,OAAO,CAACV,UAAD,EAAa;AAClB,QAAI,CAACA,UAAU,CAACS,IAAhB,EACE,OAAO5G,QAAP;;AACF,YAAQmG,UAAU,CAACS,IAAnB;AACE,WAAK,CAAL;AACA,WAAK,CAAL;AACE,eAAO5G,QAAP;;AACF,WAAK,CAAL;AACE,eAAOE,SAAP;;AACF,WAAK,CAAL;AACE,eAAOD,UAAP;AAPJ;AASD;;AACD8G,EAAAA,SAAS,CAACZ,UAAD,EAAa;AACpB,QAAI,CAACA,UAAU,CAACyB,MAAhB,EACE,OAAO,IAAP;AACF,WAAO,CAACzB,UAAU,CAACyB,MAAnB;AACD;;AACDX,EAAAA,gBAAgB,CAACD,WAAD,EAAcE,KAAd,EAAqB;AACnC,UAAMW,mBAAmB,GAAG;AAC1BV,MAAAA,IAAI,EAAE;AADoB,KAA5B;AAGA,UAAMW,SAAS,GAAGd,WAAW,CAACc,SAA9B;AACA,UAAMC,aAAa,GAAGf,WAAW,CAACe,aAAlC;AACA,UAAMC,QAAQ,GAAGhB,WAAW,CAACgB,QAA7B;AACA,UAAMrG,KAAK,GAAG,IAAd;AACAmG,IAAAA,SAAS,CAACtE,OAAV,CAAkB,UAASe,IAAT,EAAe0D,KAAf,EAAsB;AACtC,UAAI1D,IAAI,KAAK,UAAb,EAAyB;AACvB,cAAM2D,OAAO,GAAGvG,KAAK,CAACwG,gBAAN,CAAuBJ,aAAa,CAACE,KAAD,CAApC,EAA6Cf,KAA7C,CAAhB;AACAW,QAAAA,mBAAmB,CAAC1B,UAApB,GAAiC+B,OAAO,CAAC/B,UAAzC;AACA0B,QAAAA,mBAAmB,CAACO,MAApB,GAA6BF,OAAO,CAACG,QAArC;AACAR,QAAAA,mBAAmB,CAACtD,IAApB,GAA2BwD,aAAa,CAACE,KAAD,CAAxC;AACD;AACF,KAPD;AAQAD,IAAAA,QAAQ,CAACxE,OAAT,CAAiB,UAASe,IAAT,EAAe0D,KAAf,EAAsB;AACrC,UAAI1D,IAAI,KAAKsD,mBAAmB,CAACtD,IAAjC,EAAuC;AACrCsD,QAAAA,mBAAmB,CAACV,IAApB,CAAyBW,SAAS,CAACG,KAAD,CAAlC,IAA6CtG,KAAK,CAACwG,gBAAN,CAAuBJ,aAAa,CAACE,KAAD,CAApC,EAA6Cf,KAA7C,CAA7C;AACD;AACF,KAJD;AAKA,WAAOW,mBAAP;AACD;;AACDM,EAAAA,gBAAgB,CAACG,OAAD,EAAUpB,KAAV,EAAiB;AAC/B,SAAK,MAAM3C,IAAX,IAAmB2C,KAAnB,EAA0B;AACxB,UAAIA,KAAK,CAAC3C,IAAD,CAAL,CAAY+D,OAAZ,KAAwBA,OAA5B,EACE,OAAOpB,KAAK,CAAC3C,IAAD,CAAZ;AACH;AACF;;AACD6C,EAAAA,iBAAiB,CAACmB,YAAD,EAAe;AAC9B,UAAMpB,IAAI,GAAG,EAAb;;AACA,SAAK,MAAM5C,IAAX,IAAmBgE,YAAnB,EAAiC;AAC/B,YAAMC,IAAI,GAAGD,YAAY,CAAChE,IAAD,CAAzB;AACA,YAAM3C,IAAI,GAAG4G,IAAI,CAACH,QAAlB;AACA,UAAI,CAACzG,IAAL,EACE;AACF,YAAM6G,OAAO,GAAG,KAAKC,WAAL,CAAiB9G,IAAjB,CAAhB;AACA,UAAI4G,IAAI,CAACG,iBAAL,KAA2B,KAAK,CAApC,EACEF,OAAO,CAACG,KAAR,GAAgB,KAAKC,eAAL,CAAqBL,IAAI,CAACG,iBAA1B,CAAhB;AACF,UAAIH,IAAI,CAACM,kBAAL,KAA4B,KAAK,CAArC,EACEL,OAAO,CAACM,KAAR,GAAgB,KAAKF,eAAL,CAAqBL,IAAI,CAACM,kBAA1B,CAAhB;;AACF,cAAQvE,IAAR;AACE,aAAK,OAAL;AACE4C,UAAAA,IAAI,CAAC5B,GAAL,GAAWkD,OAAX;AACA;;AACF,aAAK,WAAL;AACEtB,UAAAA,IAAI,CAAC6B,YAAL,GAAoBP,OAApB;AACAtB,UAAAA,IAAI,CAAC8B,SAAL,GAAiB,GAAjB;AACA;;AACF,aAAK,UAAL;AACE9B,UAAAA,IAAI,CAAC+B,WAAL,GAAmBT,OAAnB;AACAtB,UAAAA,IAAI,CAACgC,QAAL,GAAgB,QAAhB;AACA;;AACF,aAAK,UAAL;AACEhC,UAAAA,IAAI,CAACiC,WAAL,GAAmBX,OAAnB;AACAtB,UAAAA,IAAI,CAACkC,QAAL,GAAgB,OAAhB;AACA;;AACF,aAAK,gBAAL;AACElC,UAAAA,IAAI,CAACkC,QAAL,GAAgB,OAAhB;AACA;;AACF,aAAK,UAAL;AACElC,UAAAA,IAAI,CAACmC,YAAL,GAAoBb,OAApB;AACAtB,UAAAA,IAAI,CAACoC,SAAL,GAAiB,GAAjB;AACA;;AACF,aAAK,cAAL;AACA,aAAK,OAAL;AACEpC,UAAAA,IAAI,CAACqC,QAAL,GAAgBf,OAAhB;AACAtB,UAAAA,IAAI,CAACsC,WAAL,GAAmB,IAAnB;AACA;;AACF,aAAK,QAAL;AACEtC,UAAAA,IAAI,CAACuC,SAAL,GAAiBjB,OAAjB;AACA,cAAID,IAAI,CAACmB,SAAL,KAAmB,KAAK,CAA5B,EACExC,IAAI,CAACyC,WAAL,GAAmB,IAAIzJ,OAAJ,CAAYqI,IAAI,CAACmB,SAAjB,EAA4BnB,IAAI,CAACmB,SAAjC,CAAnB;AACF;;AACF,aAAK,MAAL;AACExC,UAAAA,IAAI,CAAC0C,OAAL,GAAepB,OAAf;AACA;AAnCJ;AAqCD;;AACD,QAAItB,IAAI,CAAC6B,YAAL,IAAqB7B,IAAI,CAAC+B,WAA9B,EACE,OAAO/B,IAAI,CAAC+B,WAAZ;AACF,WAAO/B,IAAP;AACD,GAjJkB,CAkJnB;AACA;;;AACAE,EAAAA,uBAAuB,CAAClB,UAAD,EAAaG,QAAb,EAAuBa,IAAvB,EAA6B;AAClD,SAAK,MAAM5C,IAAX,IAAmB4B,UAAnB,EAA+B;AAC7B,YAAM2D,SAAS,GAAG3D,UAAU,CAAC5B,IAAD,CAA5B;;AACA,UAAIuF,SAAS,CAAC3C,IAAd,EAAoB;AAClB,cAAM4C,OAAO,GAAGD,SAAS,CAAC3C,IAAV,CAAe,CAAf,CAAhB;AACA,cAAMvF,IAAI,GAAG,KAAKoI,qBAAL,CAA2BD,OAAO,CAACE,UAAnC,EAA+C3D,QAA/C,CAAb;AACA,YAAI,CAAC1E,IAAL,EACE;AACF,cAAM6G,OAAO,GAAG,KAAKC,WAAL,CAAiB9G,IAAjB,CAAhB;AACA,YAAImI,OAAO,CAACG,IAAR,KAAiB,KAAK,CAA1B,EACEzB,OAAO,CAACG,KAAR,GAAgB,KAAKC,eAAL,CAAqBkB,OAAO,CAACG,IAAR,CAAaC,CAAlC,CAAhB;AACF,YAAIJ,OAAO,CAACG,IAAR,KAAiB,KAAK,CAA1B,EACEzB,OAAO,CAACM,KAAR,GAAgB,KAAKF,eAAL,CAAqBkB,OAAO,CAACG,IAAR,CAAaE,CAAlC,CAAhB;;AACF,gBAAQ7F,IAAR;AACE,eAAK,OAAL;AACE4C,YAAAA,IAAI,CAAC5B,GAAL,GAAWkD,OAAX;AACA;;AACF,eAAK,SAAL;AACEtB,YAAAA,IAAI,CAACnB,KAAL,GAAayC,OAAb;AACA;;AACF,eAAK,WAAL;AACEtB,YAAAA,IAAI,CAAC6B,YAAL,GAAoBP,OAApB;AACAtB,YAAAA,IAAI,CAAC8B,SAAL,GAAiB,CAAjB;AACA;;AACF,eAAK,UAAL;AACE9B,YAAAA,IAAI,CAAC+B,WAAL,GAAmBT,OAAnB;AACAtB,YAAAA,IAAI,CAACgC,QAAL,GAAgB,QAAhB;AACA;;AACF,eAAK,YAAL;AACEhC,YAAAA,IAAI,CAACiC,WAAL,GAAmBX,OAAnB;AACAtB,YAAAA,IAAI,CAACkC,QAAL,GAAgB,OAAhB;AACA;;AACF,eAAK,UAAL;AACElC,YAAAA,IAAI,CAACmC,YAAL,GAAoBb,OAApB;AACAtB,YAAAA,IAAI,CAACoC,SAAL,GAAiB,CAAjB;AACA;;AACF,eAAK,cAAL;AACA,eAAK,OAAL;AACEpC,YAAAA,IAAI,CAACqC,QAAL,GAAgBf,OAAhB;AACAtB,YAAAA,IAAI,CAACsC,WAAL,GAAmB,IAAnB;AACA;;AACF,eAAK,QAAL;AACEtC,YAAAA,IAAI,CAACuC,SAAL,GAAiBjB,OAAjB;AACA;;AACF,eAAK,MAAL;AACEtB,YAAAA,IAAI,CAAC0C,OAAL,GAAepB,OAAf;AACA;AAjCJ;AAmCD;AACF;AACF;;AACDnB,EAAAA,eAAe,CAACnB,UAAD,EAAagB,IAAb,EAAmB;AAChC,UAAMR,MAAM,GAAG,EAAf;;AACA,QAAIR,UAAU,CAAC/F,KAAX,IAAoB,CAAC+G,IAAI,CAAC5B,GAA9B,EAAmC;AACjCoB,MAAAA,MAAM,CAACtB,KAAP,GAAe,IAAIjF,KAAJ,GAAYiK,SAAZ,CAAsBlE,UAAU,CAAC/F,KAAX,CAAiBkK,KAAvC,CAAf;AACD,KAFD,MAEO;AACL3D,MAAAA,MAAM,CAACtB,KAAP,GAAe,IAAIjF,KAAJ,EAAf;AACD;;AACD,QAAI+F,UAAU,CAACoE,YAAX,IAA2BpE,UAAU,CAACoE,YAAX,CAAwBD,KAAxB,KAAkC,CAAjE,EAAoE;AAClE3D,MAAAA,MAAM,CAAC6D,OAAP,GAAiB,IAAIrE,UAAU,CAACoE,YAAX,CAAwBD,KAA7C;AACA3D,MAAAA,MAAM,CAAC8C,WAAP,GAAqB,IAArB;AACD;;AACD,QAAItD,UAAU,CAAC,aAAD,CAAd,EACEQ,MAAM,CAAC8D,SAAP,GAAmBtE,UAAU,CAAC,aAAD,CAAV,CAA0BmE,KAA1B,GAAkC,GAArD;AACF,QAAInE,UAAU,CAAC,kBAAD,CAAd,EACEQ,MAAM,CAAC+D,eAAP,GAAyB,IAAIvE,UAAU,CAAC,kBAAD,CAAV,CAA+BmE,KAA5D;AACF,SAAKK,uBAAL,CAA6BhE,MAA7B,EAAqCR,UAArC,EAAiDgB,IAAjD;AACA,SAAKyD,uBAAL,CAA6BjE,MAA7B,EAAqCR,UAArC,EAAiDgB,IAAjD;AACA,SAAK0D,oBAAL,CAA0BlE,MAA1B,EAAkCR,UAAlC,EAA8CgB,IAA9C;AACA,WAAOR,MAAP;AACD;;AACDgE,EAAAA,uBAAuB,CAAChE,MAAD,EAASR,UAAT,EAAqB;AAC1C,QAAIA,UAAU,CAAC2E,SAAX,IAAwB3E,UAAU,CAAC2E,SAAX,CAAqBR,KAArB,GAA6B,CAAzD,EAA4D;AAC1D3D,MAAAA,MAAM,CAACoE,SAAP,GAAmB5E,UAAU,CAAC2E,SAAX,CAAqBR,KAAxC;;AACA,UAAInE,UAAU,CAAC,iBAAD,CAAd,EAAmC;AACjCQ,QAAAA,MAAM,CAACqE,kBAAP,GAA4B,OAAO,IAAI7E,UAAU,CAAC,iBAAD,CAAV,CAA8BmE,KAAzC,CAA5B;AACD;AACF;AACF;;AACDM,EAAAA,uBAAuB,CAACjE,MAAD,EAASR,UAAT,EAAqBgB,IAArB,EAA2B;AAChD,QAAIhB,UAAU,CAAC8E,QAAf,EAAyB;AACvBtE,MAAAA,MAAM,CAACuE,iBAAP,GAA2B/E,UAAU,CAAC8E,QAAX,CAAoBX,KAA/C;;AACA,UAAInE,UAAU,CAAC,gBAAD,CAAV,IAAgC,CAACgB,IAAI,CAACkC,QAA1C,EAAoD;AAClD1C,QAAAA,MAAM,CAAC0C,QAAP,GAAkB,IAAIjJ,KAAJ,GAAYiK,SAAZ,CAAsBlE,UAAU,CAAC,gBAAD,CAAV,CAA6BmE,KAAnD,CAAlB;AACD,OAFD,MAEO;AACL3D,QAAAA,MAAM,CAAC0C,QAAP,GAAkB,IAAIjJ,KAAJ,CAAU,OAAV,CAAlB;AACD;AACF;;AACD,QAAI+F,UAAU,CAACgF,SAAX,IAAwB,CAAChE,IAAI,CAAC6B,YAAlC,EACErC,MAAM,CAACsC,SAAP,GAAmB9C,UAAU,CAACgF,SAAX,CAAqBb,KAAxC;AACF,QAAInE,UAAU,CAACiF,QAAX,IAAuB,CAACjE,IAAI,CAACmC,YAAjC,EACE3C,MAAM,CAAC4C,SAAP,GAAmBpD,UAAU,CAACiF,QAAX,CAAoBd,KAAvC;AACH;;AACDO,EAAAA,oBAAoB,CAAClE,MAAD,EAASR,UAAT,EAAqBgB,IAArB,EAA2B;AAC7C,QAAIhB,UAAU,CAACkF,OAAf,EACE1E,MAAM,CAACtB,KAAP,CAAaiG,cAAb,CAA4BnF,UAAU,CAACkF,OAAX,CAAmBf,KAA/C;;AACF,QAAInE,UAAU,CAACoF,UAAf,EAA2B;AACzB5E,MAAAA,MAAM,CAAC6E,YAAP,GAAsBrF,UAAU,CAACoF,UAAX,CAAsBjB,KAA5C;AACA3D,MAAAA,MAAM,CAAC8E,OAAP,GAAiBpL,YAAjB;AACD;;AACD,QAAI8F,UAAU,CAACuF,UAAf,EAA2B;AACzB/E,MAAAA,MAAM,CAACuE,iBAAP,GAA2B/E,UAAU,CAACuF,UAAX,CAAsBpB,KAAjD;;AACA,UAAI,CAACnD,IAAI,CAACiC,WAAN,IAAqB,CAACjC,IAAI,CAAC5B,GAA/B,EAAoC;AAClCoB,QAAAA,MAAM,CAAC0C,QAAP,GAAkB1C,MAAM,CAACtB,KAAzB;AACD,OAFD,MAEO;AACLsB,QAAAA,MAAM,CAAC0C,QAAP,GAAkB,IAAIjJ,KAAJ,CAAU,OAAV,CAAlB;AACD;AACF;;AACD,QAAI,CAAC+F,UAAU,CAACgF,SAAZ,IAAyBhF,UAAU,CAACwF,QAApC,IAAgD,CAACxE,IAAI,CAAC+B,WAA1D,EAAuE;AACrE,UAAI/C,UAAU,CAAC,iBAAD,CAAd,EAAmC;AACjCQ,QAAAA,MAAM,CAACwC,QAAP,GAAkB,IAAI/I,KAAJ,GAAYwL,SAAZ,CAAsBzF,UAAU,CAACwF,QAAX,CAAoBrB,KAA1C,EAAiDuB,IAAjD,CAAsDlF,MAAM,CAACtB,KAAP,CAAayG,KAAb,GAAqBR,cAArB,CAAoCnF,UAAU,CAACwF,QAAX,CAAoBrB,KAAxD,CAAtD,EAAsHnE,UAAU,CAAC,iBAAD,CAAV,CAA8BmE,KAApJ,CAAlB;AACD,OAFD,MAEO;AACL3D,QAAAA,MAAM,CAACwC,QAAP,GAAkB,IAAI/I,KAAJ,GAAYwL,SAAZ,CAAsBzF,UAAU,CAACwF,QAAX,CAAoBrB,KAA1C,CAAlB;AACD;AACF;;AACD,QAAI3D,MAAM,CAACwC,QAAP,IAAmBhD,UAAU,CAAC4F,UAAlC,EAA8C;AAC5CpF,MAAAA,MAAM,CAACqF,SAAP,GAAmB,IAAIC,IAAI,CAACC,GAAL,CAAS,CAAT,EAAY/F,UAAU,CAAC4F,UAAX,CAAsBzB,KAAtB,GAA8B,EAA9B,GAAmC,CAA/C,CAAvB;AACD;AACF;;AACD/C,EAAAA,WAAW,CAACP,WAAD,EAAcG,IAAd,EAAoBhB,UAApB,EAAgC;AACzC,QAAIa,WAAW,CAACoB,MAAhB,EAAwB;AACtB,YAAMA,MAAM,GAAG,KAAKM,WAAL,CAAiB1B,WAAW,CAACoB,MAA7B,CAAf;;AACA,UAAIjC,UAAU,CAACsD,WAAX,IAA0BtD,UAAU,CAACqE,OAAX,GAAqB,KAAnD,EAA0D;AACxDpC,QAAAA,MAAM,CAAC+D,OAAP,GAAiB7L,gCAAjB;;AACA,YAAI6F,UAAU,CAACqF,YAAX,KAA4B,KAAK,CAArC,EAAwC;AACtC,iBAAOrF,UAAU,CAACqF,YAAlB;AACA,iBAAOrF,UAAU,CAACsF,OAAlB;AACD;;AACD,YAAItF,UAAU,CAACoD,SAAX,KAAyB,KAAK,CAAlC,EAAqC;AACnC,iBAAOpD,UAAU,CAACoD,SAAlB;AACD;AACF,OATD,MASO;AACLnB,QAAAA,MAAM,CAAC+D,OAAP,GAAiB5L,gCAAjB;AACD;;AACD4G,MAAAA,IAAI,CAACiB,MAAL,GAAcA,MAAd;AACD;AACF,GA5RkB,CA6RnB;;;AACA4B,EAAAA,qBAAqB,CAAC/B,KAAD,EAAQ;AAC3B,QAAII,QAAQ,GAAG,EAAf;AACA,QAAI,CAACrH,QAAQ,CAACsF,QAAd,EACE,OAAO+B,QAAP;;AACFrH,IAAAA,QAAQ,CAACsF,QAAT,CAAkB9C,OAAlB,CAA0B,UAASiF,OAAT,EAAkB;AAC1C,UAAIA,OAAO,CAACR,KAAR,KAAkBA,KAAtB,EACEI,QAAQ,GAAGI,OAAO,CAACJ,QAAnB;AACH,KAHD;;AAIA,WAAOA,QAAP;AACD;;AACDK,EAAAA,WAAW,CAAC9G,IAAD,EAAO;AAChB,QAAI,CAACA,IAAL,EACE,OAAO,IAAP;AACF,UAAM6G,OAAO,GAAG,KAAK9F,aAAL,CAAmBrB,IAAnB,CAAwBM,IAAxB,EAA8B,KAAK,CAAnC,EAAsC,KAAK,CAA3C,EAA8C,YAAW;AACvEW,MAAAA,OAAO,CAAC6J,IAAR,CACE,6GADF;AAGD,KAJe,CAAhB;AAKA,WAAO3D,OAAP;AACD,GAjTkB,CAkTnB;;;AACAI,EAAAA,eAAe,CAACwD,GAAD,EAAM;AACnB,YAAQA,GAAR;AACE,WAAK,CAAL;AACE9J,QAAAA,OAAO,CAAC6J,IAAR,CAAa,uEAAb;AACA,eAAO5L,mBAAP;;AACF,WAAK,CAAL;AACE,eAAOE,cAAP;;AACF,WAAK,CAAL;AACE,eAAOD,sBAAP;;AACF,WAAK,CAAL;AACE,eAAOD,mBAAP;AATJ;AAWD;;AACDmH,EAAAA,eAAe,CAAC2E,QAAD,EAAW;AACxB,QAAIA,QAAQ,CAACxB,SAAT,IAAsBwB,QAAQ,CAACxB,SAAT,CAAmBR,KAAnB,GAA2B,CAArD,EACE,OAAO3J,oBAAP;AACF,QAAI2L,QAAQ,CAACnB,SAAb,EACE,OAAOvK,oBAAP;AACF,WAAOb,iBAAP;AACD;;AAtUkB;;AAwUrB,MAAMuD,cAAN,CAAqB;AACnBjB,EAAAA,KAAK,CAACkK,OAAD,EAAU9I,KAAV,EAAiB;AACpB,UAAMC,QAAQ,GAAG,IAAI7C,cAAJ,EAAjB;AACA6C,IAAAA,QAAQ,CAACwC,YAAT,CAAsB,UAAtB,EAAkC,IAAIpF,sBAAJ,CAA2ByL,OAAO,CAACC,MAAnC,EAA2C,CAA3C,CAAlC;AACA,UAAMC,OAAO,GAAG,KAAKC,YAAL,CAAkBH,OAAO,CAACI,aAA1B,EAAyCJ,OAAO,CAACK,iBAAjD,CAAhB;AACAlJ,IAAAA,QAAQ,CAACmJ,QAAT,CAAkBJ,OAAlB;AACA,SAAKK,WAAL,CAAiBpJ,QAAjB,EAA2B6I,OAA3B;AACA7I,IAAAA,QAAQ,CAACqJ,oBAAT;AACA,SAAKC,QAAL,CAActJ,QAAd,EAAwBD,KAAxB,EAA+BgJ,OAA/B;AACA,SAAKQ,iBAAL,CAAuBvJ,QAAvB,EAAiCD,KAAjC,EAAwCgJ,OAAxC;AACA/I,IAAAA,QAAQ,CAACwJ,SAAT,CAAmB,CAACzJ,KAAK,CAACe,KAAN,CAAY,CAAZ,CAApB,EAAoC,CAACf,KAAK,CAACe,KAAN,CAAY,CAAZ,CAArC,EAAqD,CAACf,KAAK,CAACe,KAAN,CAAY,CAAZ,CAAtD;AACA,WAAOd,QAAP;AACD,GAZkB,CAanB;;;AACAgJ,EAAAA,YAAY,CAACD,OAAD,EAAUG,iBAAV,EAA6B;AACvC,UAAMO,eAAe,GAAG,EAAxB;AACA,QAAIlI,CAAC,GAAG,CAAR;AACA2H,IAAAA,iBAAiB,CAACpJ,OAAlB,CAA0B,UAAS4J,GAAT,EAAc;AACtC,UAAIA,GAAG,GAAG,CAAV,EAAa;AACX,aAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,GAApB,EAAyBC,CAAC,EAA1B,EACEF,eAAe,CAACpJ,IAAhB,CAAqB0I,OAAO,CAACxH,CAAC,GAAGoI,CAAL,CAA5B;AACH,OAHD,MAGO,IAAID,GAAG,KAAK,CAAZ,EAAe;AACpBD,QAAAA,eAAe,CAACpJ,IAAhB,CACE0I,OAAO,CAACxH,CAAD,CADT,EAEEwH,OAAO,CAACxH,CAAC,GAAG,CAAL,CAFT,EAGEwH,OAAO,CAACxH,CAAC,GAAG,CAAL,CAHT,EAIEwH,OAAO,CAACxH,CAAD,CAJT,EAKEwH,OAAO,CAACxH,CAAC,GAAG,CAAL,CALT,EAMEwH,OAAO,CAACxH,CAAC,GAAG,CAAL,CANT;AAQD,OATM,MASA,IAAImI,GAAG,GAAG,CAAV,EAAa;AAClB,aAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,GAAG,GAAG,CAA1B,EAA6BC,CAAC,EAA9B,EAAkC;AAChCF,UAAAA,eAAe,CAACpJ,IAAhB,CAAqB0I,OAAO,CAACxH,CAAD,CAA5B,EAAiCwH,OAAO,CAACxH,CAAC,GAAGoI,CAAL,CAAxC,EAAiDZ,OAAO,CAACxH,CAAC,GAAGoI,CAAJ,GAAQ,CAAT,CAAxD;AACD;;AACD9K,QAAAA,OAAO,CAAC6J,IAAR,CAAa,iEAAb;AACD;;AACDnH,MAAAA,CAAC,IAAImI,GAAL;AACD,KApBD;AAqBA,WAAOD,eAAP;AACD,GAvCkB,CAwCnB;;;AACAL,EAAAA,WAAW,CAACpJ,QAAD,EAAW6I,OAAX,EAAoB;AAC7B,UAAMe,IAAI,GAAGtM,QAAQ,CAACsM,IAAtB;AACA,UAAMlJ,QAAQ,GAAG,EAAjB;AACA,QAAImJ,QAAQ,GAAG,CAAf;AACA,QAAIhB,OAAO,CAAClI,IAAR,KAAiB,OAArB,EACEkJ,QAAQ,GAAG,CAAX;AACF,QAAIhB,OAAO,CAAClI,IAAR,KAAiB,QAArB,EACEkJ,QAAQ,GAAG,CAAX;AACF,UAAMJ,eAAe,GAAG,KAAKK,oBAAL,CAA0BjB,OAAO,CAACK,iBAAlC,EAAqDL,OAAO,CAACkB,eAA7D,CAAxB;AACA,QAAIC,QAAQ,GAAG,CAAf;AACA,UAAMC,UAAU,GAAG,EAAnB;AACA,QAAIC,iBAAJ;AACA,QAAIC,aAAJ;AACA,QAAIC,SAAS,GAAG,CAAhB;AACA,QAAIC,YAAY,GAAG,CAAnB;;AACA,SAAK,IAAI9I,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGkI,eAAe,CAACvH,MAApC,EAA4CX,CAAC,IAAI,CAAjD,EAAoD;AAClD4I,MAAAA,aAAa,GAAGV,eAAe,CAAClI,CAAC,GAAG,CAAL,CAA/B;AACA,UAAIA,CAAC,KAAK,CAAV,EACEb,QAAQ,CAACsJ,QAAD,CAAR,GAAqBJ,IAAI,CAACO,aAAD,CAAzB;AACF,UAAID,iBAAiB,KAAK,KAAK,CAA/B,EACEA,iBAAiB,GAAGC,aAApB;;AACF,UAAIA,aAAa,KAAKD,iBAAtB,EAAyC;AACvC,YAAII,YAAJ;;AACA,YAAIL,UAAU,CAACL,IAAI,CAACM,iBAAD,CAAL,CAAd,EAAyC;AACvCI,UAAAA,YAAY,GAAGL,UAAU,CAACL,IAAI,CAACM,iBAAD,CAAL,CAAzB;AACD,SAFD,MAEO;AACLI,UAAAA,YAAY,GAAGN,QAAf;AACAC,UAAAA,UAAU,CAACL,IAAI,CAACM,iBAAD,CAAL,CAAV,GAAsCF,QAAtC;AACAtJ,UAAAA,QAAQ,CAACsJ,QAAD,CAAR,GAAqBJ,IAAI,CAACM,iBAAD,CAAzB;AACAF,UAAAA,QAAQ;AACT;;AACDhK,QAAAA,QAAQ,CAACuK,QAAT,CAAkBH,SAAlB,EAA6BC,YAA7B,EAA2CC,YAA3C;AACAF,QAAAA,SAAS,IAAIC,YAAb;AACAH,QAAAA,iBAAiB,GAAGC,aAApB;AACAE,QAAAA,YAAY,GAAG,CAAf;AACD;;AACDA,MAAAA,YAAY,IAAIR,QAAhB;AACD;;AACD,QAAI7J,QAAQ,CAACwK,MAAT,CAAgBtI,MAAhB,GAAyB,CAA7B,EAAgC;AAC9B,UAAIoI,YAAJ;;AACA,UAAIL,UAAU,CAACL,IAAI,CAACO,aAAD,CAAL,CAAd,EAAqC;AACnCG,QAAAA,YAAY,GAAGL,UAAU,CAACL,IAAI,CAACO,aAAD,CAAL,CAAzB;AACD,OAFD,MAEO;AACLG,QAAAA,YAAY,GAAGN,QAAf;AACAC,QAAAA,UAAU,CAACL,IAAI,CAACO,aAAD,CAAL,CAAV,GAAkCH,QAAlC;AACAtJ,QAAAA,QAAQ,CAACsJ,QAAD,CAAR,GAAqBJ,IAAI,CAACO,aAAD,CAAzB;AACD;;AACDnK,MAAAA,QAAQ,CAACuK,QAAT,CAAkBH,SAAlB,EAA6BC,YAA7B,EAA2CC,YAA3C;AACD;;AACDtK,IAAAA,QAAQ,CAACS,QAAT,CAAkBC,QAAlB,GAA6BA,QAA7B;AACD;;AACDoJ,EAAAA,oBAAoB,CAACZ,iBAAD,EAAoBH,OAApB,EAA6B;AAC/C,UAAMU,eAAe,GAAG,EAAxB;AACAP,IAAAA,iBAAiB,CAACpJ,OAAlB,CAA0B,UAAS4J,GAAT,EAAcnI,CAAd,EAAiB;AACzC,UAAImI,GAAG,IAAI,CAAX,EAAc;AACZD,QAAAA,eAAe,CAACpJ,IAAhB,CAAqB0I,OAAO,CAACxH,CAAC,GAAG,CAAL,CAA5B,EAAqCwH,OAAO,CAACxH,CAAC,GAAG,CAAJ,GAAQ,CAAT,CAA5C;AACD,OAFD,MAEO,IAAImI,GAAG,KAAK,CAAZ,EAAe;AACpBD,QAAAA,eAAe,CAACpJ,IAAhB,CAAqB0I,OAAO,CAACxH,CAAC,GAAG,CAAL,CAA5B,EAAqCwH,OAAO,CAACxH,CAAC,GAAG,CAAJ,GAAQ,CAAT,CAA5C,EAAyDwH,OAAO,CAACxH,CAAC,GAAG,CAAL,CAAhE,EAAyEwH,OAAO,CAACxH,CAAC,GAAG,CAAJ,GAAQ,CAAT,CAAhF;AACD,OAFM,MAEA;AACL,aAAK,IAAIoI,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,GAAG,GAAG,CAA1B,EAA6BC,CAAC,EAA9B,EAAkC;AAChCF,UAAAA,eAAe,CAACpJ,IAAhB,CAAqB0I,OAAO,CAACxH,CAAC,GAAG,CAAL,CAA5B,EAAqCwH,OAAO,CAACxH,CAAC,GAAG,CAAJ,GAAQ,CAAT,CAA5C;AACD;AACF;AACF,KAVD;AAWA,WAAOkI,eAAP;AACD,GA1GkB,CA2GnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAH,EAAAA,QAAQ,CAACtJ,QAAD,EAAWD,KAAX,EAAkB;AACxB,UAAM0K,WAAW,GAAGrI,KAAK,CAACsI,IAAN,CAAWtI,KAAK,CAACpC,QAAQ,CAACyC,UAAT,CAAoBxB,QAApB,CAA6B0J,KAA7B,GAAqC,CAAtC,CAAhB,EAA0D,YAAW;AACvF,aAAO,CAAP;AACD,KAFmB,CAApB;;AAGA,SAAK,MAAM9J,IAAX,IAAmBd,KAAK,CAAC6K,GAAzB,EAA8B;AAC5B,YAAMA,GAAG,GAAG7K,KAAK,CAAC6K,GAAN,CAAU/J,IAAV,EAAgB+J,GAA5B;AACA,YAAMC,SAAS,GAAG9K,KAAK,CAAC6K,GAAN,CAAU/J,IAAV,EAAgBgK,SAAlC;AACAA,MAAAA,SAAS,CAAC/K,OAAV,CAAkB,UAASyB,CAAT,EAAYuJ,CAAZ,EAAe;AAC/BL,QAAAA,WAAW,CAAClJ,CAAC,GAAG,CAAL,CAAX,GAAqBqJ,GAAG,CAACE,CAAC,GAAG,CAAL,CAAxB;AACAL,QAAAA,WAAW,CAAClJ,CAAC,GAAG,CAAJ,GAAQ,CAAT,CAAX,GAAyBqJ,GAAG,CAACE,CAAC,GAAG,CAAJ,GAAQ,CAAT,CAA5B;AACD,OAHD;AAID;;AACD9K,IAAAA,QAAQ,CAACwC,YAAT,CAAsB,IAAtB,EAA4B,IAAIpF,sBAAJ,CAA2BqN,WAA3B,EAAwC,CAAxC,CAA5B;AACD;;AACDlB,EAAAA,iBAAiB,CAACvJ,QAAD,EAAWD,KAAX,EAAkB;AACjC,QAAI4I,GAAG,GAAG,CAAV;;AACA,SAAK,MAAM9H,IAAX,IAAmBd,KAAK,CAAC+B,YAAzB,EAAuC;AACrC,YAAMiJ,cAAc,GAAG/K,QAAQ,CAACyC,UAAT,CAAoBxB,QAApB,CAA6B0B,KAA7B,CAAmCqI,KAAnC,EAAvB;AACA,UAAI,CAAChL,QAAQ,CAACiL,eAAT,CAAyBhK,QAA9B,EACEjB,QAAQ,CAACiL,eAAT,CAAyBhK,QAAzB,GAAoC,EAApC;AACF,YAAMiK,WAAW,GAAGnL,KAAK,CAAC+B,YAAN,CAAmBjB,IAAnB,EAAyBiI,MAA7C;AACA,YAAMqC,YAAY,GAAGpL,KAAK,CAAC+B,YAAN,CAAmBjB,IAAnB,EAAyBkI,OAA9C;AACA,YAAMpI,IAAI,GAAGZ,KAAK,CAAC+B,YAAN,CAAmBjB,IAAnB,EAAyBF,IAAtC;AACAwK,MAAAA,YAAY,CAACrL,OAAb,CAAqB,UAASyB,CAAT,EAAYuJ,CAAZ,EAAe;AAClC,YAAInK,IAAI,KAAK,UAAb,EAAyB;AACvBoK,UAAAA,cAAc,CAACxJ,CAAC,GAAG,CAAL,CAAd,IAAyB2J,WAAW,CAACJ,CAAC,GAAG,CAAL,CAApC;AACAC,UAAAA,cAAc,CAACxJ,CAAC,GAAG,CAAJ,GAAQ,CAAT,CAAd,IAA6B2J,WAAW,CAACJ,CAAC,GAAG,CAAJ,GAAQ,CAAT,CAAxC;AACAC,UAAAA,cAAc,CAACxJ,CAAC,GAAG,CAAJ,GAAQ,CAAT,CAAd,IAA6B2J,WAAW,CAACJ,CAAC,GAAG,CAAJ,GAAQ,CAAT,CAAxC;AACD,SAJD,MAIO;AACLC,UAAAA,cAAc,CAACxJ,CAAC,GAAG,CAAL,CAAd,GAAwB2J,WAAW,CAACJ,CAAC,GAAG,CAAL,CAAnC;AACAC,UAAAA,cAAc,CAACxJ,CAAC,GAAG,CAAJ,GAAQ,CAAT,CAAd,GAA4B2J,WAAW,CAACJ,CAAC,GAAG,CAAJ,GAAQ,CAAT,CAAvC;AACAC,UAAAA,cAAc,CAACxJ,CAAC,GAAG,CAAJ,GAAQ,CAAT,CAAd,GAA4B2J,WAAW,CAACJ,CAAC,GAAG,CAAJ,GAAQ,CAAT,CAAvC;AACD;AACF,OAVD;AAWA9K,MAAAA,QAAQ,CAACiL,eAAT,CAAyBhK,QAAzB,CAAkC0H,GAAlC,IAAyC,IAAIvL,sBAAJ,CAA2B2N,cAA3B,EAA2C,CAA3C,CAAzC;AACA/K,MAAAA,QAAQ,CAACiL,eAAT,CAAyBhK,QAAzB,CAAkC0H,GAAlC,EAAuC9H,IAAvC,GAA8CA,IAA9C;AACA8H,MAAAA,GAAG;AACJ;;AACD3I,IAAAA,QAAQ,CAACoL,oBAAT,GAAgC,KAAhC;AACD;;AA3JkB;;AA6JrB,SAASjN,gBAAT,CAA0BN,GAA1B,EAA+BwN,GAA/B,EAAoC;AAClC,QAAM9G,KAAK,GAAG1G,GAAG,CAACyN,OAAJ,CAAYD,GAAZ,CAAd;AACA,MAAI9G,KAAK,KAAK,CAAC,CAAf,EACE,OAAO,IAAP;AACF,SAAO1G,GAAG,CAAC0N,MAAJ,CAAW,CAAX,EAAchH,KAAd,CAAP;AACD;;AACD,SACEhH,SADF","sourcesContent":["import { Loader, FileLoader, TextureLoader, Points, LineSegments, Mesh, PointsMaterial, LineBasicMaterial, BufferAttribute, MeshPhongMaterial, BackSide, DoubleSide, FrontSide, Vector2, Color, AddOperation, EquirectangularRefractionMapping, EquirectangularReflectionMapping, ClampToEdgeWrapping, MirroredRepeatWrapping, RepeatWrapping, MeshPhysicalMaterial, MeshStandardMaterial, BufferGeometry, Float32BufferAttribute } from \"three\";\nimport { IFFParser } from \"./lwo/IFFParser.js\";\nlet _lwoTree;\nclass LWOLoader extends Loader {\n  constructor(manager, parameters = {}) {\n    super(manager);\n    this.resourcePath = parameters.resourcePath !== void 0 ? parameters.resourcePath : \"\";\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const path = scope.path === \"\" ? extractParentUrl(url, \"Objects\") : scope.path;\n    const modelName = url.split(path).pop().split(\".\")[0];\n    const loader = new FileLoader(this.manager);\n    loader.setPath(scope.path);\n    loader.setResponseType(\"arraybuffer\");\n    loader.load(\n      url,\n      function(buffer) {\n        try {\n          onLoad(scope.parse(buffer, path, modelName));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n          scope.manager.itemError(url);\n        }\n      },\n      onProgress,\n      onError\n    );\n  }\n  parse(iffBuffer, path, modelName) {\n    _lwoTree = new IFFParser().parse(iffBuffer);\n    const textureLoader = new TextureLoader(this.manager).setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n    return new LWOTreeParser(textureLoader).parse(modelName);\n  }\n}\nclass LWOTreeParser {\n  constructor(textureLoader) {\n    this.textureLoader = textureLoader;\n  }\n  parse(modelName) {\n    this.materials = new MaterialParser(this.textureLoader).parse();\n    this.defaultLayerName = modelName;\n    this.meshes = this.parseLayers();\n    return {\n      materials: this.materials,\n      meshes: this.meshes\n    };\n  }\n  parseLayers() {\n    const meshes = [];\n    const finalMeshes = [];\n    const geometryParser = new GeometryParser();\n    const scope = this;\n    _lwoTree.layers.forEach(function(layer) {\n      const geometry = geometryParser.parse(layer.geometry, layer);\n      const mesh = scope.parseMesh(geometry, layer);\n      meshes[layer.number] = mesh;\n      if (layer.parent === -1)\n        finalMeshes.push(mesh);\n      else\n        meshes[layer.parent].add(mesh);\n    });\n    this.applyPivots(finalMeshes);\n    return finalMeshes;\n  }\n  parseMesh(geometry, layer) {\n    let mesh;\n    const materials = this.getMaterials(geometry.userData.matNames, layer.geometry.type);\n    this.duplicateUVs(geometry, materials);\n    if (layer.geometry.type === \"points\")\n      mesh = new Points(geometry, materials);\n    else if (layer.geometry.type === \"lines\")\n      mesh = new LineSegments(geometry, materials);\n    else\n      mesh = new Mesh(geometry, materials);\n    if (layer.name)\n      mesh.name = layer.name;\n    else\n      mesh.name = this.defaultLayerName + \"_layer_\" + layer.number;\n    mesh.userData.pivot = layer.pivot;\n    return mesh;\n  }\n  // TODO: may need to be reversed in z to convert LWO to three.js coordinates\n  applyPivots(meshes) {\n    meshes.forEach(function(mesh) {\n      mesh.traverse(function(child) {\n        const pivot = child.userData.pivot;\n        child.position.x += pivot[0];\n        child.position.y += pivot[1];\n        child.position.z += pivot[2];\n        if (child.parent) {\n          const parentPivot = child.parent.userData.pivot;\n          child.position.x -= parentPivot[0];\n          child.position.y -= parentPivot[1];\n          child.position.z -= parentPivot[2];\n        }\n      });\n    });\n  }\n  getMaterials(namesArray, type) {\n    const materials = [];\n    const scope = this;\n    namesArray.forEach(function(name, i) {\n      materials[i] = scope.getMaterialByName(name);\n    });\n    if (type === \"points\" || type === \"lines\") {\n      materials.forEach(function(mat, i) {\n        const spec = {\n          color: mat.color\n        };\n        if (type === \"points\") {\n          spec.size = 0.1;\n          spec.map = mat.map;\n          spec.morphTargets = mat.morphTargets;\n          materials[i] = new PointsMaterial(spec);\n        } else if (type === \"lines\") {\n          materials[i] = new LineBasicMaterial(spec);\n        }\n      });\n    }\n    const filtered = materials.filter(Boolean);\n    if (filtered.length === 1)\n      return filtered[0];\n    return materials;\n  }\n  getMaterialByName(name) {\n    return this.materials.filter(function(m) {\n      return m.name === name;\n    })[0];\n  }\n  // If the material has an aoMap, duplicate UVs\n  duplicateUVs(geometry, materials) {\n    let duplicateUVs = false;\n    if (!Array.isArray(materials)) {\n      if (materials.aoMap)\n        duplicateUVs = true;\n    } else {\n      materials.forEach(function(material) {\n        if (material.aoMap)\n          duplicateUVs = true;\n      });\n    }\n    if (!duplicateUVs)\n      return;\n    geometry.setAttribute(\"uv2\", new BufferAttribute(geometry.attributes.uv.array, 2));\n  }\n}\nclass MaterialParser {\n  constructor(textureLoader) {\n    this.textureLoader = textureLoader;\n  }\n  parse() {\n    const materials = [];\n    this.textures = {};\n    for (const name in _lwoTree.materials) {\n      if (_lwoTree.format === \"LWO3\") {\n        materials.push(this.parseMaterial(_lwoTree.materials[name], name, _lwoTree.textures));\n      } else if (_lwoTree.format === \"LWO2\") {\n        materials.push(this.parseMaterialLwo2(_lwoTree.materials[name], name, _lwoTree.textures));\n      }\n    }\n    return materials;\n  }\n  parseMaterial(materialData, name, textures) {\n    let params = {\n      name,\n      side: this.getSide(materialData.attributes),\n      flatShading: this.getSmooth(materialData.attributes)\n    };\n    const connections = this.parseConnections(materialData.connections, materialData.nodes);\n    const maps = this.parseTextureNodes(connections.maps);\n    this.parseAttributeImageMaps(connections.attributes, textures, maps, materialData.maps);\n    const attributes = this.parseAttributes(connections.attributes, maps);\n    this.parseEnvMap(connections, maps, attributes);\n    params = Object.assign(maps, params);\n    params = Object.assign(params, attributes);\n    const materialType = this.getMaterialType(connections.attributes);\n    return new materialType(params);\n  }\n  parseMaterialLwo2(materialData, name) {\n    let params = {\n      name,\n      side: this.getSide(materialData.attributes),\n      flatShading: this.getSmooth(materialData.attributes)\n    };\n    const attributes = this.parseAttributes(materialData.attributes, {});\n    params = Object.assign(params, attributes);\n    return new MeshPhongMaterial(params);\n  }\n  // Note: converting from left to right handed coords by switching x -> -x in vertices, and\n  // then switching mat FrontSide -> BackSide\n  // NB: this means that FrontSide and BackSide have been switched!\n  getSide(attributes) {\n    if (!attributes.side)\n      return BackSide;\n    switch (attributes.side) {\n      case 0:\n      case 1:\n        return BackSide;\n      case 2:\n        return FrontSide;\n      case 3:\n        return DoubleSide;\n    }\n  }\n  getSmooth(attributes) {\n    if (!attributes.smooth)\n      return true;\n    return !attributes.smooth;\n  }\n  parseConnections(connections, nodes) {\n    const materialConnections = {\n      maps: {}\n    };\n    const inputName = connections.inputName;\n    const inputNodeName = connections.inputNodeName;\n    const nodeName = connections.nodeName;\n    const scope = this;\n    inputName.forEach(function(name, index) {\n      if (name === \"Material\") {\n        const matNode = scope.getNodeByRefName(inputNodeName[index], nodes);\n        materialConnections.attributes = matNode.attributes;\n        materialConnections.envMap = matNode.fileName;\n        materialConnections.name = inputNodeName[index];\n      }\n    });\n    nodeName.forEach(function(name, index) {\n      if (name === materialConnections.name) {\n        materialConnections.maps[inputName[index]] = scope.getNodeByRefName(inputNodeName[index], nodes);\n      }\n    });\n    return materialConnections;\n  }\n  getNodeByRefName(refName, nodes) {\n    for (const name in nodes) {\n      if (nodes[name].refName === refName)\n        return nodes[name];\n    }\n  }\n  parseTextureNodes(textureNodes) {\n    const maps = {};\n    for (const name in textureNodes) {\n      const node = textureNodes[name];\n      const path = node.fileName;\n      if (!path)\n        return;\n      const texture = this.loadTexture(path);\n      if (node.widthWrappingMode !== void 0)\n        texture.wrapS = this.getWrappingType(node.widthWrappingMode);\n      if (node.heightWrappingMode !== void 0)\n        texture.wrapT = this.getWrappingType(node.heightWrappingMode);\n      switch (name) {\n        case \"Color\":\n          maps.map = texture;\n          break;\n        case \"Roughness\":\n          maps.roughnessMap = texture;\n          maps.roughness = 0.5;\n          break;\n        case \"Specular\":\n          maps.specularMap = texture;\n          maps.specular = 16777215;\n          break;\n        case \"Luminous\":\n          maps.emissiveMap = texture;\n          maps.emissive = 8421504;\n          break;\n        case \"Luminous Color\":\n          maps.emissive = 8421504;\n          break;\n        case \"Metallic\":\n          maps.metalnessMap = texture;\n          maps.metalness = 0.5;\n          break;\n        case \"Transparency\":\n        case \"Alpha\":\n          maps.alphaMap = texture;\n          maps.transparent = true;\n          break;\n        case \"Normal\":\n          maps.normalMap = texture;\n          if (node.amplitude !== void 0)\n            maps.normalScale = new Vector2(node.amplitude, node.amplitude);\n          break;\n        case \"Bump\":\n          maps.bumpMap = texture;\n          break;\n      }\n    }\n    if (maps.roughnessMap && maps.specularMap)\n      delete maps.specularMap;\n    return maps;\n  }\n  // maps can also be defined on individual material attributes, parse those here\n  // This occurs on Standard (Phong) surfaces\n  parseAttributeImageMaps(attributes, textures, maps) {\n    for (const name in attributes) {\n      const attribute = attributes[name];\n      if (attribute.maps) {\n        const mapData = attribute.maps[0];\n        const path = this.getTexturePathByIndex(mapData.imageIndex, textures);\n        if (!path)\n          return;\n        const texture = this.loadTexture(path);\n        if (mapData.wrap !== void 0)\n          texture.wrapS = this.getWrappingType(mapData.wrap.w);\n        if (mapData.wrap !== void 0)\n          texture.wrapT = this.getWrappingType(mapData.wrap.h);\n        switch (name) {\n          case \"Color\":\n            maps.map = texture;\n            break;\n          case \"Diffuse\":\n            maps.aoMap = texture;\n            break;\n          case \"Roughness\":\n            maps.roughnessMap = texture;\n            maps.roughness = 1;\n            break;\n          case \"Specular\":\n            maps.specularMap = texture;\n            maps.specular = 16777215;\n            break;\n          case \"Luminosity\":\n            maps.emissiveMap = texture;\n            maps.emissive = 8421504;\n            break;\n          case \"Metallic\":\n            maps.metalnessMap = texture;\n            maps.metalness = 1;\n            break;\n          case \"Transparency\":\n          case \"Alpha\":\n            maps.alphaMap = texture;\n            maps.transparent = true;\n            break;\n          case \"Normal\":\n            maps.normalMap = texture;\n            break;\n          case \"Bump\":\n            maps.bumpMap = texture;\n            break;\n        }\n      }\n    }\n  }\n  parseAttributes(attributes, maps) {\n    const params = {};\n    if (attributes.Color && !maps.map) {\n      params.color = new Color().fromArray(attributes.Color.value);\n    } else {\n      params.color = new Color();\n    }\n    if (attributes.Transparency && attributes.Transparency.value !== 0) {\n      params.opacity = 1 - attributes.Transparency.value;\n      params.transparent = true;\n    }\n    if (attributes[\"Bump Height\"])\n      params.bumpScale = attributes[\"Bump Height\"].value * 0.1;\n    if (attributes[\"Refraction Index\"])\n      params.refractionRatio = 1 / attributes[\"Refraction Index\"].value;\n    this.parsePhysicalAttributes(params, attributes, maps);\n    this.parseStandardAttributes(params, attributes, maps);\n    this.parsePhongAttributes(params, attributes, maps);\n    return params;\n  }\n  parsePhysicalAttributes(params, attributes) {\n    if (attributes.Clearcoat && attributes.Clearcoat.value > 0) {\n      params.clearcoat = attributes.Clearcoat.value;\n      if (attributes[\"Clearcoat Gloss\"]) {\n        params.clearcoatRoughness = 0.5 * (1 - attributes[\"Clearcoat Gloss\"].value);\n      }\n    }\n  }\n  parseStandardAttributes(params, attributes, maps) {\n    if (attributes.Luminous) {\n      params.emissiveIntensity = attributes.Luminous.value;\n      if (attributes[\"Luminous Color\"] && !maps.emissive) {\n        params.emissive = new Color().fromArray(attributes[\"Luminous Color\"].value);\n      } else {\n        params.emissive = new Color(8421504);\n      }\n    }\n    if (attributes.Roughness && !maps.roughnessMap)\n      params.roughness = attributes.Roughness.value;\n    if (attributes.Metallic && !maps.metalnessMap)\n      params.metalness = attributes.Metallic.value;\n  }\n  parsePhongAttributes(params, attributes, maps) {\n    if (attributes.Diffuse)\n      params.color.multiplyScalar(attributes.Diffuse.value);\n    if (attributes.Reflection) {\n      params.reflectivity = attributes.Reflection.value;\n      params.combine = AddOperation;\n    }\n    if (attributes.Luminosity) {\n      params.emissiveIntensity = attributes.Luminosity.value;\n      if (!maps.emissiveMap && !maps.map) {\n        params.emissive = params.color;\n      } else {\n        params.emissive = new Color(8421504);\n      }\n    }\n    if (!attributes.Roughness && attributes.Specular && !maps.specularMap) {\n      if (attributes[\"Color Highlight\"]) {\n        params.specular = new Color().setScalar(attributes.Specular.value).lerp(params.color.clone().multiplyScalar(attributes.Specular.value), attributes[\"Color Highlight\"].value);\n      } else {\n        params.specular = new Color().setScalar(attributes.Specular.value);\n      }\n    }\n    if (params.specular && attributes.Glossiness) {\n      params.shininess = 7 + Math.pow(2, attributes.Glossiness.value * 12 + 2);\n    }\n  }\n  parseEnvMap(connections, maps, attributes) {\n    if (connections.envMap) {\n      const envMap = this.loadTexture(connections.envMap);\n      if (attributes.transparent && attributes.opacity < 0.999) {\n        envMap.mapping = EquirectangularRefractionMapping;\n        if (attributes.reflectivity !== void 0) {\n          delete attributes.reflectivity;\n          delete attributes.combine;\n        }\n        if (attributes.metalness !== void 0) {\n          delete attributes.metalness;\n        }\n      } else {\n        envMap.mapping = EquirectangularReflectionMapping;\n      }\n      maps.envMap = envMap;\n    }\n  }\n  // get texture defined at top level by its index\n  getTexturePathByIndex(index) {\n    let fileName = \"\";\n    if (!_lwoTree.textures)\n      return fileName;\n    _lwoTree.textures.forEach(function(texture) {\n      if (texture.index === index)\n        fileName = texture.fileName;\n    });\n    return fileName;\n  }\n  loadTexture(path) {\n    if (!path)\n      return null;\n    const texture = this.textureLoader.load(path, void 0, void 0, function() {\n      console.warn(\n        \"LWOLoader: non-standard resource hierarchy. Use `resourcePath` parameter to specify root content directory.\"\n      );\n    });\n    return texture;\n  }\n  // 0 = Reset, 1 = Repeat, 2 = Mirror, 3 = Edge\n  getWrappingType(num) {\n    switch (num) {\n      case 0:\n        console.warn('LWOLoader: \"Reset\" texture wrapping type is not supported in three.js');\n        return ClampToEdgeWrapping;\n      case 1:\n        return RepeatWrapping;\n      case 2:\n        return MirroredRepeatWrapping;\n      case 3:\n        return ClampToEdgeWrapping;\n    }\n  }\n  getMaterialType(nodeData) {\n    if (nodeData.Clearcoat && nodeData.Clearcoat.value > 0)\n      return MeshPhysicalMaterial;\n    if (nodeData.Roughness)\n      return MeshStandardMaterial;\n    return MeshPhongMaterial;\n  }\n}\nclass GeometryParser {\n  parse(geoData, layer) {\n    const geometry = new BufferGeometry();\n    geometry.setAttribute(\"position\", new Float32BufferAttribute(geoData.points, 3));\n    const indices = this.splitIndices(geoData.vertexIndices, geoData.polygonDimensions);\n    geometry.setIndex(indices);\n    this.parseGroups(geometry, geoData);\n    geometry.computeVertexNormals();\n    this.parseUVs(geometry, layer, indices);\n    this.parseMorphTargets(geometry, layer, indices);\n    geometry.translate(-layer.pivot[0], -layer.pivot[1], -layer.pivot[2]);\n    return geometry;\n  }\n  // split quads into tris\n  splitIndices(indices, polygonDimensions) {\n    const remappedIndices = [];\n    let i = 0;\n    polygonDimensions.forEach(function(dim) {\n      if (dim < 4) {\n        for (let k = 0; k < dim; k++)\n          remappedIndices.push(indices[i + k]);\n      } else if (dim === 4) {\n        remappedIndices.push(\n          indices[i],\n          indices[i + 1],\n          indices[i + 2],\n          indices[i],\n          indices[i + 2],\n          indices[i + 3]\n        );\n      } else if (dim > 4) {\n        for (let k = 1; k < dim - 1; k++) {\n          remappedIndices.push(indices[i], indices[i + k], indices[i + k + 1]);\n        }\n        console.warn(\"LWOLoader: polygons with greater than 4 sides are not supported\");\n      }\n      i += dim;\n    });\n    return remappedIndices;\n  }\n  // NOTE: currently ignoring poly indices and assuming that they are intelligently ordered\n  parseGroups(geometry, geoData) {\n    const tags = _lwoTree.tags;\n    const matNames = [];\n    let elemSize = 3;\n    if (geoData.type === \"lines\")\n      elemSize = 2;\n    if (geoData.type === \"points\")\n      elemSize = 1;\n    const remappedIndices = this.splitMaterialIndices(geoData.polygonDimensions, geoData.materialIndices);\n    let indexNum = 0;\n    const indexPairs = {};\n    let prevMaterialIndex;\n    let materialIndex;\n    let prevStart = 0;\n    let currentCount = 0;\n    for (let i = 0; i < remappedIndices.length; i += 2) {\n      materialIndex = remappedIndices[i + 1];\n      if (i === 0)\n        matNames[indexNum] = tags[materialIndex];\n      if (prevMaterialIndex === void 0)\n        prevMaterialIndex = materialIndex;\n      if (materialIndex !== prevMaterialIndex) {\n        let currentIndex;\n        if (indexPairs[tags[prevMaterialIndex]]) {\n          currentIndex = indexPairs[tags[prevMaterialIndex]];\n        } else {\n          currentIndex = indexNum;\n          indexPairs[tags[prevMaterialIndex]] = indexNum;\n          matNames[indexNum] = tags[prevMaterialIndex];\n          indexNum++;\n        }\n        geometry.addGroup(prevStart, currentCount, currentIndex);\n        prevStart += currentCount;\n        prevMaterialIndex = materialIndex;\n        currentCount = 0;\n      }\n      currentCount += elemSize;\n    }\n    if (geometry.groups.length > 0) {\n      let currentIndex;\n      if (indexPairs[tags[materialIndex]]) {\n        currentIndex = indexPairs[tags[materialIndex]];\n      } else {\n        currentIndex = indexNum;\n        indexPairs[tags[materialIndex]] = indexNum;\n        matNames[indexNum] = tags[materialIndex];\n      }\n      geometry.addGroup(prevStart, currentCount, currentIndex);\n    }\n    geometry.userData.matNames = matNames;\n  }\n  splitMaterialIndices(polygonDimensions, indices) {\n    const remappedIndices = [];\n    polygonDimensions.forEach(function(dim, i) {\n      if (dim <= 3) {\n        remappedIndices.push(indices[i * 2], indices[i * 2 + 1]);\n      } else if (dim === 4) {\n        remappedIndices.push(indices[i * 2], indices[i * 2 + 1], indices[i * 2], indices[i * 2 + 1]);\n      } else {\n        for (let k = 0; k < dim - 2; k++) {\n          remappedIndices.push(indices[i * 2], indices[i * 2 + 1]);\n        }\n      }\n    });\n    return remappedIndices;\n  }\n  // UV maps:\n  // 1: are defined via index into an array of points, not into a geometry\n  // - the geometry is also defined by an index into this array, but the indexes may not match\n  // 2: there can be any number of UV maps for a single geometry. Here these are combined,\n  // \twith preference given to the first map encountered\n  // 3: UV maps can be partial - that is, defined for only a part of the geometry\n  // 4: UV maps can be VMAP or VMAD (discontinuous, to allow for seams). In practice, most\n  // UV maps are defined as partially VMAP and partially VMAD\n  // VMADs are currently not supported\n  parseUVs(geometry, layer) {\n    const remappedUVs = Array.from(Array(geometry.attributes.position.count * 2), function() {\n      return 0;\n    });\n    for (const name in layer.uvs) {\n      const uvs = layer.uvs[name].uvs;\n      const uvIndices = layer.uvs[name].uvIndices;\n      uvIndices.forEach(function(i, j) {\n        remappedUVs[i * 2] = uvs[j * 2];\n        remappedUVs[i * 2 + 1] = uvs[j * 2 + 1];\n      });\n    }\n    geometry.setAttribute(\"uv\", new Float32BufferAttribute(remappedUVs, 2));\n  }\n  parseMorphTargets(geometry, layer) {\n    let num = 0;\n    for (const name in layer.morphTargets) {\n      const remappedPoints = geometry.attributes.position.array.slice();\n      if (!geometry.morphAttributes.position)\n        geometry.morphAttributes.position = [];\n      const morphPoints = layer.morphTargets[name].points;\n      const morphIndices = layer.morphTargets[name].indices;\n      const type = layer.morphTargets[name].type;\n      morphIndices.forEach(function(i, j) {\n        if (type === \"relative\") {\n          remappedPoints[i * 3] += morphPoints[j * 3];\n          remappedPoints[i * 3 + 1] += morphPoints[j * 3 + 1];\n          remappedPoints[i * 3 + 2] += morphPoints[j * 3 + 2];\n        } else {\n          remappedPoints[i * 3] = morphPoints[j * 3];\n          remappedPoints[i * 3 + 1] = morphPoints[j * 3 + 1];\n          remappedPoints[i * 3 + 2] = morphPoints[j * 3 + 2];\n        }\n      });\n      geometry.morphAttributes.position[num] = new Float32BufferAttribute(remappedPoints, 3);\n      geometry.morphAttributes.position[num].name = name;\n      num++;\n    }\n    geometry.morphTargetsRelative = false;\n  }\n}\nfunction extractParentUrl(url, dir) {\n  const index = url.indexOf(dir);\n  if (index === -1)\n    return \"./\";\n  return url.substr(0, index);\n}\nexport {\n  LWOLoader\n};\n"]},"metadata":{},"sourceType":"module"}