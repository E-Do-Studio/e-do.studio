{"ast":null,"code":"var FresnelShader = {\n  uniforms: {\n    mRefractionRatio: {\n      value: 1.02\n    },\n    mFresnelBias: {\n      value: 0.1\n    },\n    mFresnelPower: {\n      value: 2\n    },\n    mFresnelScale: {\n      value: 1\n    },\n    tCube: {\n      value: null\n    }\n  },\n  vertexShader: [\"uniform float mRefractionRatio;\", \"uniform float mFresnelBias;\", \"uniform float mFresnelScale;\", \"uniform float mFresnelPower;\", \"varying vec3 vReflect;\", \"varying vec3 vRefract[3];\", \"varying float vReflectionFactor;\", \"void main() {\", \"\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\", \"\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\", \"\tvec3 worldNormal = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );\", \"\tvec3 I = worldPosition.xyz - cameraPosition;\", \"\tvReflect = reflect( I, worldNormal );\", \"\tvRefract[0] = refract( normalize( I ), worldNormal, mRefractionRatio );\", \"\tvRefract[1] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.99 );\", \"\tvRefract[2] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.98 );\", \"\tvReflectionFactor = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( I ), worldNormal ), mFresnelPower );\", \"\tgl_Position = projectionMatrix * mvPosition;\", \"}\"].join(\"\\n\"),\n  fragmentShader: [\"uniform samplerCube tCube;\", \"varying vec3 vReflect;\", \"varying vec3 vRefract[3];\", \"varying float vReflectionFactor;\", \"void main() {\", \"\tvec4 reflectedColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );\", \"\tvec4 refractedColor = vec4( 1.0 );\", \"\trefractedColor.r = textureCube( tCube, vec3( -vRefract[0].x, vRefract[0].yz ) ).r;\", \"\trefractedColor.g = textureCube( tCube, vec3( -vRefract[1].x, vRefract[1].yz ) ).g;\", \"\trefractedColor.b = textureCube( tCube, vec3( -vRefract[2].x, vRefract[2].yz ) ).b;\", \"\tgl_FragColor = mix( refractedColor, reflectedColor, clamp( vReflectionFactor, 0.0, 1.0 ) );\", \"}\"].join(\"\\n\")\n};\nexport { FresnelShader };","map":{"version":3,"sources":["/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/three-stdlib/shaders/FresnelShader.js"],"names":["FresnelShader","uniforms","mRefractionRatio","value","mFresnelBias","mFresnelPower","mFresnelScale","tCube","vertexShader","join","fragmentShader"],"mappings":"AAAA,IAAMA,aAAa,GAAG;AACpBC,EAAAA,QAAQ,EAAE;AACRC,IAAAA,gBAAgB,EAAE;AAAEC,MAAAA,KAAK,EAAE;AAAT,KADV;AAERC,IAAAA,YAAY,EAAE;AAAED,MAAAA,KAAK,EAAE;AAAT,KAFN;AAGRE,IAAAA,aAAa,EAAE;AAAEF,MAAAA,KAAK,EAAE;AAAT,KAHP;AAIRG,IAAAA,aAAa,EAAE;AAAEH,MAAAA,KAAK,EAAE;AAAT,KAJP;AAKRI,IAAAA,KAAK,EAAE;AAAEJ,MAAAA,KAAK,EAAE;AAAT;AALC,GADU;AAQpBK,EAAAA,YAAY,EAAE,CACZ,iCADY,EAEZ,6BAFY,EAGZ,8BAHY,EAIZ,8BAJY,EAKZ,wBALY,EAMZ,2BANY,EAOZ,kCAPY,EAQZ,eARY,EASZ,6DATY,EAUZ,4DAVY,EAWZ,+GAXY,EAYZ,+CAZY,EAaZ,wCAbY,EAcZ,0EAdY,EAeZ,iFAfY,EAgBZ,iFAhBY,EAiBZ,qHAjBY,EAkBZ,+CAlBY,EAmBZ,GAnBY,EAoBZC,IApBY,CAoBP,IApBO,CARM;AA6BpBC,EAAAA,cAAc,EAAE,CACd,4BADc,EAEd,wBAFc,EAGd,2BAHc,EAId,kCAJc,EAKd,eALc,EAMd,gFANc,EAOd,qCAPc,EAQd,qFARc,EASd,qFATc,EAUd,qFAVc,EAWd,8FAXc,EAYd,GAZc,EAadD,IAbc,CAaT,IAbS;AA7BI,CAAtB;AA4CA,SACET,aADF","sourcesContent":["const FresnelShader = {\n  uniforms: {\n    mRefractionRatio: { value: 1.02 },\n    mFresnelBias: { value: 0.1 },\n    mFresnelPower: { value: 2 },\n    mFresnelScale: { value: 1 },\n    tCube: { value: null }\n  },\n  vertexShader: [\n    \"uniform float mRefractionRatio;\",\n    \"uniform float mFresnelBias;\",\n    \"uniform float mFresnelScale;\",\n    \"uniform float mFresnelPower;\",\n    \"varying vec3 vReflect;\",\n    \"varying vec3 vRefract[3];\",\n    \"varying float vReflectionFactor;\",\n    \"void main() {\",\n    \"\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\n    \"\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\",\n    \"\tvec3 worldNormal = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );\",\n    \"\tvec3 I = worldPosition.xyz - cameraPosition;\",\n    \"\tvReflect = reflect( I, worldNormal );\",\n    \"\tvRefract[0] = refract( normalize( I ), worldNormal, mRefractionRatio );\",\n    \"\tvRefract[1] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.99 );\",\n    \"\tvRefract[2] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.98 );\",\n    \"\tvReflectionFactor = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( I ), worldNormal ), mFresnelPower );\",\n    \"\tgl_Position = projectionMatrix * mvPosition;\",\n    \"}\"\n  ].join(\"\\n\"),\n  fragmentShader: [\n    \"uniform samplerCube tCube;\",\n    \"varying vec3 vReflect;\",\n    \"varying vec3 vRefract[3];\",\n    \"varying float vReflectionFactor;\",\n    \"void main() {\",\n    \"\tvec4 reflectedColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );\",\n    \"\tvec4 refractedColor = vec4( 1.0 );\",\n    \"\trefractedColor.r = textureCube( tCube, vec3( -vRefract[0].x, vRefract[0].yz ) ).r;\",\n    \"\trefractedColor.g = textureCube( tCube, vec3( -vRefract[1].x, vRefract[1].yz ) ).g;\",\n    \"\trefractedColor.b = textureCube( tCube, vec3( -vRefract[2].x, vRefract[2].yz ) ).b;\",\n    \"\tgl_FragColor = mix( refractedColor, reflectedColor, clamp( vReflectionFactor, 0.0, 1.0 ) );\",\n    \"}\"\n  ].join(\"\\n\")\n};\nexport {\n  FresnelShader\n};\n"]},"metadata":{},"sourceType":"module"}