{"ast":null,"code":"import _classCallCheck from \"/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _assertThisInitialized from \"/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { Mesh, Vector3, Color, FrontSide, Plane, Matrix4, Vector4, PerspectiveCamera, WebGLRenderTarget, UniformsUtils, UniformsLib, ShaderMaterial } from \"three\";\n\nvar Water = /*#__PURE__*/function (_Mesh) {\n  _inherits(Water, _Mesh);\n\n  var _super = _createSuper(Water);\n\n  function Water(geometry) {\n    var _this;\n\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Water);\n\n    _this = _super.call(this, geometry);\n    _this.isWater = true;\n\n    var scope = _assertThisInitialized(_this);\n\n    var textureWidth = options.textureWidth !== void 0 ? options.textureWidth : 512;\n    var textureHeight = options.textureHeight !== void 0 ? options.textureHeight : 512;\n    var clipBias = options.clipBias !== void 0 ? options.clipBias : 0;\n    var alpha = options.alpha !== void 0 ? options.alpha : 1;\n    var time = options.time !== void 0 ? options.time : 0;\n    var normalSampler = options.waterNormals !== void 0 ? options.waterNormals : null;\n    var sunDirection = options.sunDirection !== void 0 ? options.sunDirection : new Vector3(0.70707, 0.70707, 0);\n    var sunColor = new Color(options.sunColor !== void 0 ? options.sunColor : 16777215);\n    var waterColor = new Color(options.waterColor !== void 0 ? options.waterColor : 8355711);\n    var eye = options.eye !== void 0 ? options.eye : new Vector3(0, 0, 0);\n    var distortionScale = options.distortionScale !== void 0 ? options.distortionScale : 20;\n    var side = options.side !== void 0 ? options.side : FrontSide;\n    var fog = options.fog !== void 0 ? options.fog : false;\n    var mirrorPlane = new Plane();\n    var normal = new Vector3();\n    var mirrorWorldPosition = new Vector3();\n    var cameraWorldPosition = new Vector3();\n    var rotationMatrix = new Matrix4();\n    var lookAtPosition = new Vector3(0, 0, -1);\n    var clipPlane = new Vector4();\n    var view = new Vector3();\n    var target = new Vector3();\n    var q = new Vector4();\n    var textureMatrix = new Matrix4();\n    var mirrorCamera = new PerspectiveCamera();\n    var renderTarget = new WebGLRenderTarget(textureWidth, textureHeight);\n    var mirrorShader = {\n      uniforms: UniformsUtils.merge([UniformsLib[\"fog\"], UniformsLib[\"lights\"], {\n        normalSampler: {\n          value: null\n        },\n        mirrorSampler: {\n          value: null\n        },\n        alpha: {\n          value: 1\n        },\n        time: {\n          value: 0\n        },\n        size: {\n          value: 1\n        },\n        distortionScale: {\n          value: 20\n        },\n        textureMatrix: {\n          value: new Matrix4()\n        },\n        sunColor: {\n          value: new Color(8355711)\n        },\n        sunDirection: {\n          value: new Vector3(0.70707, 0.70707, 0)\n        },\n        eye: {\n          value: new Vector3()\n        },\n        waterColor: {\n          value: new Color(5592405)\n        }\n      }]),\n      vertexShader:\n      /* glsl */\n      \"\\n\\t\\t\\t\\tuniform mat4 textureMatrix;\\n\\t\\t\\t\\tuniform float time;\\n\\n\\t\\t\\t\\tvarying vec4 mirrorCoord;\\n\\t\\t\\t\\tvarying vec4 worldPosition;\\n\\n\\t\\t\\t\\t#include <common>\\n\\t\\t\\t\\t#include <fog_pars_vertex>\\n\\t\\t\\t\\t#include <shadowmap_pars_vertex>\\n\\t\\t\\t\\t#include <logdepthbuf_pars_vertex>\\n\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tmirrorCoord = modelMatrix * vec4( position, 1.0 );\\n\\t\\t\\t\\t\\tworldPosition = mirrorCoord.xyzw;\\n\\t\\t\\t\\t\\tmirrorCoord = textureMatrix * mirrorCoord;\\n\\t\\t\\t\\t\\tvec4 mvPosition =  modelViewMatrix * vec4( position, 1.0 );\\n\\t\\t\\t\\t\\tgl_Position = projectionMatrix * mvPosition;\\n\\n\\t\\t\\t\\t#include <beginnormal_vertex>\\n\\t\\t\\t\\t#include <defaultnormal_vertex>\\n\\t\\t\\t\\t#include <logdepthbuf_vertex>\\n\\t\\t\\t\\t#include <fog_vertex>\\n\\t\\t\\t\\t#include <shadowmap_vertex>\\n\\t\\t\\t}\",\n      fragmentShader:\n      /* glsl */\n      \"\\n\\t\\t\\t\\tuniform sampler2D mirrorSampler;\\n\\t\\t\\t\\tuniform float alpha;\\n\\t\\t\\t\\tuniform float time;\\n\\t\\t\\t\\tuniform float size;\\n\\t\\t\\t\\tuniform float distortionScale;\\n\\t\\t\\t\\tuniform sampler2D normalSampler;\\n\\t\\t\\t\\tuniform vec3 sunColor;\\n\\t\\t\\t\\tuniform vec3 sunDirection;\\n\\t\\t\\t\\tuniform vec3 eye;\\n\\t\\t\\t\\tuniform vec3 waterColor;\\n\\n\\t\\t\\t\\tvarying vec4 mirrorCoord;\\n\\t\\t\\t\\tvarying vec4 worldPosition;\\n\\n\\t\\t\\t\\tvec4 getNoise( vec2 uv ) {\\n\\t\\t\\t\\t\\tvec2 uv0 = ( uv / 103.0 ) + vec2(time / 17.0, time / 29.0);\\n\\t\\t\\t\\t\\tvec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0 );\\n\\t\\t\\t\\t\\tvec2 uv2 = uv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );\\n\\t\\t\\t\\t\\tvec2 uv3 = uv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );\\n\\t\\t\\t\\t\\tvec4 noise = texture2D( normalSampler, uv0 ) +\\n\\t\\t\\t\\t\\t\\ttexture2D( normalSampler, uv1 ) +\\n\\t\\t\\t\\t\\t\\ttexture2D( normalSampler, uv2 ) +\\n\\t\\t\\t\\t\\t\\ttexture2D( normalSampler, uv3 );\\n\\t\\t\\t\\t\\treturn noise * 0.5 - 1.0;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvoid sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor ) {\\n\\t\\t\\t\\t\\tvec3 reflection = normalize( reflect( -sunDirection, surfaceNormal ) );\\n\\t\\t\\t\\t\\tfloat direction = max( 0.0, dot( eyeDirection, reflection ) );\\n\\t\\t\\t\\t\\tspecularColor += pow( direction, shiny ) * sunColor * spec;\\n\\t\\t\\t\\t\\tdiffuseColor += max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t#include <common>\\n\\t\\t\\t\\t#include <packing>\\n\\t\\t\\t\\t#include <bsdfs>\\n\\t\\t\\t\\t#include <fog_pars_fragment>\\n\\t\\t\\t\\t#include <logdepthbuf_pars_fragment>\\n\\t\\t\\t\\t#include <lights_pars_begin>\\n\\t\\t\\t\\t#include <shadowmap_pars_fragment>\\n\\t\\t\\t\\t#include <shadowmask_pars_fragment>\\n\\n\\t\\t\\t\\tvoid main() {\\n\\n\\t\\t\\t\\t\\t#include <logdepthbuf_fragment>\\n\\t\\t\\t\\t\\tvec4 noise = getNoise( worldPosition.xz * size );\\n\\t\\t\\t\\t\\tvec3 surfaceNormal = normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) );\\n\\n\\t\\t\\t\\t\\tvec3 diffuseLight = vec3(0.0);\\n\\t\\t\\t\\t\\tvec3 specularLight = vec3(0.0);\\n\\n\\t\\t\\t\\t\\tvec3 worldToEye = eye-worldPosition.xyz;\\n\\t\\t\\t\\t\\tvec3 eyeDirection = normalize( worldToEye );\\n\\t\\t\\t\\t\\tsunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );\\n\\n\\t\\t\\t\\t\\tfloat distance = length(worldToEye);\\n\\n\\t\\t\\t\\t\\tvec2 distortion = surfaceNormal.xz * ( 0.001 + 1.0 / distance ) * distortionScale;\\n\\t\\t\\t\\t\\tvec3 reflectionSample = vec3( texture2D( mirrorSampler, mirrorCoord.xy / mirrorCoord.w + distortion ) );\\n\\n\\t\\t\\t\\t\\tfloat theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );\\n\\t\\t\\t\\t\\tfloat rf0 = 0.3;\\n\\t\\t\\t\\t\\tfloat reflectance = rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 5.0 );\\n\\t\\t\\t\\t\\tvec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;\\n\\t\\t\\t\\t\\tvec3 albedo = mix( ( sunColor * diffuseLight * 0.3 + scatter ) * getShadowMask(), ( vec3( 0.1 ) + reflectionSample * 0.9 + reflectionSample * specularLight ), reflectance);\\n\\t\\t\\t\\t\\tvec3 outgoingLight = albedo;\\n\\t\\t\\t\\t\\tgl_FragColor = vec4( outgoingLight, alpha );\\n\\n\\t\\t\\t\\t\\t#include <tonemapping_fragment>\\n\\t\\t\\t\\t\\t#include <encodings_fragment>\\n\\t\\t\\t\\t\\t#include <fog_fragment>\\t\\n\\t\\t\\t\\t}\"\n    };\n    var material = new ShaderMaterial({\n      fragmentShader: mirrorShader.fragmentShader,\n      vertexShader: mirrorShader.vertexShader,\n      uniforms: UniformsUtils.clone(mirrorShader.uniforms),\n      lights: true,\n      side: side,\n      fog: fog\n    });\n    material.uniforms[\"mirrorSampler\"].value = renderTarget.texture;\n    material.uniforms[\"textureMatrix\"].value = textureMatrix;\n    material.uniforms[\"alpha\"].value = alpha;\n    material.uniforms[\"time\"].value = time;\n    material.uniforms[\"normalSampler\"].value = normalSampler;\n    material.uniforms[\"sunColor\"].value = sunColor;\n    material.uniforms[\"waterColor\"].value = waterColor;\n    material.uniforms[\"sunDirection\"].value = sunDirection;\n    material.uniforms[\"distortionScale\"].value = distortionScale;\n    material.uniforms[\"eye\"].value = eye;\n    scope.material = material;\n\n    scope.onBeforeRender = function (renderer, scene, camera) {\n      mirrorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n      rotationMatrix.extractRotation(scope.matrixWorld);\n      normal.set(0, 0, 1);\n      normal.applyMatrix4(rotationMatrix);\n      view.subVectors(mirrorWorldPosition, cameraWorldPosition);\n      if (view.dot(normal) > 0) return;\n      view.reflect(normal).negate();\n      view.add(mirrorWorldPosition);\n      rotationMatrix.extractRotation(camera.matrixWorld);\n      lookAtPosition.set(0, 0, -1);\n      lookAtPosition.applyMatrix4(rotationMatrix);\n      lookAtPosition.add(cameraWorldPosition);\n      target.subVectors(mirrorWorldPosition, lookAtPosition);\n      target.reflect(normal).negate();\n      target.add(mirrorWorldPosition);\n      mirrorCamera.position.copy(view);\n      mirrorCamera.up.set(0, 1, 0);\n      mirrorCamera.up.applyMatrix4(rotationMatrix);\n      mirrorCamera.up.reflect(normal);\n      mirrorCamera.lookAt(target);\n      mirrorCamera.far = camera.far;\n      mirrorCamera.updateMatrixWorld();\n      mirrorCamera.projectionMatrix.copy(camera.projectionMatrix);\n      textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);\n      textureMatrix.multiply(mirrorCamera.projectionMatrix);\n      textureMatrix.multiply(mirrorCamera.matrixWorldInverse);\n      mirrorPlane.setFromNormalAndCoplanarPoint(normal, mirrorWorldPosition);\n      mirrorPlane.applyMatrix4(mirrorCamera.matrixWorldInverse);\n      clipPlane.set(mirrorPlane.normal.x, mirrorPlane.normal.y, mirrorPlane.normal.z, mirrorPlane.constant);\n      var projectionMatrix = mirrorCamera.projectionMatrix;\n      q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n      q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n      q.z = -1;\n      q.w = (1 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];\n      clipPlane.multiplyScalar(2 / clipPlane.dot(q));\n      projectionMatrix.elements[2] = clipPlane.x;\n      projectionMatrix.elements[6] = clipPlane.y;\n      projectionMatrix.elements[10] = clipPlane.z + 1 - clipBias;\n      projectionMatrix.elements[14] = clipPlane.w;\n      eye.setFromMatrixPosition(camera.matrixWorld);\n      var currentRenderTarget = renderer.getRenderTarget();\n      var currentXrEnabled = renderer.xr.enabled;\n      var currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n      scope.visible = false;\n      renderer.xr.enabled = false;\n      renderer.shadowMap.autoUpdate = false;\n      renderer.setRenderTarget(renderTarget);\n      renderer.state.buffers.depth.setMask(true);\n      if (renderer.autoClear === false) renderer.clear();\n      renderer.render(scene, mirrorCamera);\n      scope.visible = true;\n      renderer.xr.enabled = currentXrEnabled;\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n      renderer.setRenderTarget(currentRenderTarget);\n      var viewport = camera.viewport;\n\n      if (viewport !== void 0) {\n        renderer.state.viewport(viewport);\n      }\n    };\n\n    return _this;\n  }\n\n  return Water;\n}(Mesh);\n\nexport { Water };","map":{"version":3,"sources":["/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/three-stdlib/objects/Water.js"],"names":["Mesh","Vector3","Color","FrontSide","Plane","Matrix4","Vector4","PerspectiveCamera","WebGLRenderTarget","UniformsUtils","UniformsLib","ShaderMaterial","Water","geometry","options","isWater","scope","textureWidth","textureHeight","clipBias","alpha","time","normalSampler","waterNormals","sunDirection","sunColor","waterColor","eye","distortionScale","side","fog","mirrorPlane","normal","mirrorWorldPosition","cameraWorldPosition","rotationMatrix","lookAtPosition","clipPlane","view","target","q","textureMatrix","mirrorCamera","renderTarget","mirrorShader","uniforms","merge","value","mirrorSampler","size","vertexShader","fragmentShader","material","clone","lights","texture","onBeforeRender","renderer","scene","camera","setFromMatrixPosition","matrixWorld","extractRotation","set","applyMatrix4","subVectors","dot","reflect","negate","add","position","copy","up","lookAt","far","updateMatrixWorld","projectionMatrix","multiply","matrixWorldInverse","setFromNormalAndCoplanarPoint","x","y","z","constant","Math","sign","elements","w","multiplyScalar","currentRenderTarget","getRenderTarget","currentXrEnabled","xr","enabled","currentShadowAutoUpdate","shadowMap","autoUpdate","visible","setRenderTarget","state","buffers","depth","setMask","autoClear","clear","render","viewport"],"mappings":"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","sourcesContent":["import { Mesh, Vector3, Color, FrontSide, Plane, Matrix4, Vector4, PerspectiveCamera, WebGLRenderTarget, UniformsUtils, UniformsLib, ShaderMaterial } from \"three\";\nclass Water extends Mesh {\n  constructor(geometry, options = {}) {\n    super(geometry);\n    this.isWater = true;\n    const scope = this;\n    const textureWidth = options.textureWidth !== void 0 ? options.textureWidth : 512;\n    const textureHeight = options.textureHeight !== void 0 ? options.textureHeight : 512;\n    const clipBias = options.clipBias !== void 0 ? options.clipBias : 0;\n    const alpha = options.alpha !== void 0 ? options.alpha : 1;\n    const time = options.time !== void 0 ? options.time : 0;\n    const normalSampler = options.waterNormals !== void 0 ? options.waterNormals : null;\n    const sunDirection = options.sunDirection !== void 0 ? options.sunDirection : new Vector3(0.70707, 0.70707, 0);\n    const sunColor = new Color(options.sunColor !== void 0 ? options.sunColor : 16777215);\n    const waterColor = new Color(options.waterColor !== void 0 ? options.waterColor : 8355711);\n    const eye = options.eye !== void 0 ? options.eye : new Vector3(0, 0, 0);\n    const distortionScale = options.distortionScale !== void 0 ? options.distortionScale : 20;\n    const side = options.side !== void 0 ? options.side : FrontSide;\n    const fog = options.fog !== void 0 ? options.fog : false;\n    const mirrorPlane = new Plane();\n    const normal = new Vector3();\n    const mirrorWorldPosition = new Vector3();\n    const cameraWorldPosition = new Vector3();\n    const rotationMatrix = new Matrix4();\n    const lookAtPosition = new Vector3(0, 0, -1);\n    const clipPlane = new Vector4();\n    const view = new Vector3();\n    const target = new Vector3();\n    const q = new Vector4();\n    const textureMatrix = new Matrix4();\n    const mirrorCamera = new PerspectiveCamera();\n    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight);\n    const mirrorShader = {\n      uniforms: UniformsUtils.merge([\n        UniformsLib[\"fog\"],\n        UniformsLib[\"lights\"],\n        {\n          normalSampler: { value: null },\n          mirrorSampler: { value: null },\n          alpha: { value: 1 },\n          time: { value: 0 },\n          size: { value: 1 },\n          distortionScale: { value: 20 },\n          textureMatrix: { value: new Matrix4() },\n          sunColor: { value: new Color(8355711) },\n          sunDirection: { value: new Vector3(0.70707, 0.70707, 0) },\n          eye: { value: new Vector3() },\n          waterColor: { value: new Color(5592405) }\n        }\n      ]),\n      vertexShader: (\n        /* glsl */\n        `\n\t\t\t\tuniform mat4 textureMatrix;\n\t\t\t\tuniform float time;\n\n\t\t\t\tvarying vec4 mirrorCoord;\n\t\t\t\tvarying vec4 worldPosition;\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <fog_pars_vertex>\n\t\t\t\t#include <shadowmap_pars_vertex>\n\t\t\t\t#include <logdepthbuf_pars_vertex>\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tmirrorCoord = modelMatrix * vec4( position, 1.0 );\n\t\t\t\t\tworldPosition = mirrorCoord.xyzw;\n\t\t\t\t\tmirrorCoord = textureMatrix * mirrorCoord;\n\t\t\t\t\tvec4 mvPosition =  modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t\t#include <beginnormal_vertex>\n\t\t\t\t#include <defaultnormal_vertex>\n\t\t\t\t#include <logdepthbuf_vertex>\n\t\t\t\t#include <fog_vertex>\n\t\t\t\t#include <shadowmap_vertex>\n\t\t\t}`\n      ),\n      fragmentShader: (\n        /* glsl */\n        `\n\t\t\t\tuniform sampler2D mirrorSampler;\n\t\t\t\tuniform float alpha;\n\t\t\t\tuniform float time;\n\t\t\t\tuniform float size;\n\t\t\t\tuniform float distortionScale;\n\t\t\t\tuniform sampler2D normalSampler;\n\t\t\t\tuniform vec3 sunColor;\n\t\t\t\tuniform vec3 sunDirection;\n\t\t\t\tuniform vec3 eye;\n\t\t\t\tuniform vec3 waterColor;\n\n\t\t\t\tvarying vec4 mirrorCoord;\n\t\t\t\tvarying vec4 worldPosition;\n\n\t\t\t\tvec4 getNoise( vec2 uv ) {\n\t\t\t\t\tvec2 uv0 = ( uv / 103.0 ) + vec2(time / 17.0, time / 29.0);\n\t\t\t\t\tvec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0 );\n\t\t\t\t\tvec2 uv2 = uv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );\n\t\t\t\t\tvec2 uv3 = uv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );\n\t\t\t\t\tvec4 noise = texture2D( normalSampler, uv0 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv1 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv2 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv3 );\n\t\t\t\t\treturn noise * 0.5 - 1.0;\n\t\t\t\t}\n\n\t\t\t\tvoid sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor ) {\n\t\t\t\t\tvec3 reflection = normalize( reflect( -sunDirection, surfaceNormal ) );\n\t\t\t\t\tfloat direction = max( 0.0, dot( eyeDirection, reflection ) );\n\t\t\t\t\tspecularColor += pow( direction, shiny ) * sunColor * spec;\n\t\t\t\t\tdiffuseColor += max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;\n\t\t\t\t}\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <packing>\n\t\t\t\t#include <bsdfs>\n\t\t\t\t#include <fog_pars_fragment>\n\t\t\t\t#include <logdepthbuf_pars_fragment>\n\t\t\t\t#include <lights_pars_begin>\n\t\t\t\t#include <shadowmap_pars_fragment>\n\t\t\t\t#include <shadowmask_pars_fragment>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t#include <logdepthbuf_fragment>\n\t\t\t\t\tvec4 noise = getNoise( worldPosition.xz * size );\n\t\t\t\t\tvec3 surfaceNormal = normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) );\n\n\t\t\t\t\tvec3 diffuseLight = vec3(0.0);\n\t\t\t\t\tvec3 specularLight = vec3(0.0);\n\n\t\t\t\t\tvec3 worldToEye = eye-worldPosition.xyz;\n\t\t\t\t\tvec3 eyeDirection = normalize( worldToEye );\n\t\t\t\t\tsunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );\n\n\t\t\t\t\tfloat distance = length(worldToEye);\n\n\t\t\t\t\tvec2 distortion = surfaceNormal.xz * ( 0.001 + 1.0 / distance ) * distortionScale;\n\t\t\t\t\tvec3 reflectionSample = vec3( texture2D( mirrorSampler, mirrorCoord.xy / mirrorCoord.w + distortion ) );\n\n\t\t\t\t\tfloat theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );\n\t\t\t\t\tfloat rf0 = 0.3;\n\t\t\t\t\tfloat reflectance = rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 5.0 );\n\t\t\t\t\tvec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;\n\t\t\t\t\tvec3 albedo = mix( ( sunColor * diffuseLight * 0.3 + scatter ) * getShadowMask(), ( vec3( 0.1 ) + reflectionSample * 0.9 + reflectionSample * specularLight ), reflectance);\n\t\t\t\t\tvec3 outgoingLight = albedo;\n\t\t\t\t\tgl_FragColor = vec4( outgoingLight, alpha );\n\n\t\t\t\t\t#include <tonemapping_fragment>\n\t\t\t\t\t#include <encodings_fragment>\n\t\t\t\t\t#include <fog_fragment>\t\n\t\t\t\t}`\n      )\n    };\n    const material = new ShaderMaterial({\n      fragmentShader: mirrorShader.fragmentShader,\n      vertexShader: mirrorShader.vertexShader,\n      uniforms: UniformsUtils.clone(mirrorShader.uniforms),\n      lights: true,\n      side,\n      fog\n    });\n    material.uniforms[\"mirrorSampler\"].value = renderTarget.texture;\n    material.uniforms[\"textureMatrix\"].value = textureMatrix;\n    material.uniforms[\"alpha\"].value = alpha;\n    material.uniforms[\"time\"].value = time;\n    material.uniforms[\"normalSampler\"].value = normalSampler;\n    material.uniforms[\"sunColor\"].value = sunColor;\n    material.uniforms[\"waterColor\"].value = waterColor;\n    material.uniforms[\"sunDirection\"].value = sunDirection;\n    material.uniforms[\"distortionScale\"].value = distortionScale;\n    material.uniforms[\"eye\"].value = eye;\n    scope.material = material;\n    scope.onBeforeRender = function(renderer, scene, camera) {\n      mirrorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n      rotationMatrix.extractRotation(scope.matrixWorld);\n      normal.set(0, 0, 1);\n      normal.applyMatrix4(rotationMatrix);\n      view.subVectors(mirrorWorldPosition, cameraWorldPosition);\n      if (view.dot(normal) > 0)\n        return;\n      view.reflect(normal).negate();\n      view.add(mirrorWorldPosition);\n      rotationMatrix.extractRotation(camera.matrixWorld);\n      lookAtPosition.set(0, 0, -1);\n      lookAtPosition.applyMatrix4(rotationMatrix);\n      lookAtPosition.add(cameraWorldPosition);\n      target.subVectors(mirrorWorldPosition, lookAtPosition);\n      target.reflect(normal).negate();\n      target.add(mirrorWorldPosition);\n      mirrorCamera.position.copy(view);\n      mirrorCamera.up.set(0, 1, 0);\n      mirrorCamera.up.applyMatrix4(rotationMatrix);\n      mirrorCamera.up.reflect(normal);\n      mirrorCamera.lookAt(target);\n      mirrorCamera.far = camera.far;\n      mirrorCamera.updateMatrixWorld();\n      mirrorCamera.projectionMatrix.copy(camera.projectionMatrix);\n      textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);\n      textureMatrix.multiply(mirrorCamera.projectionMatrix);\n      textureMatrix.multiply(mirrorCamera.matrixWorldInverse);\n      mirrorPlane.setFromNormalAndCoplanarPoint(normal, mirrorWorldPosition);\n      mirrorPlane.applyMatrix4(mirrorCamera.matrixWorldInverse);\n      clipPlane.set(mirrorPlane.normal.x, mirrorPlane.normal.y, mirrorPlane.normal.z, mirrorPlane.constant);\n      const projectionMatrix = mirrorCamera.projectionMatrix;\n      q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n      q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n      q.z = -1;\n      q.w = (1 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];\n      clipPlane.multiplyScalar(2 / clipPlane.dot(q));\n      projectionMatrix.elements[2] = clipPlane.x;\n      projectionMatrix.elements[6] = clipPlane.y;\n      projectionMatrix.elements[10] = clipPlane.z + 1 - clipBias;\n      projectionMatrix.elements[14] = clipPlane.w;\n      eye.setFromMatrixPosition(camera.matrixWorld);\n      const currentRenderTarget = renderer.getRenderTarget();\n      const currentXrEnabled = renderer.xr.enabled;\n      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n      scope.visible = false;\n      renderer.xr.enabled = false;\n      renderer.shadowMap.autoUpdate = false;\n      renderer.setRenderTarget(renderTarget);\n      renderer.state.buffers.depth.setMask(true);\n      if (renderer.autoClear === false)\n        renderer.clear();\n      renderer.render(scene, mirrorCamera);\n      scope.visible = true;\n      renderer.xr.enabled = currentXrEnabled;\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n      renderer.setRenderTarget(currentRenderTarget);\n      const viewport = camera.viewport;\n      if (viewport !== void 0) {\n        renderer.state.viewport(viewport);\n      }\n    };\n  }\n}\nexport {\n  Water\n};\n"]},"metadata":{},"sourceType":"module"}