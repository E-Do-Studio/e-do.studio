{"ast":null,"code":"import { Vector3, Color } from \"three\";\nconst GodRaysDepthMaskShader = {\n  uniforms: {\n    tInput: {\n      value: null\n    }\n  },\n  vertexShader: [\"varying vec2 vUv;\", \"void main() {\", \" vUv = uv;\", \" gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n  fragmentShader: [\"varying vec2 vUv;\", \"uniform sampler2D tInput;\", \"void main() {\", \"\tgl_FragColor = vec4( 1.0 ) - texture2D( tInput, vUv );\", \"}\"].join(\"\\n\")\n};\nconst GodRaysGenerateShader = {\n  uniforms: {\n    tInput: {\n      value: null\n    },\n    fStepSize: {\n      value: 1\n    },\n    vSunPositionScreenSpace: {\n      value: /* @__PURE__ */new Vector3()\n    }\n  },\n  vertexShader: [\"varying vec2 vUv;\", \"void main() {\", \" vUv = uv;\", \" gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n  fragmentShader: [\"#define TAPS_PER_PASS 6.0\", \"varying vec2 vUv;\", \"uniform sampler2D tInput;\", \"uniform vec3 vSunPositionScreenSpace;\", \"uniform float fStepSize;\", // filter step size\n  \"void main() {\", // delta from current pixel to \"sun\" position\n  \"\tvec2 delta = vSunPositionScreenSpace.xy - vUv;\", \"\tfloat dist = length( delta );\", // Step vector (uv space)\n  \"\tvec2 stepv = fStepSize * delta / dist;\", // Number of iterations between pixel and sun\n  \"\tfloat iters = dist/fStepSize;\", \"\tvec2 uv = vUv.xy;\", \"\tfloat col = 0.0;\", // This breaks ANGLE in Chrome 22\n  //\t- see http://code.google.com/p/chromium/issues/detail?id=153105\n\n  /*\n  \t\t// Unrolling didnt do much on my hardware (ATI Mobility Radeon 3450),\n  \t\t// so i've just left the loop\n  \n  \t\t\"for ( float i = 0.0; i < TAPS_PER_PASS; i += 1.0 ) {\",\n  \n  \t\t// Accumulate samples, making sure we dont walk past the light source.\n  \n  \t\t// The check for uv.y < 1 would not be necessary with \"border\" UV wrap\n  \t\t// mode, with a black border color. I don't think this is currently\n  \t\t// exposed by three.js. As a result there might be artifacts when the\n  \t\t// sun is to the left, right or bottom of screen as these cases are\n  \t\t// not specifically handled.\n  \n  \t\t\"\tcol += ( i <= iters && uv.y < 1.0 ? texture2D( tInput, uv ).r : 0.0 );\",\n  \t\t\"\tuv += stepv;\",\n  \n  \t\t\"}\",\n  \t\t*/\n  // Unrolling loop manually makes it work in ANGLE\n  \"\tfloat f = min( 1.0, max( vSunPositionScreenSpace.z / 1000.0, 0.0 ) );\", // used to fade out godrays\n  \"\tif ( 0.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;\", \"\tuv += stepv;\", \"\tif ( 1.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;\", \"\tuv += stepv;\", \"\tif ( 2.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;\", \"\tuv += stepv;\", \"\tif ( 3.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;\", \"\tuv += stepv;\", \"\tif ( 4.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;\", \"\tuv += stepv;\", \"\tif ( 5.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;\", \"\tuv += stepv;\", // Should technically be dividing by 'iters', but 'TAPS_PER_PASS' smooths out\n  // objectionable artifacts, in particular near the sun position. The side\n  // effect is that the result is darker than it should be around the sun, as\n  // TAPS_PER_PASS is greater than the number of samples actually accumulated.\n  // When the result is inverted (in the shader 'godrays_combine', this produces\n  // a slight bright spot at the position of the sun, even when it is occluded.\n  \"\tgl_FragColor = vec4( col/TAPS_PER_PASS );\", \"\tgl_FragColor.a = 1.0;\", \"}\"].join(\"\\n\")\n};\nconst GodRaysCombineShader = {\n  uniforms: {\n    tColors: {\n      value: null\n    },\n    tGodRays: {\n      value: null\n    },\n    fGodRayIntensity: {\n      value: 0.69\n    }\n  },\n  vertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"\tvUv = uv;\", \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n  fragmentShader: [\"varying vec2 vUv;\", \"uniform sampler2D tColors;\", \"uniform sampler2D tGodRays;\", \"uniform float fGodRayIntensity;\", \"void main() {\", // Since THREE.MeshDepthMaterial renders foreground objects white and background\n  // objects black, the god-rays will be white streaks. Therefore value is inverted\n  // before being combined with tColors\n  \"\tgl_FragColor = texture2D( tColors, vUv ) + fGodRayIntensity * vec4( 1.0 - texture2D( tGodRays, vUv ).r );\", \"\tgl_FragColor.a = 1.0;\", \"}\"].join(\"\\n\")\n};\nconst GodRaysFakeSunShader = {\n  uniforms: {\n    vSunPositionScreenSpace: {\n      value: /* @__PURE__ */new Vector3()\n    },\n    fAspect: {\n      value: 1\n    },\n    sunColor: {\n      value: /* @__PURE__ */new Color(16772608)\n    },\n    bgColor: {\n      value: /* @__PURE__ */new Color(0)\n    }\n  },\n  vertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"\tvUv = uv;\", \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n  fragmentShader: [\"varying vec2 vUv;\", \"uniform vec3 vSunPositionScreenSpace;\", \"uniform float fAspect;\", \"uniform vec3 sunColor;\", \"uniform vec3 bgColor;\", \"void main() {\", \"\tvec2 diff = vUv - vSunPositionScreenSpace.xy;\", // Correct for aspect ratio\n  \"\tdiff.x *= fAspect;\", \"\tfloat prop = clamp( length( diff ) / 0.5, 0.0, 1.0 );\", \"\tprop = 0.35 * pow( 1.0 - prop, 3.0 );\", \"\tgl_FragColor.xyz = ( vSunPositionScreenSpace.z > 0.0 ) ? mix( sunColor, bgColor, 1.0 - prop ) : bgColor;\", \"\tgl_FragColor.w = 1.0;\", \"}\"].join(\"\\n\")\n};\nexport { GodRaysCombineShader, GodRaysDepthMaskShader, GodRaysFakeSunShader, GodRaysGenerateShader };","map":{"version":3,"sources":["/Users/theodaguier/_workdir/dev/pro/e-do/E-Do-Studio/node_modules/three-stdlib/shaders/GodRaysShader.js"],"names":["Vector3","Color","GodRaysDepthMaskShader","uniforms","tInput","value","vertexShader","join","fragmentShader","GodRaysGenerateShader","fStepSize","vSunPositionScreenSpace","GodRaysCombineShader","tColors","tGodRays","fGodRayIntensity","GodRaysFakeSunShader","fAspect","sunColor","bgColor"],"mappings":"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","sourcesContent":["import { Vector3, Color } from \"three\";\nconst GodRaysDepthMaskShader = {\n  uniforms: {\n    tInput: {\n      value: null\n    }\n  },\n  vertexShader: [\n    \"varying vec2 vUv;\",\n    \"void main() {\",\n    \" vUv = uv;\",\n    \" gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n    \"}\"\n  ].join(\"\\n\"),\n  fragmentShader: [\n    \"varying vec2 vUv;\",\n    \"uniform sampler2D tInput;\",\n    \"void main() {\",\n    \"\tgl_FragColor = vec4( 1.0 ) - texture2D( tInput, vUv );\",\n    \"}\"\n  ].join(\"\\n\")\n};\nconst GodRaysGenerateShader = {\n  uniforms: {\n    tInput: {\n      value: null\n    },\n    fStepSize: {\n      value: 1\n    },\n    vSunPositionScreenSpace: {\n      value: /* @__PURE__ */ new Vector3()\n    }\n  },\n  vertexShader: [\n    \"varying vec2 vUv;\",\n    \"void main() {\",\n    \" vUv = uv;\",\n    \" gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n    \"}\"\n  ].join(\"\\n\"),\n  fragmentShader: [\n    \"#define TAPS_PER_PASS 6.0\",\n    \"varying vec2 vUv;\",\n    \"uniform sampler2D tInput;\",\n    \"uniform vec3 vSunPositionScreenSpace;\",\n    \"uniform float fStepSize;\",\n    // filter step size\n    \"void main() {\",\n    // delta from current pixel to \"sun\" position\n    \"\tvec2 delta = vSunPositionScreenSpace.xy - vUv;\",\n    \"\tfloat dist = length( delta );\",\n    // Step vector (uv space)\n    \"\tvec2 stepv = fStepSize * delta / dist;\",\n    // Number of iterations between pixel and sun\n    \"\tfloat iters = dist/fStepSize;\",\n    \"\tvec2 uv = vUv.xy;\",\n    \"\tfloat col = 0.0;\",\n    // This breaks ANGLE in Chrome 22\n    //\t- see http://code.google.com/p/chromium/issues/detail?id=153105\n    /*\n    \t\t// Unrolling didnt do much on my hardware (ATI Mobility Radeon 3450),\n    \t\t// so i've just left the loop\n    \n    \t\t\"for ( float i = 0.0; i < TAPS_PER_PASS; i += 1.0 ) {\",\n    \n    \t\t// Accumulate samples, making sure we dont walk past the light source.\n    \n    \t\t// The check for uv.y < 1 would not be necessary with \"border\" UV wrap\n    \t\t// mode, with a black border color. I don't think this is currently\n    \t\t// exposed by three.js. As a result there might be artifacts when the\n    \t\t// sun is to the left, right or bottom of screen as these cases are\n    \t\t// not specifically handled.\n    \n    \t\t\"\tcol += ( i <= iters && uv.y < 1.0 ? texture2D( tInput, uv ).r : 0.0 );\",\n    \t\t\"\tuv += stepv;\",\n    \n    \t\t\"}\",\n    \t\t*/\n    // Unrolling loop manually makes it work in ANGLE\n    \"\tfloat f = min( 1.0, max( vSunPositionScreenSpace.z / 1000.0, 0.0 ) );\",\n    // used to fade out godrays\n    \"\tif ( 0.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;\",\n    \"\tuv += stepv;\",\n    \"\tif ( 1.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;\",\n    \"\tuv += stepv;\",\n    \"\tif ( 2.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;\",\n    \"\tuv += stepv;\",\n    \"\tif ( 3.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;\",\n    \"\tuv += stepv;\",\n    \"\tif ( 4.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;\",\n    \"\tuv += stepv;\",\n    \"\tif ( 5.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;\",\n    \"\tuv += stepv;\",\n    // Should technically be dividing by 'iters', but 'TAPS_PER_PASS' smooths out\n    // objectionable artifacts, in particular near the sun position. The side\n    // effect is that the result is darker than it should be around the sun, as\n    // TAPS_PER_PASS is greater than the number of samples actually accumulated.\n    // When the result is inverted (in the shader 'godrays_combine', this produces\n    // a slight bright spot at the position of the sun, even when it is occluded.\n    \"\tgl_FragColor = vec4( col/TAPS_PER_PASS );\",\n    \"\tgl_FragColor.a = 1.0;\",\n    \"}\"\n  ].join(\"\\n\")\n};\nconst GodRaysCombineShader = {\n  uniforms: {\n    tColors: {\n      value: null\n    },\n    tGodRays: {\n      value: null\n    },\n    fGodRayIntensity: {\n      value: 0.69\n    }\n  },\n  vertexShader: [\n    \"varying vec2 vUv;\",\n    \"void main() {\",\n    \"\tvUv = uv;\",\n    \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n    \"}\"\n  ].join(\"\\n\"),\n  fragmentShader: [\n    \"varying vec2 vUv;\",\n    \"uniform sampler2D tColors;\",\n    \"uniform sampler2D tGodRays;\",\n    \"uniform float fGodRayIntensity;\",\n    \"void main() {\",\n    // Since THREE.MeshDepthMaterial renders foreground objects white and background\n    // objects black, the god-rays will be white streaks. Therefore value is inverted\n    // before being combined with tColors\n    \"\tgl_FragColor = texture2D( tColors, vUv ) + fGodRayIntensity * vec4( 1.0 - texture2D( tGodRays, vUv ).r );\",\n    \"\tgl_FragColor.a = 1.0;\",\n    \"}\"\n  ].join(\"\\n\")\n};\nconst GodRaysFakeSunShader = {\n  uniforms: {\n    vSunPositionScreenSpace: {\n      value: /* @__PURE__ */ new Vector3()\n    },\n    fAspect: {\n      value: 1\n    },\n    sunColor: {\n      value: /* @__PURE__ */ new Color(16772608)\n    },\n    bgColor: {\n      value: /* @__PURE__ */ new Color(0)\n    }\n  },\n  vertexShader: [\n    \"varying vec2 vUv;\",\n    \"void main() {\",\n    \"\tvUv = uv;\",\n    \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n    \"}\"\n  ].join(\"\\n\"),\n  fragmentShader: [\n    \"varying vec2 vUv;\",\n    \"uniform vec3 vSunPositionScreenSpace;\",\n    \"uniform float fAspect;\",\n    \"uniform vec3 sunColor;\",\n    \"uniform vec3 bgColor;\",\n    \"void main() {\",\n    \"\tvec2 diff = vUv - vSunPositionScreenSpace.xy;\",\n    // Correct for aspect ratio\n    \"\tdiff.x *= fAspect;\",\n    \"\tfloat prop = clamp( length( diff ) / 0.5, 0.0, 1.0 );\",\n    \"\tprop = 0.35 * pow( 1.0 - prop, 3.0 );\",\n    \"\tgl_FragColor.xyz = ( vSunPositionScreenSpace.z > 0.0 ) ? mix( sunColor, bgColor, 1.0 - prop ) : bgColor;\",\n    \"\tgl_FragColor.w = 1.0;\",\n    \"}\"\n  ].join(\"\\n\")\n};\nexport {\n  GodRaysCombineShader,\n  GodRaysDepthMaskShader,\n  GodRaysFakeSunShader,\n  GodRaysGenerateShader\n};\n"]},"metadata":{},"sourceType":"module"}