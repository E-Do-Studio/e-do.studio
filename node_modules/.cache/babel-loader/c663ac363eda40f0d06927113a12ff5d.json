{"ast":null,"code":"var ToneMapShader = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    averageLuminance: {\n      value: 1\n    },\n    luminanceMap: {\n      value: null\n    },\n    maxLuminance: {\n      value: 16\n    },\n    minLuminance: {\n      value: 0.01\n    },\n    middleGrey: {\n      value: 0.6\n    }\n  },\n  vertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"\tvUv = uv;\", \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n  fragmentShader: [\"#include <common>\", \"uniform sampler2D tDiffuse;\", \"varying vec2 vUv;\", \"uniform float middleGrey;\", \"uniform float minLuminance;\", \"uniform float maxLuminance;\", \"#ifdef ADAPTED_LUMINANCE\", \"\tuniform sampler2D luminanceMap;\", \"#else\", \"\tuniform float averageLuminance;\", \"#endif\", \"vec3 ToneMap( vec3 vColor ) {\", \"\t#ifdef ADAPTED_LUMINANCE\", // Get the calculated average luminance\n  \"\t\tfloat fLumAvg = texture2D(luminanceMap, vec2(0.5, 0.5)).r;\", \"\t#else\", \"\t\tfloat fLumAvg = averageLuminance;\", \"\t#endif\", // Calculate the luminance of the current pixel\n  \"\tfloat fLumPixel = linearToRelativeLuminance( vColor );\", // Apply the modified operator (Eq. 4)\n  \"\tfloat fLumScaled = (fLumPixel * middleGrey) / max( minLuminance, fLumAvg );\", \"\tfloat fLumCompressed = (fLumScaled * (1.0 + (fLumScaled / (maxLuminance * maxLuminance)))) / (1.0 + fLumScaled);\", \"\treturn fLumCompressed * vColor;\", \"}\", \"void main() {\", \"\tvec4 texel = texture2D( tDiffuse, vUv );\", \"\tgl_FragColor = vec4( ToneMap( texel.xyz ), texel.w );\", \"}\"].join(\"\\n\")\n};\nexport { ToneMapShader };","map":{"version":3,"sources":["/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/three-stdlib/shaders/ToneMapShader.js"],"names":["ToneMapShader","uniforms","tDiffuse","value","averageLuminance","luminanceMap","maxLuminance","minLuminance","middleGrey","vertexShader","join","fragmentShader"],"mappings":"AAAA,IAAMA,aAAa,GAAG;AACpBC,EAAAA,QAAQ,EAAE;AACRC,IAAAA,QAAQ,EAAE;AAAEC,MAAAA,KAAK,EAAE;AAAT,KADF;AAERC,IAAAA,gBAAgB,EAAE;AAAED,MAAAA,KAAK,EAAE;AAAT,KAFV;AAGRE,IAAAA,YAAY,EAAE;AAAEF,MAAAA,KAAK,EAAE;AAAT,KAHN;AAIRG,IAAAA,YAAY,EAAE;AAAEH,MAAAA,KAAK,EAAE;AAAT,KAJN;AAKRI,IAAAA,YAAY,EAAE;AAAEJ,MAAAA,KAAK,EAAE;AAAT,KALN;AAMRK,IAAAA,UAAU,EAAE;AAAEL,MAAAA,KAAK,EAAE;AAAT;AANJ,GADU;AASpBM,EAAAA,YAAY,EAAE,CACZ,mBADY,EAEZ,eAFY,EAGZ,YAHY,EAIZ,4EAJY,EAKZ,GALY,EAMZC,IANY,CAMP,IANO,CATM;AAgBpBC,EAAAA,cAAc,EAAE,CACd,mBADc,EAEd,6BAFc,EAGd,mBAHc,EAId,2BAJc,EAKd,6BALc,EAMd,6BANc,EAOd,0BAPc,EAQd,kCARc,EASd,OATc,EAUd,kCAVc,EAWd,QAXc,EAYd,+BAZc,EAad,2BAbc,EAcd;AACA,gEAfc,EAgBd,QAhBc,EAiBd,qCAjBc,EAkBd,SAlBc,EAmBd;AACA,2DApBc,EAqBd;AACA,gFAtBc,EAuBd,mHAvBc,EAwBd,kCAxBc,EAyBd,GAzBc,EA0Bd,eA1Bc,EA2Bd,2CA3Bc,EA4Bd,wDA5Bc,EA6Bd,GA7Bc,EA8BdD,IA9Bc,CA8BT,IA9BS;AAhBI,CAAtB;AAgDA,SACEV,aADF","sourcesContent":["const ToneMapShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    averageLuminance: { value: 1 },\n    luminanceMap: { value: null },\n    maxLuminance: { value: 16 },\n    minLuminance: { value: 0.01 },\n    middleGrey: { value: 0.6 }\n  },\n  vertexShader: [\n    \"varying vec2 vUv;\",\n    \"void main() {\",\n    \"\tvUv = uv;\",\n    \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n    \"}\"\n  ].join(\"\\n\"),\n  fragmentShader: [\n    \"#include <common>\",\n    \"uniform sampler2D tDiffuse;\",\n    \"varying vec2 vUv;\",\n    \"uniform float middleGrey;\",\n    \"uniform float minLuminance;\",\n    \"uniform float maxLuminance;\",\n    \"#ifdef ADAPTED_LUMINANCE\",\n    \"\tuniform sampler2D luminanceMap;\",\n    \"#else\",\n    \"\tuniform float averageLuminance;\",\n    \"#endif\",\n    \"vec3 ToneMap( vec3 vColor ) {\",\n    \"\t#ifdef ADAPTED_LUMINANCE\",\n    // Get the calculated average luminance\n    \"\t\tfloat fLumAvg = texture2D(luminanceMap, vec2(0.5, 0.5)).r;\",\n    \"\t#else\",\n    \"\t\tfloat fLumAvg = averageLuminance;\",\n    \"\t#endif\",\n    // Calculate the luminance of the current pixel\n    \"\tfloat fLumPixel = linearToRelativeLuminance( vColor );\",\n    // Apply the modified operator (Eq. 4)\n    \"\tfloat fLumScaled = (fLumPixel * middleGrey) / max( minLuminance, fLumAvg );\",\n    \"\tfloat fLumCompressed = (fLumScaled * (1.0 + (fLumScaled / (maxLuminance * maxLuminance)))) / (1.0 + fLumScaled);\",\n    \"\treturn fLumCompressed * vColor;\",\n    \"}\",\n    \"void main() {\",\n    \"\tvec4 texel = texture2D( tDiffuse, vUv );\",\n    \"\tgl_FragColor = vec4( ToneMap( texel.xyz ), texel.w );\",\n    \"}\"\n  ].join(\"\\n\")\n};\nexport {\n  ToneMapShader\n};\n"]},"metadata":{},"sourceType":"module"}