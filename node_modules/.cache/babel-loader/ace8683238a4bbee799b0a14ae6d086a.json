{"ast":null,"code":"'use strict';\n\nvar http = require('http');\n\nvar https = require('https');\n\nvar urllib = require('url');\n\nvar zlib = require('zlib');\n\nvar PassThrough = require('stream').PassThrough;\n\nvar Cookies = require('./cookies');\n\nvar MAX_REDIRECTS = 5;\n\nmodule.exports = function (url) {\n  return fetch(url);\n};\n\nfunction fetch(url, options) {\n  options = options || {};\n  options.fetchRes = options.fetchRes || new PassThrough();\n  options.cookies = options.cookies || new Cookies();\n  options.redirects = options.redirects || 0;\n  var fetchRes = options.fetchRes;\n  var parsed = urllib.parse(url);\n  var finished = false;\n  var cookies;\n  var handler = parsed.protocol === 'https:' ? https : http;\n  var headers = {\n    'accept-encoding': 'gzip,deflate'\n  };\n\n  if (parsed.auth) {\n    headers.Authorization = 'Basic ' + new Buffer(parsed.auth).toString('base64');\n  }\n\n  if (cookies = options.cookies.get(url)) {\n    headers.cookie = cookies;\n  }\n\n  var req = handler.get({\n    host: parsed.hostname,\n    path: parsed.path,\n    port: parsed.port ? parsed.port : parsed.protocol === 'https:' ? 443 : 80,\n    headers: headers,\n    rejectUnauthorized: false,\n    agent: false\n  });\n  req.on('response', function (res) {\n    var inflate;\n\n    if (finished) {\n      return;\n    }\n\n    switch (res.headers['content-encoding']) {\n      case 'gzip':\n      case 'deflate':\n        inflate = zlib.createUnzip();\n        break;\n    }\n\n    if (res.headers['set-cookie']) {\n      [].concat(res.headers['set-cookie'] || []).forEach(function (cookie) {\n        options.cookies.set(cookie, url);\n      });\n    }\n\n    if ([301, 302, 303, 307, 308].indexOf(res.statusCode) >= 0 && res.headers.location) {\n      // redirect\n      options.redirects++;\n\n      if (options.redirects > MAX_REDIRECTS) {\n        finished = true;\n        fetchRes.emit('error', new Error('Maximum redirect count exceeded'));\n        req.abort();\n        return;\n      }\n\n      return fetch(urllib.resolve(url, res.headers.location), options);\n    }\n\n    if (res.statusCode >= 300) {\n      finished = true;\n      fetchRes.emit('error', new Error('Invalid status code ' + res.statusCode));\n      req.abort();\n      return;\n    }\n\n    res.on('error', function (err) {\n      if (finished) {\n        return;\n      }\n\n      finished = true;\n      fetchRes.emit('error', err);\n      req.abort();\n    });\n\n    if (inflate) {\n      res.pipe(inflate).pipe(fetchRes);\n      inflate.on('error', function (err) {\n        if (finished) {\n          return;\n        }\n\n        finished = true;\n        fetchRes.emit('error', err);\n        req.abort();\n      });\n    } else {\n      res.pipe(fetchRes);\n    }\n  });\n  req.on('error', function (err) {\n    if (finished) {\n      return;\n    }\n\n    finished = true;\n    fetchRes.emit('error', err);\n  });\n  return fetchRes;\n}","map":{"version":3,"sources":["/Users/theodaguier/e-do/node_modules/nodemailer-fetch/lib/fetch.js"],"names":["http","require","https","urllib","zlib","PassThrough","Cookies","MAX_REDIRECTS","module","exports","url","fetch","options","fetchRes","cookies","redirects","parsed","parse","finished","handler","protocol","headers","auth","Authorization","Buffer","toString","get","cookie","req","host","hostname","path","port","rejectUnauthorized","agent","on","res","inflate","createUnzip","concat","forEach","set","indexOf","statusCode","location","emit","Error","abort","resolve","err","pipe"],"mappings":"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","sourcesContent":["'use strict';\n\nvar http = require('http');\nvar https = require('https');\nvar urllib = require('url');\nvar zlib = require('zlib');\nvar PassThrough = require('stream').PassThrough;\nvar Cookies = require('./cookies');\n\nvar MAX_REDIRECTS = 5;\n\nmodule.exports = function (url) {\n    return fetch(url);\n};\n\nfunction fetch(url, options) {\n    options = options || {};\n\n    options.fetchRes = options.fetchRes || new PassThrough();\n    options.cookies = options.cookies || new Cookies();\n    options.redirects = options.redirects || 0;\n\n    var fetchRes = options.fetchRes;\n    var parsed = urllib.parse(url);\n    var finished = false;\n    var cookies;\n\n    var handler = parsed.protocol === 'https:' ? https : http;\n\n    var headers = {\n        'accept-encoding': 'gzip,deflate'\n    };\n\n    if (parsed.auth) {\n        headers.Authorization = 'Basic ' + new Buffer(parsed.auth).toString('base64');\n    }\n\n    if ((cookies = options.cookies.get(url))) {\n        headers.cookie = cookies;\n    }\n\n    var req = handler.get({\n        host: parsed.hostname,\n        path: parsed.path,\n        port: parsed.port ? parsed.port : (parsed.protocol === 'https:' ? 443 : 80),\n        headers: headers,\n        rejectUnauthorized: false,\n        agent: false\n    });\n\n    req.on('response', function (res) {\n        var inflate;\n\n        if (finished) {\n            return;\n        }\n\n        switch (res.headers['content-encoding']) {\n            case 'gzip':\n            case 'deflate':\n                inflate = zlib.createUnzip();\n                break;\n        }\n\n        if (res.headers['set-cookie']) {\n            [].concat(res.headers['set-cookie'] || []).forEach(function (cookie) {\n                options.cookies.set(cookie, url);\n            });\n        }\n\n        if ([301, 302, 303, 307, 308].indexOf(res.statusCode) >= 0 && res.headers.location) {\n            // redirect\n            options.redirects++;\n            if (options.redirects > MAX_REDIRECTS) {\n                finished = true;\n                fetchRes.emit('error', new Error('Maximum redirect count exceeded'));\n                req.abort();\n                return;\n            }\n            return fetch(urllib.resolve(url, res.headers.location), options);\n        }\n\n        if (res.statusCode >= 300) {\n            finished = true;\n            fetchRes.emit('error', new Error('Invalid status code ' + res.statusCode));\n            req.abort();\n            return;\n        }\n\n        res.on('error', function (err) {\n            if (finished) {\n                return;\n            }\n            finished = true;\n            fetchRes.emit('error', err);\n            req.abort();\n        });\n\n        if (inflate) {\n            res.pipe(inflate).pipe(fetchRes);\n            inflate.on('error', function (err) {\n                if (finished) {\n                    return;\n                }\n                finished = true;\n                fetchRes.emit('error', err);\n                req.abort();\n            });\n        } else {\n            res.pipe(fetchRes);\n        }\n    });\n\n    req.on('error', function (err) {\n        if (finished) {\n            return;\n        }\n        finished = true;\n        fetchRes.emit('error', err);\n    });\n\n    return fetchRes;\n}\n"]},"metadata":{},"sourceType":"script"}