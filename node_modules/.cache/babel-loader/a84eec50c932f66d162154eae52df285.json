{"ast":null,"code":"import _classCallCheck from \"/Users/theodaguier/_workdir/dev/pro/e-do/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/theodaguier/_workdir/dev/pro/e-do/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"/Users/theodaguier/_workdir/dev/pro/e-do/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"/Users/theodaguier/_workdir/dev/pro/e-do/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/theodaguier/_workdir/dev/pro/e-do/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nvar __defProp = Object.defineProperty;\n\nvar __defNormalProp = function __defNormalProp(obj, key, value) {\n  return key in obj ? __defProp(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\n\nvar __publicField = function __publicField(obj, key, value) {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n\n  return value;\n};\n\nimport { Pass, FullScreenQuad } from \"./Pass.js\";\nimport { Vector2, Color, WebGLRenderTarget, MeshDepthMaterial, DoubleSide, RGBADepthPacking, NoBlending, UniformsUtils, ShaderMaterial, Matrix4, Vector3, AdditiveBlending } from \"three\";\nimport { CopyShader } from \"../shaders/CopyShader.js\";\n\nvar OutlinePass = /*#__PURE__*/function (_Pass) {\n  _inherits(OutlinePass, _Pass);\n\n  var _super = _createSuper(OutlinePass);\n\n  function OutlinePass(resolution, scene, camera, selectedObjects) {\n    var _this;\n\n    _classCallCheck(this, OutlinePass);\n\n    _this = _super.call(this);\n\n    __publicField(_assertThisInitialized(_this), \"renderScene\");\n\n    __publicField(_assertThisInitialized(_this), \"renderCamera\");\n\n    __publicField(_assertThisInitialized(_this), \"selectedObjects\");\n\n    __publicField(_assertThisInitialized(_this), \"visibleEdgeColor\");\n\n    __publicField(_assertThisInitialized(_this), \"hiddenEdgeColor\");\n\n    __publicField(_assertThisInitialized(_this), \"edgeGlow\");\n\n    __publicField(_assertThisInitialized(_this), \"usePatternTexture\");\n\n    __publicField(_assertThisInitialized(_this), \"edgeThickness\");\n\n    __publicField(_assertThisInitialized(_this), \"edgeStrength\");\n\n    __publicField(_assertThisInitialized(_this), \"downSampleRatio\");\n\n    __publicField(_assertThisInitialized(_this), \"pulsePeriod\");\n\n    __publicField(_assertThisInitialized(_this), \"resolution\");\n\n    __publicField(_assertThisInitialized(_this), \"renderTargetMaskBuffer\");\n\n    __publicField(_assertThisInitialized(_this), \"depthMaterial\");\n\n    __publicField(_assertThisInitialized(_this), \"prepareMaskMaterial\");\n\n    __publicField(_assertThisInitialized(_this), \"renderTargetDepthBuffer\");\n\n    __publicField(_assertThisInitialized(_this), \"renderTargetMaskDownSampleBuffer\");\n\n    __publicField(_assertThisInitialized(_this), \"renderTargetBlurBuffer1\");\n\n    __publicField(_assertThisInitialized(_this), \"renderTargetBlurBuffer2\");\n\n    __publicField(_assertThisInitialized(_this), \"edgeDetectionMaterial\");\n\n    __publicField(_assertThisInitialized(_this), \"renderTargetEdgeBuffer1\");\n\n    __publicField(_assertThisInitialized(_this), \"renderTargetEdgeBuffer2\");\n\n    __publicField(_assertThisInitialized(_this), \"separableBlurMaterial1\");\n\n    __publicField(_assertThisInitialized(_this), \"separableBlurMaterial2\");\n\n    __publicField(_assertThisInitialized(_this), \"overlayMaterial\");\n\n    __publicField(_assertThisInitialized(_this), \"materialCopy\");\n\n    __publicField(_assertThisInitialized(_this), \"oldClearAlpha\");\n\n    __publicField(_assertThisInitialized(_this), \"fsQuad\");\n\n    __publicField(_assertThisInitialized(_this), \"tempPulseColor1\");\n\n    __publicField(_assertThisInitialized(_this), \"tempPulseColor2\");\n\n    __publicField(_assertThisInitialized(_this), \"textureMatrix\");\n\n    __publicField(_assertThisInitialized(_this), \"patternTexture\");\n\n    __publicField(_assertThisInitialized(_this), \"_visibilityCache\");\n\n    __publicField(_assertThisInitialized(_this), \"_oldClearColor\");\n\n    __publicField(_assertThisInitialized(_this), \"copyUniforms\");\n\n    __publicField(_assertThisInitialized(_this), \"BlurDirectionX\", new Vector2(1, 0));\n\n    __publicField(_assertThisInitialized(_this), \"BlurDirectionY\", new Vector2(0, 1));\n\n    _this.renderScene = scene;\n    _this.renderCamera = camera;\n    _this.selectedObjects = selectedObjects !== void 0 ? selectedObjects : [];\n    _this.visibleEdgeColor = new Color(1, 1, 1);\n    _this.hiddenEdgeColor = new Color(0.1, 0.04, 0.02);\n    _this.edgeGlow = 0;\n    _this.usePatternTexture = false;\n    _this.edgeThickness = 1;\n    _this.edgeStrength = 3;\n    _this.downSampleRatio = 2;\n    _this.pulsePeriod = 0;\n    _this._visibilityCache = /* @__PURE__ */new Map();\n    _this.resolution = resolution !== void 0 ? new Vector2(resolution.x, resolution.y) : new Vector2(256, 256);\n    var resx = Math.round(_this.resolution.x / _this.downSampleRatio);\n    var resy = Math.round(_this.resolution.y / _this.downSampleRatio);\n    _this.renderTargetMaskBuffer = new WebGLRenderTarget(_this.resolution.x, _this.resolution.y);\n    _this.renderTargetMaskBuffer.texture.name = \"OutlinePass.mask\";\n    _this.renderTargetMaskBuffer.texture.generateMipmaps = false;\n    _this.depthMaterial = new MeshDepthMaterial();\n    _this.depthMaterial.side = DoubleSide;\n    _this.depthMaterial.depthPacking = RGBADepthPacking;\n    _this.depthMaterial.blending = NoBlending;\n    _this.prepareMaskMaterial = _this.getPrepareMaskMaterial();\n    _this.prepareMaskMaterial.side = DoubleSide;\n    _this.prepareMaskMaterial.fragmentShader = replaceDepthToViewZ(_this.prepareMaskMaterial.fragmentShader, _this.renderCamera);\n    _this.renderTargetDepthBuffer = new WebGLRenderTarget(_this.resolution.x, _this.resolution.y);\n    _this.renderTargetDepthBuffer.texture.name = \"OutlinePass.depth\";\n    _this.renderTargetDepthBuffer.texture.generateMipmaps = false;\n    _this.renderTargetMaskDownSampleBuffer = new WebGLRenderTarget(resx, resy);\n    _this.renderTargetMaskDownSampleBuffer.texture.name = \"OutlinePass.depthDownSample\";\n    _this.renderTargetMaskDownSampleBuffer.texture.generateMipmaps = false;\n    _this.renderTargetBlurBuffer1 = new WebGLRenderTarget(resx, resy);\n    _this.renderTargetBlurBuffer1.texture.name = \"OutlinePass.blur1\";\n    _this.renderTargetBlurBuffer1.texture.generateMipmaps = false;\n    _this.renderTargetBlurBuffer2 = new WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2));\n    _this.renderTargetBlurBuffer2.texture.name = \"OutlinePass.blur2\";\n    _this.renderTargetBlurBuffer2.texture.generateMipmaps = false;\n    _this.edgeDetectionMaterial = _this.getEdgeDetectionMaterial();\n    _this.renderTargetEdgeBuffer1 = new WebGLRenderTarget(resx, resy);\n    _this.renderTargetEdgeBuffer1.texture.name = \"OutlinePass.edge1\";\n    _this.renderTargetEdgeBuffer1.texture.generateMipmaps = false;\n    _this.renderTargetEdgeBuffer2 = new WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2));\n    _this.renderTargetEdgeBuffer2.texture.name = \"OutlinePass.edge2\";\n    _this.renderTargetEdgeBuffer2.texture.generateMipmaps = false;\n    var MAX_EDGE_THICKNESS = 4;\n    var MAX_EDGE_GLOW = 4;\n    _this.separableBlurMaterial1 = _this.getSeperableBlurMaterial(MAX_EDGE_THICKNESS);\n\n    _this.separableBlurMaterial1.uniforms[\"texSize\"].value.set(resx, resy);\n\n    _this.separableBlurMaterial1.uniforms[\"kernelRadius\"].value = 1;\n    _this.separableBlurMaterial2 = _this.getSeperableBlurMaterial(MAX_EDGE_GLOW);\n\n    _this.separableBlurMaterial2.uniforms[\"texSize\"].value.set(Math.round(resx / 2), Math.round(resy / 2));\n\n    _this.separableBlurMaterial2.uniforms[\"kernelRadius\"].value = MAX_EDGE_GLOW;\n    _this.overlayMaterial = _this.getOverlayMaterial();\n    if (CopyShader === void 0) console.error(\"THREE.OutlinePass relies on CopyShader\");\n    var copyShader = CopyShader;\n    _this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);\n    _this.copyUniforms[\"opacity\"].value = 1;\n    _this.materialCopy = new ShaderMaterial({\n      uniforms: _this.copyUniforms,\n      vertexShader: copyShader.vertexShader,\n      fragmentShader: copyShader.fragmentShader,\n      blending: NoBlending,\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    _this.enabled = true;\n    _this.needsSwap = false;\n    _this._oldClearColor = new Color();\n    _this.oldClearAlpha = 1;\n    _this.fsQuad = new FullScreenQuad(_this.materialCopy);\n    _this.tempPulseColor1 = new Color();\n    _this.tempPulseColor2 = new Color();\n    _this.textureMatrix = new Matrix4();\n\n    function replaceDepthToViewZ(string, camera2) {\n      var type = camera2.isPerspectiveCamera ? \"perspective\" : \"orthographic\";\n      return string.replace(/DEPTH_TO_VIEW_Z/g, type + \"DepthToViewZ\");\n    }\n\n    return _this;\n  }\n\n  _createClass(OutlinePass, [{\n    key: \"dispose\",\n    value: function dispose() {\n      this.renderTargetMaskBuffer.dispose();\n      this.renderTargetDepthBuffer.dispose();\n      this.renderTargetMaskDownSampleBuffer.dispose();\n      this.renderTargetBlurBuffer1.dispose();\n      this.renderTargetBlurBuffer2.dispose();\n      this.renderTargetEdgeBuffer1.dispose();\n      this.renderTargetEdgeBuffer2.dispose();\n    }\n  }, {\n    key: \"setSize\",\n    value: function setSize(width, height) {\n      this.renderTargetMaskBuffer.setSize(width, height);\n      this.renderTargetDepthBuffer.setSize(width, height);\n      var resx = Math.round(width / this.downSampleRatio);\n      var resy = Math.round(height / this.downSampleRatio);\n      this.renderTargetMaskDownSampleBuffer.setSize(resx, resy);\n      this.renderTargetBlurBuffer1.setSize(resx, resy);\n      this.renderTargetEdgeBuffer1.setSize(resx, resy);\n      this.separableBlurMaterial1.uniforms[\"texSize\"].value.set(resx, resy);\n      resx = Math.round(resx / 2);\n      resy = Math.round(resy / 2);\n      this.renderTargetBlurBuffer2.setSize(resx, resy);\n      this.renderTargetEdgeBuffer2.setSize(resx, resy);\n      this.separableBlurMaterial2.uniforms[\"texSize\"].value.set(resx, resy);\n    }\n  }, {\n    key: \"changeVisibilityOfSelectedObjects\",\n    value: function changeVisibilityOfSelectedObjects(bVisible) {\n      var cache = this._visibilityCache;\n\n      function gatherSelectedMeshesCallBack(object) {\n        if (object.isMesh) {\n          if (bVisible === true) {\n            object.visible = cache.get(object);\n          } else {\n            cache.set(object, object.visible);\n            object.visible = bVisible;\n          }\n        }\n      }\n\n      for (var i = 0; i < this.selectedObjects.length; i++) {\n        var selectedObject = this.selectedObjects[i];\n        selectedObject.traverse(gatherSelectedMeshesCallBack);\n      }\n    }\n  }, {\n    key: \"changeVisibilityOfNonSelectedObjects\",\n    value: function changeVisibilityOfNonSelectedObjects(bVisible) {\n      var cache = this._visibilityCache;\n      var selectedMeshes = [];\n\n      function gatherSelectedMeshesCallBack(object) {\n        if (object.isMesh) selectedMeshes.push(object);\n      }\n\n      for (var i = 0; i < this.selectedObjects.length; i++) {\n        var selectedObject = this.selectedObjects[i];\n        selectedObject.traverse(gatherSelectedMeshesCallBack);\n      }\n\n      function VisibilityChangeCallBack(object) {\n        if (object.isMesh || object.isSprite) {\n          var bFound = false;\n\n          for (var _i = 0; _i < selectedMeshes.length; _i++) {\n            var selectedObjectId = selectedMeshes[_i].id;\n\n            if (selectedObjectId === object.id) {\n              bFound = true;\n              break;\n            }\n          }\n\n          if (bFound === false) {\n            var visibility = object.visible;\n\n            if (bVisible === false || cache.get(object) === true) {\n              object.visible = bVisible;\n            }\n\n            cache.set(object, visibility);\n          }\n        } else if (object.isPoints || object.isLine) {\n          if (bVisible === true) {\n            object.visible = cache.get(object);\n          } else {\n            cache.set(object, object.visible);\n            object.visible = bVisible;\n          }\n        }\n      }\n\n      this.renderScene.traverse(VisibilityChangeCallBack);\n    }\n  }, {\n    key: \"updateTextureMatrix\",\n    value: function updateTextureMatrix() {\n      this.textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);\n      this.textureMatrix.multiply(this.renderCamera.projectionMatrix);\n      this.textureMatrix.multiply(this.renderCamera.matrixWorldInverse);\n    }\n  }, {\n    key: \"render\",\n    value: function render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\n      if (this.selectedObjects.length > 0) {\n        renderer.getClearColor(this._oldClearColor);\n        this.oldClearAlpha = renderer.getClearAlpha();\n        var oldAutoClear = renderer.autoClear;\n        renderer.autoClear = false;\n        if (maskActive) renderer.state.buffers.stencil.setTest(false);\n        renderer.setClearColor(16777215, 1);\n        this.changeVisibilityOfSelectedObjects(false);\n        var currentBackground = this.renderScene.background;\n        this.renderScene.background = null;\n        this.renderScene.overrideMaterial = this.depthMaterial;\n        renderer.setRenderTarget(this.renderTargetDepthBuffer);\n        renderer.clear();\n        renderer.render(this.renderScene, this.renderCamera);\n        this.changeVisibilityOfSelectedObjects(true);\n\n        this._visibilityCache.clear();\n\n        this.updateTextureMatrix();\n        this.changeVisibilityOfNonSelectedObjects(false);\n        this.renderScene.overrideMaterial = this.prepareMaskMaterial;\n        this.prepareMaskMaterial.uniforms[\"cameraNearFar\"].value.set(this.renderCamera.near, this.renderCamera.far);\n        this.prepareMaskMaterial.uniforms[\"depthTexture\"].value = this.renderTargetDepthBuffer.texture;\n        this.prepareMaskMaterial.uniforms[\"textureMatrix\"].value = this.textureMatrix;\n        renderer.setRenderTarget(this.renderTargetMaskBuffer);\n        renderer.clear();\n        renderer.render(this.renderScene, this.renderCamera);\n        this.renderScene.overrideMaterial = null;\n        this.changeVisibilityOfNonSelectedObjects(true);\n\n        this._visibilityCache.clear();\n\n        this.renderScene.background = currentBackground;\n        this.fsQuad.material = this.materialCopy;\n        this.copyUniforms[\"tDiffuse\"].value = this.renderTargetMaskBuffer.texture;\n        renderer.setRenderTarget(this.renderTargetMaskDownSampleBuffer);\n        renderer.clear();\n        this.fsQuad.render(renderer);\n        this.tempPulseColor1.copy(this.visibleEdgeColor);\n        this.tempPulseColor2.copy(this.hiddenEdgeColor);\n\n        if (this.pulsePeriod > 0) {\n          var scalar = (1 + 0.25) / 2 + Math.cos(performance.now() * 0.01 / this.pulsePeriod) * (1 - 0.25) / 2;\n          this.tempPulseColor1.multiplyScalar(scalar);\n          this.tempPulseColor2.multiplyScalar(scalar);\n        }\n\n        this.fsQuad.material = this.edgeDetectionMaterial;\n        this.edgeDetectionMaterial.uniforms[\"maskTexture\"].value = this.renderTargetMaskDownSampleBuffer.texture;\n        this.edgeDetectionMaterial.uniforms[\"texSize\"].value.set(this.renderTargetMaskDownSampleBuffer.width, this.renderTargetMaskDownSampleBuffer.height);\n        this.edgeDetectionMaterial.uniforms[\"visibleEdgeColor\"].value = this.tempPulseColor1;\n        this.edgeDetectionMaterial.uniforms[\"hiddenEdgeColor\"].value = this.tempPulseColor2;\n        renderer.setRenderTarget(this.renderTargetEdgeBuffer1);\n        renderer.clear();\n        this.fsQuad.render(renderer);\n        this.fsQuad.material = this.separableBlurMaterial1;\n        this.separableBlurMaterial1.uniforms[\"colorTexture\"].value = this.renderTargetEdgeBuffer1.texture;\n        this.separableBlurMaterial1.uniforms[\"direction\"].value = this.BlurDirectionX;\n        this.separableBlurMaterial1.uniforms[\"kernelRadius\"].value = this.edgeThickness;\n        renderer.setRenderTarget(this.renderTargetBlurBuffer1);\n        renderer.clear();\n        this.fsQuad.render(renderer);\n        this.separableBlurMaterial1.uniforms[\"colorTexture\"].value = this.renderTargetBlurBuffer1.texture;\n        this.separableBlurMaterial1.uniforms[\"direction\"].value = this.BlurDirectionY;\n        renderer.setRenderTarget(this.renderTargetEdgeBuffer1);\n        renderer.clear();\n        this.fsQuad.render(renderer);\n        this.fsQuad.material = this.separableBlurMaterial2;\n        this.separableBlurMaterial2.uniforms[\"colorTexture\"].value = this.renderTargetEdgeBuffer1.texture;\n        this.separableBlurMaterial2.uniforms[\"direction\"].value = this.BlurDirectionX;\n        renderer.setRenderTarget(this.renderTargetBlurBuffer2);\n        renderer.clear();\n        this.fsQuad.render(renderer);\n        this.separableBlurMaterial2.uniforms[\"colorTexture\"].value = this.renderTargetBlurBuffer2.texture;\n        this.separableBlurMaterial2.uniforms[\"direction\"].value = this.BlurDirectionY;\n        renderer.setRenderTarget(this.renderTargetEdgeBuffer2);\n        renderer.clear();\n        this.fsQuad.render(renderer);\n        this.fsQuad.material = this.overlayMaterial;\n        this.overlayMaterial.uniforms[\"maskTexture\"].value = this.renderTargetMaskBuffer.texture;\n        this.overlayMaterial.uniforms[\"edgeTexture1\"].value = this.renderTargetEdgeBuffer1.texture;\n        this.overlayMaterial.uniforms[\"edgeTexture2\"].value = this.renderTargetEdgeBuffer2.texture;\n        this.overlayMaterial.uniforms[\"patternTexture\"].value = this.patternTexture;\n        this.overlayMaterial.uniforms[\"edgeStrength\"].value = this.edgeStrength;\n        this.overlayMaterial.uniforms[\"edgeGlow\"].value = this.edgeGlow;\n        this.overlayMaterial.uniforms[\"usePatternTexture\"].value = this.usePatternTexture;\n        if (maskActive) renderer.state.buffers.stencil.setTest(true);\n        renderer.setRenderTarget(readBuffer);\n        this.fsQuad.render(renderer);\n        renderer.setClearColor(this._oldClearColor, this.oldClearAlpha);\n        renderer.autoClear = oldAutoClear;\n      }\n\n      if (this.renderToScreen) {\n        this.fsQuad.material = this.materialCopy;\n        this.copyUniforms[\"tDiffuse\"].value = readBuffer.texture;\n        renderer.setRenderTarget(null);\n        this.fsQuad.render(renderer);\n      }\n    }\n  }, {\n    key: \"getPrepareMaskMaterial\",\n    value: function getPrepareMaskMaterial() {\n      return new ShaderMaterial({\n        uniforms: {\n          depthTexture: {\n            value: null\n          },\n          cameraNearFar: {\n            value: new Vector2(0.5, 0.5)\n          },\n          textureMatrix: {\n            value: null\n          }\n        },\n        vertexShader: \"#include <morphtarget_pars_vertex>\\n\\t\\t\\t\\t#include <skinning_pars_vertex>\\n\\t\\t\\t\\tvarying vec4 projTexCoord;\\n\\t\\t\\t\\tvarying vec4 vPosition;\\n\\t\\t\\t\\tuniform mat4 textureMatrix;\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\t#include <skinbase_vertex>\\n\\t\\t\\t\\t\\t#include <begin_vertex>\\n\\t\\t\\t\\t\\t#include <morphtarget_vertex>\\n\\t\\t\\t\\t\\t#include <skinning_vertex>\\n\\t\\t\\t\\t\\t#include <project_vertex>\\n\\t\\t\\t\\t\\tvPosition = mvPosition;\\n\\t\\t\\t\\t\\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\\n\\t\\t\\t\\t\\tprojTexCoord = textureMatrix * worldPosition;\\n\\t\\t\\t\\t}\",\n        fragmentShader: \"#include <packing>\\n\\t\\t\\t\\tvarying vec4 vPosition;\\n\\t\\t\\t\\tvarying vec4 projTexCoord;\\n\\t\\t\\t\\tuniform sampler2D depthTexture;\\n\\t\\t\\t\\tuniform vec2 cameraNearFar;\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tfloat depth = unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));\\n\\t\\t\\t\\t\\tfloat viewZ = - DEPTH_TO_VIEW_Z( depth, cameraNearFar.x, cameraNearFar.y );\\n\\t\\t\\t\\t\\tfloat depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;\\n\\t\\t\\t\\t\\tgl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);\\n\\t\\t\\t\\t}\"\n      });\n    }\n  }, {\n    key: \"getEdgeDetectionMaterial\",\n    value: function getEdgeDetectionMaterial() {\n      return new ShaderMaterial({\n        uniforms: {\n          maskTexture: {\n            value: null\n          },\n          texSize: {\n            value: new Vector2(0.5, 0.5)\n          },\n          visibleEdgeColor: {\n            value: new Vector3(1, 1, 1)\n          },\n          hiddenEdgeColor: {\n            value: new Vector3(1, 1, 1)\n          }\n        },\n        vertexShader: \"varying vec2 vUv;\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tvUv = uv;\\n\\t\\t\\t\\t\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\t\\t\\t\\t}\",\n        fragmentShader: \"varying vec2 vUv;\\n\\t\\t\\t\\tuniform sampler2D maskTexture;\\n\\t\\t\\t\\tuniform vec2 texSize;\\n\\t\\t\\t\\tuniform vec3 visibleEdgeColor;\\n\\t\\t\\t\\tuniform vec3 hiddenEdgeColor;\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tvec2 invSize = 1.0 / texSize;\\n\\t\\t\\t\\t\\tvec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);\\n\\t\\t\\t\\t\\tvec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);\\n\\t\\t\\t\\t\\tvec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);\\n\\t\\t\\t\\t\\tvec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);\\n\\t\\t\\t\\t\\tvec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);\\n\\t\\t\\t\\t\\tfloat diff1 = (c1.r - c2.r)*0.5;\\n\\t\\t\\t\\t\\tfloat diff2 = (c3.r - c4.r)*0.5;\\n\\t\\t\\t\\t\\tfloat d = length( vec2(diff1, diff2) );\\n\\t\\t\\t\\t\\tfloat a1 = min(c1.g, c2.g);\\n\\t\\t\\t\\t\\tfloat a2 = min(c3.g, c4.g);\\n\\t\\t\\t\\t\\tfloat visibilityFactor = min(a1, a2);\\n\\t\\t\\t\\t\\tvec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;\\n\\t\\t\\t\\t\\tgl_FragColor = vec4(edgeColor, 1.0) * vec4(d);\\n\\t\\t\\t\\t}\"\n      });\n    }\n  }, {\n    key: \"getSeperableBlurMaterial\",\n    value: function getSeperableBlurMaterial(maxRadius) {\n      return new ShaderMaterial({\n        defines: {\n          MAX_RADIUS: maxRadius\n        },\n        uniforms: {\n          colorTexture: {\n            value: null\n          },\n          texSize: {\n            value: new Vector2(0.5, 0.5)\n          },\n          direction: {\n            value: new Vector2(0.5, 0.5)\n          },\n          kernelRadius: {\n            value: 1\n          }\n        },\n        vertexShader: \"varying vec2 vUv;\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tvUv = uv;\\n\\t\\t\\t\\t\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\t\\t\\t\\t}\",\n        fragmentShader: \"#include <common>\\n\\t\\t\\t\\tvarying vec2 vUv;\\n\\t\\t\\t\\tuniform sampler2D colorTexture;\\n\\t\\t\\t\\tuniform vec2 texSize;\\n\\t\\t\\t\\tuniform vec2 direction;\\n\\t\\t\\t\\tuniform float kernelRadius;\\n\\t\\t\\t\\tfloat gaussianPdf(in float x, in float sigma) {\\n\\t\\t\\t\\t\\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tvec2 invSize = 1.0 / texSize;\\n\\t\\t\\t\\t\\tfloat weightSum = gaussianPdf(0.0, kernelRadius);\\n\\t\\t\\t\\t\\tvec4 diffuseSum = texture2D( colorTexture, vUv) * weightSum;\\n\\t\\t\\t\\t\\tvec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);\\n\\t\\t\\t\\t\\tvec2 uvOffset = delta;\\n\\t\\t\\t\\t\\tfor( int i = 1; i <= MAX_RADIUS; i ++ ) {\\n\\t\\t\\t\\t\\t\\tfloat w = gaussianPdf(uvOffset.x, kernelRadius);\\n\\t\\t\\t\\t\\t\\tvec4 sample1 = texture2D( colorTexture, vUv + uvOffset);\\n\\t\\t\\t\\t\\t\\tvec4 sample2 = texture2D( colorTexture, vUv - uvOffset);\\n\\t\\t\\t\\t\\t\\tdiffuseSum += ((sample1 + sample2) * w);\\n\\t\\t\\t\\t\\t\\tweightSum += (2.0 * w);\\n\\t\\t\\t\\t\\t\\tuvOffset += delta;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tgl_FragColor = diffuseSum/weightSum;\\n\\t\\t\\t\\t}\"\n      });\n    }\n  }, {\n    key: \"getOverlayMaterial\",\n    value: function getOverlayMaterial() {\n      return new ShaderMaterial({\n        uniforms: {\n          maskTexture: {\n            value: null\n          },\n          edgeTexture1: {\n            value: null\n          },\n          edgeTexture2: {\n            value: null\n          },\n          patternTexture: {\n            value: null\n          },\n          edgeStrength: {\n            value: 1\n          },\n          edgeGlow: {\n            value: 1\n          },\n          usePatternTexture: {\n            value: 0\n          }\n        },\n        vertexShader: \"varying vec2 vUv;\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tvUv = uv;\\n\\t\\t\\t\\t\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\t\\t\\t\\t}\",\n        fragmentShader: \"varying vec2 vUv;\\n\\t\\t\\t\\tuniform sampler2D maskTexture;\\n\\t\\t\\t\\tuniform sampler2D edgeTexture1;\\n\\t\\t\\t\\tuniform sampler2D edgeTexture2;\\n\\t\\t\\t\\tuniform sampler2D patternTexture;\\n\\t\\t\\t\\tuniform float edgeStrength;\\n\\t\\t\\t\\tuniform float edgeGlow;\\n\\t\\t\\t\\tuniform bool usePatternTexture;\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tvec4 edgeValue1 = texture2D(edgeTexture1, vUv);\\n\\t\\t\\t\\t\\tvec4 edgeValue2 = texture2D(edgeTexture2, vUv);\\n\\t\\t\\t\\t\\tvec4 maskColor = texture2D(maskTexture, vUv);\\n\\t\\t\\t\\t\\tvec4 patternColor = texture2D(patternTexture, 6.0 * vUv);\\n\\t\\t\\t\\t\\tfloat visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;\\n\\t\\t\\t\\t\\tvec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;\\n\\t\\t\\t\\t\\tvec4 finalColor = edgeStrength * maskColor.r * edgeValue;\\n\\t\\t\\t\\t\\tif(usePatternTexture)\\n\\t\\t\\t\\t\\t\\tfinalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);\\n\\t\\t\\t\\t\\tgl_FragColor = finalColor;\\n\\t\\t\\t\\t}\",\n        blending: AdditiveBlending,\n        depthTest: false,\n        depthWrite: false,\n        transparent: true\n      });\n    }\n  }]);\n\n  return OutlinePass;\n}(Pass);\n\nexport { OutlinePass };","map":{"version":3,"sources":["/Users/theodaguier/_workdir/dev/pro/e-do/E-Do-Studio/node_modules/three-stdlib/postprocessing/OutlinePass.js"],"names":["__defProp","Object","defineProperty","__defNormalProp","obj","key","value","enumerable","configurable","writable","__publicField","Pass","FullScreenQuad","Vector2","Color","WebGLRenderTarget","MeshDepthMaterial","DoubleSide","RGBADepthPacking","NoBlending","UniformsUtils","ShaderMaterial","Matrix4","Vector3","AdditiveBlending","CopyShader","OutlinePass","resolution","scene","camera","selectedObjects","renderScene","renderCamera","visibleEdgeColor","hiddenEdgeColor","edgeGlow","usePatternTexture","edgeThickness","edgeStrength","downSampleRatio","pulsePeriod","_visibilityCache","Map","x","y","resx","Math","round","resy","renderTargetMaskBuffer","texture","name","generateMipmaps","depthMaterial","side","depthPacking","blending","prepareMaskMaterial","getPrepareMaskMaterial","fragmentShader","replaceDepthToViewZ","renderTargetDepthBuffer","renderTargetMaskDownSampleBuffer","renderTargetBlurBuffer1","renderTargetBlurBuffer2","edgeDetectionMaterial","getEdgeDetectionMaterial","renderTargetEdgeBuffer1","renderTargetEdgeBuffer2","MAX_EDGE_THICKNESS","MAX_EDGE_GLOW","separableBlurMaterial1","getSeperableBlurMaterial","uniforms","set","separableBlurMaterial2","overlayMaterial","getOverlayMaterial","console","error","copyShader","copyUniforms","clone","materialCopy","vertexShader","depthTest","depthWrite","transparent","enabled","needsSwap","_oldClearColor","oldClearAlpha","fsQuad","tempPulseColor1","tempPulseColor2","textureMatrix","string","camera2","type","isPerspectiveCamera","replace","dispose","width","height","setSize","bVisible","cache","gatherSelectedMeshesCallBack","object","isMesh","visible","get","i","length","selectedObject","traverse","selectedMeshes","push","VisibilityChangeCallBack","isSprite","bFound","selectedObjectId","id","visibility","isPoints","isLine","multiply","projectionMatrix","matrixWorldInverse","renderer","writeBuffer","readBuffer","deltaTime","maskActive","getClearColor","getClearAlpha","oldAutoClear","autoClear","state","buffers","stencil","setTest","setClearColor","changeVisibilityOfSelectedObjects","currentBackground","background","overrideMaterial","setRenderTarget","clear","render","updateTextureMatrix","changeVisibilityOfNonSelectedObjects","near","far","material","copy","scalar","cos","performance","now","multiplyScalar","BlurDirectionX","BlurDirectionY","patternTexture","renderToScreen","depthTexture","cameraNearFar","maskTexture","texSize","maxRadius","defines","MAX_RADIUS","colorTexture","direction","kernelRadius","edgeTexture1","edgeTexture2"],"mappings":"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","sourcesContent":["var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Pass, FullScreenQuad } from \"./Pass.js\";\nimport { Vector2, Color, WebGLRenderTarget, MeshDepthMaterial, DoubleSide, RGBADepthPacking, NoBlending, UniformsUtils, ShaderMaterial, Matrix4, Vector3, AdditiveBlending } from \"three\";\nimport { CopyShader } from \"../shaders/CopyShader.js\";\nclass OutlinePass extends Pass {\n  constructor(resolution, scene, camera, selectedObjects) {\n    super();\n    __publicField(this, \"renderScene\");\n    __publicField(this, \"renderCamera\");\n    __publicField(this, \"selectedObjects\");\n    __publicField(this, \"visibleEdgeColor\");\n    __publicField(this, \"hiddenEdgeColor\");\n    __publicField(this, \"edgeGlow\");\n    __publicField(this, \"usePatternTexture\");\n    __publicField(this, \"edgeThickness\");\n    __publicField(this, \"edgeStrength\");\n    __publicField(this, \"downSampleRatio\");\n    __publicField(this, \"pulsePeriod\");\n    __publicField(this, \"resolution\");\n    __publicField(this, \"renderTargetMaskBuffer\");\n    __publicField(this, \"depthMaterial\");\n    __publicField(this, \"prepareMaskMaterial\");\n    __publicField(this, \"renderTargetDepthBuffer\");\n    __publicField(this, \"renderTargetMaskDownSampleBuffer\");\n    __publicField(this, \"renderTargetBlurBuffer1\");\n    __publicField(this, \"renderTargetBlurBuffer2\");\n    __publicField(this, \"edgeDetectionMaterial\");\n    __publicField(this, \"renderTargetEdgeBuffer1\");\n    __publicField(this, \"renderTargetEdgeBuffer2\");\n    __publicField(this, \"separableBlurMaterial1\");\n    __publicField(this, \"separableBlurMaterial2\");\n    __publicField(this, \"overlayMaterial\");\n    __publicField(this, \"materialCopy\");\n    __publicField(this, \"oldClearAlpha\");\n    __publicField(this, \"fsQuad\");\n    __publicField(this, \"tempPulseColor1\");\n    __publicField(this, \"tempPulseColor2\");\n    __publicField(this, \"textureMatrix\");\n    __publicField(this, \"patternTexture\");\n    __publicField(this, \"_visibilityCache\");\n    __publicField(this, \"_oldClearColor\");\n    __publicField(this, \"copyUniforms\");\n    __publicField(this, \"BlurDirectionX\", new Vector2(1, 0));\n    __publicField(this, \"BlurDirectionY\", new Vector2(0, 1));\n    this.renderScene = scene;\n    this.renderCamera = camera;\n    this.selectedObjects = selectedObjects !== void 0 ? selectedObjects : [];\n    this.visibleEdgeColor = new Color(1, 1, 1);\n    this.hiddenEdgeColor = new Color(0.1, 0.04, 0.02);\n    this.edgeGlow = 0;\n    this.usePatternTexture = false;\n    this.edgeThickness = 1;\n    this.edgeStrength = 3;\n    this.downSampleRatio = 2;\n    this.pulsePeriod = 0;\n    this._visibilityCache = /* @__PURE__ */ new Map();\n    this.resolution = resolution !== void 0 ? new Vector2(resolution.x, resolution.y) : new Vector2(256, 256);\n    const resx = Math.round(this.resolution.x / this.downSampleRatio);\n    const resy = Math.round(this.resolution.y / this.downSampleRatio);\n    this.renderTargetMaskBuffer = new WebGLRenderTarget(this.resolution.x, this.resolution.y);\n    this.renderTargetMaskBuffer.texture.name = \"OutlinePass.mask\";\n    this.renderTargetMaskBuffer.texture.generateMipmaps = false;\n    this.depthMaterial = new MeshDepthMaterial();\n    this.depthMaterial.side = DoubleSide;\n    this.depthMaterial.depthPacking = RGBADepthPacking;\n    this.depthMaterial.blending = NoBlending;\n    this.prepareMaskMaterial = this.getPrepareMaskMaterial();\n    this.prepareMaskMaterial.side = DoubleSide;\n    this.prepareMaskMaterial.fragmentShader = replaceDepthToViewZ(\n      this.prepareMaskMaterial.fragmentShader,\n      this.renderCamera\n    );\n    this.renderTargetDepthBuffer = new WebGLRenderTarget(this.resolution.x, this.resolution.y);\n    this.renderTargetDepthBuffer.texture.name = \"OutlinePass.depth\";\n    this.renderTargetDepthBuffer.texture.generateMipmaps = false;\n    this.renderTargetMaskDownSampleBuffer = new WebGLRenderTarget(resx, resy);\n    this.renderTargetMaskDownSampleBuffer.texture.name = \"OutlinePass.depthDownSample\";\n    this.renderTargetMaskDownSampleBuffer.texture.generateMipmaps = false;\n    this.renderTargetBlurBuffer1 = new WebGLRenderTarget(resx, resy);\n    this.renderTargetBlurBuffer1.texture.name = \"OutlinePass.blur1\";\n    this.renderTargetBlurBuffer1.texture.generateMipmaps = false;\n    this.renderTargetBlurBuffer2 = new WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2));\n    this.renderTargetBlurBuffer2.texture.name = \"OutlinePass.blur2\";\n    this.renderTargetBlurBuffer2.texture.generateMipmaps = false;\n    this.edgeDetectionMaterial = this.getEdgeDetectionMaterial();\n    this.renderTargetEdgeBuffer1 = new WebGLRenderTarget(resx, resy);\n    this.renderTargetEdgeBuffer1.texture.name = \"OutlinePass.edge1\";\n    this.renderTargetEdgeBuffer1.texture.generateMipmaps = false;\n    this.renderTargetEdgeBuffer2 = new WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2));\n    this.renderTargetEdgeBuffer2.texture.name = \"OutlinePass.edge2\";\n    this.renderTargetEdgeBuffer2.texture.generateMipmaps = false;\n    const MAX_EDGE_THICKNESS = 4;\n    const MAX_EDGE_GLOW = 4;\n    this.separableBlurMaterial1 = this.getSeperableBlurMaterial(MAX_EDGE_THICKNESS);\n    this.separableBlurMaterial1.uniforms[\"texSize\"].value.set(resx, resy);\n    this.separableBlurMaterial1.uniforms[\"kernelRadius\"].value = 1;\n    this.separableBlurMaterial2 = this.getSeperableBlurMaterial(MAX_EDGE_GLOW);\n    this.separableBlurMaterial2.uniforms[\"texSize\"].value.set(Math.round(resx / 2), Math.round(resy / 2));\n    this.separableBlurMaterial2.uniforms[\"kernelRadius\"].value = MAX_EDGE_GLOW;\n    this.overlayMaterial = this.getOverlayMaterial();\n    if (CopyShader === void 0)\n      console.error(\"THREE.OutlinePass relies on CopyShader\");\n    const copyShader = CopyShader;\n    this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);\n    this.copyUniforms[\"opacity\"].value = 1;\n    this.materialCopy = new ShaderMaterial({\n      uniforms: this.copyUniforms,\n      vertexShader: copyShader.vertexShader,\n      fragmentShader: copyShader.fragmentShader,\n      blending: NoBlending,\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    this.enabled = true;\n    this.needsSwap = false;\n    this._oldClearColor = new Color();\n    this.oldClearAlpha = 1;\n    this.fsQuad = new FullScreenQuad(this.materialCopy);\n    this.tempPulseColor1 = new Color();\n    this.tempPulseColor2 = new Color();\n    this.textureMatrix = new Matrix4();\n    function replaceDepthToViewZ(string, camera2) {\n      const type = camera2.isPerspectiveCamera ? \"perspective\" : \"orthographic\";\n      return string.replace(/DEPTH_TO_VIEW_Z/g, type + \"DepthToViewZ\");\n    }\n  }\n  dispose() {\n    this.renderTargetMaskBuffer.dispose();\n    this.renderTargetDepthBuffer.dispose();\n    this.renderTargetMaskDownSampleBuffer.dispose();\n    this.renderTargetBlurBuffer1.dispose();\n    this.renderTargetBlurBuffer2.dispose();\n    this.renderTargetEdgeBuffer1.dispose();\n    this.renderTargetEdgeBuffer2.dispose();\n  }\n  setSize(width, height) {\n    this.renderTargetMaskBuffer.setSize(width, height);\n    this.renderTargetDepthBuffer.setSize(width, height);\n    let resx = Math.round(width / this.downSampleRatio);\n    let resy = Math.round(height / this.downSampleRatio);\n    this.renderTargetMaskDownSampleBuffer.setSize(resx, resy);\n    this.renderTargetBlurBuffer1.setSize(resx, resy);\n    this.renderTargetEdgeBuffer1.setSize(resx, resy);\n    this.separableBlurMaterial1.uniforms[\"texSize\"].value.set(resx, resy);\n    resx = Math.round(resx / 2);\n    resy = Math.round(resy / 2);\n    this.renderTargetBlurBuffer2.setSize(resx, resy);\n    this.renderTargetEdgeBuffer2.setSize(resx, resy);\n    this.separableBlurMaterial2.uniforms[\"texSize\"].value.set(resx, resy);\n  }\n  changeVisibilityOfSelectedObjects(bVisible) {\n    const cache = this._visibilityCache;\n    function gatherSelectedMeshesCallBack(object) {\n      if (object.isMesh) {\n        if (bVisible === true) {\n          object.visible = cache.get(object);\n        } else {\n          cache.set(object, object.visible);\n          object.visible = bVisible;\n        }\n      }\n    }\n    for (let i = 0; i < this.selectedObjects.length; i++) {\n      const selectedObject = this.selectedObjects[i];\n      selectedObject.traverse(gatherSelectedMeshesCallBack);\n    }\n  }\n  changeVisibilityOfNonSelectedObjects(bVisible) {\n    const cache = this._visibilityCache;\n    const selectedMeshes = [];\n    function gatherSelectedMeshesCallBack(object) {\n      if (object.isMesh)\n        selectedMeshes.push(object);\n    }\n    for (let i = 0; i < this.selectedObjects.length; i++) {\n      const selectedObject = this.selectedObjects[i];\n      selectedObject.traverse(gatherSelectedMeshesCallBack);\n    }\n    function VisibilityChangeCallBack(object) {\n      if (object.isMesh || object.isSprite) {\n        let bFound = false;\n        for (let i = 0; i < selectedMeshes.length; i++) {\n          const selectedObjectId = selectedMeshes[i].id;\n          if (selectedObjectId === object.id) {\n            bFound = true;\n            break;\n          }\n        }\n        if (bFound === false) {\n          const visibility = object.visible;\n          if (bVisible === false || cache.get(object) === true) {\n            object.visible = bVisible;\n          }\n          cache.set(object, visibility);\n        }\n      } else if (object.isPoints || object.isLine) {\n        if (bVisible === true) {\n          object.visible = cache.get(object);\n        } else {\n          cache.set(object, object.visible);\n          object.visible = bVisible;\n        }\n      }\n    }\n    this.renderScene.traverse(VisibilityChangeCallBack);\n  }\n  updateTextureMatrix() {\n    this.textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);\n    this.textureMatrix.multiply(this.renderCamera.projectionMatrix);\n    this.textureMatrix.multiply(this.renderCamera.matrixWorldInverse);\n  }\n  render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\n    if (this.selectedObjects.length > 0) {\n      renderer.getClearColor(this._oldClearColor);\n      this.oldClearAlpha = renderer.getClearAlpha();\n      const oldAutoClear = renderer.autoClear;\n      renderer.autoClear = false;\n      if (maskActive)\n        renderer.state.buffers.stencil.setTest(false);\n      renderer.setClearColor(16777215, 1);\n      this.changeVisibilityOfSelectedObjects(false);\n      const currentBackground = this.renderScene.background;\n      this.renderScene.background = null;\n      this.renderScene.overrideMaterial = this.depthMaterial;\n      renderer.setRenderTarget(this.renderTargetDepthBuffer);\n      renderer.clear();\n      renderer.render(this.renderScene, this.renderCamera);\n      this.changeVisibilityOfSelectedObjects(true);\n      this._visibilityCache.clear();\n      this.updateTextureMatrix();\n      this.changeVisibilityOfNonSelectedObjects(false);\n      this.renderScene.overrideMaterial = this.prepareMaskMaterial;\n      this.prepareMaskMaterial.uniforms[\"cameraNearFar\"].value.set(\n        this.renderCamera.near,\n        this.renderCamera.far\n      );\n      this.prepareMaskMaterial.uniforms[\"depthTexture\"].value = this.renderTargetDepthBuffer.texture;\n      this.prepareMaskMaterial.uniforms[\"textureMatrix\"].value = this.textureMatrix;\n      renderer.setRenderTarget(this.renderTargetMaskBuffer);\n      renderer.clear();\n      renderer.render(this.renderScene, this.renderCamera);\n      this.renderScene.overrideMaterial = null;\n      this.changeVisibilityOfNonSelectedObjects(true);\n      this._visibilityCache.clear();\n      this.renderScene.background = currentBackground;\n      this.fsQuad.material = this.materialCopy;\n      this.copyUniforms[\"tDiffuse\"].value = this.renderTargetMaskBuffer.texture;\n      renderer.setRenderTarget(this.renderTargetMaskDownSampleBuffer);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      this.tempPulseColor1.copy(this.visibleEdgeColor);\n      this.tempPulseColor2.copy(this.hiddenEdgeColor);\n      if (this.pulsePeriod > 0) {\n        const scalar = (1 + 0.25) / 2 + Math.cos(performance.now() * 0.01 / this.pulsePeriod) * (1 - 0.25) / 2;\n        this.tempPulseColor1.multiplyScalar(scalar);\n        this.tempPulseColor2.multiplyScalar(scalar);\n      }\n      this.fsQuad.material = this.edgeDetectionMaterial;\n      this.edgeDetectionMaterial.uniforms[\"maskTexture\"].value = this.renderTargetMaskDownSampleBuffer.texture;\n      this.edgeDetectionMaterial.uniforms[\"texSize\"].value.set(\n        this.renderTargetMaskDownSampleBuffer.width,\n        this.renderTargetMaskDownSampleBuffer.height\n      );\n      this.edgeDetectionMaterial.uniforms[\"visibleEdgeColor\"].value = this.tempPulseColor1;\n      this.edgeDetectionMaterial.uniforms[\"hiddenEdgeColor\"].value = this.tempPulseColor2;\n      renderer.setRenderTarget(this.renderTargetEdgeBuffer1);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      this.fsQuad.material = this.separableBlurMaterial1;\n      this.separableBlurMaterial1.uniforms[\"colorTexture\"].value = this.renderTargetEdgeBuffer1.texture;\n      this.separableBlurMaterial1.uniforms[\"direction\"].value = this.BlurDirectionX;\n      this.separableBlurMaterial1.uniforms[\"kernelRadius\"].value = this.edgeThickness;\n      renderer.setRenderTarget(this.renderTargetBlurBuffer1);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      this.separableBlurMaterial1.uniforms[\"colorTexture\"].value = this.renderTargetBlurBuffer1.texture;\n      this.separableBlurMaterial1.uniforms[\"direction\"].value = this.BlurDirectionY;\n      renderer.setRenderTarget(this.renderTargetEdgeBuffer1);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      this.fsQuad.material = this.separableBlurMaterial2;\n      this.separableBlurMaterial2.uniforms[\"colorTexture\"].value = this.renderTargetEdgeBuffer1.texture;\n      this.separableBlurMaterial2.uniforms[\"direction\"].value = this.BlurDirectionX;\n      renderer.setRenderTarget(this.renderTargetBlurBuffer2);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      this.separableBlurMaterial2.uniforms[\"colorTexture\"].value = this.renderTargetBlurBuffer2.texture;\n      this.separableBlurMaterial2.uniforms[\"direction\"].value = this.BlurDirectionY;\n      renderer.setRenderTarget(this.renderTargetEdgeBuffer2);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      this.fsQuad.material = this.overlayMaterial;\n      this.overlayMaterial.uniforms[\"maskTexture\"].value = this.renderTargetMaskBuffer.texture;\n      this.overlayMaterial.uniforms[\"edgeTexture1\"].value = this.renderTargetEdgeBuffer1.texture;\n      this.overlayMaterial.uniforms[\"edgeTexture2\"].value = this.renderTargetEdgeBuffer2.texture;\n      this.overlayMaterial.uniforms[\"patternTexture\"].value = this.patternTexture;\n      this.overlayMaterial.uniforms[\"edgeStrength\"].value = this.edgeStrength;\n      this.overlayMaterial.uniforms[\"edgeGlow\"].value = this.edgeGlow;\n      this.overlayMaterial.uniforms[\"usePatternTexture\"].value = this.usePatternTexture;\n      if (maskActive)\n        renderer.state.buffers.stencil.setTest(true);\n      renderer.setRenderTarget(readBuffer);\n      this.fsQuad.render(renderer);\n      renderer.setClearColor(this._oldClearColor, this.oldClearAlpha);\n      renderer.autoClear = oldAutoClear;\n    }\n    if (this.renderToScreen) {\n      this.fsQuad.material = this.materialCopy;\n      this.copyUniforms[\"tDiffuse\"].value = readBuffer.texture;\n      renderer.setRenderTarget(null);\n      this.fsQuad.render(renderer);\n    }\n  }\n  getPrepareMaskMaterial() {\n    return new ShaderMaterial({\n      uniforms: {\n        depthTexture: { value: null },\n        cameraNearFar: { value: new Vector2(0.5, 0.5) },\n        textureMatrix: { value: null }\n      },\n      vertexShader: `#include <morphtarget_pars_vertex>\n\t\t\t\t#include <skinning_pars_vertex>\n\t\t\t\tvarying vec4 projTexCoord;\n\t\t\t\tvarying vec4 vPosition;\n\t\t\t\tuniform mat4 textureMatrix;\n\t\t\t\tvoid main() {\n\t\t\t\t\t#include <skinbase_vertex>\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <morphtarget_vertex>\n\t\t\t\t\t#include <skinning_vertex>\n\t\t\t\t\t#include <project_vertex>\n\t\t\t\t\tvPosition = mvPosition;\n\t\t\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\t\t\t\t\tprojTexCoord = textureMatrix * worldPosition;\n\t\t\t\t}`,\n      fragmentShader: `#include <packing>\n\t\t\t\tvarying vec4 vPosition;\n\t\t\t\tvarying vec4 projTexCoord;\n\t\t\t\tuniform sampler2D depthTexture;\n\t\t\t\tuniform vec2 cameraNearFar;\n\t\t\t\tvoid main() {\n\t\t\t\t\tfloat depth = unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));\n\t\t\t\t\tfloat viewZ = - DEPTH_TO_VIEW_Z( depth, cameraNearFar.x, cameraNearFar.y );\n\t\t\t\t\tfloat depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;\n\t\t\t\t\tgl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);\n\t\t\t\t}`\n    });\n  }\n  getEdgeDetectionMaterial() {\n    return new ShaderMaterial({\n      uniforms: {\n        maskTexture: { value: null },\n        texSize: { value: new Vector2(0.5, 0.5) },\n        visibleEdgeColor: { value: new Vector3(1, 1, 1) },\n        hiddenEdgeColor: { value: new Vector3(1, 1, 1) }\n      },\n      vertexShader: `varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n      fragmentShader: `varying vec2 vUv;\n\t\t\t\tuniform sampler2D maskTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec3 visibleEdgeColor;\n\t\t\t\tuniform vec3 hiddenEdgeColor;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tvec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);\n\t\t\t\t\tvec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);\n\t\t\t\t\tvec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);\n\t\t\t\t\tvec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);\n\t\t\t\t\tvec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);\n\t\t\t\t\tfloat diff1 = (c1.r - c2.r)*0.5;\n\t\t\t\t\tfloat diff2 = (c3.r - c4.r)*0.5;\n\t\t\t\t\tfloat d = length( vec2(diff1, diff2) );\n\t\t\t\t\tfloat a1 = min(c1.g, c2.g);\n\t\t\t\t\tfloat a2 = min(c3.g, c4.g);\n\t\t\t\t\tfloat visibilityFactor = min(a1, a2);\n\t\t\t\t\tvec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;\n\t\t\t\t\tgl_FragColor = vec4(edgeColor, 1.0) * vec4(d);\n\t\t\t\t}`\n    });\n  }\n  getSeperableBlurMaterial(maxRadius) {\n    return new ShaderMaterial({\n      defines: {\n        MAX_RADIUS: maxRadius\n      },\n      uniforms: {\n        colorTexture: { value: null },\n        texSize: { value: new Vector2(0.5, 0.5) },\n        direction: { value: new Vector2(0.5, 0.5) },\n        kernelRadius: { value: 1 }\n      },\n      vertexShader: `varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n      fragmentShader: `#include <common>\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec2 direction;\n\t\t\t\tuniform float kernelRadius;\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\n\t\t\t\t}\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, kernelRadius);\n\t\t\t\t\tvec4 diffuseSum = texture2D( colorTexture, vUv) * weightSum;\n\t\t\t\t\tvec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);\n\t\t\t\t\tvec2 uvOffset = delta;\n\t\t\t\t\tfor( int i = 1; i <= MAX_RADIUS; i ++ ) {\n\t\t\t\t\t\tfloat w = gaussianPdf(uvOffset.x, kernelRadius);\n\t\t\t\t\t\tvec4 sample1 = texture2D( colorTexture, vUv + uvOffset);\n\t\t\t\t\t\tvec4 sample2 = texture2D( colorTexture, vUv - uvOffset);\n\t\t\t\t\t\tdiffuseSum += ((sample1 + sample2) * w);\n\t\t\t\t\t\tweightSum += (2.0 * w);\n\t\t\t\t\t\tuvOffset += delta;\n\t\t\t\t\t}\n\t\t\t\t\tgl_FragColor = diffuseSum/weightSum;\n\t\t\t\t}`\n    });\n  }\n  getOverlayMaterial() {\n    return new ShaderMaterial({\n      uniforms: {\n        maskTexture: { value: null },\n        edgeTexture1: { value: null },\n        edgeTexture2: { value: null },\n        patternTexture: { value: null },\n        edgeStrength: { value: 1 },\n        edgeGlow: { value: 1 },\n        usePatternTexture: { value: 0 }\n      },\n      vertexShader: `varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n      fragmentShader: `varying vec2 vUv;\n\t\t\t\tuniform sampler2D maskTexture;\n\t\t\t\tuniform sampler2D edgeTexture1;\n\t\t\t\tuniform sampler2D edgeTexture2;\n\t\t\t\tuniform sampler2D patternTexture;\n\t\t\t\tuniform float edgeStrength;\n\t\t\t\tuniform float edgeGlow;\n\t\t\t\tuniform bool usePatternTexture;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec4 edgeValue1 = texture2D(edgeTexture1, vUv);\n\t\t\t\t\tvec4 edgeValue2 = texture2D(edgeTexture2, vUv);\n\t\t\t\t\tvec4 maskColor = texture2D(maskTexture, vUv);\n\t\t\t\t\tvec4 patternColor = texture2D(patternTexture, 6.0 * vUv);\n\t\t\t\t\tfloat visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;\n\t\t\t\t\tvec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;\n\t\t\t\t\tvec4 finalColor = edgeStrength * maskColor.r * edgeValue;\n\t\t\t\t\tif(usePatternTexture)\n\t\t\t\t\t\tfinalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);\n\t\t\t\t\tgl_FragColor = finalColor;\n\t\t\t\t}`,\n      blending: AdditiveBlending,\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n  }\n}\nexport {\n  OutlinePass\n};\n"]},"metadata":{},"sourceType":"module"}