{"ast":null,"code":"import _classCallCheck from \"/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport { FloatType, Scene, Camera, Mesh, PlaneGeometry, NearestFilter, ShaderMaterial, ClampToEdgeWrapping, WebGLRenderTarget, RGBAFormat, DataTexture, NoToneMapping } from \"three\";\n\nvar GPUComputationRenderer = function GPUComputationRenderer(sizeX, sizeY, renderer) {\n  _classCallCheck(this, GPUComputationRenderer);\n\n  this.variables = [];\n  this.currentTextureIndex = 0;\n  var dataType = FloatType;\n  var scene = new Scene();\n  var camera = new Camera();\n  camera.position.z = 1;\n  var passThruUniforms = {\n    passThruTexture: {\n      value: null\n    }\n  };\n  var passThruShader = createShaderMaterial(getPassThroughFragmentShader(), passThruUniforms);\n  var mesh = new Mesh(new PlaneGeometry(2, 2), passThruShader);\n  scene.add(mesh);\n\n  this.setDataType = function (type) {\n    dataType = type;\n    return this;\n  };\n\n  this.addVariable = function (variableName, computeFragmentShader, initialValueTexture) {\n    var material = this.createShaderMaterial(computeFragmentShader);\n    var variable = {\n      name: variableName,\n      initialValueTexture: initialValueTexture,\n      material: material,\n      dependencies: null,\n      renderTargets: [],\n      wrapS: null,\n      wrapT: null,\n      minFilter: NearestFilter,\n      magFilter: NearestFilter\n    };\n    this.variables.push(variable);\n    return variable;\n  };\n\n  this.setVariableDependencies = function (variable, dependencies) {\n    variable.dependencies = dependencies;\n  };\n\n  this.init = function () {\n    if (renderer.capabilities.isWebGL2 === false && renderer.extensions.has(\"OES_texture_float\") === false) {\n      return \"No OES_texture_float support for float textures.\";\n    }\n\n    if (renderer.capabilities.maxVertexTextures === 0) {\n      return \"No support for vertex shader textures.\";\n    }\n\n    for (var i = 0; i < this.variables.length; i++) {\n      var variable = this.variables[i];\n      variable.renderTargets[0] = this.createRenderTarget(sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter);\n      variable.renderTargets[1] = this.createRenderTarget(sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter);\n      this.renderTexture(variable.initialValueTexture, variable.renderTargets[0]);\n      this.renderTexture(variable.initialValueTexture, variable.renderTargets[1]);\n      var material = variable.material;\n      var uniforms = material.uniforms;\n\n      if (variable.dependencies !== null) {\n        for (var d = 0; d < variable.dependencies.length; d++) {\n          var depVar = variable.dependencies[d];\n\n          if (depVar.name !== variable.name) {\n            var found = false;\n\n            for (var j = 0; j < this.variables.length; j++) {\n              if (depVar.name === this.variables[j].name) {\n                found = true;\n                break;\n              }\n            }\n\n            if (!found) {\n              return \"Variable dependency not found. Variable=\" + variable.name + \", dependency=\" + depVar.name;\n            }\n          }\n\n          uniforms[depVar.name] = {\n            value: null\n          };\n          material.fragmentShader = \"\\nuniform sampler2D \" + depVar.name + \";\\n\" + material.fragmentShader;\n        }\n      }\n    }\n\n    this.currentTextureIndex = 0;\n    return null;\n  };\n\n  this.compute = function () {\n    var currentTextureIndex = this.currentTextureIndex;\n    var nextTextureIndex = this.currentTextureIndex === 0 ? 1 : 0;\n\n    for (var i = 0, il = this.variables.length; i < il; i++) {\n      var variable = this.variables[i];\n\n      if (variable.dependencies !== null) {\n        var uniforms = variable.material.uniforms;\n\n        for (var d = 0, dl = variable.dependencies.length; d < dl; d++) {\n          var depVar = variable.dependencies[d];\n          uniforms[depVar.name].value = depVar.renderTargets[currentTextureIndex].texture;\n        }\n      }\n\n      this.doRenderTarget(variable.material, variable.renderTargets[nextTextureIndex]);\n    }\n\n    this.currentTextureIndex = nextTextureIndex;\n  };\n\n  this.getCurrentRenderTarget = function (variable) {\n    return variable.renderTargets[this.currentTextureIndex];\n  };\n\n  this.getAlternateRenderTarget = function (variable) {\n    return variable.renderTargets[this.currentTextureIndex === 0 ? 1 : 0];\n  };\n\n  this.dispose = function () {\n    mesh.geometry.dispose();\n    mesh.material.dispose();\n    var variables = this.variables;\n\n    for (var i = 0; i < variables.length; i++) {\n      var variable = variables[i];\n      if (variable.initialValueTexture) variable.initialValueTexture.dispose();\n      var renderTargets = variable.renderTargets;\n\n      for (var j = 0; j < renderTargets.length; j++) {\n        var renderTarget = renderTargets[j];\n        renderTarget.dispose();\n      }\n    }\n  };\n\n  function addResolutionDefine(materialShader) {\n    materialShader.defines.resolution = \"vec2( \" + sizeX.toFixed(1) + \", \" + sizeY.toFixed(1) + \" )\";\n  }\n\n  this.addResolutionDefine = addResolutionDefine;\n\n  function createShaderMaterial(computeFragmentShader, uniforms) {\n    uniforms = uniforms || {};\n    var material = new ShaderMaterial({\n      uniforms: uniforms,\n      vertexShader: getPassThroughVertexShader(),\n      fragmentShader: computeFragmentShader\n    });\n    addResolutionDefine(material);\n    return material;\n  }\n\n  this.createShaderMaterial = createShaderMaterial;\n\n  this.createRenderTarget = function (sizeXTexture, sizeYTexture, wrapS, wrapT, minFilter, magFilter) {\n    sizeXTexture = sizeXTexture || sizeX;\n    sizeYTexture = sizeYTexture || sizeY;\n    wrapS = wrapS || ClampToEdgeWrapping;\n    wrapT = wrapT || ClampToEdgeWrapping;\n    minFilter = minFilter || NearestFilter;\n    magFilter = magFilter || NearestFilter;\n    var renderTarget = new WebGLRenderTarget(sizeXTexture, sizeYTexture, {\n      wrapS: wrapS,\n      wrapT: wrapT,\n      minFilter: minFilter,\n      magFilter: magFilter,\n      format: RGBAFormat,\n      type: dataType,\n      depthBuffer: false\n    });\n    return renderTarget;\n  };\n\n  this.createTexture = function () {\n    var data = new Float32Array(sizeX * sizeY * 4);\n    var texture = new DataTexture(data, sizeX, sizeY, RGBAFormat, FloatType);\n    texture.needsUpdate = true;\n    return texture;\n  };\n\n  this.renderTexture = function (input, output) {\n    passThruUniforms.passThruTexture.value = input;\n    this.doRenderTarget(passThruShader, output);\n    passThruUniforms.passThruTexture.value = null;\n  };\n\n  this.doRenderTarget = function (material, output) {\n    var currentRenderTarget = renderer.getRenderTarget();\n    var currentXrEnabled = renderer.xr.enabled;\n    var currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n    var currentOutputColorSpace = renderer.outputColorSpace;\n    var currentToneMapping = renderer.toneMapping;\n    renderer.xr.enabled = false;\n    renderer.shadowMap.autoUpdate = false;\n    if (\"outputColorSpace\" in renderer) renderer.outputColorSpace = \"srgb-linear\";else renderer.encoding = 3e3;\n    renderer.toneMapping = NoToneMapping;\n    mesh.material = material;\n    renderer.setRenderTarget(output);\n    renderer.render(scene, camera);\n    mesh.material = passThruShader;\n    renderer.xr.enabled = currentXrEnabled;\n    renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n    renderer.outputColorSpace = currentOutputColorSpace;\n    renderer.toneMapping = currentToneMapping;\n    renderer.setRenderTarget(currentRenderTarget);\n  };\n\n  function getPassThroughVertexShader() {\n    return \"void main()\t{\\n\\n\tgl_Position = vec4( position, 1.0 );\\n\\n}\\n\";\n  }\n\n  function getPassThroughFragmentShader() {\n    return \"uniform sampler2D passThruTexture;\\n\\nvoid main() {\\n\\n\tvec2 uv = gl_FragCoord.xy / resolution.xy;\\n\\n\tgl_FragColor = texture2D( passThruTexture, uv );\\n\\n}\\n\";\n  }\n};\n\nexport { GPUComputationRenderer };","map":{"version":3,"sources":["/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/three-stdlib/misc/GPUComputationRenderer.js"],"names":["FloatType","Scene","Camera","Mesh","PlaneGeometry","NearestFilter","ShaderMaterial","ClampToEdgeWrapping","WebGLRenderTarget","RGBAFormat","DataTexture","NoToneMapping","GPUComputationRenderer","sizeX","sizeY","renderer","variables","currentTextureIndex","dataType","scene","camera","position","z","passThruUniforms","passThruTexture","value","passThruShader","createShaderMaterial","getPassThroughFragmentShader","mesh","add","setDataType","type","addVariable","variableName","computeFragmentShader","initialValueTexture","material","variable","name","dependencies","renderTargets","wrapS","wrapT","minFilter","magFilter","push","setVariableDependencies","init","capabilities","isWebGL2","extensions","has","maxVertexTextures","i","length","createRenderTarget","renderTexture","uniforms","d","depVar","found","j","fragmentShader","compute","nextTextureIndex","il","dl","texture","doRenderTarget","getCurrentRenderTarget","getAlternateRenderTarget","dispose","geometry","renderTarget","addResolutionDefine","materialShader","defines","resolution","toFixed","vertexShader","getPassThroughVertexShader","sizeXTexture","sizeYTexture","format","depthBuffer","createTexture","data","Float32Array","needsUpdate","input","output","currentRenderTarget","getRenderTarget","currentXrEnabled","xr","enabled","currentShadowAutoUpdate","shadowMap","autoUpdate","currentOutputColorSpace","outputColorSpace","currentToneMapping","toneMapping","encoding","setRenderTarget","render"],"mappings":"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","sourcesContent":["import { FloatType, Scene, Camera, Mesh, PlaneGeometry, NearestFilter, ShaderMaterial, ClampToEdgeWrapping, WebGLRenderTarget, RGBAFormat, DataTexture, NoToneMapping } from \"three\";\nclass GPUComputationRenderer {\n  constructor(sizeX, sizeY, renderer) {\n    this.variables = [];\n    this.currentTextureIndex = 0;\n    let dataType = FloatType;\n    const scene = new Scene();\n    const camera = new Camera();\n    camera.position.z = 1;\n    const passThruUniforms = {\n      passThruTexture: { value: null }\n    };\n    const passThruShader = createShaderMaterial(getPassThroughFragmentShader(), passThruUniforms);\n    const mesh = new Mesh(new PlaneGeometry(2, 2), passThruShader);\n    scene.add(mesh);\n    this.setDataType = function(type) {\n      dataType = type;\n      return this;\n    };\n    this.addVariable = function(variableName, computeFragmentShader, initialValueTexture) {\n      const material = this.createShaderMaterial(computeFragmentShader);\n      const variable = {\n        name: variableName,\n        initialValueTexture,\n        material,\n        dependencies: null,\n        renderTargets: [],\n        wrapS: null,\n        wrapT: null,\n        minFilter: NearestFilter,\n        magFilter: NearestFilter\n      };\n      this.variables.push(variable);\n      return variable;\n    };\n    this.setVariableDependencies = function(variable, dependencies) {\n      variable.dependencies = dependencies;\n    };\n    this.init = function() {\n      if (renderer.capabilities.isWebGL2 === false && renderer.extensions.has(\"OES_texture_float\") === false) {\n        return \"No OES_texture_float support for float textures.\";\n      }\n      if (renderer.capabilities.maxVertexTextures === 0) {\n        return \"No support for vertex shader textures.\";\n      }\n      for (let i = 0; i < this.variables.length; i++) {\n        const variable = this.variables[i];\n        variable.renderTargets[0] = this.createRenderTarget(\n          sizeX,\n          sizeY,\n          variable.wrapS,\n          variable.wrapT,\n          variable.minFilter,\n          variable.magFilter\n        );\n        variable.renderTargets[1] = this.createRenderTarget(\n          sizeX,\n          sizeY,\n          variable.wrapS,\n          variable.wrapT,\n          variable.minFilter,\n          variable.magFilter\n        );\n        this.renderTexture(variable.initialValueTexture, variable.renderTargets[0]);\n        this.renderTexture(variable.initialValueTexture, variable.renderTargets[1]);\n        const material = variable.material;\n        const uniforms = material.uniforms;\n        if (variable.dependencies !== null) {\n          for (let d = 0; d < variable.dependencies.length; d++) {\n            const depVar = variable.dependencies[d];\n            if (depVar.name !== variable.name) {\n              let found = false;\n              for (let j = 0; j < this.variables.length; j++) {\n                if (depVar.name === this.variables[j].name) {\n                  found = true;\n                  break;\n                }\n              }\n              if (!found) {\n                return \"Variable dependency not found. Variable=\" + variable.name + \", dependency=\" + depVar.name;\n              }\n            }\n            uniforms[depVar.name] = { value: null };\n            material.fragmentShader = \"\\nuniform sampler2D \" + depVar.name + \";\\n\" + material.fragmentShader;\n          }\n        }\n      }\n      this.currentTextureIndex = 0;\n      return null;\n    };\n    this.compute = function() {\n      const currentTextureIndex = this.currentTextureIndex;\n      const nextTextureIndex = this.currentTextureIndex === 0 ? 1 : 0;\n      for (let i = 0, il = this.variables.length; i < il; i++) {\n        const variable = this.variables[i];\n        if (variable.dependencies !== null) {\n          const uniforms = variable.material.uniforms;\n          for (let d = 0, dl = variable.dependencies.length; d < dl; d++) {\n            const depVar = variable.dependencies[d];\n            uniforms[depVar.name].value = depVar.renderTargets[currentTextureIndex].texture;\n          }\n        }\n        this.doRenderTarget(variable.material, variable.renderTargets[nextTextureIndex]);\n      }\n      this.currentTextureIndex = nextTextureIndex;\n    };\n    this.getCurrentRenderTarget = function(variable) {\n      return variable.renderTargets[this.currentTextureIndex];\n    };\n    this.getAlternateRenderTarget = function(variable) {\n      return variable.renderTargets[this.currentTextureIndex === 0 ? 1 : 0];\n    };\n    this.dispose = function() {\n      mesh.geometry.dispose();\n      mesh.material.dispose();\n      const variables = this.variables;\n      for (let i = 0; i < variables.length; i++) {\n        const variable = variables[i];\n        if (variable.initialValueTexture)\n          variable.initialValueTexture.dispose();\n        const renderTargets = variable.renderTargets;\n        for (let j = 0; j < renderTargets.length; j++) {\n          const renderTarget = renderTargets[j];\n          renderTarget.dispose();\n        }\n      }\n    };\n    function addResolutionDefine(materialShader) {\n      materialShader.defines.resolution = \"vec2( \" + sizeX.toFixed(1) + \", \" + sizeY.toFixed(1) + \" )\";\n    }\n    this.addResolutionDefine = addResolutionDefine;\n    function createShaderMaterial(computeFragmentShader, uniforms) {\n      uniforms = uniforms || {};\n      const material = new ShaderMaterial({\n        uniforms,\n        vertexShader: getPassThroughVertexShader(),\n        fragmentShader: computeFragmentShader\n      });\n      addResolutionDefine(material);\n      return material;\n    }\n    this.createShaderMaterial = createShaderMaterial;\n    this.createRenderTarget = function(sizeXTexture, sizeYTexture, wrapS, wrapT, minFilter, magFilter) {\n      sizeXTexture = sizeXTexture || sizeX;\n      sizeYTexture = sizeYTexture || sizeY;\n      wrapS = wrapS || ClampToEdgeWrapping;\n      wrapT = wrapT || ClampToEdgeWrapping;\n      minFilter = minFilter || NearestFilter;\n      magFilter = magFilter || NearestFilter;\n      const renderTarget = new WebGLRenderTarget(sizeXTexture, sizeYTexture, {\n        wrapS,\n        wrapT,\n        minFilter,\n        magFilter,\n        format: RGBAFormat,\n        type: dataType,\n        depthBuffer: false\n      });\n      return renderTarget;\n    };\n    this.createTexture = function() {\n      const data = new Float32Array(sizeX * sizeY * 4);\n      const texture = new DataTexture(data, sizeX, sizeY, RGBAFormat, FloatType);\n      texture.needsUpdate = true;\n      return texture;\n    };\n    this.renderTexture = function(input, output) {\n      passThruUniforms.passThruTexture.value = input;\n      this.doRenderTarget(passThruShader, output);\n      passThruUniforms.passThruTexture.value = null;\n    };\n    this.doRenderTarget = function(material, output) {\n      const currentRenderTarget = renderer.getRenderTarget();\n      const currentXrEnabled = renderer.xr.enabled;\n      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n      const currentOutputColorSpace = renderer.outputColorSpace;\n      const currentToneMapping = renderer.toneMapping;\n      renderer.xr.enabled = false;\n      renderer.shadowMap.autoUpdate = false;\n      if (\"outputColorSpace\" in renderer)\n        renderer.outputColorSpace = \"srgb-linear\";\n      else\n        renderer.encoding = 3e3;\n      renderer.toneMapping = NoToneMapping;\n      mesh.material = material;\n      renderer.setRenderTarget(output);\n      renderer.render(scene, camera);\n      mesh.material = passThruShader;\n      renderer.xr.enabled = currentXrEnabled;\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n      renderer.outputColorSpace = currentOutputColorSpace;\n      renderer.toneMapping = currentToneMapping;\n      renderer.setRenderTarget(currentRenderTarget);\n    };\n    function getPassThroughVertexShader() {\n      return \"void main()\t{\\n\\n\tgl_Position = vec4( position, 1.0 );\\n\\n}\\n\";\n    }\n    function getPassThroughFragmentShader() {\n      return \"uniform sampler2D passThruTexture;\\n\\nvoid main() {\\n\\n\tvec2 uv = gl_FragCoord.xy / resolution.xy;\\n\\n\tgl_FragColor = texture2D( passThruTexture, uv );\\n\\n}\\n\";\n    }\n  }\n}\nexport {\n  GPUComputationRenderer\n};\n"]},"metadata":{},"sourceType":"module"}