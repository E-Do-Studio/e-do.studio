{"ast":null,"code":"import { Loader, FileLoader, BufferGeometry, BufferAttribute } from \"three\";\nlet bigEndianPlatform = null;\n\nfunction isBigEndianPlatform() {\n  if (bigEndianPlatform === null) {\n    const buffer = new ArrayBuffer(2),\n          uint8Array = new Uint8Array(buffer),\n          uint16Array = new Uint16Array(buffer);\n    uint8Array[0] = 170;\n    uint8Array[1] = 187;\n    bigEndianPlatform = uint16Array[0] === 43707;\n  }\n\n  return bigEndianPlatform;\n}\n\nconst InvertedEncodingTypes = [null, Float32Array, null, Int8Array, Int16Array, null, Int32Array, Uint8Array, Uint16Array, null, Uint32Array];\nconst getMethods = {\n  Uint16Array: \"getUint16\",\n  Uint32Array: \"getUint32\",\n  Int16Array: \"getInt16\",\n  Int32Array: \"getInt32\",\n  Float32Array: \"getFloat32\",\n  Float64Array: \"getFloat64\"\n};\n\nfunction copyFromBuffer(sourceArrayBuffer, viewType, position, length, fromBigEndian) {\n  const bytesPerElement = viewType.BYTES_PER_ELEMENT;\n  let result;\n\n  if (fromBigEndian === isBigEndianPlatform() || bytesPerElement === 1) {\n    result = new viewType(sourceArrayBuffer, position, length);\n  } else {\n    const readView = new DataView(sourceArrayBuffer, position, length * bytesPerElement),\n          getMethod = getMethods[viewType.name],\n          littleEndian = !fromBigEndian;\n    result = new viewType(length);\n\n    for (let i = 0; i < length; i++) {\n      result[i] = readView[getMethod](i * bytesPerElement, littleEndian);\n    }\n  }\n\n  return result;\n}\n\nfunction decodePrwm(buffer) {\n  const array = new Uint8Array(buffer),\n        version = array[0];\n  let flags = array[1];\n  const indexedGeometry = !!(flags >> 7 & 1),\n        indicesType = flags >> 6 & 1,\n        bigEndian = (flags >> 5 & 1) === 1,\n        attributesNumber = flags & 31;\n  let valuesNumber = 0,\n      indicesNumber = 0;\n\n  if (bigEndian) {\n    valuesNumber = (array[2] << 16) + (array[3] << 8) + array[4];\n    indicesNumber = (array[5] << 16) + (array[6] << 8) + array[7];\n  } else {\n    valuesNumber = array[2] + (array[3] << 8) + (array[4] << 16);\n    indicesNumber = array[5] + (array[6] << 8) + (array[7] << 16);\n  }\n\n  if (version === 0) {\n    throw new Error(\"PRWM decoder: Invalid format version: 0\");\n  } else if (version !== 1) {\n    throw new Error(\"PRWM decoder: Unsupported format version: \" + version);\n  }\n\n  if (!indexedGeometry) {\n    if (indicesType !== 0) {\n      throw new Error(\"PRWM decoder: Indices type must be set to 0 for non-indexed geometries\");\n    } else if (indicesNumber !== 0) {\n      throw new Error(\"PRWM decoder: Number of indices must be set to 0 for non-indexed geometries\");\n    }\n  }\n\n  let pos = 8;\n  const attributes = {};\n\n  for (let i = 0; i < attributesNumber; i++) {\n    let attributeName = \"\";\n\n    while (pos < array.length) {\n      const char = array[pos];\n      pos++;\n\n      if (char === 0) {\n        break;\n      } else {\n        attributeName += String.fromCharCode(char);\n      }\n    }\n\n    flags = array[pos];\n    const attributeType = flags >> 7 & 1;\n    const cardinality = (flags >> 4 & 3) + 1;\n    const encodingType = flags & 15;\n    const arrayType = InvertedEncodingTypes[encodingType];\n    pos++;\n    pos = Math.ceil(pos / 4) * 4;\n    const values = copyFromBuffer(buffer, arrayType, pos, cardinality * valuesNumber, bigEndian);\n    pos += arrayType.BYTES_PER_ELEMENT * cardinality * valuesNumber;\n    attributes[attributeName] = {\n      type: attributeType,\n      cardinality,\n      values\n    };\n  }\n\n  pos = Math.ceil(pos / 4) * 4;\n  let indices = null;\n\n  if (indexedGeometry) {\n    indices = copyFromBuffer(buffer, indicesType === 1 ? Uint32Array : Uint16Array, pos, indicesNumber, bigEndian);\n  }\n\n  return {\n    version,\n    attributes,\n    indices\n  };\n}\n\nclass PRWMLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setResponseType(\"arraybuffer\");\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    url = url.replace(/\\*/g, isBigEndianPlatform() ? \"be\" : \"le\");\n    loader.load(url, function (arrayBuffer) {\n      try {\n        onLoad(scope.parse(arrayBuffer));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n\n  parse(arrayBuffer) {\n    const data = decodePrwm(arrayBuffer),\n          attributesKey = Object.keys(data.attributes),\n          bufferGeometry = new BufferGeometry();\n\n    for (let i = 0; i < attributesKey.length; i++) {\n      const attribute = data.attributes[attributesKey[i]];\n      bufferGeometry.setAttribute(attributesKey[i], new BufferAttribute(attribute.values, attribute.cardinality, attribute.normalized));\n    }\n\n    if (data.indices !== null) {\n      bufferGeometry.setIndex(new BufferAttribute(data.indices, 1));\n    }\n\n    return bufferGeometry;\n  }\n\n  static isBigEndianPlatform() {\n    return isBigEndianPlatform();\n  }\n\n}\n\nexport { PRWMLoader };","map":{"version":3,"sources":["/Users/theodaguier/_workdir/dev/pro/e-do/E-Do-Studio/node_modules/three-stdlib/loaders/PRWMLoader.js"],"names":["Loader","FileLoader","BufferGeometry","BufferAttribute","bigEndianPlatform","isBigEndianPlatform","buffer","ArrayBuffer","uint8Array","Uint8Array","uint16Array","Uint16Array","InvertedEncodingTypes","Float32Array","Int8Array","Int16Array","Int32Array","Uint32Array","getMethods","Float64Array","copyFromBuffer","sourceArrayBuffer","viewType","position","length","fromBigEndian","bytesPerElement","BYTES_PER_ELEMENT","result","readView","DataView","getMethod","name","littleEndian","i","decodePrwm","array","version","flags","indexedGeometry","indicesType","bigEndian","attributesNumber","valuesNumber","indicesNumber","Error","pos","attributes","attributeName","char","String","fromCharCode","attributeType","cardinality","encodingType","arrayType","Math","ceil","values","type","indices","PRWMLoader","constructor","manager","load","url","onLoad","onProgress","onError","scope","loader","setPath","path","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","replace","arrayBuffer","parse","e","console","error","itemError","data","attributesKey","Object","keys","bufferGeometry","attribute","setAttribute","normalized","setIndex"],"mappings":"AAAA,SAASA,MAAT,EAAiBC,UAAjB,EAA6BC,cAA7B,EAA6CC,eAA7C,QAAoE,OAApE;AACA,IAAIC,iBAAiB,GAAG,IAAxB;;AACA,SAASC,mBAAT,GAA+B;AAC7B,MAAID,iBAAiB,KAAK,IAA1B,EAAgC;AAC9B,UAAME,MAAM,GAAG,IAAIC,WAAJ,CAAgB,CAAhB,CAAf;AAAA,UAAmCC,UAAU,GAAG,IAAIC,UAAJ,CAAeH,MAAf,CAAhD;AAAA,UAAwEI,WAAW,GAAG,IAAIC,WAAJ,CAAgBL,MAAhB,CAAtF;AACAE,IAAAA,UAAU,CAAC,CAAD,CAAV,GAAgB,GAAhB;AACAA,IAAAA,UAAU,CAAC,CAAD,CAAV,GAAgB,GAAhB;AACAJ,IAAAA,iBAAiB,GAAGM,WAAW,CAAC,CAAD,CAAX,KAAmB,KAAvC;AACD;;AACD,SAAON,iBAAP;AACD;;AACD,MAAMQ,qBAAqB,GAAG,CAC5B,IAD4B,EAE5BC,YAF4B,EAG5B,IAH4B,EAI5BC,SAJ4B,EAK5BC,UAL4B,EAM5B,IAN4B,EAO5BC,UAP4B,EAQ5BP,UAR4B,EAS5BE,WAT4B,EAU5B,IAV4B,EAW5BM,WAX4B,CAA9B;AAaA,MAAMC,UAAU,GAAG;AACjBP,EAAAA,WAAW,EAAE,WADI;AAEjBM,EAAAA,WAAW,EAAE,WAFI;AAGjBF,EAAAA,UAAU,EAAE,UAHK;AAIjBC,EAAAA,UAAU,EAAE,UAJK;AAKjBH,EAAAA,YAAY,EAAE,YALG;AAMjBM,EAAAA,YAAY,EAAE;AANG,CAAnB;;AAQA,SAASC,cAAT,CAAwBC,iBAAxB,EAA2CC,QAA3C,EAAqDC,QAArD,EAA+DC,MAA/D,EAAuEC,aAAvE,EAAsF;AACpF,QAAMC,eAAe,GAAGJ,QAAQ,CAACK,iBAAjC;AACA,MAAIC,MAAJ;;AACA,MAAIH,aAAa,KAAKpB,mBAAmB,EAArC,IAA2CqB,eAAe,KAAK,CAAnE,EAAsE;AACpEE,IAAAA,MAAM,GAAG,IAAIN,QAAJ,CAAaD,iBAAb,EAAgCE,QAAhC,EAA0CC,MAA1C,CAAT;AACD,GAFD,MAEO;AACL,UAAMK,QAAQ,GAAG,IAAIC,QAAJ,CAAaT,iBAAb,EAAgCE,QAAhC,EAA0CC,MAAM,GAAGE,eAAnD,CAAjB;AAAA,UAAsFK,SAAS,GAAGb,UAAU,CAACI,QAAQ,CAACU,IAAV,CAA5G;AAAA,UAA6HC,YAAY,GAAG,CAACR,aAA7I;AACAG,IAAAA,MAAM,GAAG,IAAIN,QAAJ,CAAaE,MAAb,CAAT;;AACA,SAAK,IAAIU,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGV,MAApB,EAA4BU,CAAC,EAA7B,EAAiC;AAC/BN,MAAAA,MAAM,CAACM,CAAD,CAAN,GAAYL,QAAQ,CAACE,SAAD,CAAR,CAAoBG,CAAC,GAAGR,eAAxB,EAAyCO,YAAzC,CAAZ;AACD;AACF;;AACD,SAAOL,MAAP;AACD;;AACD,SAASO,UAAT,CAAoB7B,MAApB,EAA4B;AAC1B,QAAM8B,KAAK,GAAG,IAAI3B,UAAJ,CAAeH,MAAf,CAAd;AAAA,QAAsC+B,OAAO,GAAGD,KAAK,CAAC,CAAD,CAArD;AACA,MAAIE,KAAK,GAAGF,KAAK,CAAC,CAAD,CAAjB;AACA,QAAMG,eAAe,GAAG,CAAC,EAAED,KAAK,IAAI,CAAT,GAAa,CAAf,CAAzB;AAAA,QAA4CE,WAAW,GAAGF,KAAK,IAAI,CAAT,GAAa,CAAvE;AAAA,QAA0EG,SAAS,GAAG,CAACH,KAAK,IAAI,CAAT,GAAa,CAAd,MAAqB,CAA3G;AAAA,QAA8GI,gBAAgB,GAAGJ,KAAK,GAAG,EAAzI;AACA,MAAIK,YAAY,GAAG,CAAnB;AAAA,MAAsBC,aAAa,GAAG,CAAtC;;AACA,MAAIH,SAAJ,EAAe;AACbE,IAAAA,YAAY,GAAG,CAACP,KAAK,CAAC,CAAD,CAAL,IAAY,EAAb,KAAoBA,KAAK,CAAC,CAAD,CAAL,IAAY,CAAhC,IAAqCA,KAAK,CAAC,CAAD,CAAzD;AACAQ,IAAAA,aAAa,GAAG,CAACR,KAAK,CAAC,CAAD,CAAL,IAAY,EAAb,KAAoBA,KAAK,CAAC,CAAD,CAAL,IAAY,CAAhC,IAAqCA,KAAK,CAAC,CAAD,CAA1D;AACD,GAHD,MAGO;AACLO,IAAAA,YAAY,GAAGP,KAAK,CAAC,CAAD,CAAL,IAAYA,KAAK,CAAC,CAAD,CAAL,IAAY,CAAxB,KAA8BA,KAAK,CAAC,CAAD,CAAL,IAAY,EAA1C,CAAf;AACAQ,IAAAA,aAAa,GAAGR,KAAK,CAAC,CAAD,CAAL,IAAYA,KAAK,CAAC,CAAD,CAAL,IAAY,CAAxB,KAA8BA,KAAK,CAAC,CAAD,CAAL,IAAY,EAA1C,CAAhB;AACD;;AACD,MAAIC,OAAO,KAAK,CAAhB,EAAmB;AACjB,UAAM,IAAIQ,KAAJ,CAAU,yCAAV,CAAN;AACD,GAFD,MAEO,IAAIR,OAAO,KAAK,CAAhB,EAAmB;AACxB,UAAM,IAAIQ,KAAJ,CAAU,+CAA+CR,OAAzD,CAAN;AACD;;AACD,MAAI,CAACE,eAAL,EAAsB;AACpB,QAAIC,WAAW,KAAK,CAApB,EAAuB;AACrB,YAAM,IAAIK,KAAJ,CAAU,wEAAV,CAAN;AACD,KAFD,MAEO,IAAID,aAAa,KAAK,CAAtB,EAAyB;AAC9B,YAAM,IAAIC,KAAJ,CAAU,6EAAV,CAAN;AACD;AACF;;AACD,MAAIC,GAAG,GAAG,CAAV;AACA,QAAMC,UAAU,GAAG,EAAnB;;AACA,OAAK,IAAIb,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGQ,gBAApB,EAAsCR,CAAC,EAAvC,EAA2C;AACzC,QAAIc,aAAa,GAAG,EAApB;;AACA,WAAOF,GAAG,GAAGV,KAAK,CAACZ,MAAnB,EAA2B;AACzB,YAAMyB,IAAI,GAAGb,KAAK,CAACU,GAAD,CAAlB;AACAA,MAAAA,GAAG;;AACH,UAAIG,IAAI,KAAK,CAAb,EAAgB;AACd;AACD,OAFD,MAEO;AACLD,QAAAA,aAAa,IAAIE,MAAM,CAACC,YAAP,CAAoBF,IAApB,CAAjB;AACD;AACF;;AACDX,IAAAA,KAAK,GAAGF,KAAK,CAACU,GAAD,CAAb;AACA,UAAMM,aAAa,GAAGd,KAAK,IAAI,CAAT,GAAa,CAAnC;AACA,UAAMe,WAAW,GAAG,CAACf,KAAK,IAAI,CAAT,GAAa,CAAd,IAAmB,CAAvC;AACA,UAAMgB,YAAY,GAAGhB,KAAK,GAAG,EAA7B;AACA,UAAMiB,SAAS,GAAG3C,qBAAqB,CAAC0C,YAAD,CAAvC;AACAR,IAAAA,GAAG;AACHA,IAAAA,GAAG,GAAGU,IAAI,CAACC,IAAL,CAAUX,GAAG,GAAG,CAAhB,IAAqB,CAA3B;AACA,UAAMY,MAAM,GAAGtC,cAAc,CAACd,MAAD,EAASiD,SAAT,EAAoBT,GAApB,EAAyBO,WAAW,GAAGV,YAAvC,EAAqDF,SAArD,CAA7B;AACAK,IAAAA,GAAG,IAAIS,SAAS,CAAC5B,iBAAV,GAA8B0B,WAA9B,GAA4CV,YAAnD;AACAI,IAAAA,UAAU,CAACC,aAAD,CAAV,GAA4B;AAC1BW,MAAAA,IAAI,EAAEP,aADoB;AAE1BC,MAAAA,WAF0B;AAG1BK,MAAAA;AAH0B,KAA5B;AAKD;;AACDZ,EAAAA,GAAG,GAAGU,IAAI,CAACC,IAAL,CAAUX,GAAG,GAAG,CAAhB,IAAqB,CAA3B;AACA,MAAIc,OAAO,GAAG,IAAd;;AACA,MAAIrB,eAAJ,EAAqB;AACnBqB,IAAAA,OAAO,GAAGxC,cAAc,CAACd,MAAD,EAASkC,WAAW,KAAK,CAAhB,GAAoBvB,WAApB,GAAkCN,WAA3C,EAAwDmC,GAAxD,EAA6DF,aAA7D,EAA4EH,SAA5E,CAAxB;AACD;;AACD,SAAO;AACLJ,IAAAA,OADK;AAELU,IAAAA,UAFK;AAGLa,IAAAA;AAHK,GAAP;AAKD;;AACD,MAAMC,UAAN,SAAyB7D,MAAzB,CAAgC;AAC9B8D,EAAAA,WAAW,CAACC,OAAD,EAAU;AACnB,UAAMA,OAAN;AACD;;AACDC,EAAAA,IAAI,CAACC,GAAD,EAAMC,MAAN,EAAcC,UAAd,EAA0BC,OAA1B,EAAmC;AACrC,UAAMC,KAAK,GAAG,IAAd;AACA,UAAMC,MAAM,GAAG,IAAIrE,UAAJ,CAAeoE,KAAK,CAACN,OAArB,CAAf;AACAO,IAAAA,MAAM,CAACC,OAAP,CAAeF,KAAK,CAACG,IAArB;AACAF,IAAAA,MAAM,CAACG,eAAP,CAAuB,aAAvB;AACAH,IAAAA,MAAM,CAACI,gBAAP,CAAwBL,KAAK,CAACM,aAA9B;AACAL,IAAAA,MAAM,CAACM,kBAAP,CAA0BP,KAAK,CAACQ,eAAhC;AACAZ,IAAAA,GAAG,GAAGA,GAAG,CAACa,OAAJ,CAAY,KAAZ,EAAmBzE,mBAAmB,KAAK,IAAL,GAAY,IAAlD,CAAN;AACAiE,IAAAA,MAAM,CAACN,IAAP,CACEC,GADF,EAEE,UAASc,WAAT,EAAsB;AACpB,UAAI;AACFb,QAAAA,MAAM,CAACG,KAAK,CAACW,KAAN,CAAYD,WAAZ,CAAD,CAAN;AACD,OAFD,CAEE,OAAOE,CAAP,EAAU;AACV,YAAIb,OAAJ,EAAa;AACXA,UAAAA,OAAO,CAACa,CAAD,CAAP;AACD,SAFD,MAEO;AACLC,UAAAA,OAAO,CAACC,KAAR,CAAcF,CAAd;AACD;;AACDZ,QAAAA,KAAK,CAACN,OAAN,CAAcqB,SAAd,CAAwBnB,GAAxB;AACD;AACF,KAbH,EAcEE,UAdF,EAeEC,OAfF;AAiBD;;AACDY,EAAAA,KAAK,CAACD,WAAD,EAAc;AACjB,UAAMM,IAAI,GAAGlD,UAAU,CAAC4C,WAAD,CAAvB;AAAA,UAAsCO,aAAa,GAAGC,MAAM,CAACC,IAAP,CAAYH,IAAI,CAACtC,UAAjB,CAAtD;AAAA,UAAoF0C,cAAc,GAAG,IAAIvF,cAAJ,EAArG;;AACA,SAAK,IAAIgC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGoD,aAAa,CAAC9D,MAAlC,EAA0CU,CAAC,EAA3C,EAA+C;AAC7C,YAAMwD,SAAS,GAAGL,IAAI,CAACtC,UAAL,CAAgBuC,aAAa,CAACpD,CAAD,CAA7B,CAAlB;AACAuD,MAAAA,cAAc,CAACE,YAAf,CACEL,aAAa,CAACpD,CAAD,CADf,EAEE,IAAI/B,eAAJ,CAAoBuF,SAAS,CAAChC,MAA9B,EAAsCgC,SAAS,CAACrC,WAAhD,EAA6DqC,SAAS,CAACE,UAAvE,CAFF;AAID;;AACD,QAAIP,IAAI,CAACzB,OAAL,KAAiB,IAArB,EAA2B;AACzB6B,MAAAA,cAAc,CAACI,QAAf,CAAwB,IAAI1F,eAAJ,CAAoBkF,IAAI,CAACzB,OAAzB,EAAkC,CAAlC,CAAxB;AACD;;AACD,WAAO6B,cAAP;AACD;;AACyB,SAAnBpF,mBAAmB,GAAG;AAC3B,WAAOA,mBAAmB,EAA1B;AACD;;AA9C6B;;AAgDhC,SACEwD,UADF","sourcesContent":["import { Loader, FileLoader, BufferGeometry, BufferAttribute } from \"three\";\nlet bigEndianPlatform = null;\nfunction isBigEndianPlatform() {\n  if (bigEndianPlatform === null) {\n    const buffer = new ArrayBuffer(2), uint8Array = new Uint8Array(buffer), uint16Array = new Uint16Array(buffer);\n    uint8Array[0] = 170;\n    uint8Array[1] = 187;\n    bigEndianPlatform = uint16Array[0] === 43707;\n  }\n  return bigEndianPlatform;\n}\nconst InvertedEncodingTypes = [\n  null,\n  Float32Array,\n  null,\n  Int8Array,\n  Int16Array,\n  null,\n  Int32Array,\n  Uint8Array,\n  Uint16Array,\n  null,\n  Uint32Array\n];\nconst getMethods = {\n  Uint16Array: \"getUint16\",\n  Uint32Array: \"getUint32\",\n  Int16Array: \"getInt16\",\n  Int32Array: \"getInt32\",\n  Float32Array: \"getFloat32\",\n  Float64Array: \"getFloat64\"\n};\nfunction copyFromBuffer(sourceArrayBuffer, viewType, position, length, fromBigEndian) {\n  const bytesPerElement = viewType.BYTES_PER_ELEMENT;\n  let result;\n  if (fromBigEndian === isBigEndianPlatform() || bytesPerElement === 1) {\n    result = new viewType(sourceArrayBuffer, position, length);\n  } else {\n    const readView = new DataView(sourceArrayBuffer, position, length * bytesPerElement), getMethod = getMethods[viewType.name], littleEndian = !fromBigEndian;\n    result = new viewType(length);\n    for (let i = 0; i < length; i++) {\n      result[i] = readView[getMethod](i * bytesPerElement, littleEndian);\n    }\n  }\n  return result;\n}\nfunction decodePrwm(buffer) {\n  const array = new Uint8Array(buffer), version = array[0];\n  let flags = array[1];\n  const indexedGeometry = !!(flags >> 7 & 1), indicesType = flags >> 6 & 1, bigEndian = (flags >> 5 & 1) === 1, attributesNumber = flags & 31;\n  let valuesNumber = 0, indicesNumber = 0;\n  if (bigEndian) {\n    valuesNumber = (array[2] << 16) + (array[3] << 8) + array[4];\n    indicesNumber = (array[5] << 16) + (array[6] << 8) + array[7];\n  } else {\n    valuesNumber = array[2] + (array[3] << 8) + (array[4] << 16);\n    indicesNumber = array[5] + (array[6] << 8) + (array[7] << 16);\n  }\n  if (version === 0) {\n    throw new Error(\"PRWM decoder: Invalid format version: 0\");\n  } else if (version !== 1) {\n    throw new Error(\"PRWM decoder: Unsupported format version: \" + version);\n  }\n  if (!indexedGeometry) {\n    if (indicesType !== 0) {\n      throw new Error(\"PRWM decoder: Indices type must be set to 0 for non-indexed geometries\");\n    } else if (indicesNumber !== 0) {\n      throw new Error(\"PRWM decoder: Number of indices must be set to 0 for non-indexed geometries\");\n    }\n  }\n  let pos = 8;\n  const attributes = {};\n  for (let i = 0; i < attributesNumber; i++) {\n    let attributeName = \"\";\n    while (pos < array.length) {\n      const char = array[pos];\n      pos++;\n      if (char === 0) {\n        break;\n      } else {\n        attributeName += String.fromCharCode(char);\n      }\n    }\n    flags = array[pos];\n    const attributeType = flags >> 7 & 1;\n    const cardinality = (flags >> 4 & 3) + 1;\n    const encodingType = flags & 15;\n    const arrayType = InvertedEncodingTypes[encodingType];\n    pos++;\n    pos = Math.ceil(pos / 4) * 4;\n    const values = copyFromBuffer(buffer, arrayType, pos, cardinality * valuesNumber, bigEndian);\n    pos += arrayType.BYTES_PER_ELEMENT * cardinality * valuesNumber;\n    attributes[attributeName] = {\n      type: attributeType,\n      cardinality,\n      values\n    };\n  }\n  pos = Math.ceil(pos / 4) * 4;\n  let indices = null;\n  if (indexedGeometry) {\n    indices = copyFromBuffer(buffer, indicesType === 1 ? Uint32Array : Uint16Array, pos, indicesNumber, bigEndian);\n  }\n  return {\n    version,\n    attributes,\n    indices\n  };\n}\nclass PRWMLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setResponseType(\"arraybuffer\");\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    url = url.replace(/\\*/g, isBigEndianPlatform() ? \"be\" : \"le\");\n    loader.load(\n      url,\n      function(arrayBuffer) {\n        try {\n          onLoad(scope.parse(arrayBuffer));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n          scope.manager.itemError(url);\n        }\n      },\n      onProgress,\n      onError\n    );\n  }\n  parse(arrayBuffer) {\n    const data = decodePrwm(arrayBuffer), attributesKey = Object.keys(data.attributes), bufferGeometry = new BufferGeometry();\n    for (let i = 0; i < attributesKey.length; i++) {\n      const attribute = data.attributes[attributesKey[i]];\n      bufferGeometry.setAttribute(\n        attributesKey[i],\n        new BufferAttribute(attribute.values, attribute.cardinality, attribute.normalized)\n      );\n    }\n    if (data.indices !== null) {\n      bufferGeometry.setIndex(new BufferAttribute(data.indices, 1));\n    }\n    return bufferGeometry;\n  }\n  static isBigEndianPlatform() {\n    return isBigEndianPlatform();\n  }\n}\nexport {\n  PRWMLoader\n};\n"]},"metadata":{},"sourceType":"module"}