{"ast":null,"code":"import _classCallCheck from \"/Users/theodaguier/_workdir/dev/pro/e-do/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/theodaguier/_workdir/dev/pro/e-do/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/theodaguier/_workdir/dev/pro/e-do/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/theodaguier/_workdir/dev/pro/e-do/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { Loader, FileLoader, LoaderUtils, BufferGeometry, Float32BufferAttribute, PointsMaterial, Points } from \"three\";\n\nvar PCDLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(PCDLoader, _Loader);\n\n  var _super = _createSuper(PCDLoader);\n\n  function PCDLoader(manager) {\n    var _this;\n\n    _classCallCheck(this, PCDLoader);\n\n    _this = _super.call(this, manager);\n    _this.littleEndian = true;\n    return _this;\n  }\n\n  _createClass(PCDLoader, [{\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var loader = new FileLoader(scope.manager);\n      loader.setPath(scope.path);\n      loader.setResponseType(\"arraybuffer\");\n      loader.setRequestHeader(scope.requestHeader);\n      loader.setWithCredentials(scope.withCredentials);\n      loader.load(url, function (data) {\n        try {\n          onLoad(scope.parse(data, url));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(data, url) {\n      function decompressLZF(inData, outLength) {\n        var inLength = inData.length;\n        var outData = new Uint8Array(outLength);\n        var inPtr = 0;\n        var outPtr = 0;\n        var ctrl;\n        var len;\n        var ref;\n\n        do {\n          ctrl = inData[inPtr++];\n\n          if (ctrl < 1 << 5) {\n            ctrl++;\n            if (outPtr + ctrl > outLength) throw new Error(\"Output buffer is not large enough\");\n            if (inPtr + ctrl > inLength) throw new Error(\"Invalid compressed data\");\n\n            do {\n              outData[outPtr++] = inData[inPtr++];\n            } while (--ctrl);\n          } else {\n            len = ctrl >> 5;\n            ref = outPtr - ((ctrl & 31) << 8) - 1;\n            if (inPtr >= inLength) throw new Error(\"Invalid compressed data\");\n\n            if (len === 7) {\n              len += inData[inPtr++];\n              if (inPtr >= inLength) throw new Error(\"Invalid compressed data\");\n            }\n\n            ref -= inData[inPtr++];\n            if (outPtr + len + 2 > outLength) throw new Error(\"Output buffer is not large enough\");\n            if (ref < 0) throw new Error(\"Invalid compressed data\");\n            if (ref >= outPtr) throw new Error(\"Invalid compressed data\");\n\n            do {\n              outData[outPtr++] = outData[ref++];\n            } while (--len + 2);\n          }\n        } while (inPtr < inLength);\n\n        return outData;\n      }\n\n      function parseHeader(data2) {\n        var PCDheader2 = {};\n        var result1 = data2.search(/[\\r\\n]DATA\\s(\\S*)\\s/i);\n        var result2 = /[\\r\\n]DATA\\s(\\S*)\\s/i.exec(data2.substr(result1 - 1));\n        PCDheader2.data = result2[1];\n        PCDheader2.headerLen = result2[0].length + result1;\n        PCDheader2.str = data2.substr(0, PCDheader2.headerLen);\n        PCDheader2.str = PCDheader2.str.replace(/\\#.*/gi, \"\");\n        PCDheader2.version = /VERSION (.*)/i.exec(PCDheader2.str);\n        PCDheader2.fields = /FIELDS (.*)/i.exec(PCDheader2.str);\n        PCDheader2.size = /SIZE (.*)/i.exec(PCDheader2.str);\n        PCDheader2.type = /TYPE (.*)/i.exec(PCDheader2.str);\n        PCDheader2.count = /COUNT (.*)/i.exec(PCDheader2.str);\n        PCDheader2.width = /WIDTH (.*)/i.exec(PCDheader2.str);\n        PCDheader2.height = /HEIGHT (.*)/i.exec(PCDheader2.str);\n        PCDheader2.viewpoint = /VIEWPOINT (.*)/i.exec(PCDheader2.str);\n        PCDheader2.points = /POINTS (.*)/i.exec(PCDheader2.str);\n        if (PCDheader2.version !== null) PCDheader2.version = parseFloat(PCDheader2.version[1]);\n        if (PCDheader2.fields !== null) PCDheader2.fields = PCDheader2.fields[1].split(\" \");\n        if (PCDheader2.type !== null) PCDheader2.type = PCDheader2.type[1].split(\" \");\n        if (PCDheader2.width !== null) PCDheader2.width = parseInt(PCDheader2.width[1]);\n        if (PCDheader2.height !== null) PCDheader2.height = parseInt(PCDheader2.height[1]);\n        if (PCDheader2.viewpoint !== null) PCDheader2.viewpoint = PCDheader2.viewpoint[1];\n        if (PCDheader2.points !== null) PCDheader2.points = parseInt(PCDheader2.points[1], 10);\n        if (PCDheader2.points === null) PCDheader2.points = PCDheader2.width * PCDheader2.height;\n\n        if (PCDheader2.size !== null) {\n          PCDheader2.size = PCDheader2.size[1].split(\" \").map(function (x) {\n            return parseInt(x, 10);\n          });\n        }\n\n        if (PCDheader2.count !== null) {\n          PCDheader2.count = PCDheader2.count[1].split(\" \").map(function (x) {\n            return parseInt(x, 10);\n          });\n        } else {\n          PCDheader2.count = [];\n\n          for (var i = 0, l = PCDheader2.fields.length; i < l; i++) {\n            PCDheader2.count.push(1);\n          }\n        }\n\n        PCDheader2.offset = {};\n        var sizeSum = 0;\n\n        for (var _i = 0, _l = PCDheader2.fields.length; _i < _l; _i++) {\n          if (PCDheader2.data === \"ascii\") {\n            PCDheader2.offset[PCDheader2.fields[_i]] = _i;\n          } else {\n            PCDheader2.offset[PCDheader2.fields[_i]] = sizeSum;\n            sizeSum += PCDheader2.size[_i] * PCDheader2.count[_i];\n          }\n        }\n\n        PCDheader2.rowSize = sizeSum;\n        return PCDheader2;\n      }\n\n      var textData = LoaderUtils.decodeText(new Uint8Array(data));\n      var PCDheader = parseHeader(textData);\n      var position = [];\n      var normal = [];\n      var color = [];\n\n      if (PCDheader.data === \"ascii\") {\n        var offset = PCDheader.offset;\n        var pcdData = textData.substr(PCDheader.headerLen);\n        var lines = pcdData.split(\"\\n\");\n\n        for (var i = 0, l = lines.length; i < l; i++) {\n          if (lines[i] === \"\") continue;\n          var line = lines[i].split(\" \");\n\n          if (offset.x !== void 0) {\n            position.push(parseFloat(line[offset.x]));\n            position.push(parseFloat(line[offset.y]));\n            position.push(parseFloat(line[offset.z]));\n          }\n\n          if (offset.rgb !== void 0) {\n            var rgb = parseFloat(line[offset.rgb]);\n            var r = rgb >> 16 & 255;\n            var g = rgb >> 8 & 255;\n            var b = rgb >> 0 & 255;\n            color.push(r / 255, g / 255, b / 255);\n          }\n\n          if (offset.normal_x !== void 0) {\n            normal.push(parseFloat(line[offset.normal_x]));\n            normal.push(parseFloat(line[offset.normal_y]));\n            normal.push(parseFloat(line[offset.normal_z]));\n          }\n        }\n      }\n\n      if (PCDheader.data === \"binary_compressed\") {\n        var sizes = new Uint32Array(data.slice(PCDheader.headerLen, PCDheader.headerLen + 8));\n        var compressedSize = sizes[0];\n        var decompressedSize = sizes[1];\n        var decompressed = decompressLZF(new Uint8Array(data, PCDheader.headerLen + 8, compressedSize), decompressedSize);\n        var dataview = new DataView(decompressed.buffer);\n        var _offset = PCDheader.offset;\n\n        for (var _i2 = 0; _i2 < PCDheader.points; _i2++) {\n          if (_offset.x !== void 0) {\n            position.push(dataview.getFloat32(PCDheader.points * _offset.x + PCDheader.size[0] * _i2, this.littleEndian));\n            position.push(dataview.getFloat32(PCDheader.points * _offset.y + PCDheader.size[1] * _i2, this.littleEndian));\n            position.push(dataview.getFloat32(PCDheader.points * _offset.z + PCDheader.size[2] * _i2, this.littleEndian));\n          }\n\n          if (_offset.rgb !== void 0) {\n            color.push(dataview.getUint8(PCDheader.points * _offset.rgb + PCDheader.size[3] * _i2 + 2) / 255);\n            color.push(dataview.getUint8(PCDheader.points * _offset.rgb + PCDheader.size[3] * _i2 + 1) / 255);\n            color.push(dataview.getUint8(PCDheader.points * _offset.rgb + PCDheader.size[3] * _i2 + 0) / 255);\n          }\n\n          if (_offset.normal_x !== void 0) {\n            normal.push(dataview.getFloat32(PCDheader.points * _offset.normal_x + PCDheader.size[4] * _i2, this.littleEndian));\n            normal.push(dataview.getFloat32(PCDheader.points * _offset.normal_y + PCDheader.size[5] * _i2, this.littleEndian));\n            normal.push(dataview.getFloat32(PCDheader.points * _offset.normal_z + PCDheader.size[6] * _i2, this.littleEndian));\n          }\n        }\n      }\n\n      if (PCDheader.data === \"binary\") {\n        var _dataview = new DataView(data, PCDheader.headerLen);\n\n        var _offset2 = PCDheader.offset;\n\n        for (var _i3 = 0, row = 0; _i3 < PCDheader.points; _i3++, row += PCDheader.rowSize) {\n          if (_offset2.x !== void 0) {\n            position.push(_dataview.getFloat32(row + _offset2.x, this.littleEndian));\n            position.push(_dataview.getFloat32(row + _offset2.y, this.littleEndian));\n            position.push(_dataview.getFloat32(row + _offset2.z, this.littleEndian));\n          }\n\n          if (_offset2.rgb !== void 0) {\n            color.push(_dataview.getUint8(row + _offset2.rgb + 2) / 255);\n            color.push(_dataview.getUint8(row + _offset2.rgb + 1) / 255);\n            color.push(_dataview.getUint8(row + _offset2.rgb + 0) / 255);\n          }\n\n          if (_offset2.normal_x !== void 0) {\n            normal.push(_dataview.getFloat32(row + _offset2.normal_x, this.littleEndian));\n            normal.push(_dataview.getFloat32(row + _offset2.normal_y, this.littleEndian));\n            normal.push(_dataview.getFloat32(row + _offset2.normal_z, this.littleEndian));\n          }\n        }\n      }\n\n      var geometry = new BufferGeometry();\n      if (position.length > 0) geometry.setAttribute(\"position\", new Float32BufferAttribute(position, 3));\n      if (normal.length > 0) geometry.setAttribute(\"normal\", new Float32BufferAttribute(normal, 3));\n      if (color.length > 0) geometry.setAttribute(\"color\", new Float32BufferAttribute(color, 3));\n      geometry.computeBoundingSphere();\n      var material = new PointsMaterial({\n        size: 5e-3\n      });\n\n      if (color.length > 0) {\n        material.vertexColors = true;\n      } else {\n        material.color.setHex(Math.random() * 16777215);\n      }\n\n      var mesh = new Points(geometry, material);\n      var name = url.split(\"\").reverse().join(\"\");\n      name = /([^\\/]*)/.exec(name);\n      name = name[1].split(\"\").reverse().join(\"\");\n      mesh.name = name;\n      return mesh;\n    }\n  }]);\n\n  return PCDLoader;\n}(Loader);\n\nexport { PCDLoader };","map":{"version":3,"sources":["/Users/theodaguier/_workdir/dev/pro/e-do/E-Do-Studio/node_modules/three-stdlib/loaders/PCDLoader.js"],"names":["Loader","FileLoader","LoaderUtils","BufferGeometry","Float32BufferAttribute","PointsMaterial","Points","PCDLoader","manager","littleEndian","url","onLoad","onProgress","onError","scope","loader","setPath","path","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","load","data","parse","e","console","error","itemError","decompressLZF","inData","outLength","inLength","length","outData","Uint8Array","inPtr","outPtr","ctrl","len","ref","Error","parseHeader","data2","PCDheader2","result1","search","result2","exec","substr","headerLen","str","replace","version","fields","size","type","count","width","height","viewpoint","points","parseFloat","split","parseInt","map","x","i","l","push","offset","sizeSum","rowSize","textData","decodeText","PCDheader","position","normal","color","pcdData","lines","line","y","z","rgb","r","g","b","normal_x","normal_y","normal_z","sizes","Uint32Array","slice","compressedSize","decompressedSize","decompressed","dataview","DataView","buffer","getFloat32","getUint8","row","geometry","setAttribute","computeBoundingSphere","material","vertexColors","setHex","Math","random","mesh","name","reverse","join"],"mappings":"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","sourcesContent":["import { Loader, FileLoader, LoaderUtils, BufferGeometry, Float32BufferAttribute, PointsMaterial, Points } from \"three\";\nclass PCDLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.littleEndian = true;\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setResponseType(\"arraybuffer\");\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(\n      url,\n      function(data) {\n        try {\n          onLoad(scope.parse(data, url));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n          scope.manager.itemError(url);\n        }\n      },\n      onProgress,\n      onError\n    );\n  }\n  parse(data, url) {\n    function decompressLZF(inData, outLength) {\n      const inLength = inData.length;\n      const outData = new Uint8Array(outLength);\n      let inPtr = 0;\n      let outPtr = 0;\n      let ctrl;\n      let len;\n      let ref;\n      do {\n        ctrl = inData[inPtr++];\n        if (ctrl < 1 << 5) {\n          ctrl++;\n          if (outPtr + ctrl > outLength)\n            throw new Error(\"Output buffer is not large enough\");\n          if (inPtr + ctrl > inLength)\n            throw new Error(\"Invalid compressed data\");\n          do {\n            outData[outPtr++] = inData[inPtr++];\n          } while (--ctrl);\n        } else {\n          len = ctrl >> 5;\n          ref = outPtr - ((ctrl & 31) << 8) - 1;\n          if (inPtr >= inLength)\n            throw new Error(\"Invalid compressed data\");\n          if (len === 7) {\n            len += inData[inPtr++];\n            if (inPtr >= inLength)\n              throw new Error(\"Invalid compressed data\");\n          }\n          ref -= inData[inPtr++];\n          if (outPtr + len + 2 > outLength)\n            throw new Error(\"Output buffer is not large enough\");\n          if (ref < 0)\n            throw new Error(\"Invalid compressed data\");\n          if (ref >= outPtr)\n            throw new Error(\"Invalid compressed data\");\n          do {\n            outData[outPtr++] = outData[ref++];\n          } while (--len + 2);\n        }\n      } while (inPtr < inLength);\n      return outData;\n    }\n    function parseHeader(data2) {\n      const PCDheader2 = {};\n      const result1 = data2.search(/[\\r\\n]DATA\\s(\\S*)\\s/i);\n      const result2 = /[\\r\\n]DATA\\s(\\S*)\\s/i.exec(data2.substr(result1 - 1));\n      PCDheader2.data = result2[1];\n      PCDheader2.headerLen = result2[0].length + result1;\n      PCDheader2.str = data2.substr(0, PCDheader2.headerLen);\n      PCDheader2.str = PCDheader2.str.replace(/\\#.*/gi, \"\");\n      PCDheader2.version = /VERSION (.*)/i.exec(PCDheader2.str);\n      PCDheader2.fields = /FIELDS (.*)/i.exec(PCDheader2.str);\n      PCDheader2.size = /SIZE (.*)/i.exec(PCDheader2.str);\n      PCDheader2.type = /TYPE (.*)/i.exec(PCDheader2.str);\n      PCDheader2.count = /COUNT (.*)/i.exec(PCDheader2.str);\n      PCDheader2.width = /WIDTH (.*)/i.exec(PCDheader2.str);\n      PCDheader2.height = /HEIGHT (.*)/i.exec(PCDheader2.str);\n      PCDheader2.viewpoint = /VIEWPOINT (.*)/i.exec(PCDheader2.str);\n      PCDheader2.points = /POINTS (.*)/i.exec(PCDheader2.str);\n      if (PCDheader2.version !== null)\n        PCDheader2.version = parseFloat(PCDheader2.version[1]);\n      if (PCDheader2.fields !== null)\n        PCDheader2.fields = PCDheader2.fields[1].split(\" \");\n      if (PCDheader2.type !== null)\n        PCDheader2.type = PCDheader2.type[1].split(\" \");\n      if (PCDheader2.width !== null)\n        PCDheader2.width = parseInt(PCDheader2.width[1]);\n      if (PCDheader2.height !== null)\n        PCDheader2.height = parseInt(PCDheader2.height[1]);\n      if (PCDheader2.viewpoint !== null)\n        PCDheader2.viewpoint = PCDheader2.viewpoint[1];\n      if (PCDheader2.points !== null)\n        PCDheader2.points = parseInt(PCDheader2.points[1], 10);\n      if (PCDheader2.points === null)\n        PCDheader2.points = PCDheader2.width * PCDheader2.height;\n      if (PCDheader2.size !== null) {\n        PCDheader2.size = PCDheader2.size[1].split(\" \").map(function(x) {\n          return parseInt(x, 10);\n        });\n      }\n      if (PCDheader2.count !== null) {\n        PCDheader2.count = PCDheader2.count[1].split(\" \").map(function(x) {\n          return parseInt(x, 10);\n        });\n      } else {\n        PCDheader2.count = [];\n        for (let i = 0, l = PCDheader2.fields.length; i < l; i++) {\n          PCDheader2.count.push(1);\n        }\n      }\n      PCDheader2.offset = {};\n      let sizeSum = 0;\n      for (let i = 0, l = PCDheader2.fields.length; i < l; i++) {\n        if (PCDheader2.data === \"ascii\") {\n          PCDheader2.offset[PCDheader2.fields[i]] = i;\n        } else {\n          PCDheader2.offset[PCDheader2.fields[i]] = sizeSum;\n          sizeSum += PCDheader2.size[i] * PCDheader2.count[i];\n        }\n      }\n      PCDheader2.rowSize = sizeSum;\n      return PCDheader2;\n    }\n    const textData = LoaderUtils.decodeText(new Uint8Array(data));\n    const PCDheader = parseHeader(textData);\n    const position = [];\n    const normal = [];\n    const color = [];\n    if (PCDheader.data === \"ascii\") {\n      const offset = PCDheader.offset;\n      const pcdData = textData.substr(PCDheader.headerLen);\n      const lines = pcdData.split(\"\\n\");\n      for (let i = 0, l = lines.length; i < l; i++) {\n        if (lines[i] === \"\")\n          continue;\n        const line = lines[i].split(\" \");\n        if (offset.x !== void 0) {\n          position.push(parseFloat(line[offset.x]));\n          position.push(parseFloat(line[offset.y]));\n          position.push(parseFloat(line[offset.z]));\n        }\n        if (offset.rgb !== void 0) {\n          const rgb = parseFloat(line[offset.rgb]);\n          const r = rgb >> 16 & 255;\n          const g = rgb >> 8 & 255;\n          const b = rgb >> 0 & 255;\n          color.push(r / 255, g / 255, b / 255);\n        }\n        if (offset.normal_x !== void 0) {\n          normal.push(parseFloat(line[offset.normal_x]));\n          normal.push(parseFloat(line[offset.normal_y]));\n          normal.push(parseFloat(line[offset.normal_z]));\n        }\n      }\n    }\n    if (PCDheader.data === \"binary_compressed\") {\n      const sizes = new Uint32Array(data.slice(PCDheader.headerLen, PCDheader.headerLen + 8));\n      const compressedSize = sizes[0];\n      const decompressedSize = sizes[1];\n      const decompressed = decompressLZF(\n        new Uint8Array(data, PCDheader.headerLen + 8, compressedSize),\n        decompressedSize\n      );\n      const dataview = new DataView(decompressed.buffer);\n      const offset = PCDheader.offset;\n      for (let i = 0; i < PCDheader.points; i++) {\n        if (offset.x !== void 0) {\n          position.push(dataview.getFloat32(PCDheader.points * offset.x + PCDheader.size[0] * i, this.littleEndian));\n          position.push(dataview.getFloat32(PCDheader.points * offset.y + PCDheader.size[1] * i, this.littleEndian));\n          position.push(dataview.getFloat32(PCDheader.points * offset.z + PCDheader.size[2] * i, this.littleEndian));\n        }\n        if (offset.rgb !== void 0) {\n          color.push(dataview.getUint8(PCDheader.points * offset.rgb + PCDheader.size[3] * i + 2) / 255);\n          color.push(dataview.getUint8(PCDheader.points * offset.rgb + PCDheader.size[3] * i + 1) / 255);\n          color.push(dataview.getUint8(PCDheader.points * offset.rgb + PCDheader.size[3] * i + 0) / 255);\n        }\n        if (offset.normal_x !== void 0) {\n          normal.push(\n            dataview.getFloat32(PCDheader.points * offset.normal_x + PCDheader.size[4] * i, this.littleEndian)\n          );\n          normal.push(\n            dataview.getFloat32(PCDheader.points * offset.normal_y + PCDheader.size[5] * i, this.littleEndian)\n          );\n          normal.push(\n            dataview.getFloat32(PCDheader.points * offset.normal_z + PCDheader.size[6] * i, this.littleEndian)\n          );\n        }\n      }\n    }\n    if (PCDheader.data === \"binary\") {\n      const dataview = new DataView(data, PCDheader.headerLen);\n      const offset = PCDheader.offset;\n      for (let i = 0, row = 0; i < PCDheader.points; i++, row += PCDheader.rowSize) {\n        if (offset.x !== void 0) {\n          position.push(dataview.getFloat32(row + offset.x, this.littleEndian));\n          position.push(dataview.getFloat32(row + offset.y, this.littleEndian));\n          position.push(dataview.getFloat32(row + offset.z, this.littleEndian));\n        }\n        if (offset.rgb !== void 0) {\n          color.push(dataview.getUint8(row + offset.rgb + 2) / 255);\n          color.push(dataview.getUint8(row + offset.rgb + 1) / 255);\n          color.push(dataview.getUint8(row + offset.rgb + 0) / 255);\n        }\n        if (offset.normal_x !== void 0) {\n          normal.push(dataview.getFloat32(row + offset.normal_x, this.littleEndian));\n          normal.push(dataview.getFloat32(row + offset.normal_y, this.littleEndian));\n          normal.push(dataview.getFloat32(row + offset.normal_z, this.littleEndian));\n        }\n      }\n    }\n    const geometry = new BufferGeometry();\n    if (position.length > 0)\n      geometry.setAttribute(\"position\", new Float32BufferAttribute(position, 3));\n    if (normal.length > 0)\n      geometry.setAttribute(\"normal\", new Float32BufferAttribute(normal, 3));\n    if (color.length > 0)\n      geometry.setAttribute(\"color\", new Float32BufferAttribute(color, 3));\n    geometry.computeBoundingSphere();\n    const material = new PointsMaterial({ size: 5e-3 });\n    if (color.length > 0) {\n      material.vertexColors = true;\n    } else {\n      material.color.setHex(Math.random() * 16777215);\n    }\n    const mesh = new Points(geometry, material);\n    let name = url.split(\"\").reverse().join(\"\");\n    name = /([^\\/]*)/.exec(name);\n    name = name[1].split(\"\").reverse().join(\"\");\n    mesh.name = name;\n    return mesh;\n  }\n}\nexport {\n  PCDLoader\n};\n"]},"metadata":{},"sourceType":"module"}