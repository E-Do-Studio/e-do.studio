{"ast":null,"code":"'use strict';\n\nconst packageInfo = require('../../package.json');\n\nconst EventEmitter = require('events').EventEmitter;\n\nconst net = require('net');\n\nconst tls = require('tls');\n\nconst os = require('os');\n\nconst crypto = require('crypto');\n\nconst DataStream = require('./data-stream');\n\nconst PassThrough = require('stream').PassThrough;\n\nconst shared = require('../shared'); // default timeout values in ms\n\n\nconst CONNECTION_TIMEOUT = 2 * 60 * 1000; // how much to wait for the connection to be established\n\nconst SOCKET_TIMEOUT = 10 * 60 * 1000; // how much to wait for socket inactivity before disconnecting the client\n\nconst GREETING_TIMEOUT = 30 * 1000; // how much to wait after connection is established but SMTP greeting is not receieved\n\n/**\n * Generates a SMTP connection object\n *\n * Optional options object takes the following possible properties:\n *\n *  * **port** - is the port to connect to (defaults to 587 or 465)\n *  * **host** - is the hostname or IP address to connect to (defaults to 'localhost')\n *  * **secure** - use SSL\n *  * **ignoreTLS** - ignore server support for STARTTLS\n *  * **requireTLS** - forces the client to use STARTTLS\n *  * **name** - the name of the client server\n *  * **localAddress** - outbound address to bind to (see: http://nodejs.org/api/net.html#net_net_connect_options_connectionlistener)\n *  * **greetingTimeout** - Time to wait in ms until greeting message is received from the server (defaults to 10000)\n *  * **connectionTimeout** - how many milliseconds to wait for the connection to establish\n *  * **socketTimeout** - Time of inactivity until the connection is closed (defaults to 1 hour)\n *  * **lmtp** - if true, uses LMTP instead of SMTP protocol\n *  * **logger** - bunyan compatible logger interface\n *  * **debug** - if true pass SMTP traffic to the logger\n *  * **tls** - options for createCredentials\n *  * **socket** - existing socket to use instead of creating a new one (see: http://nodejs.org/api/net.html#net_class_net_socket)\n *  * **secured** - boolean indicates that the provided socket has already been upgraded to tls\n *\n * @constructor\n * @namespace SMTP Client module\n * @param {Object} [options] Option properties\n */\n\nclass SMTPConnection extends EventEmitter {\n  constructor(options) {\n    super(options);\n    this.id = crypto.randomBytes(8).toString('base64').replace(/\\W/g, '');\n    this.stage = 'init';\n    this.options = options || {};\n    this.secureConnection = !!this.options.secure;\n    this.alreadySecured = !!this.options.secured;\n    this.port = this.options.port || (this.secureConnection ? 465 : 587);\n    this.host = this.options.host || 'localhost';\n\n    if (typeof this.options.secure === 'undefined' && this.port === 465) {\n      // if secure option is not set but port is 465, then default to secure\n      this.secureConnection = true;\n    }\n\n    this.name = this.options.name || this._getHostname();\n    this.logger = shared.getLogger(this.options, {\n      component: this.options.component || 'smtp-connection',\n      sid: this.id\n    });\n    /**\n     * Expose version nr, just for the reference\n     * @type {String}\n     */\n\n    this.version = packageInfo.version;\n    /**\n     * If true, then the user is authenticated\n     * @type {Boolean}\n     */\n\n    this.authenticated = false;\n    /**\n     * If set to true, this instance is no longer active\n     * @private\n     */\n\n    this.destroyed = false;\n    /**\n     * Defines if the current connection is secure or not. If not,\n     * STARTTLS can be used if available\n     * @private\n     */\n\n    this.secure = !!this.secureConnection;\n    /**\n     * Store incomplete messages coming from the server\n     * @private\n     */\n\n    this._remainder = '';\n    /**\n     * Unprocessed responses from the server\n     * @type {Array}\n     */\n\n    this._responseQueue = [];\n    this.lastServerResponse = false;\n    /**\n     * The socket connecting to the server\n     * @publick\n     */\n\n    this._socket = false;\n    /**\n     * Lists supported auth mechanisms\n     * @private\n     */\n\n    this._supportedAuth = [];\n    /**\n     * Includes current envelope (from, to)\n     * @private\n     */\n\n    this._envelope = false;\n    /**\n     * Lists supported extensions\n     * @private\n     */\n\n    this._supportedExtensions = [];\n    /**\n     * Defines the maximum allowed size for a single message\n     * @private\n     */\n\n    this._maxAllowedSize = 0;\n    /**\n     * Function queue to run if a data chunk comes from the server\n     * @private\n     */\n\n    this._responseActions = [];\n    this._recipientQueue = [];\n    /**\n     * Timeout variable for waiting the greeting\n     * @private\n     */\n\n    this._greetingTimeout = false;\n    /**\n     * Timeout variable for waiting the connection to start\n     * @private\n     */\n\n    this._connectionTimeout = false;\n    /**\n     * If the socket is deemed already closed\n     * @private\n     */\n\n    this._destroyed = false;\n    /**\n     * If the socket is already being closed\n     * @private\n     */\n\n    this._closing = false;\n  }\n  /**\n   * Creates a connection to a SMTP server and sets up connection\n   * listener\n   */\n\n\n  connect(connectCallback) {\n    if (typeof connectCallback === 'function') {\n      this.once('connect', () => {\n        this.logger.debug({\n          tnx: 'smtp'\n        }, 'SMTP handshake finished');\n        connectCallback();\n      });\n    }\n\n    let opts = {\n      port: this.port,\n      host: this.host\n    };\n\n    if (this.options.localAddress) {\n      opts.localAddress = this.options.localAddress;\n    }\n\n    if (this.options.connection) {\n      // connection is already opened\n      this._socket = this.options.connection;\n\n      if (this.secureConnection && !this.alreadySecured) {\n        setImmediate(() => this._upgradeConnection(err => {\n          if (err) {\n            this._onError(new Error('Error initiating TLS - ' + (err.message || err)), 'ETLS', false, 'CONN');\n\n            return;\n          }\n\n          this._onConnect();\n        }));\n      } else {\n        setImmediate(() => this._onConnect());\n      }\n    } else if (this.options.socket) {\n      // socket object is set up but not yet connected\n      this._socket = this.options.socket;\n\n      try {\n        this._socket.connect(this.port, this.host, () => {\n          this._socket.setKeepAlive(true);\n\n          this._onConnect();\n        });\n      } catch (E) {\n        return setImmediate(() => this._onError(E, 'ECONNECTION', false, 'CONN'));\n      }\n    } else if (this.secureConnection) {\n      // connect using tls\n      if (this.options.tls) {\n        Object.keys(this.options.tls).forEach(key => {\n          opts[key] = this.options.tls[key];\n        });\n      }\n\n      try {\n        this._socket = tls.connect(this.port, this.host, opts, () => {\n          this._socket.setKeepAlive(true);\n\n          this._onConnect();\n        });\n      } catch (E) {\n        return setImmediate(() => this._onError(E, 'ECONNECTION', false, 'CONN'));\n      }\n    } else {\n      // connect using plaintext\n      try {\n        this._socket = net.connect(opts, () => {\n          this._socket.setKeepAlive(true);\n\n          this._onConnect();\n        });\n      } catch (E) {\n        return setImmediate(() => this._onError(E, 'ECONNECTION', false, 'CONN'));\n      }\n    }\n\n    this._connectionTimeout = setTimeout(() => {\n      this._onError('Connection timeout', 'ETIMEDOUT', false, 'CONN');\n    }, this.options.connectionTimeout || CONNECTION_TIMEOUT);\n\n    this._socket.on('error', err => {\n      this._onError(err, 'ECONNECTION', false, 'CONN');\n    });\n  }\n  /**\n   * Sends QUIT\n   */\n\n\n  quit() {\n    this._sendCommand('QUIT');\n\n    this._responseActions.push(this.close);\n  }\n  /**\n   * Closes the connection to the server\n   */\n\n\n  close() {\n    clearTimeout(this._connectionTimeout);\n    clearTimeout(this._greetingTimeout);\n    this._responseActions = []; // allow to run this function only once\n\n    if (this._closing) {\n      return;\n    }\n\n    this._closing = true;\n    let closeMethod = 'end';\n\n    if (this.stage === 'init') {\n      // Close the socket immediately when connection timed out\n      closeMethod = 'destroy';\n    }\n\n    this.logger.debug({\n      tnx: 'smtp'\n    }, 'Closing connection to the server using \"%s\"', closeMethod);\n    let socket = this._socket && this._socket.socket || this._socket;\n\n    if (socket && !socket.destroyed) {\n      try {\n        this._socket[closeMethod]();\n      } catch (E) {// just ignore\n      }\n    }\n\n    this._destroy();\n  }\n  /**\n   * Authenticate user\n   */\n\n\n  login(authData, callback) {\n    this._auth = authData || {}; // Select SASL authentication method\n\n    this._authMethod = (this._auth.method || '').toString().trim().toUpperCase() || false;\n\n    if (!this._authMethod && this._auth.oauth2 && !this._auth.credentials) {\n      this._authMethod = 'XOAUTH2';\n    } else if (!this._authMethod || this._authMethod === 'XOAUTH2' && !this._auth.oauth2) {\n      // use first supported\n      this._authMethod = (this._supportedAuth[0] || 'PLAIN').toUpperCase().trim();\n    }\n\n    if (this._authMethod !== 'XOAUTH2' && !this._auth.credentials) {\n      if (this._auth.user && this._auth.pass) {\n        this._auth.credentials = {\n          user: this._auth.user,\n          pass: this._auth.pass\n        };\n      } else {\n        return callback(this._formatError('Missing credentials for \"' + this._authMethod + '\"', 'EAUTH', false, 'API'));\n      }\n    }\n\n    switch (this._authMethod) {\n      case 'XOAUTH2':\n        this._handleXOauth2Token(false, callback);\n\n        return;\n\n      case 'LOGIN':\n        this._responseActions.push(str => {\n          this._actionAUTH_LOGIN_USER(str, callback);\n        });\n\n        this._sendCommand('AUTH LOGIN');\n\n        return;\n\n      case 'PLAIN':\n        this._responseActions.push(str => {\n          this._actionAUTHComplete(str, callback);\n        });\n\n        this._sendCommand('AUTH PLAIN ' + new Buffer( //this._auth.user+'\\u0000'+\n        '\\u0000' + // skip authorization identity as it causes problems with some servers\n        this._auth.credentials.user + '\\u0000' + this._auth.credentials.pass, 'utf-8').toString('base64'));\n\n        return;\n\n      case 'CRAM-MD5':\n        this._responseActions.push(str => {\n          this._actionAUTH_CRAM_MD5(str, callback);\n        });\n\n        this._sendCommand('AUTH CRAM-MD5');\n\n        return;\n    }\n\n    return callback(this._formatError('Unknown authentication method \"' + this._authMethod + '\"', 'EAUTH', false, 'API'));\n  }\n  /**\n   * Sends a message\n   *\n   * @param {Object} envelope Envelope object, {from: addr, to: [addr]}\n   * @param {Object} message String, Buffer or a Stream\n   * @param {Function} callback Callback to return once sending is completed\n   */\n\n\n  send(envelope, message, done) {\n    if (!message) {\n      return done(this._formatError('Empty message', 'EMESSAGE', false, 'API'));\n    } // reject larger messages than allowed\n\n\n    if (this._maxAllowedSize && envelope.size > this._maxAllowedSize) {\n      return setImmediate(() => {\n        done(this._formatError('Message size larger than allowed ' + this._maxAllowedSize, 'EMESSAGE', false, 'MAIL FROM'));\n      });\n    } // ensure that callback is only called once\n\n\n    let returned = false;\n\n    let callback = function () {\n      if (returned) {\n        return;\n      }\n\n      returned = true;\n      done(...arguments);\n    };\n\n    if (typeof message.on === 'function') {\n      message.on('error', err => callback(this._formatError(err, 'ESTREAM', false, 'API')));\n    }\n\n    this._setEnvelope(envelope, (err, info) => {\n      if (err) {\n        return callback(err);\n      }\n\n      let stream = this._createSendStream((err, str) => {\n        if (err) {\n          return callback(err);\n        }\n\n        info.response = str;\n        return callback(null, info);\n      });\n\n      if (typeof message.pipe === 'function') {\n        message.pipe(stream);\n      } else {\n        stream.write(message);\n        stream.end();\n      }\n    });\n  }\n  /**\n   * Resets connection state\n   *\n   * @param {Function} callback Callback to return once connection is reset\n   */\n\n\n  reset(callback) {\n    this._sendCommand('RSET');\n\n    this._responseActions.push(str => {\n      if (str.charAt(0) !== '2') {\n        return callback(this._formatError('Could not reset session state:\\n' + str, 'EPROTOCOL', str, 'RSET'));\n      }\n\n      this._envelope = false;\n      return callback(null, true);\n    });\n  }\n  /**\n   * Connection listener that is run when the connection to\n   * the server is opened\n   *\n   * @event\n   */\n\n\n  _onConnect() {\n    clearTimeout(this._connectionTimeout);\n    this.logger.info({\n      tnx: 'network',\n      localAddress: this._socket.localAddress,\n      localPort: this._socket.localPort,\n      remoteAddress: this._socket.remoteAddress,\n      remotePort: this._socket.remotePort\n    }, '%s established to %s:%s', this.secure ? 'Secure connection' : 'Connection', this._socket.remoteAddress, this._socket.remotePort);\n\n    if (this._destroyed) {\n      // Connection was established after we already had canceled it\n      this.close();\n      return;\n    }\n\n    this.stage = 'connected'; // clear existing listeners for the socket\n\n    this._socket.removeAllListeners('data');\n\n    this._socket.removeAllListeners('timeout');\n\n    this._socket.removeAllListeners('close');\n\n    this._socket.removeAllListeners('end');\n\n    this._socket.on('data', chunk => this._onData(chunk));\n\n    this._socket.once('close', errored => this._onClose(errored));\n\n    this._socket.once('end', () => this._onEnd());\n\n    this._socket.setTimeout(this.options.socketTimeout || SOCKET_TIMEOUT);\n\n    this._socket.on('timeout', () => this._onTimeout());\n\n    this._greetingTimeout = setTimeout(() => {\n      // if still waiting for greeting, give up\n      if (this._socket && !this._destroyed && this._responseActions[0] === this._actionGreeting) {\n        this._onError('Greeting never received', 'ETIMEDOUT', false, 'CONN');\n      }\n    }, this.options.greetingTimeout || GREETING_TIMEOUT);\n\n    this._responseActions.push(this._actionGreeting); // we have a 'data' listener set up so resume socket if it was paused\n\n\n    this._socket.resume();\n  }\n  /**\n   * 'data' listener for data coming from the server\n   *\n   * @event\n   * @param {Buffer} chunk Data chunk coming from the server\n   */\n\n\n  _onData(chunk) {\n    if (this._destroyed || !chunk || !chunk.length) {\n      return;\n    }\n\n    let data = (chunk || '').toString('binary');\n    let lines = (this._remainder + data).split(/\\r?\\n/);\n    let lastline;\n    this._remainder = lines.pop();\n\n    for (let i = 0, len = lines.length; i < len; i++) {\n      if (this._responseQueue.length) {\n        lastline = this._responseQueue[this._responseQueue.length - 1];\n\n        if (/^\\d+\\-/.test(lastline.split('\\n').pop())) {\n          this._responseQueue[this._responseQueue.length - 1] += '\\n' + lines[i];\n          continue;\n        }\n      }\n\n      this._responseQueue.push(lines[i]);\n    }\n\n    this._processResponse();\n  }\n  /**\n   * 'error' listener for the socket\n   *\n   * @event\n   * @param {Error} err Error object\n   * @param {String} type Error name\n   */\n\n\n  _onError(err, type, data, command) {\n    clearTimeout(this._connectionTimeout);\n    clearTimeout(this._greetingTimeout);\n\n    if (this._destroyed) {\n      // just ignore, already closed\n      // this might happen when a socket is canceled because of reached timeout\n      // but the socket timeout error itself receives only after\n      return;\n    }\n\n    err = this._formatError(err, type, data, command);\n    let entry = {\n      err\n    };\n\n    if (type) {\n      entry.errorType = type;\n    }\n\n    if (data) {\n      entry.errorData = data;\n    }\n\n    if (command) {\n      entry.command = command;\n    }\n\n    this.logger.error(data, err.message);\n    this.emit('error', err);\n    this.close();\n  }\n\n  _formatError(message, type, response, command) {\n    let err;\n\n    if (/Error\\]$/i.test(Object.prototype.toString.call(message))) {\n      err = message;\n    } else {\n      err = new Error(message);\n    }\n\n    if (type && type !== 'Error') {\n      err.code = type;\n    }\n\n    if (response) {\n      err.response = response;\n      err.message += ': ' + response;\n    }\n\n    let responseCode = typeof response === 'string' && Number((response.match(/^\\d+/) || [])[0]) || false;\n\n    if (responseCode) {\n      err.responseCode = responseCode;\n    }\n\n    if (command) {\n      err.command = command;\n    }\n\n    return err;\n  }\n  /**\n   * 'close' listener for the socket\n   *\n   * @event\n   */\n\n\n  _onClose() {\n    this.logger.info({\n      tnx: 'network'\n    }, 'Connection closed');\n\n    if (this.upgrading && !this._destroyed) {\n      return this._onError(new Error('Connection closed unexpectedly'), 'ETLS', false, 'CONN');\n    } else if (![this._actionGreeting, this.close].includes(this._responseActions[0]) && !this._destroyed) {\n      return this._onError(new Error('Connection closed unexpectedly'), 'ECONNECTION', false, 'CONN');\n    }\n\n    this._destroy();\n  }\n  /**\n   * 'end' listener for the socket\n   *\n   * @event\n   */\n\n\n  _onEnd() {\n    this._destroy();\n  }\n  /**\n   * 'timeout' listener for the socket\n   *\n   * @event\n   */\n\n\n  _onTimeout() {\n    return this._onError(new Error('Timeout'), 'ETIMEDOUT', false, 'CONN');\n  }\n  /**\n   * Destroys the client, emits 'end'\n   */\n\n\n  _destroy() {\n    if (this._destroyed) {\n      return;\n    }\n\n    this._destroyed = true;\n    this.emit('end');\n  }\n  /**\n   * Upgrades the connection to TLS\n   *\n   * @param {Function} callback Callback function to run when the connection\n   *        has been secured\n   */\n\n\n  _upgradeConnection(callback) {\n    // do not remove all listeners or it breaks node v0.10 as there's\n    // apparently a 'finish' event set that would be cleared as well\n    // we can safely keep 'error', 'end', 'close' etc. events\n    this._socket.removeAllListeners('data'); // incoming data is going to be gibberish from this point onwards\n\n\n    this._socket.removeAllListeners('timeout'); // timeout will be re-set for the new socket object\n\n\n    let socketPlain = this._socket;\n    let opts = {\n      socket: this._socket,\n      host: this.host\n    };\n    Object.keys(this.options.tls || {}).forEach(key => {\n      opts[key] = this.options.tls[key];\n    });\n    this.upgrading = true;\n    this._socket = tls.connect(opts, () => {\n      this.secure = true;\n      this.upgrading = false;\n\n      this._socket.on('data', chunk => this._onData(chunk));\n\n      socketPlain.removeAllListeners('close');\n      socketPlain.removeAllListeners('end');\n      return callback(null, true);\n    });\n\n    this._socket.on('error', err => this._onError(err, 'ESOCKET', false, 'CONN'));\n\n    this._socket.once('close', errored => this._onClose(errored));\n\n    this._socket.once('end', () => this._onEnd());\n\n    this._socket.setTimeout(this.options.socketTimeout || SOCKET_TIMEOUT); // 10 min.\n\n\n    this._socket.on('timeout', () => this._onTimeout()); // resume in case the socket was paused\n\n\n    socketPlain.resume();\n  }\n  /**\n   * Processes queued responses from the server\n   *\n   * @param {Boolean} force If true, ignores _processing flag\n   */\n\n\n  _processResponse() {\n    if (!this._responseQueue.length) {\n      return false;\n    }\n\n    let str = this.lastServerResponse = (this._responseQueue.shift() || '').toString();\n\n    if (/^\\d+\\-/.test(str.split('\\n').pop())) {\n      // keep waiting for the final part of multiline response\n      return;\n    }\n\n    if (this.options.debug || this.options.transactionLog) {\n      this.logger.debug({\n        tnx: 'server'\n      }, str.replace(/\\r?\\n$/, ''));\n    }\n\n    if (!str.trim()) {\n      // skip unexpected empty lines\n      setImmediate(() => this._processResponse(true));\n    }\n\n    let action = this._responseActions.shift();\n\n    if (typeof action === 'function') {\n      action.call(this, str);\n      setImmediate(() => this._processResponse(true));\n    } else {\n      return this._onError(new Error('Unexpected Response'), 'EPROTOCOL', str, 'CONN');\n    }\n  }\n  /**\n   * Send a command to the server, append \\r\\n\n   *\n   * @param {String} str String to be sent to the server\n   */\n\n\n  _sendCommand(str) {\n    if (this._destroyed) {\n      // Connection already closed, can't send any more data\n      return;\n    }\n\n    if (this._socket.destroyed) {\n      return this.close();\n    }\n\n    if (this.options.debug || this.options.transactionLog) {\n      this.logger.debug({\n        tnx: 'client'\n      }, (str || '').toString().replace(/\\r?\\n$/, ''));\n    }\n\n    this._socket.write(new Buffer(str + '\\r\\n', 'utf-8'));\n  }\n  /**\n   * Initiates a new message by submitting envelope data, starting with\n   * MAIL FROM: command\n   *\n   * @param {Object} envelope Envelope object in the form of\n   *        {from:'...', to:['...']}\n   *        or\n   *        {from:{address:'...',name:'...'}, to:[address:'...',name:'...']}\n   */\n\n\n  _setEnvelope(envelope, callback) {\n    let args = [];\n    let useSmtpUtf8 = false;\n    this._envelope = envelope || {};\n    this._envelope.from = (this._envelope.from && this._envelope.from.address || this._envelope.from || '').toString().trim();\n    this._envelope.to = [].concat(this._envelope.to || []).map(to => (to && to.address || to || '').toString().trim());\n\n    if (!this._envelope.to.length) {\n      return callback(this._formatError('No recipients defined', 'EENVELOPE', false, 'API'));\n    }\n\n    if (this._envelope.from && /[\\r\\n<>]/.test(this._envelope.from)) {\n      return callback(this._formatError('Invalid sender ' + JSON.stringify(this._envelope.from), 'EENVELOPE', false, 'API'));\n    } // check if the sender address uses only ASCII characters,\n    // otherwise require usage of SMTPUTF8 extension\n\n\n    if (/[\\x80-\\uFFFF]/.test(this._envelope.from)) {\n      useSmtpUtf8 = true;\n    }\n\n    for (let i = 0, len = this._envelope.to.length; i < len; i++) {\n      if (!this._envelope.to[i] || /[\\r\\n<>]/.test(this._envelope.to[i])) {\n        return callback(this._formatError('Invalid recipient ' + JSON.stringify(this._envelope.to[i]), 'EENVELOPE', false, 'API'));\n      } // check if the recipients addresses use only ASCII characters,\n      // otherwise require usage of SMTPUTF8 extension\n\n\n      if (/[\\x80-\\uFFFF]/.test(this._envelope.to[i])) {\n        useSmtpUtf8 = true;\n      }\n    } // clone the recipients array for latter manipulation\n\n\n    this._envelope.rcptQueue = JSON.parse(JSON.stringify(this._envelope.to || []));\n    this._envelope.rejected = [];\n    this._envelope.rejectedErrors = [];\n    this._envelope.accepted = [];\n\n    if (this._envelope.dsn) {\n      try {\n        this._envelope.dsn = this._setDsnEnvelope(this._envelope.dsn);\n      } catch (err) {\n        return callback(this._formatError('Invalid DSN ' + err.message, 'EENVELOPE', false, 'API'));\n      }\n    }\n\n    this._responseActions.push(str => {\n      this._actionMAIL(str, callback);\n    }); // If the server supports SMTPUTF8 and the envelope includes an internationalized\n    // email address then append SMTPUTF8 keyword to the MAIL FROM command\n\n\n    if (useSmtpUtf8 && this._supportedExtensions.includes('SMTPUTF8')) {\n      args.push('SMTPUTF8');\n      this._usingSmtpUtf8 = true;\n    } // If the server supports 8BITMIME and the message might contain non-ascii bytes\n    // then append the 8BITMIME keyword to the MAIL FROM command\n\n\n    if (this._envelope.use8BitMime && this._supportedExtensions.includes('8BITMIME')) {\n      args.push('BODY=8BITMIME');\n      this._using8BitMime = true;\n    }\n\n    if (this._envelope.size && this._supportedExtensions.includes('SIZE')) {\n      args.push('SIZE=' + this._envelope.size);\n    } // If the server supports DSN and the envelope includes an DSN prop\n    // then append DSN params to the MAIL FROM command\n\n\n    if (this._envelope.dsn && this._supportedExtensions.includes('DSN')) {\n      if (this._envelope.dsn.ret) {\n        args.push('RET=' + shared.encodeXText(this._envelope.dsn.ret));\n      }\n\n      if (this._envelope.dsn.envid) {\n        args.push('ENVID=' + shared.encodeXText(this._envelope.dsn.envid));\n      }\n    }\n\n    this._sendCommand('MAIL FROM:<' + this._envelope.from + '>' + (args.length ? ' ' + args.join(' ') : ''));\n  }\n\n  _setDsnEnvelope(params) {\n    let ret = (params.ret || params.return || '').toString().toUpperCase() || null;\n\n    if (ret) {\n      switch (ret) {\n        case 'HDRS':\n        case 'HEADERS':\n          ret = 'HDRS';\n          break;\n\n        case 'FULL':\n        case 'BODY':\n          ret = 'full';\n          break;\n      }\n    }\n\n    if (ret && !['FULL', 'HDRS'].includes(ret)) {\n      throw new Error('ret: ' + JSON.stringify(ret));\n    }\n\n    let envid = (params.envid || params.id || '').toString() || null;\n    let notify = params.notify || null;\n\n    if (notify) {\n      if (typeof notify === 'string') {\n        notify = notify.split(',');\n      }\n\n      notify = notify.map(n => n.trim().toUpperCase());\n      let validNotify = ['NEVER', 'SUCCESS', 'FAILURE', 'DELAY'];\n      let invaliNotify = notify.filter(n => !validNotify.includes(n));\n\n      if (invaliNotify.length || notify.length > 1 && notify.includes('NEVER')) {\n        throw new Error('notify: ' + JSON.stringify(notify.join(',')));\n      }\n\n      notify = notify.join(',');\n    }\n\n    let orcpt = (params.orcpt || params.recipient).toString() || null;\n\n    if (orcpt && orcpt.indexOf(';') < 0) {\n      orcpt = 'rfc822;' + orcpt;\n    }\n\n    return {\n      ret,\n      envid,\n      notify,\n      orcpt\n    };\n  }\n\n  _getDsnRcptToArgs() {\n    let args = []; // If the server supports DSN and the envelope includes an DSN prop\n    // then append DSN params to the RCPT TO command\n\n    if (this._envelope.dsn && this._supportedExtensions.includes('DSN')) {\n      if (this._envelope.dsn.notify) {\n        args.push('NOTIFY=' + shared.encodeXText(this._envelope.dsn.notify));\n      }\n\n      if (this._envelope.dsn.orcpt) {\n        args.push('ORCPT=' + shared.encodeXText(this._envelope.dsn.orcpt));\n      }\n    }\n\n    return args.length ? ' ' + args.join(' ') : '';\n  }\n\n  _createSendStream(callback) {\n    let dataStream = new DataStream();\n    let logStream;\n\n    if (this.options.lmtp) {\n      this._envelope.accepted.forEach((recipient, i) => {\n        let final = i === this._envelope.accepted.length - 1;\n\n        this._responseActions.push(str => {\n          this._actionLMTPStream(recipient, final, str, callback);\n        });\n      });\n    } else {\n      this._responseActions.push(str => {\n        this._actionSMTPStream(str, callback);\n      });\n    }\n\n    dataStream.pipe(this._socket, {\n      end: false\n    });\n\n    if (this.options.debug) {\n      logStream = new PassThrough();\n      logStream.on('readable', () => {\n        let chunk;\n\n        while (chunk = logStream.read()) {\n          this.logger.debug({\n            tnx: 'message'\n          }, chunk.toString('binary').replace(/\\r?\\n$/, ''));\n        }\n      });\n      dataStream.pipe(logStream);\n    }\n\n    dataStream.once('end', () => {\n      this.logger.info({\n        tnx: 'message',\n        inByteCount: dataStream.inByteCount,\n        outByteCount: dataStream.outByteCount\n      }, '<%s bytes encoded mime message (source size %s bytes)>', dataStream.outByteCount, dataStream.inByteCount);\n    });\n    return dataStream;\n  }\n  /** ACTIONS **/\n\n  /**\n   * Will be run after the connection is created and the server sends\n   * a greeting. If the incoming message starts with 220 initiate\n   * SMTP session by sending EHLO command\n   *\n   * @param {String} str Message from the server\n   */\n\n\n  _actionGreeting(str) {\n    clearTimeout(this._greetingTimeout);\n\n    if (str.substr(0, 3) !== '220') {\n      this._onError(new Error('Invalid greeting from server:\\n' + str), 'EPROTOCOL', str, 'CONN');\n\n      return;\n    }\n\n    if (this.options.lmtp) {\n      this._responseActions.push(this._actionLHLO);\n\n      this._sendCommand('LHLO ' + this.name);\n    } else {\n      this._responseActions.push(this._actionEHLO);\n\n      this._sendCommand('EHLO ' + this.name);\n    }\n  }\n  /**\n   * Handles server response for LHLO command. If it yielded in\n   * error, emit 'error', otherwise treat this as an EHLO response\n   *\n   * @param {String} str Message from the server\n   */\n\n\n  _actionLHLO(str) {\n    if (str.charAt(0) !== '2') {\n      this._onError(new Error('Invalid response for LHLO:\\n' + str), 'EPROTOCOL', str, 'LHLO');\n\n      return;\n    }\n\n    this._actionEHLO(str);\n  }\n  /**\n   * Handles server response for EHLO command. If it yielded in\n   * error, try HELO instead, otherwise initiate TLS negotiation\n   * if STARTTLS is supported by the server or move into the\n   * authentication phase.\n   *\n   * @param {String} str Message from the server\n   */\n\n\n  _actionEHLO(str) {\n    let match;\n\n    if (str.substr(0, 3) === '421') {\n      this._onError(new Error('Server terminates connection:\\n' + str), 'ECONNECTION', str, 'EHLO');\n\n      return;\n    }\n\n    if (str.charAt(0) !== '2') {\n      if (this.options.requireTLS) {\n        this._onError(new Error('EHLO failed but HELO does not support required STARTTLS:\\n' + str), 'ECONNECTION', str, 'EHLO');\n\n        return;\n      } // Try HELO instead\n\n\n      this._responseActions.push(this._actionHELO);\n\n      this._sendCommand('HELO ' + this.name);\n\n      return;\n    } // Detect if the server supports STARTTLS\n\n\n    if (!this.secure && !this.options.ignoreTLS && (/[ \\-]STARTTLS\\b/mi.test(str) || this.options.requireTLS)) {\n      this._sendCommand('STARTTLS');\n\n      this._responseActions.push(this._actionSTARTTLS);\n\n      return;\n    } // Detect if the server supports SMTPUTF8\n\n\n    if (/[ \\-]SMTPUTF8\\b/mi.test(str)) {\n      this._supportedExtensions.push('SMTPUTF8');\n    } // Detect if the server supports DSN\n\n\n    if (/[ \\-]DSN\\b/mi.test(str)) {\n      this._supportedExtensions.push('DSN');\n    } // Detect if the server supports 8BITMIME\n\n\n    if (/[ \\-]8BITMIME\\b/mi.test(str)) {\n      this._supportedExtensions.push('8BITMIME');\n    } // Detect if the server supports PIPELINING\n\n\n    if (/[ \\-]PIPELINING\\b/mi.test(str)) {\n      this._supportedExtensions.push('PIPELINING');\n    } // Detect if the server supports PLAIN auth\n\n\n    if (/AUTH(?:(\\s+|=)[^\\n]*\\s+|\\s+|=)PLAIN/i.test(str)) {\n      this._supportedAuth.push('PLAIN');\n    } // Detect if the server supports LOGIN auth\n\n\n    if (/AUTH(?:(\\s+|=)[^\\n]*\\s+|\\s+|=)LOGIN/i.test(str)) {\n      this._supportedAuth.push('LOGIN');\n    } // Detect if the server supports CRAM-MD5 auth\n\n\n    if (/AUTH(?:(\\s+|=)[^\\n]*\\s+|\\s+|=)CRAM-MD5/i.test(str)) {\n      this._supportedAuth.push('CRAM-MD5');\n    } // Detect if the server supports XOAUTH2 auth\n\n\n    if (/AUTH(?:(\\s+|=)[^\\n]*\\s+|\\s+|=)XOAUTH2/i.test(str)) {\n      this._supportedAuth.push('XOAUTH2');\n    } // Detect if the server supports SIZE extensions (and the max allowed size)\n\n\n    if (match = str.match(/[ \\-]SIZE(?:[ \\t]+(\\d+))?/mi)) {\n      this._supportedExtensions.push('SIZE');\n\n      this._maxAllowedSize = Number(match[1]) || 0;\n    }\n\n    this.emit('connect');\n  }\n  /**\n   * Handles server response for HELO command. If it yielded in\n   * error, emit 'error', otherwise move into the authentication phase.\n   *\n   * @param {String} str Message from the server\n   */\n\n\n  _actionHELO(str) {\n    if (str.charAt(0) !== '2') {\n      this._onError(new Error('Invalid response for EHLO/HELO:\\n' + str), 'EPROTOCOL', str, 'HELO');\n\n      return;\n    }\n\n    this.emit('connect');\n  }\n  /**\n   * Handles server response for STARTTLS command. If there's an error\n   * try HELO instead, otherwise initiate TLS upgrade. If the upgrade\n   * succeedes restart the EHLO\n   *\n   * @param {String} str Message from the server\n   */\n\n\n  _actionSTARTTLS(str) {\n    if (str.charAt(0) !== '2') {\n      if (this.options.opportunisticTLS) {\n        this.logger.info({\n          tnx: 'smtp'\n        }, 'Failed STARTTLS upgrade, continuing unencrypted');\n        return this.emit('connect');\n      }\n\n      this._onError(new Error('Error upgrading connection with STARTTLS'), 'ETLS', str, 'STARTTLS');\n\n      return;\n    }\n\n    this._upgradeConnection((err, secured) => {\n      if (err) {\n        this._onError(new Error('Error initiating TLS - ' + (err.message || err)), 'ETLS', false, 'STARTTLS');\n\n        return;\n      }\n\n      this.logger.info({\n        tnx: 'smtp'\n      }, 'Connection upgraded with STARTTLS');\n\n      if (secured) {\n        // restart session\n        this._responseActions.push(this._actionEHLO);\n\n        this._sendCommand('EHLO ' + this.name);\n      } else {\n        this.emit('connect');\n      }\n    });\n  }\n  /**\n   * Handle the response for AUTH LOGIN command. We are expecting\n   * '334 VXNlcm5hbWU6' (base64 for 'Username:'). Data to be sent as\n   * response needs to be base64 encoded username. We do not need\n   * exact match but settle with 334 response in general as some\n   * hosts invalidly use a longer message than VXNlcm5hbWU6\n   *\n   * @param {String} str Message from the server\n   */\n\n\n  _actionAUTH_LOGIN_USER(str, callback) {\n    if (!/^334[ \\-]/.test(str)) {\n      // expecting '334 VXNlcm5hbWU6'\n      callback(this._formatError('Invalid login sequence while waiting for \"334 VXNlcm5hbWU6\"', 'EAUTH', str, 'AUTH LOGIN'));\n      return;\n    }\n\n    this._responseActions.push(str => {\n      this._actionAUTH_LOGIN_PASS(str, callback);\n    });\n\n    this._sendCommand(new Buffer(this._auth.credentials.user + '', 'utf-8').toString('base64'));\n  }\n  /**\n   * Handle the response for AUTH CRAM-MD5 command. We are expecting\n   * '334 <challenge string>'. Data to be sent as response needs to be\n   * base64 decoded challenge string, MD5 hashed using the password as\n   * a HMAC key, prefixed by the username and a space, and finally all\n   * base64 encoded again.\n   *\n   * @param {String} str Message from the server\n   */\n\n\n  _actionAUTH_CRAM_MD5(str, callback) {\n    let challengeMatch = str.match(/^334\\s+(.+)$/);\n    let challengeString = '';\n\n    if (!challengeMatch) {\n      return callback(this._formatError('Invalid login sequence while waiting for server challenge string', 'EAUTH', str, 'AUTH CRAM-MD5'));\n    } else {\n      challengeString = challengeMatch[1];\n    } // Decode from base64\n\n\n    let base64decoded = new Buffer(challengeString, 'base64').toString('ascii'),\n        hmac_md5 = crypto.createHmac('md5', this._auth.credentials.pass);\n    hmac_md5.update(base64decoded);\n    let hex_hmac = hmac_md5.digest('hex');\n    let prepended = this._auth.credentials.user + ' ' + hex_hmac;\n\n    this._responseActions.push(str => {\n      this._actionAUTH_CRAM_MD5_PASS(str, callback);\n    });\n\n    this._sendCommand(new Buffer(prepended).toString('base64'));\n  }\n  /**\n   * Handles the response to CRAM-MD5 authentication, if there's no error,\n   * the user can be considered logged in. Start waiting for a message to send\n   *\n   * @param {String} str Message from the server\n   */\n\n\n  _actionAUTH_CRAM_MD5_PASS(str, callback) {\n    if (!str.match(/^235\\s+/)) {\n      return callback(this._formatError('Invalid login sequence while waiting for \"235\"', 'EAUTH', str, 'AUTH CRAM-MD5'));\n    }\n\n    this.logger.info({\n      tnx: 'smtp',\n      username: this._auth.user,\n      action: 'authenticated',\n      method: this._authMethod\n    }, 'User %s authenticated', JSON.stringify(this._auth.user));\n    this.authenticated = true;\n    callback(null, true);\n  }\n  /**\n   * Handle the response for AUTH LOGIN command. We are expecting\n   * '334 UGFzc3dvcmQ6' (base64 for 'Password:'). Data to be sent as\n   * response needs to be base64 encoded password.\n   *\n   * @param {String} str Message from the server\n   */\n\n\n  _actionAUTH_LOGIN_PASS(str, callback) {\n    if (!/^334[ \\-]/.test(str)) {\n      // expecting '334 UGFzc3dvcmQ6'\n      return callback(this._formatError('Invalid login sequence while waiting for \"334 UGFzc3dvcmQ6\"', 'EAUTH', str, 'AUTH LOGIN'));\n    }\n\n    this._responseActions.push(str => {\n      this._actionAUTHComplete(str, callback);\n    });\n\n    this._sendCommand(new Buffer(this._auth.credentials.pass + '', 'utf-8').toString('base64'));\n  }\n  /**\n   * Handles the response for authentication, if there's no error,\n   * the user can be considered logged in. Start waiting for a message to send\n   *\n   * @param {String} str Message from the server\n   */\n\n\n  _actionAUTHComplete(str, isRetry, callback) {\n    if (!callback && typeof isRetry === 'function') {\n      callback = isRetry;\n      isRetry = false;\n    }\n\n    if (str.substr(0, 3) === '334') {\n      this._responseActions.push(str => {\n        if (isRetry || this._authMethod !== 'XOAUTH2') {\n          this._actionAUTHComplete(str, true, callback);\n        } else {\n          // fetch a new OAuth2 access token\n          setImmediate(() => this._handleXOauth2Token(true, callback));\n        }\n      });\n\n      this._sendCommand('');\n\n      return;\n    }\n\n    if (str.charAt(0) !== '2') {\n      this.logger.info({\n        tnx: 'smtp',\n        username: this._auth.user,\n        action: 'authfail',\n        method: this._authMethod\n      }, 'User %s failed to authenticate', JSON.stringify(this._auth.user));\n      return callback(this._formatError('Invalid login', 'EAUTH', str, 'AUTH ' + this._authMethod));\n    }\n\n    this.logger.info({\n      tnx: 'smtp',\n      username: this._auth.user,\n      action: 'authenticated',\n      method: this._authMethod\n    }, 'User %s authenticated', JSON.stringify(this._auth.user));\n    this.authenticated = true;\n    callback(null, true);\n  }\n  /**\n   * Handle response for a MAIL FROM: command\n   *\n   * @param {String} str Message from the server\n   */\n\n\n  _actionMAIL(str, callback) {\n    let message, curRecipient;\n\n    if (Number(str.charAt(0)) !== 2) {\n      if (this._usingSmtpUtf8 && /^550 /.test(str) && /[\\x80-\\uFFFF]/.test(this._envelope.from)) {\n        message = 'Internationalized mailbox name not allowed';\n      } else {\n        message = 'Mail command failed';\n      }\n\n      return callback(this._formatError(message, 'EENVELOPE', str, 'MAIL FROM'));\n    }\n\n    if (!this._envelope.rcptQueue.length) {\n      return callback(this._formatError('Can\\'t send mail - no recipients defined', 'EENVELOPE', false, 'API'));\n    } else {\n      this._recipientQueue = [];\n\n      if (this._supportedExtensions.includes('PIPELINING')) {\n        while (this._envelope.rcptQueue.length) {\n          curRecipient = this._envelope.rcptQueue.shift();\n\n          this._recipientQueue.push(curRecipient);\n\n          this._responseActions.push(str => {\n            this._actionRCPT(str, callback);\n          });\n\n          this._sendCommand('RCPT TO:<' + curRecipient + '>' + this._getDsnRcptToArgs());\n        }\n      } else {\n        curRecipient = this._envelope.rcptQueue.shift();\n\n        this._recipientQueue.push(curRecipient);\n\n        this._responseActions.push(str => {\n          this._actionRCPT(str, callback);\n        });\n\n        this._sendCommand('RCPT TO:<' + curRecipient + '>' + this._getDsnRcptToArgs());\n      }\n    }\n  }\n  /**\n   * Handle response for a RCPT TO: command\n   *\n   * @param {String} str Message from the server\n   */\n\n\n  _actionRCPT(str, callback) {\n    let message,\n        err,\n        curRecipient = this._recipientQueue.shift();\n\n    if (Number(str.charAt(0)) !== 2) {\n      // this is a soft error\n      if (this._usingSmtpUtf8 && /^553 /.test(str) && /[\\x80-\\uFFFF]/.test(curRecipient)) {\n        message = 'Internationalized mailbox name not allowed';\n      } else {\n        message = 'Recipient command failed';\n      }\n\n      this._envelope.rejected.push(curRecipient); // store error for the failed recipient\n\n\n      err = this._formatError(message, 'EENVELOPE', str, 'RCPT TO');\n      err.recipient = curRecipient;\n\n      this._envelope.rejectedErrors.push(err);\n    } else {\n      this._envelope.accepted.push(curRecipient);\n    }\n\n    if (!this._envelope.rcptQueue.length && !this._recipientQueue.length) {\n      if (this._envelope.rejected.length < this._envelope.to.length) {\n        this._responseActions.push(str => {\n          this._actionDATA(str, callback);\n        });\n\n        this._sendCommand('DATA');\n      } else {\n        err = this._formatError('Can\\'t send mail - all recipients were rejected', 'EENVELOPE', str, 'RCPT TO');\n        err.rejected = this._envelope.rejected;\n        err.rejectedErrors = this._envelope.rejectedErrors;\n        return callback(err);\n      }\n    } else if (this._envelope.rcptQueue.length) {\n      curRecipient = this._envelope.rcptQueue.shift();\n\n      this._recipientQueue.push(curRecipient);\n\n      this._responseActions.push(str => {\n        this._actionRCPT(str, callback);\n      });\n\n      this._sendCommand('RCPT TO:<' + curRecipient + '>' + this._getDsnRcptToArgs());\n    }\n  }\n  /**\n   * Handle response for a DATA command\n   *\n   * @param {String} str Message from the server\n   */\n\n\n  _actionDATA(str, callback) {\n    // response should be 354 but according to this issue https://github.com/eleith/emailjs/issues/24\n    // some servers might use 250 instead, so lets check for 2 or 3 as the first digit\n    if (!/^[23]/.test(str)) {\n      return callback(this._formatError('Data command failed', 'EENVELOPE', str, 'DATA'));\n    }\n\n    let response = {\n      accepted: this._envelope.accepted,\n      rejected: this._envelope.rejected\n    };\n\n    if (this._envelope.rejectedErrors.length) {\n      response.rejectedErrors = this._envelope.rejectedErrors;\n    }\n\n    callback(null, response);\n  }\n  /**\n   * Handle response for a DATA stream when using SMTP\n   * We expect a single response that defines if the sending succeeded or failed\n   *\n   * @param {String} str Message from the server\n   */\n\n\n  _actionSMTPStream(str, callback) {\n    if (Number(str.charAt(0)) !== 2) {\n      // Message failed\n      return callback(this._formatError('Message failed', 'EMESSAGE', str, 'DATA'));\n    } else {\n      // Message sent succesfully\n      return callback(null, str);\n    }\n  }\n  /**\n   * Handle response for a DATA stream\n   * We expect a separate response for every recipient. All recipients can either\n   * succeed or fail separately\n   *\n   * @param {String} recipient The recipient this response applies to\n   * @param {Boolean} final Is this the final recipient?\n   * @param {String} str Message from the server\n   */\n\n\n  _actionLMTPStream(recipient, final, str, callback) {\n    let err;\n\n    if (Number(str.charAt(0)) !== 2) {\n      // Message failed\n      err = this._formatError('Message failed for recipient ' + recipient, 'EMESSAGE', str, 'DATA');\n      err.recipient = recipient;\n\n      this._envelope.rejected.push(recipient);\n\n      this._envelope.rejectedErrors.push(err);\n\n      for (let i = 0, len = this._envelope.accepted.length; i < len; i++) {\n        if (this._envelope.accepted[i] === recipient) {\n          this._envelope.accepted.splice(i, 1);\n        }\n      }\n    }\n\n    if (final) {\n      return callback(null, str);\n    }\n  }\n\n  _handleXOauth2Token(isRetry, callback) {\n    this._auth.oauth2.getToken(isRetry, (err, accessToken) => {\n      if (err) {\n        this.logger.info({\n          tnx: 'smtp',\n          username: this._auth.user,\n          action: 'authfail',\n          method: this._authMethod\n        }, 'User %s failed to authenticate', JSON.stringify(this._auth.user));\n        return callback(this._formatError(err, 'EAUTH', false, 'AUTH XOAUTH2'));\n      }\n\n      this._responseActions.push(str => {\n        this._actionAUTHComplete(str, isRetry, callback);\n      });\n\n      this._sendCommand('AUTH XOAUTH2 ' + this._auth.oauth2.buildXOAuth2Token(accessToken));\n    });\n  }\n\n  _getHostname() {\n    // defaul hostname is machine hostname or [IP]\n    let defaultHostname = os.hostname() || ''; // ignore if not FQDN\n\n    if (defaultHostname.indexOf('.') < 0) {\n      defaultHostname = '[127.0.0.1]';\n    } // IP should be enclosed in []\n\n\n    if (defaultHostname.match(/^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$/)) {\n      defaultHostname = '[' + defaultHostname + ']';\n    }\n\n    return defaultHostname;\n  }\n\n}\n\nmodule.exports = SMTPConnection;","map":{"version":3,"sources":["/Users/theodaguier/e-do/node_modules/smtp-connection/node_modules/nodemailer/lib/smtp-connection/index.js"],"names":["packageInfo","require","EventEmitter","net","tls","os","crypto","DataStream","PassThrough","shared","CONNECTION_TIMEOUT","SOCKET_TIMEOUT","GREETING_TIMEOUT","SMTPConnection","constructor","options","id","randomBytes","toString","replace","stage","secureConnection","secure","alreadySecured","secured","port","host","name","_getHostname","logger","getLogger","component","sid","version","authenticated","destroyed","_remainder","_responseQueue","lastServerResponse","_socket","_supportedAuth","_envelope","_supportedExtensions","_maxAllowedSize","_responseActions","_recipientQueue","_greetingTimeout","_connectionTimeout","_destroyed","_closing","connect","connectCallback","once","debug","tnx","opts","localAddress","connection","setImmediate","_upgradeConnection","err","_onError","Error","message","_onConnect","socket","setKeepAlive","E","Object","keys","forEach","key","setTimeout","connectionTimeout","on","quit","_sendCommand","push","close","clearTimeout","closeMethod","_destroy","login","authData","callback","_auth","_authMethod","method","trim","toUpperCase","oauth2","credentials","user","pass","_formatError","_handleXOauth2Token","str","_actionAUTH_LOGIN_USER","_actionAUTHComplete","Buffer","_actionAUTH_CRAM_MD5","send","envelope","done","size","returned","arguments","_setEnvelope","info","stream","_createSendStream","response","pipe","write","end","reset","charAt","localPort","remoteAddress","remotePort","removeAllListeners","chunk","_onData","errored","_onClose","_onEnd","socketTimeout","_onTimeout","_actionGreeting","greetingTimeout","resume","length","data","lines","split","lastline","pop","i","len","test","_processResponse","type","command","entry","errorType","errorData","error","emit","prototype","call","code","responseCode","Number","match","upgrading","includes","socketPlain","shift","transactionLog","action","args","useSmtpUtf8","from","address","to","concat","map","JSON","stringify","rcptQueue","parse","rejected","rejectedErrors","accepted","dsn","_setDsnEnvelope","_actionMAIL","_usingSmtpUtf8","use8BitMime","_using8BitMime","ret","encodeXText","envid","join","params","return","notify","n","validNotify","invaliNotify","filter","orcpt","recipient","indexOf","_getDsnRcptToArgs","dataStream","logStream","lmtp","final","_actionLMTPStream","_actionSMTPStream","read","inByteCount","outByteCount","substr","_actionLHLO","_actionEHLO","requireTLS","_actionHELO","ignoreTLS","_actionSTARTTLS","opportunisticTLS","_actionAUTH_LOGIN_PASS","challengeMatch","challengeString","base64decoded","hmac_md5","createHmac","update","hex_hmac","digest","prepended","_actionAUTH_CRAM_MD5_PASS","username","isRetry","curRecipient","_actionRCPT","_actionDATA","splice","getToken","accessToken","buildXOAuth2Token","defaultHostname","hostname","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst packageInfo = require('../../package.json');\nconst EventEmitter = require('events').EventEmitter;\nconst net = require('net');\nconst tls = require('tls');\nconst os = require('os');\nconst crypto = require('crypto');\nconst DataStream = require('./data-stream');\nconst PassThrough = require('stream').PassThrough;\nconst shared = require('../shared');\n\n// default timeout values in ms\nconst CONNECTION_TIMEOUT = 2 * 60 * 1000; // how much to wait for the connection to be established\nconst SOCKET_TIMEOUT = 10 * 60 * 1000; // how much to wait for socket inactivity before disconnecting the client\nconst GREETING_TIMEOUT = 30 * 1000; // how much to wait after connection is established but SMTP greeting is not receieved\n\n/**\n * Generates a SMTP connection object\n *\n * Optional options object takes the following possible properties:\n *\n *  * **port** - is the port to connect to (defaults to 587 or 465)\n *  * **host** - is the hostname or IP address to connect to (defaults to 'localhost')\n *  * **secure** - use SSL\n *  * **ignoreTLS** - ignore server support for STARTTLS\n *  * **requireTLS** - forces the client to use STARTTLS\n *  * **name** - the name of the client server\n *  * **localAddress** - outbound address to bind to (see: http://nodejs.org/api/net.html#net_net_connect_options_connectionlistener)\n *  * **greetingTimeout** - Time to wait in ms until greeting message is received from the server (defaults to 10000)\n *  * **connectionTimeout** - how many milliseconds to wait for the connection to establish\n *  * **socketTimeout** - Time of inactivity until the connection is closed (defaults to 1 hour)\n *  * **lmtp** - if true, uses LMTP instead of SMTP protocol\n *  * **logger** - bunyan compatible logger interface\n *  * **debug** - if true pass SMTP traffic to the logger\n *  * **tls** - options for createCredentials\n *  * **socket** - existing socket to use instead of creating a new one (see: http://nodejs.org/api/net.html#net_class_net_socket)\n *  * **secured** - boolean indicates that the provided socket has already been upgraded to tls\n *\n * @constructor\n * @namespace SMTP Client module\n * @param {Object} [options] Option properties\n */\nclass SMTPConnection extends EventEmitter {\n    constructor(options) {\n        super(options);\n\n        this.id = crypto.randomBytes(8).toString('base64').replace(/\\W/g, '');\n        this.stage = 'init';\n\n        this.options = options || {};\n\n        this.secureConnection = !!this.options.secure;\n        this.alreadySecured = !!this.options.secured;\n\n        this.port = this.options.port || (this.secureConnection ? 465 : 587);\n        this.host = this.options.host || 'localhost';\n\n        if (typeof this.options.secure === 'undefined' && this.port === 465) {\n            // if secure option is not set but port is 465, then default to secure\n            this.secureConnection = true;\n        }\n\n        this.name = this.options.name || this._getHostname();\n\n        this.logger = shared.getLogger(this.options, {\n            component: this.options.component || 'smtp-connection',\n            sid: this.id\n        });\n\n        /**\n         * Expose version nr, just for the reference\n         * @type {String}\n         */\n        this.version = packageInfo.version;\n\n        /**\n         * If true, then the user is authenticated\n         * @type {Boolean}\n         */\n        this.authenticated = false;\n\n        /**\n         * If set to true, this instance is no longer active\n         * @private\n         */\n        this.destroyed = false;\n\n        /**\n         * Defines if the current connection is secure or not. If not,\n         * STARTTLS can be used if available\n         * @private\n         */\n        this.secure = !!this.secureConnection;\n\n        /**\n         * Store incomplete messages coming from the server\n         * @private\n         */\n        this._remainder = '';\n\n        /**\n         * Unprocessed responses from the server\n         * @type {Array}\n         */\n        this._responseQueue = [];\n\n        this.lastServerResponse = false;\n\n        /**\n         * The socket connecting to the server\n         * @publick\n         */\n        this._socket = false;\n\n        /**\n         * Lists supported auth mechanisms\n         * @private\n         */\n        this._supportedAuth = [];\n\n        /**\n         * Includes current envelope (from, to)\n         * @private\n         */\n        this._envelope = false;\n\n        /**\n         * Lists supported extensions\n         * @private\n         */\n        this._supportedExtensions = [];\n\n        /**\n         * Defines the maximum allowed size for a single message\n         * @private\n         */\n        this._maxAllowedSize = 0;\n\n        /**\n         * Function queue to run if a data chunk comes from the server\n         * @private\n         */\n        this._responseActions = [];\n        this._recipientQueue = [];\n\n        /**\n         * Timeout variable for waiting the greeting\n         * @private\n         */\n        this._greetingTimeout = false;\n\n        /**\n         * Timeout variable for waiting the connection to start\n         * @private\n         */\n        this._connectionTimeout = false;\n\n        /**\n         * If the socket is deemed already closed\n         * @private\n         */\n        this._destroyed = false;\n\n        /**\n         * If the socket is already being closed\n         * @private\n         */\n        this._closing = false;\n    }\n\n    /**\n     * Creates a connection to a SMTP server and sets up connection\n     * listener\n     */\n    connect(connectCallback) {\n        if (typeof connectCallback === 'function') {\n            this.once('connect', () => {\n                this.logger.debug({\n                    tnx: 'smtp'\n                }, 'SMTP handshake finished');\n                connectCallback();\n            });\n        }\n\n        let opts = {\n            port: this.port,\n            host: this.host\n        };\n\n        if (this.options.localAddress) {\n            opts.localAddress = this.options.localAddress;\n        }\n\n        if (this.options.connection) {\n            // connection is already opened\n            this._socket = this.options.connection;\n            if (this.secureConnection && !this.alreadySecured) {\n                setImmediate(() => this._upgradeConnection(err => {\n                    if (err) {\n                        this._onError(new Error('Error initiating TLS - ' + (err.message || err)), 'ETLS', false, 'CONN');\n                        return;\n                    }\n                    this._onConnect();\n                }));\n            } else {\n                setImmediate(() => this._onConnect());\n            }\n        } else if (this.options.socket) {\n            // socket object is set up but not yet connected\n            this._socket = this.options.socket;\n            try {\n                this._socket.connect(this.port, this.host, () => {\n                    this._socket.setKeepAlive(true);\n                    this._onConnect();\n                });\n            } catch (E) {\n                return setImmediate(() => this._onError(E, 'ECONNECTION', false, 'CONN'));\n            }\n        } else if (this.secureConnection) {\n            // connect using tls\n            if (this.options.tls) {\n                Object.keys(this.options.tls).forEach(key => {\n                    opts[key] = this.options.tls[key];\n                });\n            }\n            try {\n                this._socket = tls.connect(this.port, this.host, opts, () => {\n                    this._socket.setKeepAlive(true);\n                    this._onConnect();\n                });\n            } catch (E) {\n                return setImmediate(() => this._onError(E, 'ECONNECTION', false, 'CONN'));\n            }\n        } else {\n            // connect using plaintext\n            try {\n                this._socket = net.connect(opts, () => {\n                    this._socket.setKeepAlive(true);\n                    this._onConnect();\n                });\n            } catch (E) {\n                return setImmediate(() => this._onError(E, 'ECONNECTION', false, 'CONN'));\n            }\n        }\n\n        this._connectionTimeout = setTimeout(() => {\n            this._onError('Connection timeout', 'ETIMEDOUT', false, 'CONN');\n        }, this.options.connectionTimeout || CONNECTION_TIMEOUT);\n\n        this._socket.on('error', err => {\n            this._onError(err, 'ECONNECTION', false, 'CONN');\n        });\n    }\n\n    /**\n     * Sends QUIT\n     */\n    quit() {\n        this._sendCommand('QUIT');\n        this._responseActions.push(this.close);\n    }\n\n    /**\n     * Closes the connection to the server\n     */\n    close() {\n        clearTimeout(this._connectionTimeout);\n        clearTimeout(this._greetingTimeout);\n        this._responseActions = [];\n\n        // allow to run this function only once\n        if (this._closing) {\n            return;\n        }\n        this._closing = true;\n\n        let closeMethod = 'end';\n\n        if (this.stage === 'init') {\n            // Close the socket immediately when connection timed out\n            closeMethod = 'destroy';\n        }\n\n        this.logger.debug({\n            tnx: 'smtp'\n        }, 'Closing connection to the server using \"%s\"', closeMethod);\n\n        let socket = this._socket && this._socket.socket || this._socket;\n\n        if (socket && !socket.destroyed) {\n            try {\n                this._socket[closeMethod]();\n            } catch (E) {\n                // just ignore\n            }\n        }\n\n        this._destroy();\n    }\n\n    /**\n     * Authenticate user\n     */\n    login(authData, callback) {\n        this._auth = authData || {};\n\n        // Select SASL authentication method\n        this._authMethod = (this._auth.method || '').toString().trim().toUpperCase() || false;\n        if (!this._authMethod && this._auth.oauth2 && !this._auth.credentials) {\n            this._authMethod = 'XOAUTH2';\n        } else if (!this._authMethod || (this._authMethod === 'XOAUTH2' && !this._auth.oauth2)) {\n            // use first supported\n            this._authMethod = (this._supportedAuth[0] || 'PLAIN').toUpperCase().trim();\n        }\n\n        if (this._authMethod !== 'XOAUTH2' && !this._auth.credentials) {\n            if (this._auth.user && this._auth.pass) {\n                this._auth.credentials = {\n                    user: this._auth.user,\n                    pass: this._auth.pass\n                };\n            } else {\n                return callback(this._formatError('Missing credentials for \"' + this._authMethod + '\"', 'EAUTH', false, 'API'));\n            }\n        }\n\n        switch (this._authMethod) {\n            case 'XOAUTH2':\n                this._handleXOauth2Token(false, callback);\n                return;\n            case 'LOGIN':\n                this._responseActions.push(str => {\n                    this._actionAUTH_LOGIN_USER(str, callback);\n                });\n                this._sendCommand('AUTH LOGIN');\n                return;\n            case 'PLAIN':\n                this._responseActions.push(str => {\n                    this._actionAUTHComplete(str, callback);\n                });\n                this._sendCommand('AUTH PLAIN ' + new Buffer(\n                    //this._auth.user+'\\u0000'+\n                    '\\u0000' + // skip authorization identity as it causes problems with some servers\n                    this._auth.credentials.user + '\\u0000' +\n                    this._auth.credentials.pass, 'utf-8').toString('base64'));\n                return;\n            case 'CRAM-MD5':\n                this._responseActions.push(str => {\n                    this._actionAUTH_CRAM_MD5(str, callback);\n                });\n                this._sendCommand('AUTH CRAM-MD5');\n                return;\n        }\n\n        return callback(this._formatError('Unknown authentication method \"' + this._authMethod + '\"', 'EAUTH', false, 'API'));\n    }\n\n    /**\n     * Sends a message\n     *\n     * @param {Object} envelope Envelope object, {from: addr, to: [addr]}\n     * @param {Object} message String, Buffer or a Stream\n     * @param {Function} callback Callback to return once sending is completed\n     */\n    send(envelope, message, done) {\n        if (!message) {\n            return done(this._formatError('Empty message', 'EMESSAGE', false, 'API'));\n        }\n\n        // reject larger messages than allowed\n        if (this._maxAllowedSize && envelope.size > this._maxAllowedSize) {\n            return setImmediate(() => {\n                done(this._formatError('Message size larger than allowed ' + this._maxAllowedSize, 'EMESSAGE', false, 'MAIL FROM'));\n            });\n        }\n\n        // ensure that callback is only called once\n        let returned = false;\n        let callback = function () {\n            if (returned) {\n                return;\n            }\n            returned = true;\n\n            done(...arguments);\n        };\n\n        if (typeof message.on === 'function') {\n            message.on('error', err => callback(this._formatError(err, 'ESTREAM', false, 'API')));\n        }\n\n        this._setEnvelope(envelope, (err, info) => {\n            if (err) {\n                return callback(err);\n            }\n            let stream = this._createSendStream((err, str) => {\n                if (err) {\n                    return callback(err);\n                }\n                info.response = str;\n                return callback(null, info);\n            });\n            if (typeof message.pipe === 'function') {\n                message.pipe(stream);\n            } else {\n                stream.write(message);\n                stream.end();\n            }\n\n        });\n    }\n\n    /**\n     * Resets connection state\n     *\n     * @param {Function} callback Callback to return once connection is reset\n     */\n    reset(callback) {\n        this._sendCommand('RSET');\n        this._responseActions.push(str => {\n            if (str.charAt(0) !== '2') {\n                return callback(this._formatError('Could not reset session state:\\n' + str, 'EPROTOCOL', str, 'RSET'));\n            }\n            this._envelope = false;\n            return callback(null, true);\n        });\n    }\n\n    /**\n     * Connection listener that is run when the connection to\n     * the server is opened\n     *\n     * @event\n     */\n    _onConnect() {\n        clearTimeout(this._connectionTimeout);\n\n        this.logger.info({\n            tnx: 'network',\n            localAddress: this._socket.localAddress,\n            localPort: this._socket.localPort,\n            remoteAddress: this._socket.remoteAddress,\n            remotePort: this._socket.remotePort\n        }, '%s established to %s:%s', this.secure ? 'Secure connection' : 'Connection', this._socket.remoteAddress, this._socket.remotePort);\n\n        if (this._destroyed) {\n            // Connection was established after we already had canceled it\n            this.close();\n            return;\n        }\n\n        this.stage = 'connected';\n\n        // clear existing listeners for the socket\n        this._socket.removeAllListeners('data');\n        this._socket.removeAllListeners('timeout');\n        this._socket.removeAllListeners('close');\n        this._socket.removeAllListeners('end');\n\n        this._socket.on('data', chunk => this._onData(chunk));\n        this._socket.once('close', errored => this._onClose(errored));\n        this._socket.once('end', () => this._onEnd());\n\n        this._socket.setTimeout(this.options.socketTimeout || SOCKET_TIMEOUT);\n        this._socket.on('timeout', () => this._onTimeout());\n\n        this._greetingTimeout = setTimeout(() => {\n            // if still waiting for greeting, give up\n            if (this._socket && !this._destroyed && this._responseActions[0] === this._actionGreeting) {\n                this._onError('Greeting never received', 'ETIMEDOUT', false, 'CONN');\n            }\n        }, this.options.greetingTimeout || GREETING_TIMEOUT);\n\n        this._responseActions.push(this._actionGreeting);\n\n        // we have a 'data' listener set up so resume socket if it was paused\n        this._socket.resume();\n    }\n\n    /**\n     * 'data' listener for data coming from the server\n     *\n     * @event\n     * @param {Buffer} chunk Data chunk coming from the server\n     */\n    _onData(chunk) {\n        if (this._destroyed || !chunk || !chunk.length) {\n            return;\n        }\n\n        let data = (chunk || '').toString('binary');\n        let lines = (this._remainder + data).split(/\\r?\\n/);\n        let lastline;\n\n        this._remainder = lines.pop();\n\n        for (let i = 0, len = lines.length; i < len; i++) {\n            if (this._responseQueue.length) {\n                lastline = this._responseQueue[this._responseQueue.length - 1];\n                if (/^\\d+\\-/.test(lastline.split('\\n').pop())) {\n                    this._responseQueue[this._responseQueue.length - 1] += '\\n' + lines[i];\n                    continue;\n                }\n            }\n            this._responseQueue.push(lines[i]);\n        }\n\n        this._processResponse();\n    }\n\n    /**\n     * 'error' listener for the socket\n     *\n     * @event\n     * @param {Error} err Error object\n     * @param {String} type Error name\n     */\n    _onError(err, type, data, command) {\n        clearTimeout(this._connectionTimeout);\n        clearTimeout(this._greetingTimeout);\n\n        if (this._destroyed) {\n            // just ignore, already closed\n            // this might happen when a socket is canceled because of reached timeout\n            // but the socket timeout error itself receives only after\n            return;\n        }\n\n        err = this._formatError(err, type, data, command);\n\n        let entry = {\n            err\n        };\n        if (type) {\n            entry.errorType = type;\n        }\n        if (data) {\n            entry.errorData = data;\n        }\n        if (command) {\n            entry.command = command;\n        }\n\n        this.logger.error(data, err.message);\n\n        this.emit('error', err);\n        this.close();\n    }\n\n    _formatError(message, type, response, command) {\n        let err;\n\n        if (/Error\\]$/i.test(Object.prototype.toString.call(message))) {\n            err = message;\n        } else {\n            err = new Error(message);\n        }\n\n        if (type && type !== 'Error') {\n            err.code = type;\n        }\n\n        if (response) {\n            err.response = response;\n            err.message += ': ' + response;\n        }\n\n        let responseCode = typeof response === 'string' && Number((response.match(/^\\d+/) || [])[0]) || false;\n        if (responseCode) {\n            err.responseCode = responseCode;\n        }\n\n        if (command) {\n            err.command = command;\n        }\n\n        return err;\n    }\n\n    /**\n     * 'close' listener for the socket\n     *\n     * @event\n     */\n    _onClose() {\n        this.logger.info({\n            tnx: 'network'\n        }, 'Connection closed');\n\n        if (this.upgrading && !this._destroyed) {\n            return this._onError(new Error('Connection closed unexpectedly'), 'ETLS', false, 'CONN');\n        } else if (![this._actionGreeting, this.close].includes(this._responseActions[0]) && !this._destroyed) {\n            return this._onError(new Error('Connection closed unexpectedly'), 'ECONNECTION', false, 'CONN');\n        }\n\n        this._destroy();\n    }\n\n    /**\n     * 'end' listener for the socket\n     *\n     * @event\n     */\n    _onEnd() {\n        this._destroy();\n    }\n\n    /**\n     * 'timeout' listener for the socket\n     *\n     * @event\n     */\n    _onTimeout() {\n        return this._onError(new Error('Timeout'), 'ETIMEDOUT', false, 'CONN');\n    }\n\n    /**\n     * Destroys the client, emits 'end'\n     */\n    _destroy() {\n        if (this._destroyed) {\n            return;\n        }\n        this._destroyed = true;\n        this.emit('end');\n    }\n\n    /**\n     * Upgrades the connection to TLS\n     *\n     * @param {Function} callback Callback function to run when the connection\n     *        has been secured\n     */\n    _upgradeConnection(callback) {\n        // do not remove all listeners or it breaks node v0.10 as there's\n        // apparently a 'finish' event set that would be cleared as well\n\n        // we can safely keep 'error', 'end', 'close' etc. events\n        this._socket.removeAllListeners('data'); // incoming data is going to be gibberish from this point onwards\n        this._socket.removeAllListeners('timeout'); // timeout will be re-set for the new socket object\n\n        let socketPlain = this._socket;\n        let opts = {\n            socket: this._socket,\n            host: this.host\n        };\n\n        Object.keys(this.options.tls || {}).forEach(key => {\n            opts[key] = this.options.tls[key];\n        });\n\n        this.upgrading = true;\n        this._socket = tls.connect(opts, () => {\n            this.secure = true;\n            this.upgrading = false;\n            this._socket.on('data', chunk => this._onData(chunk));\n\n            socketPlain.removeAllListeners('close');\n            socketPlain.removeAllListeners('end');\n\n            return callback(null, true);\n        });\n\n        this._socket.on('error', err => this._onError(err, 'ESOCKET', false, 'CONN'));\n        this._socket.once('close', errored => this._onClose(errored));\n        this._socket.once('end', () => this._onEnd());\n\n        this._socket.setTimeout(this.options.socketTimeout || SOCKET_TIMEOUT); // 10 min.\n        this._socket.on('timeout', () => this._onTimeout());\n\n        // resume in case the socket was paused\n        socketPlain.resume();\n    }\n\n    /**\n     * Processes queued responses from the server\n     *\n     * @param {Boolean} force If true, ignores _processing flag\n     */\n    _processResponse() {\n        if (!this._responseQueue.length) {\n            return false;\n        }\n\n        let str = this.lastServerResponse = (this._responseQueue.shift() || '').toString();\n\n        if (/^\\d+\\-/.test(str.split('\\n').pop())) {\n            // keep waiting for the final part of multiline response\n            return;\n        }\n\n        if (this.options.debug || this.options.transactionLog) {\n            this.logger.debug({\n                tnx: 'server'\n            }, str.replace(/\\r?\\n$/, ''));\n        }\n\n        if (!str.trim()) { // skip unexpected empty lines\n            setImmediate(() => this._processResponse(true));\n        }\n\n        let action = this._responseActions.shift();\n\n        if (typeof action === 'function') {\n            action.call(this, str);\n            setImmediate(() => this._processResponse(true));\n        } else {\n            return this._onError(new Error('Unexpected Response'), 'EPROTOCOL', str, 'CONN');\n        }\n    }\n\n    /**\n     * Send a command to the server, append \\r\\n\n     *\n     * @param {String} str String to be sent to the server\n     */\n    _sendCommand(str) {\n        if (this._destroyed) {\n            // Connection already closed, can't send any more data\n            return;\n        }\n\n        if (this._socket.destroyed) {\n            return this.close();\n        }\n\n        if (this.options.debug || this.options.transactionLog) {\n            this.logger.debug({\n                tnx: 'client'\n            }, (str || '').toString().replace(/\\r?\\n$/, ''));\n        }\n\n        this._socket.write(new Buffer(str + '\\r\\n', 'utf-8'));\n    }\n\n    /**\n     * Initiates a new message by submitting envelope data, starting with\n     * MAIL FROM: command\n     *\n     * @param {Object} envelope Envelope object in the form of\n     *        {from:'...', to:['...']}\n     *        or\n     *        {from:{address:'...',name:'...'}, to:[address:'...',name:'...']}\n     */\n    _setEnvelope(envelope, callback) {\n        let args = [];\n        let useSmtpUtf8 = false;\n\n        this._envelope = envelope || {};\n        this._envelope.from = (this._envelope.from && this._envelope.from.address || this._envelope.from || '').toString().trim();\n\n        this._envelope.to = [].concat(this._envelope.to || []).map(to => (to && to.address || to || '').toString().trim());\n\n        if (!this._envelope.to.length) {\n            return callback(this._formatError('No recipients defined', 'EENVELOPE', false, 'API'));\n        }\n\n        if (this._envelope.from && /[\\r\\n<>]/.test(this._envelope.from)) {\n            return callback(this._formatError('Invalid sender ' + JSON.stringify(this._envelope.from), 'EENVELOPE', false, 'API'));\n        }\n\n        // check if the sender address uses only ASCII characters,\n        // otherwise require usage of SMTPUTF8 extension\n        if (/[\\x80-\\uFFFF]/.test(this._envelope.from)) {\n            useSmtpUtf8 = true;\n        }\n\n        for (let i = 0, len = this._envelope.to.length; i < len; i++) {\n            if (!this._envelope.to[i] || /[\\r\\n<>]/.test(this._envelope.to[i])) {\n                return callback(this._formatError('Invalid recipient ' + JSON.stringify(this._envelope.to[i]), 'EENVELOPE', false, 'API'));\n            }\n\n            // check if the recipients addresses use only ASCII characters,\n            // otherwise require usage of SMTPUTF8 extension\n            if (/[\\x80-\\uFFFF]/.test(this._envelope.to[i])) {\n                useSmtpUtf8 = true;\n            }\n        }\n\n        // clone the recipients array for latter manipulation\n        this._envelope.rcptQueue = JSON.parse(JSON.stringify(this._envelope.to || []));\n        this._envelope.rejected = [];\n        this._envelope.rejectedErrors = [];\n        this._envelope.accepted = [];\n\n        if (this._envelope.dsn) {\n            try {\n                this._envelope.dsn = this._setDsnEnvelope(this._envelope.dsn);\n            } catch (err) {\n                return callback(this._formatError('Invalid DSN ' + err.message, 'EENVELOPE', false, 'API'));\n            }\n        }\n\n        this._responseActions.push(str => {\n            this._actionMAIL(str, callback);\n        });\n\n        // If the server supports SMTPUTF8 and the envelope includes an internationalized\n        // email address then append SMTPUTF8 keyword to the MAIL FROM command\n        if (useSmtpUtf8 && this._supportedExtensions.includes('SMTPUTF8')) {\n            args.push('SMTPUTF8');\n            this._usingSmtpUtf8 = true;\n        }\n\n        // If the server supports 8BITMIME and the message might contain non-ascii bytes\n        // then append the 8BITMIME keyword to the MAIL FROM command\n        if (this._envelope.use8BitMime && this._supportedExtensions.includes('8BITMIME')) {\n            args.push('BODY=8BITMIME');\n            this._using8BitMime = true;\n        }\n\n        if (this._envelope.size && this._supportedExtensions.includes('SIZE')) {\n            args.push('SIZE=' + this._envelope.size);\n        }\n\n        // If the server supports DSN and the envelope includes an DSN prop\n        // then append DSN params to the MAIL FROM command\n        if (this._envelope.dsn && this._supportedExtensions.includes('DSN')) {\n            if (this._envelope.dsn.ret) {\n                args.push('RET=' + shared.encodeXText(this._envelope.dsn.ret));\n            }\n            if (this._envelope.dsn.envid) {\n                args.push('ENVID=' + shared.encodeXText(this._envelope.dsn.envid));\n            }\n        }\n\n        this._sendCommand('MAIL FROM:<' + (this._envelope.from) + '>' + (args.length ? ' ' + args.join(' ') : ''));\n    }\n\n    _setDsnEnvelope(params) {\n        let ret = (params.ret || params.return || '').toString().toUpperCase() || null;\n        if (ret) {\n            switch (ret) {\n                case 'HDRS':\n                case 'HEADERS':\n                    ret = 'HDRS';\n                    break;\n                case 'FULL':\n                case 'BODY':\n                    ret = 'full';\n                    break;\n            }\n        }\n\n        if (ret && !['FULL', 'HDRS'].includes(ret)) {\n            throw new Error('ret: ' + JSON.stringify(ret));\n        }\n\n        let envid = (params.envid || params.id || '').toString() || null;\n\n        let notify = params.notify || null;\n        if (notify) {\n            if (typeof notify === 'string') {\n                notify = notify.split(',');\n            }\n            notify = notify.map(n => n.trim().toUpperCase());\n            let validNotify = ['NEVER', 'SUCCESS', 'FAILURE', 'DELAY'];\n            let invaliNotify = notify.filter(n => !validNotify.includes(n));\n            if (invaliNotify.length || (notify.length > 1 && notify.includes('NEVER'))) {\n                throw new Error('notify: ' + JSON.stringify(notify.join(',')));\n            }\n            notify = notify.join(',');\n        }\n\n        let orcpt = (params.orcpt || params.recipient).toString() || null;\n        if (orcpt && orcpt.indexOf(';') < 0) {\n            orcpt = 'rfc822;' + orcpt;\n        }\n\n        return {\n            ret,\n            envid,\n            notify,\n            orcpt\n        };\n    }\n\n    _getDsnRcptToArgs() {\n        let args = [];\n        // If the server supports DSN and the envelope includes an DSN prop\n        // then append DSN params to the RCPT TO command\n        if (this._envelope.dsn && this._supportedExtensions.includes('DSN')) {\n            if (this._envelope.dsn.notify) {\n                args.push('NOTIFY=' + shared.encodeXText(this._envelope.dsn.notify));\n            }\n            if (this._envelope.dsn.orcpt) {\n                args.push('ORCPT=' + shared.encodeXText(this._envelope.dsn.orcpt));\n            }\n        }\n        return (args.length ? ' ' + args.join(' ') : '');\n    }\n\n    _createSendStream(callback) {\n        let dataStream = new DataStream();\n        let logStream;\n\n        if (this.options.lmtp) {\n            this._envelope.accepted.forEach((recipient, i) => {\n                let final = i === this._envelope.accepted.length - 1;\n                this._responseActions.push(str => {\n                    this._actionLMTPStream(recipient, final, str, callback);\n                });\n            });\n        } else {\n            this._responseActions.push(str => {\n                this._actionSMTPStream(str, callback);\n            });\n        }\n\n        dataStream.pipe(this._socket, {\n            end: false\n        });\n\n        if (this.options.debug) {\n            logStream = new PassThrough();\n            logStream.on('readable', () => {\n                let chunk;\n                while ((chunk = logStream.read())) {\n                    this.logger.debug({\n                        tnx: 'message'\n                    }, chunk.toString('binary').replace(/\\r?\\n$/, ''));\n                }\n            });\n            dataStream.pipe(logStream);\n        }\n\n        dataStream.once('end', () => {\n            this.logger.info({\n                tnx: 'message',\n                inByteCount: dataStream.inByteCount,\n                outByteCount: dataStream.outByteCount\n            }, '<%s bytes encoded mime message (source size %s bytes)>', dataStream.outByteCount, dataStream.inByteCount);\n        });\n\n        return dataStream;\n    }\n\n    /** ACTIONS **/\n\n    /**\n     * Will be run after the connection is created and the server sends\n     * a greeting. If the incoming message starts with 220 initiate\n     * SMTP session by sending EHLO command\n     *\n     * @param {String} str Message from the server\n     */\n    _actionGreeting(str) {\n        clearTimeout(this._greetingTimeout);\n\n        if (str.substr(0, 3) !== '220') {\n            this._onError(new Error('Invalid greeting from server:\\n' + str), 'EPROTOCOL', str, 'CONN');\n            return;\n        }\n\n        if (this.options.lmtp) {\n            this._responseActions.push(this._actionLHLO);\n            this._sendCommand('LHLO ' + this.name);\n        } else {\n            this._responseActions.push(this._actionEHLO);\n            this._sendCommand('EHLO ' + this.name);\n        }\n    }\n\n    /**\n     * Handles server response for LHLO command. If it yielded in\n     * error, emit 'error', otherwise treat this as an EHLO response\n     *\n     * @param {String} str Message from the server\n     */\n    _actionLHLO(str) {\n        if (str.charAt(0) !== '2') {\n            this._onError(new Error('Invalid response for LHLO:\\n' + str), 'EPROTOCOL', str, 'LHLO');\n            return;\n        }\n\n        this._actionEHLO(str);\n    }\n\n    /**\n     * Handles server response for EHLO command. If it yielded in\n     * error, try HELO instead, otherwise initiate TLS negotiation\n     * if STARTTLS is supported by the server or move into the\n     * authentication phase.\n     *\n     * @param {String} str Message from the server\n     */\n    _actionEHLO(str) {\n        let match;\n\n        if (str.substr(0, 3) === '421') {\n            this._onError(new Error('Server terminates connection:\\n' + str), 'ECONNECTION', str, 'EHLO');\n            return;\n        }\n\n        if (str.charAt(0) !== '2') {\n            if (this.options.requireTLS) {\n                this._onError(new Error('EHLO failed but HELO does not support required STARTTLS:\\n' + str), 'ECONNECTION', str, 'EHLO');\n                return;\n            }\n\n            // Try HELO instead\n            this._responseActions.push(this._actionHELO);\n            this._sendCommand('HELO ' + this.name);\n            return;\n        }\n\n        // Detect if the server supports STARTTLS\n        if (!this.secure && !this.options.ignoreTLS && (/[ \\-]STARTTLS\\b/mi.test(str) || this.options.requireTLS)) {\n            this._sendCommand('STARTTLS');\n            this._responseActions.push(this._actionSTARTTLS);\n            return;\n        }\n\n        // Detect if the server supports SMTPUTF8\n        if (/[ \\-]SMTPUTF8\\b/mi.test(str)) {\n            this._supportedExtensions.push('SMTPUTF8');\n        }\n\n        // Detect if the server supports DSN\n        if (/[ \\-]DSN\\b/mi.test(str)) {\n            this._supportedExtensions.push('DSN');\n        }\n\n        // Detect if the server supports 8BITMIME\n        if (/[ \\-]8BITMIME\\b/mi.test(str)) {\n            this._supportedExtensions.push('8BITMIME');\n        }\n\n        // Detect if the server supports PIPELINING\n        if (/[ \\-]PIPELINING\\b/mi.test(str)) {\n            this._supportedExtensions.push('PIPELINING');\n        }\n\n        // Detect if the server supports PLAIN auth\n        if (/AUTH(?:(\\s+|=)[^\\n]*\\s+|\\s+|=)PLAIN/i.test(str)) {\n            this._supportedAuth.push('PLAIN');\n        }\n\n        // Detect if the server supports LOGIN auth\n        if (/AUTH(?:(\\s+|=)[^\\n]*\\s+|\\s+|=)LOGIN/i.test(str)) {\n            this._supportedAuth.push('LOGIN');\n        }\n\n        // Detect if the server supports CRAM-MD5 auth\n        if (/AUTH(?:(\\s+|=)[^\\n]*\\s+|\\s+|=)CRAM-MD5/i.test(str)) {\n            this._supportedAuth.push('CRAM-MD5');\n        }\n\n        // Detect if the server supports XOAUTH2 auth\n        if (/AUTH(?:(\\s+|=)[^\\n]*\\s+|\\s+|=)XOAUTH2/i.test(str)) {\n            this._supportedAuth.push('XOAUTH2');\n        }\n\n        // Detect if the server supports SIZE extensions (and the max allowed size)\n        if ((match = str.match(/[ \\-]SIZE(?:[ \\t]+(\\d+))?/mi))) {\n            this._supportedExtensions.push('SIZE');\n            this._maxAllowedSize = Number(match[1]) || 0;\n        }\n\n        this.emit('connect');\n    }\n\n    /**\n     * Handles server response for HELO command. If it yielded in\n     * error, emit 'error', otherwise move into the authentication phase.\n     *\n     * @param {String} str Message from the server\n     */\n    _actionHELO(str) {\n        if (str.charAt(0) !== '2') {\n            this._onError(new Error('Invalid response for EHLO/HELO:\\n' + str), 'EPROTOCOL', str, 'HELO');\n            return;\n        }\n\n        this.emit('connect');\n    }\n\n    /**\n     * Handles server response for STARTTLS command. If there's an error\n     * try HELO instead, otherwise initiate TLS upgrade. If the upgrade\n     * succeedes restart the EHLO\n     *\n     * @param {String} str Message from the server\n     */\n    _actionSTARTTLS(str) {\n        if (str.charAt(0) !== '2') {\n            if (this.options.opportunisticTLS) {\n                this.logger.info({\n                    tnx: 'smtp'\n                }, 'Failed STARTTLS upgrade, continuing unencrypted');\n                return this.emit('connect');\n            }\n            this._onError(new Error('Error upgrading connection with STARTTLS'), 'ETLS', str, 'STARTTLS');\n            return;\n        }\n\n        this._upgradeConnection((err, secured) => {\n            if (err) {\n                this._onError(new Error('Error initiating TLS - ' + (err.message || err)), 'ETLS', false, 'STARTTLS');\n                return;\n            }\n\n            this.logger.info({\n                tnx: 'smtp'\n            }, 'Connection upgraded with STARTTLS');\n\n            if (secured) {\n                // restart session\n                this._responseActions.push(this._actionEHLO);\n                this._sendCommand('EHLO ' + this.name);\n            } else {\n                this.emit('connect');\n            }\n        });\n    }\n\n    /**\n     * Handle the response for AUTH LOGIN command. We are expecting\n     * '334 VXNlcm5hbWU6' (base64 for 'Username:'). Data to be sent as\n     * response needs to be base64 encoded username. We do not need\n     * exact match but settle with 334 response in general as some\n     * hosts invalidly use a longer message than VXNlcm5hbWU6\n     *\n     * @param {String} str Message from the server\n     */\n    _actionAUTH_LOGIN_USER(str, callback) {\n        if (!/^334[ \\-]/.test(str)) { // expecting '334 VXNlcm5hbWU6'\n            callback(this._formatError('Invalid login sequence while waiting for \"334 VXNlcm5hbWU6\"', 'EAUTH', str, 'AUTH LOGIN'));\n            return;\n        }\n\n        this._responseActions.push(str => {\n            this._actionAUTH_LOGIN_PASS(str, callback);\n        });\n\n        this._sendCommand(new Buffer(this._auth.credentials.user + '', 'utf-8').toString('base64'));\n    }\n\n    /**\n     * Handle the response for AUTH CRAM-MD5 command. We are expecting\n     * '334 <challenge string>'. Data to be sent as response needs to be\n     * base64 decoded challenge string, MD5 hashed using the password as\n     * a HMAC key, prefixed by the username and a space, and finally all\n     * base64 encoded again.\n     *\n     * @param {String} str Message from the server\n     */\n    _actionAUTH_CRAM_MD5(str, callback) {\n        let challengeMatch = str.match(/^334\\s+(.+)$/);\n        let challengeString = '';\n\n        if (!challengeMatch) {\n            return callback(this._formatError('Invalid login sequence while waiting for server challenge string', 'EAUTH', str, 'AUTH CRAM-MD5'));\n        } else {\n            challengeString = challengeMatch[1];\n        }\n\n        // Decode from base64\n        let base64decoded = new Buffer(challengeString, 'base64').toString('ascii'),\n            hmac_md5 = crypto.createHmac('md5', this._auth.credentials.pass);\n\n        hmac_md5.update(base64decoded);\n\n        let hex_hmac = hmac_md5.digest('hex');\n        let prepended = this._auth.credentials.user + ' ' + hex_hmac;\n\n        this._responseActions.push(str => {\n            this._actionAUTH_CRAM_MD5_PASS(str, callback);\n        });\n\n\n        this._sendCommand(new Buffer(prepended).toString('base64'));\n    }\n\n    /**\n     * Handles the response to CRAM-MD5 authentication, if there's no error,\n     * the user can be considered logged in. Start waiting for a message to send\n     *\n     * @param {String} str Message from the server\n     */\n    _actionAUTH_CRAM_MD5_PASS(str, callback) {\n        if (!str.match(/^235\\s+/)) {\n            return callback(this._formatError('Invalid login sequence while waiting for \"235\"', 'EAUTH', str, 'AUTH CRAM-MD5'));\n        }\n\n        this.logger.info({\n            tnx: 'smtp',\n            username: this._auth.user,\n            action: 'authenticated',\n            method: this._authMethod\n        }, 'User %s authenticated', JSON.stringify(this._auth.user));\n        this.authenticated = true;\n        callback(null, true);\n    }\n\n    /**\n     * Handle the response for AUTH LOGIN command. We are expecting\n     * '334 UGFzc3dvcmQ6' (base64 for 'Password:'). Data to be sent as\n     * response needs to be base64 encoded password.\n     *\n     * @param {String} str Message from the server\n     */\n    _actionAUTH_LOGIN_PASS(str, callback) {\n        if (!/^334[ \\-]/.test(str)) { // expecting '334 UGFzc3dvcmQ6'\n            return callback(this._formatError('Invalid login sequence while waiting for \"334 UGFzc3dvcmQ6\"', 'EAUTH', str, 'AUTH LOGIN'));\n        }\n\n        this._responseActions.push(str => {\n            this._actionAUTHComplete(str, callback);\n        });\n\n        this._sendCommand(new Buffer(this._auth.credentials.pass + '', 'utf-8').toString('base64'));\n    }\n\n    /**\n     * Handles the response for authentication, if there's no error,\n     * the user can be considered logged in. Start waiting for a message to send\n     *\n     * @param {String} str Message from the server\n     */\n    _actionAUTHComplete(str, isRetry, callback) {\n        if (!callback && typeof isRetry === 'function') {\n            callback = isRetry;\n            isRetry = false;\n        }\n\n        if (str.substr(0, 3) === '334') {\n            this._responseActions.push(str => {\n                if (isRetry || this._authMethod !== 'XOAUTH2') {\n                    this._actionAUTHComplete(str, true, callback);\n                } else {\n                    // fetch a new OAuth2 access token\n                    setImmediate(() => this._handleXOauth2Token(true, callback));\n                }\n            });\n            this._sendCommand('');\n            return;\n        }\n\n        if (str.charAt(0) !== '2') {\n            this.logger.info({\n                tnx: 'smtp',\n                username: this._auth.user,\n                action: 'authfail',\n                method: this._authMethod\n            }, 'User %s failed to authenticate', JSON.stringify(this._auth.user));\n            return callback(this._formatError('Invalid login', 'EAUTH', str, 'AUTH ' + this._authMethod));\n        }\n\n        this.logger.info({\n            tnx: 'smtp',\n            username: this._auth.user,\n            action: 'authenticated',\n            method: this._authMethod\n        }, 'User %s authenticated', JSON.stringify(this._auth.user));\n        this.authenticated = true;\n        callback(null, true);\n    }\n\n    /**\n     * Handle response for a MAIL FROM: command\n     *\n     * @param {String} str Message from the server\n     */\n    _actionMAIL(str, callback) {\n        let message, curRecipient;\n        if (Number(str.charAt(0)) !== 2) {\n            if (this._usingSmtpUtf8 && /^550 /.test(str) && /[\\x80-\\uFFFF]/.test(this._envelope.from)) {\n                message = 'Internationalized mailbox name not allowed';\n            } else {\n                message = 'Mail command failed';\n            }\n            return callback(this._formatError(message, 'EENVELOPE', str, 'MAIL FROM'));\n        }\n\n        if (!this._envelope.rcptQueue.length) {\n            return callback(this._formatError('Can\\'t send mail - no recipients defined', 'EENVELOPE', false, 'API'));\n        } else {\n            this._recipientQueue = [];\n\n            if (this._supportedExtensions.includes('PIPELINING')) {\n                while (this._envelope.rcptQueue.length) {\n                    curRecipient = this._envelope.rcptQueue.shift();\n                    this._recipientQueue.push(curRecipient);\n                    this._responseActions.push(str => {\n                        this._actionRCPT(str, callback);\n                    });\n                    this._sendCommand('RCPT TO:<' + curRecipient + '>' + this._getDsnRcptToArgs());\n                }\n            } else {\n                curRecipient = this._envelope.rcptQueue.shift();\n                this._recipientQueue.push(curRecipient);\n                this._responseActions.push(str => {\n                    this._actionRCPT(str, callback);\n                });\n                this._sendCommand('RCPT TO:<' + curRecipient + '>' + this._getDsnRcptToArgs());\n            }\n        }\n    }\n\n    /**\n     * Handle response for a RCPT TO: command\n     *\n     * @param {String} str Message from the server\n     */\n    _actionRCPT(str, callback) {\n        let message, err, curRecipient = this._recipientQueue.shift();\n        if (Number(str.charAt(0)) !== 2) {\n            // this is a soft error\n            if (this._usingSmtpUtf8 && /^553 /.test(str) && /[\\x80-\\uFFFF]/.test(curRecipient)) {\n                message = 'Internationalized mailbox name not allowed';\n            } else {\n                message = 'Recipient command failed';\n            }\n            this._envelope.rejected.push(curRecipient);\n            // store error for the failed recipient\n            err = this._formatError(message, 'EENVELOPE', str, 'RCPT TO');\n            err.recipient = curRecipient;\n            this._envelope.rejectedErrors.push(err);\n        } else {\n            this._envelope.accepted.push(curRecipient);\n        }\n\n        if (!this._envelope.rcptQueue.length && !this._recipientQueue.length) {\n            if (this._envelope.rejected.length < this._envelope.to.length) {\n                this._responseActions.push(str => {\n                    this._actionDATA(str, callback);\n                });\n                this._sendCommand('DATA');\n            } else {\n                err = this._formatError('Can\\'t send mail - all recipients were rejected', 'EENVELOPE', str, 'RCPT TO');\n                err.rejected = this._envelope.rejected;\n                err.rejectedErrors = this._envelope.rejectedErrors;\n                return callback(err);\n            }\n        } else if (this._envelope.rcptQueue.length) {\n            curRecipient = this._envelope.rcptQueue.shift();\n            this._recipientQueue.push(curRecipient);\n            this._responseActions.push(str => {\n                this._actionRCPT(str, callback);\n            });\n            this._sendCommand('RCPT TO:<' + curRecipient + '>' + this._getDsnRcptToArgs());\n        }\n    }\n\n    /**\n     * Handle response for a DATA command\n     *\n     * @param {String} str Message from the server\n     */\n    _actionDATA(str, callback) {\n        // response should be 354 but according to this issue https://github.com/eleith/emailjs/issues/24\n        // some servers might use 250 instead, so lets check for 2 or 3 as the first digit\n        if (!/^[23]/.test(str)) {\n            return callback(this._formatError('Data command failed', 'EENVELOPE', str, 'DATA'));\n        }\n\n        let response = {\n            accepted: this._envelope.accepted,\n            rejected: this._envelope.rejected\n        };\n\n        if (this._envelope.rejectedErrors.length) {\n            response.rejectedErrors = this._envelope.rejectedErrors;\n        }\n\n        callback(null, response);\n    }\n\n    /**\n     * Handle response for a DATA stream when using SMTP\n     * We expect a single response that defines if the sending succeeded or failed\n     *\n     * @param {String} str Message from the server\n     */\n    _actionSMTPStream(str, callback) {\n        if (Number(str.charAt(0)) !== 2) {\n            // Message failed\n            return callback(this._formatError('Message failed', 'EMESSAGE', str, 'DATA'));\n        } else {\n            // Message sent succesfully\n            return callback(null, str);\n        }\n    }\n\n    /**\n     * Handle response for a DATA stream\n     * We expect a separate response for every recipient. All recipients can either\n     * succeed or fail separately\n     *\n     * @param {String} recipient The recipient this response applies to\n     * @param {Boolean} final Is this the final recipient?\n     * @param {String} str Message from the server\n     */\n    _actionLMTPStream(recipient, final, str, callback) {\n        let err;\n        if (Number(str.charAt(0)) !== 2) {\n            // Message failed\n            err = this._formatError('Message failed for recipient ' + recipient, 'EMESSAGE', str, 'DATA');\n            err.recipient = recipient;\n            this._envelope.rejected.push(recipient);\n            this._envelope.rejectedErrors.push(err);\n            for (let i = 0, len = this._envelope.accepted.length; i < len; i++) {\n                if (this._envelope.accepted[i] === recipient) {\n                    this._envelope.accepted.splice(i, 1);\n                }\n            }\n        }\n        if (final) {\n            return callback(null, str);\n        }\n    }\n\n    _handleXOauth2Token(isRetry, callback) {\n        this._auth.oauth2.getToken(isRetry, (err, accessToken) => {\n            if (err) {\n                this.logger.info({\n                    tnx: 'smtp',\n                    username: this._auth.user,\n                    action: 'authfail',\n                    method: this._authMethod\n                }, 'User %s failed to authenticate', JSON.stringify(this._auth.user));\n                return callback(this._formatError(err, 'EAUTH', false, 'AUTH XOAUTH2'));\n            }\n            this._responseActions.push(str => {\n                this._actionAUTHComplete(str, isRetry, callback);\n            });\n            this._sendCommand('AUTH XOAUTH2 ' + this._auth.oauth2.buildXOAuth2Token(accessToken));\n        });\n    }\n\n    _getHostname() {\n        // defaul hostname is machine hostname or [IP]\n        let defaultHostname = os.hostname() || '';\n\n        // ignore if not FQDN\n        if (defaultHostname.indexOf('.') < 0) {\n            defaultHostname = '[127.0.0.1]';\n        }\n\n        // IP should be enclosed in []\n        if (defaultHostname.match(/^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$/)) {\n            defaultHostname = '[' + defaultHostname + ']';\n        }\n\n        return defaultHostname;\n    }\n}\n\nmodule.exports = SMTPConnection;\n"]},"metadata":{},"sourceType":"script"}