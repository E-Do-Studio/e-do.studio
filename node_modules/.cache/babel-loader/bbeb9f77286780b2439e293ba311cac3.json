{"ast":null,"code":"import { Vector2, Matrix4 } from \"three\";\nvar SSAOShader = {\n  defines: {\n    PERSPECTIVE_CAMERA: 1,\n    KERNEL_SIZE: 32\n  },\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    tNormal: {\n      value: null\n    },\n    tDepth: {\n      value: null\n    },\n    tNoise: {\n      value: null\n    },\n    kernel: {\n      value: null\n    },\n    cameraNear: {\n      value: null\n    },\n    cameraFar: {\n      value: null\n    },\n    resolution: {\n      value: /* @__PURE__ */new Vector2()\n    },\n    cameraProjectionMatrix: {\n      value: /* @__PURE__ */new Matrix4()\n    },\n    cameraInverseProjectionMatrix: {\n      value: /* @__PURE__ */new Matrix4()\n    },\n    kernelRadius: {\n      value: 8\n    },\n    minDistance: {\n      value: 5e-3\n    },\n    maxDistance: {\n      value: 0.05\n    }\n  },\n  vertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"\tvUv = uv;\", \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n  fragmentShader: [\"uniform sampler2D tDiffuse;\", \"uniform sampler2D tNormal;\", \"uniform sampler2D tDepth;\", \"uniform sampler2D tNoise;\", \"uniform vec3 kernel[ KERNEL_SIZE ];\", \"uniform vec2 resolution;\", \"uniform float cameraNear;\", \"uniform float cameraFar;\", \"uniform mat4 cameraProjectionMatrix;\", \"uniform mat4 cameraInverseProjectionMatrix;\", \"uniform float kernelRadius;\", \"uniform float minDistance;\", // avoid artifacts caused by neighbour fragments with minimal depth difference\n  \"uniform float maxDistance;\", // avoid the influence of fragments which are too far away\n  \"varying vec2 vUv;\", \"#include <packing>\", \"float getDepth( const in vec2 screenPosition ) {\", \"\treturn texture2D( tDepth, screenPosition ).x;\", \"}\", \"float getLinearDepth( const in vec2 screenPosition ) {\", \"\t#if PERSPECTIVE_CAMERA == 1\", \"\t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;\", \"\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\", \"\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\", \"\t#else\", \"\t\treturn texture2D( tDepth, screenPosition ).x;\", \"\t#endif\", \"}\", \"float getViewZ( const in float depth ) {\", \"\t#if PERSPECTIVE_CAMERA == 1\", \"\t\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\", \"\t#else\", \"\t\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\", \"\t#endif\", \"}\", \"vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {\", \"\tfloat clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];\", \"\tvec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );\", \"\tclipPosition *= clipW; // unprojection.\", \"\treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;\", \"}\", \"vec3 getViewNormal( const in vec2 screenPosition ) {\", \"\treturn unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );\", \"}\", \"void main() {\", \"\tfloat depth = getDepth( vUv );\", \"\tfloat viewZ = getViewZ( depth );\", \"\tvec3 viewPosition = getViewPosition( vUv, depth, viewZ );\", \"\tvec3 viewNormal = getViewNormal( vUv );\", \" vec2 noiseScale = vec2( resolution.x / 4.0, resolution.y / 4.0 );\", \"\tvec3 random = texture2D( tNoise, vUv * noiseScale ).xyz;\", // compute matrix used to reorient a kernel vector\n  \"\tvec3 tangent = normalize( random - viewNormal * dot( random, viewNormal ) );\", \"\tvec3 bitangent = cross( viewNormal, tangent );\", \"\tmat3 kernelMatrix = mat3( tangent, bitangent, viewNormal );\", \" float occlusion = 0.0;\", \" for ( int i = 0; i < KERNEL_SIZE; i ++ ) {\", \"\t\tvec3 sampleVector = kernelMatrix * kernel[ i ];\", // reorient sample vector in view space\n  \"\t\tvec3 samplePoint = viewPosition + ( sampleVector * kernelRadius );\", // calculate sample point\n  \"\t\tvec4 samplePointNDC = cameraProjectionMatrix * vec4( samplePoint, 1.0 );\", // project point and calculate NDC\n  \"\t\tsamplePointNDC /= samplePointNDC.w;\", \"\t\tvec2 samplePointUv = samplePointNDC.xy * 0.5 + 0.5;\", // compute uv coordinates\n  \"\t\tfloat realDepth = getLinearDepth( samplePointUv );\", // get linear depth from depth texture\n  \"\t\tfloat sampleDepth = viewZToOrthographicDepth( samplePoint.z, cameraNear, cameraFar );\", // compute linear depth of the sample view Z value\n  \"\t\tfloat delta = sampleDepth - realDepth;\", \"\t\tif ( delta > minDistance && delta < maxDistance ) {\", // if fragment is before sample point, increase occlusion\n  \"\t\t\tocclusion += 1.0;\", \"\t\t}\", \"\t}\", \"\tocclusion = clamp( occlusion / float( KERNEL_SIZE ), 0.0, 1.0 );\", \"\tgl_FragColor = vec4( vec3( 1.0 - occlusion ), 1.0 );\", \"}\"].join(\"\\n\")\n};\nvar SSAODepthShader = {\n  defines: {\n    PERSPECTIVE_CAMERA: 1\n  },\n  uniforms: {\n    tDepth: {\n      value: null\n    },\n    cameraNear: {\n      value: null\n    },\n    cameraFar: {\n      value: null\n    }\n  },\n  vertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"\tvUv = uv;\", \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n  fragmentShader: [\"uniform sampler2D tDepth;\", \"uniform float cameraNear;\", \"uniform float cameraFar;\", \"varying vec2 vUv;\", \"#include <packing>\", \"float getLinearDepth( const in vec2 screenPosition ) {\", \"\t#if PERSPECTIVE_CAMERA == 1\", \"\t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;\", \"\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\", \"\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\", \"\t#else\", \"\t\treturn texture2D( tDepth, screenPosition ).x;\", \"\t#endif\", \"}\", \"void main() {\", \"\tfloat depth = getLinearDepth( vUv );\", \"\tgl_FragColor = vec4( vec3( 1.0 - depth ), 1.0 );\", \"}\"].join(\"\\n\")\n};\nvar SSAOBlurShader = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    resolution: {\n      value: /* @__PURE__ */new Vector2()\n    }\n  },\n  vertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"\tvUv = uv;\", \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n  fragmentShader: [\"uniform sampler2D tDiffuse;\", \"uniform vec2 resolution;\", \"varying vec2 vUv;\", \"void main() {\", \"\tvec2 texelSize = ( 1.0 / resolution );\", \"\tfloat result = 0.0;\", \"\tfor ( int i = - 2; i <= 2; i ++ ) {\", \"\t\tfor ( int j = - 2; j <= 2; j ++ ) {\", \"\t\t\tvec2 offset = ( vec2( float( i ), float( j ) ) ) * texelSize;\", \"\t\t\tresult += texture2D( tDiffuse, vUv + offset ).r;\", \"\t\t}\", \"\t}\", \"\tgl_FragColor = vec4( vec3( result / ( 5.0 * 5.0 ) ), 1.0 );\", \"}\"].join(\"\\n\")\n};\nexport { SSAOBlurShader, SSAODepthShader, SSAOShader };","map":{"version":3,"sources":["/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/three-stdlib/shaders/SSAOShader.js"],"names":["Vector2","Matrix4","SSAOShader","defines","PERSPECTIVE_CAMERA","KERNEL_SIZE","uniforms","tDiffuse","value","tNormal","tDepth","tNoise","kernel","cameraNear","cameraFar","resolution","cameraProjectionMatrix","cameraInverseProjectionMatrix","kernelRadius","minDistance","maxDistance","vertexShader","join","fragmentShader","SSAODepthShader","SSAOBlurShader"],"mappings":"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","sourcesContent":["import { Vector2, Matrix4 } from \"three\";\nconst SSAOShader = {\n  defines: {\n    PERSPECTIVE_CAMERA: 1,\n    KERNEL_SIZE: 32\n  },\n  uniforms: {\n    tDiffuse: { value: null },\n    tNormal: { value: null },\n    tDepth: { value: null },\n    tNoise: { value: null },\n    kernel: { value: null },\n    cameraNear: { value: null },\n    cameraFar: { value: null },\n    resolution: { value: /* @__PURE__ */ new Vector2() },\n    cameraProjectionMatrix: { value: /* @__PURE__ */ new Matrix4() },\n    cameraInverseProjectionMatrix: { value: /* @__PURE__ */ new Matrix4() },\n    kernelRadius: { value: 8 },\n    minDistance: { value: 5e-3 },\n    maxDistance: { value: 0.05 }\n  },\n  vertexShader: [\n    \"varying vec2 vUv;\",\n    \"void main() {\",\n    \"\tvUv = uv;\",\n    \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n    \"}\"\n  ].join(\"\\n\"),\n  fragmentShader: [\n    \"uniform sampler2D tDiffuse;\",\n    \"uniform sampler2D tNormal;\",\n    \"uniform sampler2D tDepth;\",\n    \"uniform sampler2D tNoise;\",\n    \"uniform vec3 kernel[ KERNEL_SIZE ];\",\n    \"uniform vec2 resolution;\",\n    \"uniform float cameraNear;\",\n    \"uniform float cameraFar;\",\n    \"uniform mat4 cameraProjectionMatrix;\",\n    \"uniform mat4 cameraInverseProjectionMatrix;\",\n    \"uniform float kernelRadius;\",\n    \"uniform float minDistance;\",\n    // avoid artifacts caused by neighbour fragments with minimal depth difference\n    \"uniform float maxDistance;\",\n    // avoid the influence of fragments which are too far away\n    \"varying vec2 vUv;\",\n    \"#include <packing>\",\n    \"float getDepth( const in vec2 screenPosition ) {\",\n    \"\treturn texture2D( tDepth, screenPosition ).x;\",\n    \"}\",\n    \"float getLinearDepth( const in vec2 screenPosition ) {\",\n    \"\t#if PERSPECTIVE_CAMERA == 1\",\n    \"\t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;\",\n    \"\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\",\n    \"\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\",\n    \"\t#else\",\n    \"\t\treturn texture2D( tDepth, screenPosition ).x;\",\n    \"\t#endif\",\n    \"}\",\n    \"float getViewZ( const in float depth ) {\",\n    \"\t#if PERSPECTIVE_CAMERA == 1\",\n    \"\t\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\",\n    \"\t#else\",\n    \"\t\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\",\n    \"\t#endif\",\n    \"}\",\n    \"vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {\",\n    \"\tfloat clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];\",\n    \"\tvec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );\",\n    \"\tclipPosition *= clipW; // unprojection.\",\n    \"\treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;\",\n    \"}\",\n    \"vec3 getViewNormal( const in vec2 screenPosition ) {\",\n    \"\treturn unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );\",\n    \"}\",\n    \"void main() {\",\n    \"\tfloat depth = getDepth( vUv );\",\n    \"\tfloat viewZ = getViewZ( depth );\",\n    \"\tvec3 viewPosition = getViewPosition( vUv, depth, viewZ );\",\n    \"\tvec3 viewNormal = getViewNormal( vUv );\",\n    \" vec2 noiseScale = vec2( resolution.x / 4.0, resolution.y / 4.0 );\",\n    \"\tvec3 random = texture2D( tNoise, vUv * noiseScale ).xyz;\",\n    // compute matrix used to reorient a kernel vector\n    \"\tvec3 tangent = normalize( random - viewNormal * dot( random, viewNormal ) );\",\n    \"\tvec3 bitangent = cross( viewNormal, tangent );\",\n    \"\tmat3 kernelMatrix = mat3( tangent, bitangent, viewNormal );\",\n    \" float occlusion = 0.0;\",\n    \" for ( int i = 0; i < KERNEL_SIZE; i ++ ) {\",\n    \"\t\tvec3 sampleVector = kernelMatrix * kernel[ i ];\",\n    // reorient sample vector in view space\n    \"\t\tvec3 samplePoint = viewPosition + ( sampleVector * kernelRadius );\",\n    // calculate sample point\n    \"\t\tvec4 samplePointNDC = cameraProjectionMatrix * vec4( samplePoint, 1.0 );\",\n    // project point and calculate NDC\n    \"\t\tsamplePointNDC /= samplePointNDC.w;\",\n    \"\t\tvec2 samplePointUv = samplePointNDC.xy * 0.5 + 0.5;\",\n    // compute uv coordinates\n    \"\t\tfloat realDepth = getLinearDepth( samplePointUv );\",\n    // get linear depth from depth texture\n    \"\t\tfloat sampleDepth = viewZToOrthographicDepth( samplePoint.z, cameraNear, cameraFar );\",\n    // compute linear depth of the sample view Z value\n    \"\t\tfloat delta = sampleDepth - realDepth;\",\n    \"\t\tif ( delta > minDistance && delta < maxDistance ) {\",\n    // if fragment is before sample point, increase occlusion\n    \"\t\t\tocclusion += 1.0;\",\n    \"\t\t}\",\n    \"\t}\",\n    \"\tocclusion = clamp( occlusion / float( KERNEL_SIZE ), 0.0, 1.0 );\",\n    \"\tgl_FragColor = vec4( vec3( 1.0 - occlusion ), 1.0 );\",\n    \"}\"\n  ].join(\"\\n\")\n};\nconst SSAODepthShader = {\n  defines: {\n    PERSPECTIVE_CAMERA: 1\n  },\n  uniforms: {\n    tDepth: { value: null },\n    cameraNear: { value: null },\n    cameraFar: { value: null }\n  },\n  vertexShader: [\n    \"varying vec2 vUv;\",\n    \"void main() {\",\n    \"\tvUv = uv;\",\n    \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n    \"}\"\n  ].join(\"\\n\"),\n  fragmentShader: [\n    \"uniform sampler2D tDepth;\",\n    \"uniform float cameraNear;\",\n    \"uniform float cameraFar;\",\n    \"varying vec2 vUv;\",\n    \"#include <packing>\",\n    \"float getLinearDepth( const in vec2 screenPosition ) {\",\n    \"\t#if PERSPECTIVE_CAMERA == 1\",\n    \"\t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;\",\n    \"\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\",\n    \"\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\",\n    \"\t#else\",\n    \"\t\treturn texture2D( tDepth, screenPosition ).x;\",\n    \"\t#endif\",\n    \"}\",\n    \"void main() {\",\n    \"\tfloat depth = getLinearDepth( vUv );\",\n    \"\tgl_FragColor = vec4( vec3( 1.0 - depth ), 1.0 );\",\n    \"}\"\n  ].join(\"\\n\")\n};\nconst SSAOBlurShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    resolution: { value: /* @__PURE__ */ new Vector2() }\n  },\n  vertexShader: [\n    \"varying vec2 vUv;\",\n    \"void main() {\",\n    \"\tvUv = uv;\",\n    \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n    \"}\"\n  ].join(\"\\n\"),\n  fragmentShader: [\n    \"uniform sampler2D tDiffuse;\",\n    \"uniform vec2 resolution;\",\n    \"varying vec2 vUv;\",\n    \"void main() {\",\n    \"\tvec2 texelSize = ( 1.0 / resolution );\",\n    \"\tfloat result = 0.0;\",\n    \"\tfor ( int i = - 2; i <= 2; i ++ ) {\",\n    \"\t\tfor ( int j = - 2; j <= 2; j ++ ) {\",\n    \"\t\t\tvec2 offset = ( vec2( float( i ), float( j ) ) ) * texelSize;\",\n    \"\t\t\tresult += texture2D( tDiffuse, vUv + offset ).r;\",\n    \"\t\t}\",\n    \"\t}\",\n    \"\tgl_FragColor = vec4( vec3( result / ( 5.0 * 5.0 ) ), 1.0 );\",\n    \"}\"\n  ].join(\"\\n\")\n};\nexport {\n  SSAOBlurShader,\n  SSAODepthShader,\n  SSAOShader\n};\n"]},"metadata":{},"sourceType":"module"}