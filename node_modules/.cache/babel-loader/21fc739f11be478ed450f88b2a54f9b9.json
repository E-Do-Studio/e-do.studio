{"ast":null,"code":"import { Vector2 } from \"three\";\nvar BokehShader2 = {\n  uniforms: {\n    textureWidth: {\n      value: 1\n    },\n    textureHeight: {\n      value: 1\n    },\n    focalDepth: {\n      value: 1\n    },\n    focalLength: {\n      value: 24\n    },\n    fstop: {\n      value: 0.9\n    },\n    tColor: {\n      value: null\n    },\n    tDepth: {\n      value: null\n    },\n    maxblur: {\n      value: 1\n    },\n    showFocus: {\n      value: 0\n    },\n    manualdof: {\n      value: 0\n    },\n    vignetting: {\n      value: 0\n    },\n    depthblur: {\n      value: 0\n    },\n    threshold: {\n      value: 0.5\n    },\n    gain: {\n      value: 2\n    },\n    bias: {\n      value: 0.5\n    },\n    fringe: {\n      value: 0.7\n    },\n    znear: {\n      value: 0.1\n    },\n    zfar: {\n      value: 100\n    },\n    noise: {\n      value: 1\n    },\n    dithering: {\n      value: 1e-4\n    },\n    pentagon: {\n      value: 0\n    },\n    shaderFocus: {\n      value: 1\n    },\n    focusCoords: {\n      value: /* @__PURE__ */new Vector2()\n    }\n  },\n  vertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"\tvUv = uv;\", \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n  fragmentShader: [\"#include <common>\", \"varying vec2 vUv;\", \"uniform sampler2D tColor;\", \"uniform sampler2D tDepth;\", \"uniform float textureWidth;\", \"uniform float textureHeight;\", \"uniform float focalDepth;  //focal distance value in meters, but you may use autofocus option below\", \"uniform float focalLength; //focal length in mm\", \"uniform float fstop; //f-stop value\", \"uniform bool showFocus; //show debug focus point and focal range (red = focal point, green = focal range)\", \"/*\", \"make sure that these two values are the same for your camera, otherwise distances will be wrong.\", \"*/\", \"uniform float znear; // camera clipping start\", \"uniform float zfar; // camera clipping end\", \"//------------------------------------------\", \"//user variables\", \"const int samples = SAMPLES; //samples on the first ring\", \"const int rings = RINGS; //ring count\", \"const int maxringsamples = rings * samples;\", \"uniform bool manualdof; // manual dof calculation\", \"float ndofstart = 1.0; // near dof blur start\", \"float ndofdist = 2.0; // near dof blur falloff distance\", \"float fdofstart = 1.0; // far dof blur start\", \"float fdofdist = 3.0; // far dof blur falloff distance\", \"float CoC = 0.03; //circle of confusion size in mm (35mm film = 0.03mm)\", \"uniform bool vignetting; // use optical lens vignetting\", \"float vignout = 1.3; // vignetting outer border\", \"float vignin = 0.0; // vignetting inner border\", \"float vignfade = 22.0; // f-stops till vignete fades\", \"uniform bool shaderFocus;\", \"// disable if you use external focalDepth value\", \"uniform vec2 focusCoords;\", \"// autofocus point on screen (0.0,0.0 - left lower corner, 1.0,1.0 - upper right)\", \"// if center of screen use vec2(0.5, 0.5);\", \"uniform float maxblur;\", \"//clamp value of max blur (0.0 = no blur, 1.0 default)\", \"uniform float threshold; // highlight threshold;\", \"uniform float gain; // highlight gain;\", \"uniform float bias; // bokeh edge bias\", \"uniform float fringe; // bokeh chromatic aberration / fringing\", \"uniform bool noise; //use noise instead of pattern for sample dithering\", \"uniform float dithering;\", \"uniform bool depthblur; // blur the depth buffer\", \"float dbsize = 1.25; // depth blur size\", \"/*\", \"next part is experimental\", \"not looking good with small sample and ring count\", \"looks okay starting from samples = 4, rings = 4\", \"*/\", \"uniform bool pentagon; //use pentagon as bokeh shape?\", \"float feather = 0.4; //pentagon shape feather\", \"//------------------------------------------\", \"float penta(vec2 coords) {\", \"\t//pentagonal shape\", \"\tfloat scale = float(rings) - 1.3;\", \"\tvec4  HS0 = vec4( 1.0,         0.0,         0.0,  1.0);\", \"\tvec4  HS1 = vec4( 0.309016994, 0.951056516, 0.0,  1.0);\", \"\tvec4  HS2 = vec4(-0.809016994, 0.587785252, 0.0,  1.0);\", \"\tvec4  HS3 = vec4(-0.809016994,-0.587785252, 0.0,  1.0);\", \"\tvec4  HS4 = vec4( 0.309016994,-0.951056516, 0.0,  1.0);\", \"\tvec4  HS5 = vec4( 0.0        ,0.0         , 1.0,  1.0);\", \"\tvec4  one = vec4( 1.0 );\", \"\tvec4 P = vec4((coords),vec2(scale, scale));\", \"\tvec4 dist = vec4(0.0);\", \"\tfloat inorout = -4.0;\", \"\tdist.x = dot( P, HS0 );\", \"\tdist.y = dot( P, HS1 );\", \"\tdist.z = dot( P, HS2 );\", \"\tdist.w = dot( P, HS3 );\", \"\tdist = smoothstep( -feather, feather, dist );\", \"\tinorout += dot( dist, one );\", \"\tdist.x = dot( P, HS4 );\", \"\tdist.y = HS5.w - abs( P.z );\", \"\tdist = smoothstep( -feather, feather, dist );\", \"\tinorout += dist.x;\", \"\treturn clamp( inorout, 0.0, 1.0 );\", \"}\", \"float bdepth(vec2 coords) {\", \"\t// Depth buffer blur\", \"\tfloat d = 0.0;\", \"\tfloat kernel[9];\", \"\tvec2 offset[9];\", \"\tvec2 wh = vec2(1.0/textureWidth,1.0/textureHeight) * dbsize;\", \"\toffset[0] = vec2(-wh.x,-wh.y);\", \"\toffset[1] = vec2( 0.0, -wh.y);\", \"\toffset[2] = vec2( wh.x -wh.y);\", \"\toffset[3] = vec2(-wh.x,  0.0);\", \"\toffset[4] = vec2( 0.0,   0.0);\", \"\toffset[5] = vec2( wh.x,  0.0);\", \"\toffset[6] = vec2(-wh.x, wh.y);\", \"\toffset[7] = vec2( 0.0,  wh.y);\", \"\toffset[8] = vec2( wh.x, wh.y);\", \"\tkernel[0] = 1.0/16.0;   kernel[1] = 2.0/16.0;   kernel[2] = 1.0/16.0;\", \"\tkernel[3] = 2.0/16.0;   kernel[4] = 4.0/16.0;   kernel[5] = 2.0/16.0;\", \"\tkernel[6] = 1.0/16.0;   kernel[7] = 2.0/16.0;   kernel[8] = 1.0/16.0;\", \"\tfor( int i=0; i<9; i++ ) {\", \"\t\tfloat tmp = texture2D(tDepth, coords + offset[i]).r;\", \"\t\td += tmp * kernel[i];\", \"\t}\", \"\treturn d;\", \"}\", \"vec3 color(vec2 coords,float blur) {\", \"\t//processing the sample\", \"\tvec3 col = vec3(0.0);\", \"\tvec2 texel = vec2(1.0/textureWidth,1.0/textureHeight);\", \"\tcol.r = texture2D(tColor,coords + vec2(0.0,1.0)*texel*fringe*blur).r;\", \"\tcol.g = texture2D(tColor,coords + vec2(-0.866,-0.5)*texel*fringe*blur).g;\", \"\tcol.b = texture2D(tColor,coords + vec2(0.866,-0.5)*texel*fringe*blur).b;\", \"\tvec3 lumcoeff = vec3(0.299,0.587,0.114);\", \"\tfloat lum = dot(col.rgb, lumcoeff);\", \"\tfloat thresh = max((lum-threshold)*gain, 0.0);\", \"\treturn col+mix(vec3(0.0),col,thresh*blur);\", \"}\", \"vec3 debugFocus(vec3 col, float blur, float depth) {\", \"\tfloat edge = 0.002*depth; //distance based edge smoothing\", \"\tfloat m = clamp(smoothstep(0.0,edge,blur),0.0,1.0);\", \"\tfloat e = clamp(smoothstep(1.0-edge,1.0,blur),0.0,1.0);\", \"\tcol = mix(col,vec3(1.0,0.5,0.0),(1.0-m)*0.6);\", \"\tcol = mix(col,vec3(0.0,0.5,1.0),((1.0-e)-(1.0-m))*0.2);\", \"\treturn col;\", \"}\", \"float linearize(float depth) {\", \"\treturn -zfar * znear / (depth * (zfar - znear) - zfar);\", \"}\", \"float vignette() {\", \"\tfloat dist = distance(vUv.xy, vec2(0.5,0.5));\", \"\tdist = smoothstep(vignout+(fstop/vignfade), vignin+(fstop/vignfade), dist);\", \"\treturn clamp(dist,0.0,1.0);\", \"}\", \"float gather(float i, float j, int ringsamples, inout vec3 col, float w, float h, float blur) {\", \"\tfloat rings2 = float(rings);\", \"\tfloat step = PI*2.0 / float(ringsamples);\", \"\tfloat pw = cos(j*step)*i;\", \"\tfloat ph = sin(j*step)*i;\", \"\tfloat p = 1.0;\", \"\tif (pentagon) {\", \"\t\tp = penta(vec2(pw,ph));\", \"\t}\", \"\tcol += color(vUv.xy + vec2(pw*w,ph*h), blur) * mix(1.0, i/rings2, bias) * p;\", \"\treturn 1.0 * mix(1.0, i /rings2, bias) * p;\", \"}\", \"void main() {\", \"\t//scene depth calculation\", \"\tfloat depth = linearize(texture2D(tDepth,vUv.xy).x);\", \"\t// Blur depth?\", \"\tif ( depthblur ) {\", \"\t\tdepth = linearize(bdepth(vUv.xy));\", \"\t}\", \"\t//focal plane calculation\", \"\tfloat fDepth = focalDepth;\", \"\tif (shaderFocus) {\", \"\t\tfDepth = linearize(texture2D(tDepth,focusCoords).x);\", \"\t}\", \"\t// dof blur factor calculation\", \"\tfloat blur = 0.0;\", \"\tif (manualdof) {\", \"\t\tfloat a = depth-fDepth; // Focal plane\", \"\t\tfloat b = (a-fdofstart)/fdofdist; // Far DoF\", \"\t\tfloat c = (-a-ndofstart)/ndofdist; // Near Dof\", \"\t\tblur = (a>0.0) ? b : c;\", \"\t} else {\", \"\t\tfloat f = focalLength; // focal length in mm\", \"\t\tfloat d = fDepth*1000.0; // focal plane in mm\", \"\t\tfloat o = depth*1000.0; // depth in mm\", \"\t\tfloat a = (o*f)/(o-f);\", \"\t\tfloat b = (d*f)/(d-f);\", \"\t\tfloat c = (d-f)/(d*fstop*CoC);\", \"\t\tblur = abs(a-b)*c;\", \"\t}\", \"\tblur = clamp(blur,0.0,1.0);\", \"\t// calculation of pattern for dithering\", \"\tvec2 noise = vec2(rand(vUv.xy), rand( vUv.xy + vec2( 0.4, 0.6 ) ) )*dithering*blur;\", \"\t// getting blur x and y step factor\", \"\tfloat w = (1.0/textureWidth)*blur*maxblur+noise.x;\", \"\tfloat h = (1.0/textureHeight)*blur*maxblur+noise.y;\", \"\t// calculation of final color\", \"\tvec3 col = vec3(0.0);\", \"\tif(blur < 0.05) {\", \"\t\t//some optimization thingy\", \"\t\tcol = texture2D(tColor, vUv.xy).rgb;\", \"\t} else {\", \"\t\tcol = texture2D(tColor, vUv.xy).rgb;\", \"\t\tfloat s = 1.0;\", \"\t\tint ringsamples;\", \"\t\tfor (int i = 1; i <= rings; i++) {\", \"\t\t\t/*unboxstart*/\", \"\t\t\tringsamples = i * samples;\", \"\t\t\tfor (int j = 0 ; j < maxringsamples ; j++) {\", \"\t\t\t\tif (j >= ringsamples) break;\", \"\t\t\t\ts += gather(float(i), float(j), ringsamples, col, w, h, blur);\", \"\t\t\t}\", \"\t\t\t/*unboxend*/\", \"\t\t}\", \"\t\tcol /= s; //divide by sample count\", \"\t}\", \"\tif (showFocus) {\", \"\t\tcol = debugFocus(col, blur, depth);\", \"\t}\", \"\tif (vignetting) {\", \"\t\tcol *= vignette();\", \"\t}\", \"\tgl_FragColor.rgb = col;\", \"\tgl_FragColor.a = 1.0;\", \"} \"].join(\"\\n\")\n};\nvar BokehDepthShader = {\n  uniforms: {\n    mNear: {\n      value: 1\n    },\n    mFar: {\n      value: 1e3\n    }\n  },\n  vertexShader: [\"varying float vViewZDepth;\", \"void main() {\", \"\t#include <begin_vertex>\", \"\t#include <project_vertex>\", \"\tvViewZDepth = - mvPosition.z;\", \"}\"].join(\"\\n\"),\n  fragmentShader: [\"uniform float mNear;\", \"uniform float mFar;\", \"varying float vViewZDepth;\", \"void main() {\", \"\tfloat color = 1.0 - smoothstep( mNear, mFar, vViewZDepth );\", \"\tgl_FragColor = vec4( vec3( color ), 1.0 );\", \"} \"].join(\"\\n\")\n};\nexport { BokehDepthShader, BokehShader2 };","map":{"version":3,"sources":["/Users/theodaguier/Repositories/E-Do-Studio/node_modules/three-stdlib/shaders/BokehShader2.js"],"names":["Vector2","BokehShader2","uniforms","textureWidth","value","textureHeight","focalDepth","focalLength","fstop","tColor","tDepth","maxblur","showFocus","manualdof","vignetting","depthblur","threshold","gain","bias","fringe","znear","zfar","noise","dithering","pentagon","shaderFocus","focusCoords","vertexShader","join","fragmentShader","BokehDepthShader","mNear","mFar"],"mappings":"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","sourcesContent":["import { Vector2 } from \"three\";\nconst BokehShader2 = {\n  uniforms: {\n    textureWidth: { value: 1 },\n    textureHeight: { value: 1 },\n    focalDepth: { value: 1 },\n    focalLength: { value: 24 },\n    fstop: { value: 0.9 },\n    tColor: { value: null },\n    tDepth: { value: null },\n    maxblur: { value: 1 },\n    showFocus: { value: 0 },\n    manualdof: { value: 0 },\n    vignetting: { value: 0 },\n    depthblur: { value: 0 },\n    threshold: { value: 0.5 },\n    gain: { value: 2 },\n    bias: { value: 0.5 },\n    fringe: { value: 0.7 },\n    znear: { value: 0.1 },\n    zfar: { value: 100 },\n    noise: { value: 1 },\n    dithering: { value: 1e-4 },\n    pentagon: { value: 0 },\n    shaderFocus: { value: 1 },\n    focusCoords: { value: /* @__PURE__ */ new Vector2() }\n  },\n  vertexShader: [\n    \"varying vec2 vUv;\",\n    \"void main() {\",\n    \"\tvUv = uv;\",\n    \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n    \"}\"\n  ].join(\"\\n\"),\n  fragmentShader: [\n    \"#include <common>\",\n    \"varying vec2 vUv;\",\n    \"uniform sampler2D tColor;\",\n    \"uniform sampler2D tDepth;\",\n    \"uniform float textureWidth;\",\n    \"uniform float textureHeight;\",\n    \"uniform float focalDepth;  //focal distance value in meters, but you may use autofocus option below\",\n    \"uniform float focalLength; //focal length in mm\",\n    \"uniform float fstop; //f-stop value\",\n    \"uniform bool showFocus; //show debug focus point and focal range (red = focal point, green = focal range)\",\n    \"/*\",\n    \"make sure that these two values are the same for your camera, otherwise distances will be wrong.\",\n    \"*/\",\n    \"uniform float znear; // camera clipping start\",\n    \"uniform float zfar; // camera clipping end\",\n    \"//------------------------------------------\",\n    \"//user variables\",\n    \"const int samples = SAMPLES; //samples on the first ring\",\n    \"const int rings = RINGS; //ring count\",\n    \"const int maxringsamples = rings * samples;\",\n    \"uniform bool manualdof; // manual dof calculation\",\n    \"float ndofstart = 1.0; // near dof blur start\",\n    \"float ndofdist = 2.0; // near dof blur falloff distance\",\n    \"float fdofstart = 1.0; // far dof blur start\",\n    \"float fdofdist = 3.0; // far dof blur falloff distance\",\n    \"float CoC = 0.03; //circle of confusion size in mm (35mm film = 0.03mm)\",\n    \"uniform bool vignetting; // use optical lens vignetting\",\n    \"float vignout = 1.3; // vignetting outer border\",\n    \"float vignin = 0.0; // vignetting inner border\",\n    \"float vignfade = 22.0; // f-stops till vignete fades\",\n    \"uniform bool shaderFocus;\",\n    \"// disable if you use external focalDepth value\",\n    \"uniform vec2 focusCoords;\",\n    \"// autofocus point on screen (0.0,0.0 - left lower corner, 1.0,1.0 - upper right)\",\n    \"// if center of screen use vec2(0.5, 0.5);\",\n    \"uniform float maxblur;\",\n    \"//clamp value of max blur (0.0 = no blur, 1.0 default)\",\n    \"uniform float threshold; // highlight threshold;\",\n    \"uniform float gain; // highlight gain;\",\n    \"uniform float bias; // bokeh edge bias\",\n    \"uniform float fringe; // bokeh chromatic aberration / fringing\",\n    \"uniform bool noise; //use noise instead of pattern for sample dithering\",\n    \"uniform float dithering;\",\n    \"uniform bool depthblur; // blur the depth buffer\",\n    \"float dbsize = 1.25; // depth blur size\",\n    \"/*\",\n    \"next part is experimental\",\n    \"not looking good with small sample and ring count\",\n    \"looks okay starting from samples = 4, rings = 4\",\n    \"*/\",\n    \"uniform bool pentagon; //use pentagon as bokeh shape?\",\n    \"float feather = 0.4; //pentagon shape feather\",\n    \"//------------------------------------------\",\n    \"float penta(vec2 coords) {\",\n    \"\t//pentagonal shape\",\n    \"\tfloat scale = float(rings) - 1.3;\",\n    \"\tvec4  HS0 = vec4( 1.0,         0.0,         0.0,  1.0);\",\n    \"\tvec4  HS1 = vec4( 0.309016994, 0.951056516, 0.0,  1.0);\",\n    \"\tvec4  HS2 = vec4(-0.809016994, 0.587785252, 0.0,  1.0);\",\n    \"\tvec4  HS3 = vec4(-0.809016994,-0.587785252, 0.0,  1.0);\",\n    \"\tvec4  HS4 = vec4( 0.309016994,-0.951056516, 0.0,  1.0);\",\n    \"\tvec4  HS5 = vec4( 0.0        ,0.0         , 1.0,  1.0);\",\n    \"\tvec4  one = vec4( 1.0 );\",\n    \"\tvec4 P = vec4((coords),vec2(scale, scale));\",\n    \"\tvec4 dist = vec4(0.0);\",\n    \"\tfloat inorout = -4.0;\",\n    \"\tdist.x = dot( P, HS0 );\",\n    \"\tdist.y = dot( P, HS1 );\",\n    \"\tdist.z = dot( P, HS2 );\",\n    \"\tdist.w = dot( P, HS3 );\",\n    \"\tdist = smoothstep( -feather, feather, dist );\",\n    \"\tinorout += dot( dist, one );\",\n    \"\tdist.x = dot( P, HS4 );\",\n    \"\tdist.y = HS5.w - abs( P.z );\",\n    \"\tdist = smoothstep( -feather, feather, dist );\",\n    \"\tinorout += dist.x;\",\n    \"\treturn clamp( inorout, 0.0, 1.0 );\",\n    \"}\",\n    \"float bdepth(vec2 coords) {\",\n    \"\t// Depth buffer blur\",\n    \"\tfloat d = 0.0;\",\n    \"\tfloat kernel[9];\",\n    \"\tvec2 offset[9];\",\n    \"\tvec2 wh = vec2(1.0/textureWidth,1.0/textureHeight) * dbsize;\",\n    \"\toffset[0] = vec2(-wh.x,-wh.y);\",\n    \"\toffset[1] = vec2( 0.0, -wh.y);\",\n    \"\toffset[2] = vec2( wh.x -wh.y);\",\n    \"\toffset[3] = vec2(-wh.x,  0.0);\",\n    \"\toffset[4] = vec2( 0.0,   0.0);\",\n    \"\toffset[5] = vec2( wh.x,  0.0);\",\n    \"\toffset[6] = vec2(-wh.x, wh.y);\",\n    \"\toffset[7] = vec2( 0.0,  wh.y);\",\n    \"\toffset[8] = vec2( wh.x, wh.y);\",\n    \"\tkernel[0] = 1.0/16.0;   kernel[1] = 2.0/16.0;   kernel[2] = 1.0/16.0;\",\n    \"\tkernel[3] = 2.0/16.0;   kernel[4] = 4.0/16.0;   kernel[5] = 2.0/16.0;\",\n    \"\tkernel[6] = 1.0/16.0;   kernel[7] = 2.0/16.0;   kernel[8] = 1.0/16.0;\",\n    \"\tfor( int i=0; i<9; i++ ) {\",\n    \"\t\tfloat tmp = texture2D(tDepth, coords + offset[i]).r;\",\n    \"\t\td += tmp * kernel[i];\",\n    \"\t}\",\n    \"\treturn d;\",\n    \"}\",\n    \"vec3 color(vec2 coords,float blur) {\",\n    \"\t//processing the sample\",\n    \"\tvec3 col = vec3(0.0);\",\n    \"\tvec2 texel = vec2(1.0/textureWidth,1.0/textureHeight);\",\n    \"\tcol.r = texture2D(tColor,coords + vec2(0.0,1.0)*texel*fringe*blur).r;\",\n    \"\tcol.g = texture2D(tColor,coords + vec2(-0.866,-0.5)*texel*fringe*blur).g;\",\n    \"\tcol.b = texture2D(tColor,coords + vec2(0.866,-0.5)*texel*fringe*blur).b;\",\n    \"\tvec3 lumcoeff = vec3(0.299,0.587,0.114);\",\n    \"\tfloat lum = dot(col.rgb, lumcoeff);\",\n    \"\tfloat thresh = max((lum-threshold)*gain, 0.0);\",\n    \"\treturn col+mix(vec3(0.0),col,thresh*blur);\",\n    \"}\",\n    \"vec3 debugFocus(vec3 col, float blur, float depth) {\",\n    \"\tfloat edge = 0.002*depth; //distance based edge smoothing\",\n    \"\tfloat m = clamp(smoothstep(0.0,edge,blur),0.0,1.0);\",\n    \"\tfloat e = clamp(smoothstep(1.0-edge,1.0,blur),0.0,1.0);\",\n    \"\tcol = mix(col,vec3(1.0,0.5,0.0),(1.0-m)*0.6);\",\n    \"\tcol = mix(col,vec3(0.0,0.5,1.0),((1.0-e)-(1.0-m))*0.2);\",\n    \"\treturn col;\",\n    \"}\",\n    \"float linearize(float depth) {\",\n    \"\treturn -zfar * znear / (depth * (zfar - znear) - zfar);\",\n    \"}\",\n    \"float vignette() {\",\n    \"\tfloat dist = distance(vUv.xy, vec2(0.5,0.5));\",\n    \"\tdist = smoothstep(vignout+(fstop/vignfade), vignin+(fstop/vignfade), dist);\",\n    \"\treturn clamp(dist,0.0,1.0);\",\n    \"}\",\n    \"float gather(float i, float j, int ringsamples, inout vec3 col, float w, float h, float blur) {\",\n    \"\tfloat rings2 = float(rings);\",\n    \"\tfloat step = PI*2.0 / float(ringsamples);\",\n    \"\tfloat pw = cos(j*step)*i;\",\n    \"\tfloat ph = sin(j*step)*i;\",\n    \"\tfloat p = 1.0;\",\n    \"\tif (pentagon) {\",\n    \"\t\tp = penta(vec2(pw,ph));\",\n    \"\t}\",\n    \"\tcol += color(vUv.xy + vec2(pw*w,ph*h), blur) * mix(1.0, i/rings2, bias) * p;\",\n    \"\treturn 1.0 * mix(1.0, i /rings2, bias) * p;\",\n    \"}\",\n    \"void main() {\",\n    \"\t//scene depth calculation\",\n    \"\tfloat depth = linearize(texture2D(tDepth,vUv.xy).x);\",\n    \"\t// Blur depth?\",\n    \"\tif ( depthblur ) {\",\n    \"\t\tdepth = linearize(bdepth(vUv.xy));\",\n    \"\t}\",\n    \"\t//focal plane calculation\",\n    \"\tfloat fDepth = focalDepth;\",\n    \"\tif (shaderFocus) {\",\n    \"\t\tfDepth = linearize(texture2D(tDepth,focusCoords).x);\",\n    \"\t}\",\n    \"\t// dof blur factor calculation\",\n    \"\tfloat blur = 0.0;\",\n    \"\tif (manualdof) {\",\n    \"\t\tfloat a = depth-fDepth; // Focal plane\",\n    \"\t\tfloat b = (a-fdofstart)/fdofdist; // Far DoF\",\n    \"\t\tfloat c = (-a-ndofstart)/ndofdist; // Near Dof\",\n    \"\t\tblur = (a>0.0) ? b : c;\",\n    \"\t} else {\",\n    \"\t\tfloat f = focalLength; // focal length in mm\",\n    \"\t\tfloat d = fDepth*1000.0; // focal plane in mm\",\n    \"\t\tfloat o = depth*1000.0; // depth in mm\",\n    \"\t\tfloat a = (o*f)/(o-f);\",\n    \"\t\tfloat b = (d*f)/(d-f);\",\n    \"\t\tfloat c = (d-f)/(d*fstop*CoC);\",\n    \"\t\tblur = abs(a-b)*c;\",\n    \"\t}\",\n    \"\tblur = clamp(blur,0.0,1.0);\",\n    \"\t// calculation of pattern for dithering\",\n    \"\tvec2 noise = vec2(rand(vUv.xy), rand( vUv.xy + vec2( 0.4, 0.6 ) ) )*dithering*blur;\",\n    \"\t// getting blur x and y step factor\",\n    \"\tfloat w = (1.0/textureWidth)*blur*maxblur+noise.x;\",\n    \"\tfloat h = (1.0/textureHeight)*blur*maxblur+noise.y;\",\n    \"\t// calculation of final color\",\n    \"\tvec3 col = vec3(0.0);\",\n    \"\tif(blur < 0.05) {\",\n    \"\t\t//some optimization thingy\",\n    \"\t\tcol = texture2D(tColor, vUv.xy).rgb;\",\n    \"\t} else {\",\n    \"\t\tcol = texture2D(tColor, vUv.xy).rgb;\",\n    \"\t\tfloat s = 1.0;\",\n    \"\t\tint ringsamples;\",\n    \"\t\tfor (int i = 1; i <= rings; i++) {\",\n    \"\t\t\t/*unboxstart*/\",\n    \"\t\t\tringsamples = i * samples;\",\n    \"\t\t\tfor (int j = 0 ; j < maxringsamples ; j++) {\",\n    \"\t\t\t\tif (j >= ringsamples) break;\",\n    \"\t\t\t\ts += gather(float(i), float(j), ringsamples, col, w, h, blur);\",\n    \"\t\t\t}\",\n    \"\t\t\t/*unboxend*/\",\n    \"\t\t}\",\n    \"\t\tcol /= s; //divide by sample count\",\n    \"\t}\",\n    \"\tif (showFocus) {\",\n    \"\t\tcol = debugFocus(col, blur, depth);\",\n    \"\t}\",\n    \"\tif (vignetting) {\",\n    \"\t\tcol *= vignette();\",\n    \"\t}\",\n    \"\tgl_FragColor.rgb = col;\",\n    \"\tgl_FragColor.a = 1.0;\",\n    \"} \"\n  ].join(\"\\n\")\n};\nconst BokehDepthShader = {\n  uniforms: {\n    mNear: { value: 1 },\n    mFar: { value: 1e3 }\n  },\n  vertexShader: [\n    \"varying float vViewZDepth;\",\n    \"void main() {\",\n    \"\t#include <begin_vertex>\",\n    \"\t#include <project_vertex>\",\n    \"\tvViewZDepth = - mvPosition.z;\",\n    \"}\"\n  ].join(\"\\n\"),\n  fragmentShader: [\n    \"uniform float mNear;\",\n    \"uniform float mFar;\",\n    \"varying float vViewZDepth;\",\n    \"void main() {\",\n    \"\tfloat color = 1.0 - smoothstep( mNear, mFar, vViewZDepth );\",\n    \"\tgl_FragColor = vec4( vec3( color ), 1.0 );\",\n    \"} \"\n  ].join(\"\\n\")\n};\nexport {\n  BokehDepthShader,\n  BokehShader2\n};\n"]},"metadata":{},"sourceType":"module"}