{"ast":null,"code":"import _assertThisInitialized from \"/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _classCallCheck from \"/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { Loader, LoaderUtils, FileLoader, Scene, Object3D, Group, Vector3, SphereGeometry, MeshBasicMaterial, BackSide, Mesh, PointsMaterial, Points, LineBasicMaterial, LineSegments, FrontSide, DoubleSide, MeshPhongMaterial, Color, RepeatWrapping, ClampToEdgeWrapping, DataTexture, Vector2, BufferGeometry, Float32BufferAttribute, BoxGeometry, ConeGeometry, CylinderGeometry, Quaternion, ShapeUtils, BufferAttribute, TextureLoader } from \"three\";\nimport { createToken, Lexer, CstParser } from \"chevrotain\";\n\nvar VRMLLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(VRMLLoader, _Loader);\n\n  var _super = _createSuper(VRMLLoader);\n\n  function VRMLLoader(manager) {\n    _classCallCheck(this, VRMLLoader);\n\n    return _super.call(this, manager);\n  }\n\n  _createClass(VRMLLoader, [{\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var path = scope.path === \"\" ? LoaderUtils.extractUrlBase(url) : scope.path;\n      var loader = new FileLoader(scope.manager);\n      loader.setPath(scope.path);\n      loader.setRequestHeader(scope.requestHeader);\n      loader.setWithCredentials(scope.withCredentials);\n      loader.load(url, function (text) {\n        try {\n          onLoad(scope.parse(text, path));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(data, path) {\n      var nodeMap = {};\n\n      function generateVRMLTree(data2) {\n        var tokenData = createTokens();\n        var lexer = new VRMLLexer(tokenData.tokens);\n        var parser = new VRMLParser(tokenData.tokenVocabulary);\n        var visitor = createVisitor(parser.getBaseCstVisitorConstructor());\n        var lexingResult = lexer.lex(data2);\n        parser.input = lexingResult.tokens;\n        var cstOutput = parser.vrml();\n\n        if (parser.errors.length > 0) {\n          console.error(parser.errors);\n          throw Error(\"THREE.VRMLLoader: Parsing errors detected.\");\n        }\n\n        var ast = visitor.visit(cstOutput);\n        return ast;\n      }\n\n      function createTokens() {\n        var RouteIdentifier = createToken({\n          name: \"RouteIdentifier\",\n          pattern: /[^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*[\\.][^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*/\n        });\n        var Identifier = createToken({\n          name: \"Identifier\",\n          pattern: /[^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*/,\n          longer_alt: RouteIdentifier\n        });\n        var nodeTypes = [\"Anchor\", \"Billboard\", \"Collision\", \"Group\", \"Transform\", // grouping nodes\n        \"Inline\", \"LOD\", \"Switch\", // special groups\n        \"AudioClip\", \"DirectionalLight\", \"PointLight\", \"Script\", \"Shape\", \"Sound\", \"SpotLight\", \"WorldInfo\", // common nodes\n        \"CylinderSensor\", \"PlaneSensor\", \"ProximitySensor\", \"SphereSensor\", \"TimeSensor\", \"TouchSensor\", \"VisibilitySensor\", // sensors\n        \"Box\", \"Cone\", \"Cylinder\", \"ElevationGrid\", \"Extrusion\", \"IndexedFaceSet\", \"IndexedLineSet\", \"PointSet\", \"Sphere\", // geometries\n        \"Color\", \"Coordinate\", \"Normal\", \"TextureCoordinate\", // geometric properties\n        \"Appearance\", \"FontStyle\", \"ImageTexture\", \"Material\", \"MovieTexture\", \"PixelTexture\", \"TextureTransform\", // appearance\n        \"ColorInterpolator\", \"CoordinateInterpolator\", \"NormalInterpolator\", \"OrientationInterpolator\", \"PositionInterpolator\", \"ScalarInterpolator\", // interpolators\n        \"Background\", \"Fog\", \"NavigationInfo\", \"Viewpoint\", // bindable nodes\n        \"Text\" // Text must be placed at the end of the regex so there are no matches for TextureTransform and TextureCoordinate\n        ];\n        var Version = createToken({\n          name: \"Version\",\n          pattern: /#VRML.*/,\n          longer_alt: Identifier\n        });\n        var NodeName = createToken({\n          name: \"NodeName\",\n          pattern: new RegExp(nodeTypes.join(\"|\")),\n          longer_alt: Identifier\n        });\n        var DEF = createToken({\n          name: \"DEF\",\n          pattern: /DEF/,\n          longer_alt: Identifier\n        });\n        var USE = createToken({\n          name: \"USE\",\n          pattern: /USE/,\n          longer_alt: Identifier\n        });\n        var ROUTE = createToken({\n          name: \"ROUTE\",\n          pattern: /ROUTE/,\n          longer_alt: Identifier\n        });\n        var TO = createToken({\n          name: \"TO\",\n          pattern: /TO/,\n          longer_alt: Identifier\n        });\n        var StringLiteral = createToken({\n          name: \"StringLiteral\",\n          pattern: /\"(?:[^\\\\\"\\n\\r]|\\\\[bfnrtv\"\\\\/]|\\\\u[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F])*\"/\n        });\n        var HexLiteral = createToken({\n          name: \"HexLiteral\",\n          pattern: /0[xX][0-9a-fA-F]+/\n        });\n        var NumberLiteral = createToken({\n          name: \"NumberLiteral\",\n          pattern: /[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?/\n        });\n        var TrueLiteral = createToken({\n          name: \"TrueLiteral\",\n          pattern: /TRUE/\n        });\n        var FalseLiteral = createToken({\n          name: \"FalseLiteral\",\n          pattern: /FALSE/\n        });\n        var NullLiteral = createToken({\n          name: \"NullLiteral\",\n          pattern: /NULL/\n        });\n        var LSquare = createToken({\n          name: \"LSquare\",\n          pattern: /\\[/\n        });\n        var RSquare = createToken({\n          name: \"RSquare\",\n          pattern: /]/\n        });\n        var LCurly = createToken({\n          name: \"LCurly\",\n          pattern: /{/\n        });\n        var RCurly = createToken({\n          name: \"RCurly\",\n          pattern: /}/\n        });\n        var Comment = createToken({\n          name: \"Comment\",\n          pattern: /#.*/,\n          group: Lexer.SKIPPED\n        });\n        var WhiteSpace = createToken({\n          name: \"WhiteSpace\",\n          pattern: /[ ,\\s]/,\n          group: Lexer.SKIPPED\n        });\n        var tokens = [WhiteSpace, // keywords appear before the Identifier\n        NodeName, DEF, USE, ROUTE, TO, TrueLiteral, FalseLiteral, NullLiteral, // the Identifier must appear after the keywords because all keywords are valid identifiers\n        Version, Identifier, RouteIdentifier, StringLiteral, HexLiteral, NumberLiteral, LSquare, RSquare, LCurly, RCurly, Comment];\n        var tokenVocabulary = {};\n\n        for (var i = 0, l = tokens.length; i < l; i++) {\n          var token = tokens[i];\n          tokenVocabulary[token.name] = token;\n        }\n\n        return {\n          tokens: tokens,\n          tokenVocabulary: tokenVocabulary\n        };\n      }\n\n      function createVisitor(BaseVRMLVisitor) {\n        function VRMLToASTVisitor() {\n          BaseVRMLVisitor.call(this);\n          this.validateVisitor();\n        }\n\n        VRMLToASTVisitor.prototype = Object.assign(Object.create(BaseVRMLVisitor.prototype), {\n          constructor: VRMLToASTVisitor,\n          vrml: function vrml(ctx) {\n            var data2 = {\n              version: this.visit(ctx.version),\n              nodes: [],\n              routes: []\n            };\n\n            for (var i = 0, l = ctx.node.length; i < l; i++) {\n              var node = ctx.node[i];\n              data2.nodes.push(this.visit(node));\n            }\n\n            if (ctx.route) {\n              for (var _i = 0, _l = ctx.route.length; _i < _l; _i++) {\n                var route = ctx.route[_i];\n                data2.routes.push(this.visit(route));\n              }\n            }\n\n            return data2;\n          },\n          version: function version(ctx) {\n            return ctx.Version[0].image;\n          },\n          node: function node(ctx) {\n            var data2 = {\n              name: ctx.NodeName[0].image,\n              fields: []\n            };\n\n            if (ctx.field) {\n              for (var i = 0, l = ctx.field.length; i < l; i++) {\n                var field = ctx.field[i];\n                data2.fields.push(this.visit(field));\n              }\n            }\n\n            if (ctx.def) {\n              data2.DEF = this.visit(ctx.def[0]);\n            }\n\n            return data2;\n          },\n          field: function field(ctx) {\n            var data2 = {\n              name: ctx.Identifier[0].image,\n              type: null,\n              values: null\n            };\n            var result;\n\n            if (ctx.singleFieldValue) {\n              result = this.visit(ctx.singleFieldValue[0]);\n            }\n\n            if (ctx.multiFieldValue) {\n              result = this.visit(ctx.multiFieldValue[0]);\n            }\n\n            data2.type = result.type;\n            data2.values = result.values;\n            return data2;\n          },\n          def: function def(ctx) {\n            return (ctx.Identifier || ctx.NodeName)[0].image;\n          },\n          use: function use(ctx) {\n            return {\n              USE: (ctx.Identifier || ctx.NodeName)[0].image\n            };\n          },\n          singleFieldValue: function singleFieldValue(ctx) {\n            return processField(this, ctx);\n          },\n          multiFieldValue: function multiFieldValue(ctx) {\n            return processField(this, ctx);\n          },\n          route: function route(ctx) {\n            var data2 = {\n              FROM: ctx.RouteIdentifier[0].image,\n              TO: ctx.RouteIdentifier[1].image\n            };\n            return data2;\n          }\n        });\n\n        function processField(scope, ctx) {\n          var field = {\n            type: null,\n            values: []\n          };\n\n          if (ctx.node) {\n            field.type = \"node\";\n\n            for (var i = 0, l = ctx.node.length; i < l; i++) {\n              var node = ctx.node[i];\n              field.values.push(scope.visit(node));\n            }\n          }\n\n          if (ctx.use) {\n            field.type = \"use\";\n\n            for (var _i2 = 0, _l2 = ctx.use.length; _i2 < _l2; _i2++) {\n              var use = ctx.use[_i2];\n              field.values.push(scope.visit(use));\n            }\n          }\n\n          if (ctx.StringLiteral) {\n            field.type = \"string\";\n\n            for (var _i3 = 0, _l3 = ctx.StringLiteral.length; _i3 < _l3; _i3++) {\n              var stringLiteral = ctx.StringLiteral[_i3];\n              field.values.push(stringLiteral.image.replace(/'|\"/g, \"\"));\n            }\n          }\n\n          if (ctx.NumberLiteral) {\n            field.type = \"number\";\n\n            for (var _i4 = 0, _l4 = ctx.NumberLiteral.length; _i4 < _l4; _i4++) {\n              var numberLiteral = ctx.NumberLiteral[_i4];\n              field.values.push(parseFloat(numberLiteral.image));\n            }\n          }\n\n          if (ctx.HexLiteral) {\n            field.type = \"hex\";\n\n            for (var _i5 = 0, _l5 = ctx.HexLiteral.length; _i5 < _l5; _i5++) {\n              var hexLiteral = ctx.HexLiteral[_i5];\n              field.values.push(hexLiteral.image);\n            }\n          }\n\n          if (ctx.TrueLiteral) {\n            field.type = \"boolean\";\n\n            for (var _i6 = 0, _l6 = ctx.TrueLiteral.length; _i6 < _l6; _i6++) {\n              var trueLiteral = ctx.TrueLiteral[_i6];\n              if (trueLiteral.image === \"TRUE\") field.values.push(true);\n            }\n          }\n\n          if (ctx.FalseLiteral) {\n            field.type = \"boolean\";\n\n            for (var _i7 = 0, _l7 = ctx.FalseLiteral.length; _i7 < _l7; _i7++) {\n              var falseLiteral = ctx.FalseLiteral[_i7];\n              if (falseLiteral.image === \"FALSE\") field.values.push(false);\n            }\n          }\n\n          if (ctx.NullLiteral) {\n            field.type = \"null\";\n            ctx.NullLiteral.forEach(function () {\n              field.values.push(null);\n            });\n          }\n\n          return field;\n        }\n\n        return new VRMLToASTVisitor();\n      }\n\n      function parseTree(tree2) {\n        var nodes = tree2.nodes;\n        var scene2 = new Scene();\n\n        for (var i = 0, l = nodes.length; i < l; i++) {\n          var node = nodes[i];\n          buildNodeMap(node);\n        }\n\n        for (var _i8 = 0, _l8 = nodes.length; _i8 < _l8; _i8++) {\n          var _node = nodes[_i8];\n          var object = getNode(_node);\n          if (object instanceof Object3D) scene2.add(object);\n          if (_node.name === \"WorldInfo\") scene2.userData.worldInfo = object;\n        }\n\n        return scene2;\n      }\n\n      function buildNodeMap(node) {\n        if (node.DEF) {\n          nodeMap[node.DEF] = node;\n        }\n\n        var fields = node.fields;\n\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n\n          if (field.type === \"node\") {\n            var fieldValues = field.values;\n\n            for (var j = 0, jl = fieldValues.length; j < jl; j++) {\n              buildNodeMap(fieldValues[j]);\n            }\n          }\n        }\n      }\n\n      function getNode(node) {\n        if (node.USE) {\n          return resolveUSE(node.USE);\n        }\n\n        if (node.build !== void 0) return node.build;\n        node.build = buildNode(node);\n        return node.build;\n      }\n\n      function buildNode(node) {\n        var nodeName = node.name;\n        var build;\n\n        switch (nodeName) {\n          case \"Group\":\n          case \"Transform\":\n          case \"Collision\":\n            build = buildGroupingNode(node);\n            break;\n\n          case \"Background\":\n            build = buildBackgroundNode(node);\n            break;\n\n          case \"Shape\":\n            build = buildShapeNode(node);\n            break;\n\n          case \"Appearance\":\n            build = buildAppearanceNode(node);\n            break;\n\n          case \"Material\":\n            build = buildMaterialNode(node);\n            break;\n\n          case \"ImageTexture\":\n            build = buildImageTextureNode(node);\n            break;\n\n          case \"PixelTexture\":\n            build = buildPixelTextureNode(node);\n            break;\n\n          case \"TextureTransform\":\n            build = buildTextureTransformNode(node);\n            break;\n\n          case \"IndexedFaceSet\":\n            build = buildIndexedFaceSetNode(node);\n            break;\n\n          case \"IndexedLineSet\":\n            build = buildIndexedLineSetNode(node);\n            break;\n\n          case \"PointSet\":\n            build = buildPointSetNode(node);\n            break;\n\n          case \"Box\":\n            build = buildBoxNode(node);\n            break;\n\n          case \"Cone\":\n            build = buildConeNode(node);\n            break;\n\n          case \"Cylinder\":\n            build = buildCylinderNode(node);\n            break;\n\n          case \"Sphere\":\n            build = buildSphereNode(node);\n            break;\n\n          case \"ElevationGrid\":\n            build = buildElevationGridNode(node);\n            break;\n\n          case \"Extrusion\":\n            build = buildExtrusionNode(node);\n            break;\n\n          case \"Color\":\n          case \"Coordinate\":\n          case \"Normal\":\n          case \"TextureCoordinate\":\n            build = buildGeometricNode(node);\n            break;\n\n          case \"WorldInfo\":\n            build = buildWorldInfoNode(node);\n            break;\n\n          case \"Anchor\":\n          case \"Billboard\":\n          case \"Inline\":\n          case \"LOD\":\n          case \"Switch\":\n          case \"AudioClip\":\n          case \"DirectionalLight\":\n          case \"PointLight\":\n          case \"Script\":\n          case \"Sound\":\n          case \"SpotLight\":\n          case \"CylinderSensor\":\n          case \"PlaneSensor\":\n          case \"ProximitySensor\":\n          case \"SphereSensor\":\n          case \"TimeSensor\":\n          case \"TouchSensor\":\n          case \"VisibilitySensor\":\n          case \"Text\":\n          case \"FontStyle\":\n          case \"MovieTexture\":\n          case \"ColorInterpolator\":\n          case \"CoordinateInterpolator\":\n          case \"NormalInterpolator\":\n          case \"OrientationInterpolator\":\n          case \"PositionInterpolator\":\n          case \"ScalarInterpolator\":\n          case \"Fog\":\n          case \"NavigationInfo\":\n          case \"Viewpoint\":\n            break;\n\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown node:\", nodeName);\n            break;\n        }\n\n        if (build !== void 0 && node.DEF !== void 0 && build.hasOwnProperty(\"name\") === true) {\n          build.name = node.DEF;\n        }\n\n        return build;\n      }\n\n      function buildGroupingNode(node) {\n        var object = new Group();\n        var fields = node.fields;\n\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case \"bboxCenter\":\n              break;\n\n            case \"bboxSize\":\n              break;\n\n            case \"center\":\n              break;\n\n            case \"children\":\n              parseFieldChildren(fieldValues, object);\n              break;\n\n            case \"collide\":\n              break;\n\n            case \"rotation\":\n              var axis = new Vector3(fieldValues[0], fieldValues[1], fieldValues[2]);\n              var angle = fieldValues[3];\n              object.quaternion.setFromAxisAngle(axis, angle);\n              break;\n\n            case \"scale\":\n              object.scale.set(fieldValues[0], fieldValues[1], fieldValues[2]);\n              break;\n\n            case \"scaleOrientation\":\n              break;\n\n            case \"translation\":\n              object.position.set(fieldValues[0], fieldValues[1], fieldValues[2]);\n              break;\n\n            case \"proxy\":\n              break;\n\n            default:\n              console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n              break;\n          }\n        }\n\n        return object;\n      }\n\n      function buildBackgroundNode(node) {\n        var group = new Group();\n        var groundAngle, groundColor;\n        var skyAngle, skyColor;\n        var fields = node.fields;\n\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case \"groundAngle\":\n              groundAngle = fieldValues;\n              break;\n\n            case \"groundColor\":\n              groundColor = fieldValues;\n              break;\n\n            case \"backUrl\":\n              break;\n\n            case \"bottomUrl\":\n              break;\n\n            case \"frontUrl\":\n              break;\n\n            case \"leftUrl\":\n              break;\n\n            case \"rightUrl\":\n              break;\n\n            case \"topUrl\":\n              break;\n\n            case \"skyAngle\":\n              skyAngle = fieldValues;\n              break;\n\n            case \"skyColor\":\n              skyColor = fieldValues;\n              break;\n\n            default:\n              console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n              break;\n          }\n        }\n\n        var radius = 1e4;\n\n        if (skyColor) {\n          var skyGeometry = new SphereGeometry(radius, 32, 16);\n          var skyMaterial = new MeshBasicMaterial({\n            fog: false,\n            side: BackSide,\n            depthWrite: false,\n            depthTest: false\n          });\n\n          if (skyColor.length > 3) {\n            paintFaces(skyGeometry, radius, skyAngle, toColorArray(skyColor), true);\n            skyMaterial.vertexColors = true;\n          } else {\n            skyMaterial.color.setRGB(skyColor[0], skyColor[1], skyColor[2]);\n          }\n\n          var sky = new Mesh(skyGeometry, skyMaterial);\n          group.add(sky);\n        }\n\n        if (groundColor) {\n          if (groundColor.length > 0) {\n            var groundGeometry = new SphereGeometry(radius, 32, 16, 0, 2 * Math.PI, 0.5 * Math.PI, 1.5 * Math.PI);\n            var groundMaterial = new MeshBasicMaterial({\n              fog: false,\n              side: BackSide,\n              vertexColors: true,\n              depthWrite: false,\n              depthTest: false\n            });\n            paintFaces(groundGeometry, radius, groundAngle, toColorArray(groundColor), false);\n            var ground = new Mesh(groundGeometry, groundMaterial);\n            group.add(ground);\n          }\n        }\n\n        group.renderOrder = -Infinity;\n        return group;\n      }\n\n      function buildShapeNode(node) {\n        var fields = node.fields;\n        var material = new MeshBasicMaterial({\n          color: 0\n        });\n        var geometry;\n\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case \"appearance\":\n              if (fieldValues[0] !== null) {\n                material = getNode(fieldValues[0]);\n              }\n\n              break;\n\n            case \"geometry\":\n              if (fieldValues[0] !== null) {\n                geometry = getNode(fieldValues[0]);\n              }\n\n              break;\n\n            default:\n              console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n              break;\n          }\n        }\n\n        var object;\n\n        if (geometry && geometry.attributes.position) {\n          var type = geometry._type;\n\n          if (type === \"points\") {\n            var pointsMaterial = new PointsMaterial({\n              color: 16777215\n            });\n\n            if (geometry.attributes.color !== void 0) {\n              pointsMaterial.vertexColors = true;\n            } else {\n              if (material.isMeshPhongMaterial) {\n                pointsMaterial.color.copy(material.emissive);\n              }\n            }\n\n            object = new Points(geometry, pointsMaterial);\n          } else if (type === \"line\") {\n            var lineMaterial = new LineBasicMaterial({\n              color: 16777215\n            });\n\n            if (geometry.attributes.color !== void 0) {\n              lineMaterial.vertexColors = true;\n            } else {\n              if (material.isMeshPhongMaterial) {\n                lineMaterial.color.copy(material.emissive);\n              }\n            }\n\n            object = new LineSegments(geometry, lineMaterial);\n          } else {\n            if (geometry._solid !== void 0) {\n              material.side = geometry._solid ? FrontSide : DoubleSide;\n            }\n\n            if (geometry.attributes.color !== void 0) {\n              material.vertexColors = true;\n            }\n\n            object = new Mesh(geometry, material);\n          }\n        } else {\n          object = new Object3D();\n          object.visible = false;\n        }\n\n        return object;\n      }\n\n      function buildAppearanceNode(node) {\n        var material = new MeshPhongMaterial();\n        var transformData;\n        var fields = node.fields;\n\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case \"material\":\n              if (fieldValues[0] !== null) {\n                var materialData = getNode(fieldValues[0]);\n                if (materialData.diffuseColor) material.color.copy(materialData.diffuseColor);\n                if (materialData.emissiveColor) material.emissive.copy(materialData.emissiveColor);\n                if (materialData.shininess) material.shininess = materialData.shininess;\n                if (materialData.specularColor) material.specular.copy(materialData.specularColor);\n                if (materialData.transparency) material.opacity = 1 - materialData.transparency;\n                if (materialData.transparency > 0) material.transparent = true;\n              } else {\n                material = new MeshBasicMaterial({\n                  color: 0\n                });\n              }\n\n              break;\n\n            case \"texture\":\n              var textureNode = fieldValues[0];\n\n              if (textureNode !== null) {\n                if (textureNode.name === \"ImageTexture\" || textureNode.name === \"PixelTexture\") {\n                  material.map = getNode(textureNode);\n                } else {}\n              }\n\n              break;\n\n            case \"textureTransform\":\n              if (fieldValues[0] !== null) {\n                transformData = getNode(fieldValues[0]);\n              }\n\n              break;\n\n            default:\n              console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n              break;\n          }\n        }\n\n        if (material.map) {\n          if (material.map.__type) {\n            switch (material.map.__type) {\n              case TEXTURE_TYPE.INTENSITY_ALPHA:\n                material.opacity = 1;\n                break;\n\n              case TEXTURE_TYPE.RGB:\n                material.color.set(16777215);\n                break;\n\n              case TEXTURE_TYPE.RGBA:\n                material.color.set(16777215);\n                material.opacity = 1;\n                break;\n\n              default:\n            }\n\n            delete material.map.__type;\n          }\n\n          if (transformData) {\n            material.map.center.copy(transformData.center);\n            material.map.rotation = transformData.rotation;\n            material.map.repeat.copy(transformData.scale);\n            material.map.offset.copy(transformData.translation);\n          }\n        }\n\n        return material;\n      }\n\n      function buildMaterialNode(node) {\n        var materialData = {};\n        var fields = node.fields;\n\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case \"ambientIntensity\":\n              break;\n\n            case \"diffuseColor\":\n              materialData.diffuseColor = new Color(fieldValues[0], fieldValues[1], fieldValues[2]);\n              break;\n\n            case \"emissiveColor\":\n              materialData.emissiveColor = new Color(fieldValues[0], fieldValues[1], fieldValues[2]);\n              break;\n\n            case \"shininess\":\n              materialData.shininess = fieldValues[0];\n              break;\n\n            case \"specularColor\":\n              materialData.emissiveColor = new Color(fieldValues[0], fieldValues[1], fieldValues[2]);\n              break;\n\n            case \"transparency\":\n              materialData.transparency = fieldValues[0];\n              break;\n\n            default:\n              console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n              break;\n          }\n        }\n\n        return materialData;\n      }\n\n      function parseHexColor(hex, textureType, color) {\n        var value;\n\n        switch (textureType) {\n          case TEXTURE_TYPE.INTENSITY:\n            value = parseInt(hex);\n            color.r = value;\n            color.g = value;\n            color.b = value;\n            color.a = 1;\n            break;\n\n          case TEXTURE_TYPE.INTENSITY_ALPHA:\n            value = parseInt(\"0x\" + hex.substring(2, 4));\n            color.r = value;\n            color.g = value;\n            color.b = value;\n            color.a = parseInt(\"0x\" + hex.substring(4, 6));\n            break;\n\n          case TEXTURE_TYPE.RGB:\n            color.r = parseInt(\"0x\" + hex.substring(2, 4));\n            color.g = parseInt(\"0x\" + hex.substring(4, 6));\n            color.b = parseInt(\"0x\" + hex.substring(6, 8));\n            color.a = 1;\n            break;\n\n          case TEXTURE_TYPE.RGBA:\n            color.r = parseInt(\"0x\" + hex.substring(2, 4));\n            color.g = parseInt(\"0x\" + hex.substring(4, 6));\n            color.b = parseInt(\"0x\" + hex.substring(6, 8));\n            color.a = parseInt(\"0x\" + hex.substring(8, 10));\n            break;\n\n          default:\n        }\n      }\n\n      function getTextureType(num_components) {\n        var type;\n\n        switch (num_components) {\n          case 1:\n            type = TEXTURE_TYPE.INTENSITY;\n            break;\n\n          case 2:\n            type = TEXTURE_TYPE.INTENSITY_ALPHA;\n            break;\n\n          case 3:\n            type = TEXTURE_TYPE.RGB;\n            break;\n\n          case 4:\n            type = TEXTURE_TYPE.RGBA;\n            break;\n\n          default:\n        }\n\n        return type;\n      }\n\n      function buildPixelTextureNode(node) {\n        var texture;\n        var wrapS = RepeatWrapping;\n        var wrapT = RepeatWrapping;\n        var fields = node.fields;\n\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case \"image\":\n              var width = fieldValues[0];\n              var height = fieldValues[1];\n              var num_components = fieldValues[2];\n              var textureType = getTextureType(num_components);\n              var data2 = new Uint8Array(4 * width * height);\n              var color = {\n                r: 0,\n                g: 0,\n                b: 0,\n                a: 0\n              };\n\n              for (var j = 3, k = 0, jl = fieldValues.length; j < jl; j++, k++) {\n                parseHexColor(fieldValues[j], textureType, color);\n                var stride = k * 4;\n                data2[stride + 0] = color.r;\n                data2[stride + 1] = color.g;\n                data2[stride + 2] = color.b;\n                data2[stride + 3] = color.a;\n              }\n\n              texture = new DataTexture(data2, width, height);\n              texture.needsUpdate = true;\n              texture.__type = textureType;\n              break;\n\n            case \"repeatS\":\n              if (fieldValues[0] === false) wrapS = ClampToEdgeWrapping;\n              break;\n\n            case \"repeatT\":\n              if (fieldValues[0] === false) wrapT = ClampToEdgeWrapping;\n              break;\n\n            default:\n              console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n              break;\n          }\n        }\n\n        if (texture) {\n          texture.wrapS = wrapS;\n          texture.wrapT = wrapT;\n        }\n\n        return texture;\n      }\n\n      function buildImageTextureNode(node) {\n        var texture;\n        var wrapS = RepeatWrapping;\n        var wrapT = RepeatWrapping;\n        var fields = node.fields;\n\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case \"url\":\n              var url = fieldValues[0];\n              if (url) texture = textureLoader.load(url);\n              break;\n\n            case \"repeatS\":\n              if (fieldValues[0] === false) wrapS = ClampToEdgeWrapping;\n              break;\n\n            case \"repeatT\":\n              if (fieldValues[0] === false) wrapT = ClampToEdgeWrapping;\n              break;\n\n            default:\n              console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n              break;\n          }\n        }\n\n        if (texture) {\n          texture.wrapS = wrapS;\n          texture.wrapT = wrapT;\n        }\n\n        return texture;\n      }\n\n      function buildTextureTransformNode(node) {\n        var transformData = {\n          center: new Vector2(),\n          rotation: new Vector2(),\n          scale: new Vector2(),\n          translation: new Vector2()\n        };\n        var fields = node.fields;\n\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case \"center\":\n              transformData.center.set(fieldValues[0], fieldValues[1]);\n              break;\n\n            case \"rotation\":\n              transformData.rotation = fieldValues[0];\n              break;\n\n            case \"scale\":\n              transformData.scale.set(fieldValues[0], fieldValues[1]);\n              break;\n\n            case \"translation\":\n              transformData.translation.set(fieldValues[0], fieldValues[1]);\n              break;\n\n            default:\n              console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n              break;\n          }\n        }\n\n        return transformData;\n      }\n\n      function buildGeometricNode(node) {\n        return node.fields[0].values;\n      }\n\n      function buildWorldInfoNode(node) {\n        var worldInfo = {};\n        var fields = node.fields;\n\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case \"title\":\n              worldInfo.title = fieldValues[0];\n              break;\n\n            case \"info\":\n              worldInfo.info = fieldValues;\n              break;\n\n            default:\n              console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n              break;\n          }\n        }\n\n        return worldInfo;\n      }\n\n      function buildIndexedFaceSetNode(node) {\n        var color, coord, normal, texCoord;\n        var ccw = true,\n            solid = true,\n            creaseAngle = 0;\n        var colorIndex, coordIndex, normalIndex, texCoordIndex;\n        var colorPerVertex = true,\n            normalPerVertex = true;\n        var fields = node.fields;\n\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case \"color\":\n              var colorNode = fieldValues[0];\n\n              if (colorNode !== null) {\n                color = getNode(colorNode);\n              }\n\n              break;\n\n            case \"coord\":\n              var coordNode = fieldValues[0];\n\n              if (coordNode !== null) {\n                coord = getNode(coordNode);\n              }\n\n              break;\n\n            case \"normal\":\n              var normalNode = fieldValues[0];\n\n              if (normalNode !== null) {\n                normal = getNode(normalNode);\n              }\n\n              break;\n\n            case \"texCoord\":\n              var texCoordNode = fieldValues[0];\n\n              if (texCoordNode !== null) {\n                texCoord = getNode(texCoordNode);\n              }\n\n              break;\n\n            case \"ccw\":\n              ccw = fieldValues[0];\n              break;\n\n            case \"colorIndex\":\n              colorIndex = fieldValues;\n              break;\n\n            case \"colorPerVertex\":\n              colorPerVertex = fieldValues[0];\n              break;\n\n            case \"convex\":\n              break;\n\n            case \"coordIndex\":\n              coordIndex = fieldValues;\n              break;\n\n            case \"creaseAngle\":\n              creaseAngle = fieldValues[0];\n              break;\n\n            case \"normalIndex\":\n              normalIndex = fieldValues;\n              break;\n\n            case \"normalPerVertex\":\n              normalPerVertex = fieldValues[0];\n              break;\n\n            case \"solid\":\n              solid = fieldValues[0];\n              break;\n\n            case \"texCoordIndex\":\n              texCoordIndex = fieldValues;\n              break;\n\n            default:\n              console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n              break;\n          }\n        }\n\n        if (coordIndex === void 0) {\n          console.warn(\"THREE.VRMLLoader: Missing coordIndex.\");\n          return new BufferGeometry();\n        }\n\n        var triangulatedCoordIndex = triangulateFaceIndex(coordIndex, ccw);\n        var colorAttribute;\n        var normalAttribute;\n        var uvAttribute;\n\n        if (color) {\n          if (colorPerVertex === true) {\n            if (colorIndex && colorIndex.length > 0) {\n              var triangulatedColorIndex = triangulateFaceIndex(colorIndex, ccw);\n              colorAttribute = computeAttributeFromIndexedData(triangulatedCoordIndex, triangulatedColorIndex, color, 3);\n            } else {\n              colorAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(color, 3));\n            }\n          } else {\n            if (colorIndex && colorIndex.length > 0) {\n              var flattenFaceColors = flattenData(color, colorIndex);\n              var triangulatedFaceColors = triangulateFaceData(flattenFaceColors, coordIndex);\n              colorAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceColors);\n            } else {\n              var _triangulatedFaceColors = triangulateFaceData(color, coordIndex);\n\n              colorAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, _triangulatedFaceColors);\n            }\n          }\n        }\n\n        if (normal) {\n          if (normalPerVertex === true) {\n            if (normalIndex && normalIndex.length > 0) {\n              var triangulatedNormalIndex = triangulateFaceIndex(normalIndex, ccw);\n              normalAttribute = computeAttributeFromIndexedData(triangulatedCoordIndex, triangulatedNormalIndex, normal, 3);\n            } else {\n              normalAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(normal, 3));\n            }\n          } else {\n            if (normalIndex && normalIndex.length > 0) {\n              var flattenFaceNormals = flattenData(normal, normalIndex);\n              var triangulatedFaceNormals = triangulateFaceData(flattenFaceNormals, coordIndex);\n              normalAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceNormals);\n            } else {\n              var _triangulatedFaceNormals = triangulateFaceData(normal, coordIndex);\n\n              normalAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, _triangulatedFaceNormals);\n            }\n          }\n        } else {\n          normalAttribute = computeNormalAttribute(triangulatedCoordIndex, coord, creaseAngle);\n        }\n\n        if (texCoord) {\n          if (texCoordIndex && texCoordIndex.length > 0) {\n            var triangulatedTexCoordIndex = triangulateFaceIndex(texCoordIndex, ccw);\n            uvAttribute = computeAttributeFromIndexedData(triangulatedCoordIndex, triangulatedTexCoordIndex, texCoord, 2);\n          } else {\n            uvAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(texCoord, 2));\n          }\n        }\n\n        var geometry = new BufferGeometry();\n        var positionAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(coord, 3));\n        geometry.setAttribute(\"position\", positionAttribute);\n        geometry.setAttribute(\"normal\", normalAttribute);\n        if (colorAttribute) geometry.setAttribute(\"color\", colorAttribute);\n        if (uvAttribute) geometry.setAttribute(\"uv\", uvAttribute);\n        geometry._solid = solid;\n        geometry._type = \"mesh\";\n        return geometry;\n      }\n\n      function buildIndexedLineSetNode(node) {\n        var color, coord;\n        var colorIndex, coordIndex;\n        var colorPerVertex = true;\n        var fields = node.fields;\n\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case \"color\":\n              var colorNode = fieldValues[0];\n\n              if (colorNode !== null) {\n                color = getNode(colorNode);\n              }\n\n              break;\n\n            case \"coord\":\n              var coordNode = fieldValues[0];\n\n              if (coordNode !== null) {\n                coord = getNode(coordNode);\n              }\n\n              break;\n\n            case \"colorIndex\":\n              colorIndex = fieldValues;\n              break;\n\n            case \"colorPerVertex\":\n              colorPerVertex = fieldValues[0];\n              break;\n\n            case \"coordIndex\":\n              coordIndex = fieldValues;\n              break;\n\n            default:\n              console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n              break;\n          }\n        }\n\n        var colorAttribute;\n        var expandedLineIndex = expandLineIndex(coordIndex);\n\n        if (color) {\n          if (colorPerVertex === true) {\n            if (colorIndex.length > 0) {\n              var expandedColorIndex = expandLineIndex(colorIndex);\n              colorAttribute = computeAttributeFromIndexedData(expandedLineIndex, expandedColorIndex, color, 3);\n            } else {\n              colorAttribute = toNonIndexedAttribute(expandedLineIndex, new Float32BufferAttribute(color, 3));\n            }\n          } else {\n            if (colorIndex.length > 0) {\n              var flattenLineColors = flattenData(color, colorIndex);\n              var expandedLineColors = expandLineData(flattenLineColors, coordIndex);\n              colorAttribute = computeAttributeFromLineData(expandedLineIndex, expandedLineColors);\n            } else {\n              var _expandedLineColors = expandLineData(color, coordIndex);\n\n              colorAttribute = computeAttributeFromLineData(expandedLineIndex, _expandedLineColors);\n            }\n          }\n        }\n\n        var geometry = new BufferGeometry();\n        var positionAttribute = toNonIndexedAttribute(expandedLineIndex, new Float32BufferAttribute(coord, 3));\n        geometry.setAttribute(\"position\", positionAttribute);\n        if (colorAttribute) geometry.setAttribute(\"color\", colorAttribute);\n        geometry._type = \"line\";\n        return geometry;\n      }\n\n      function buildPointSetNode(node) {\n        var color, coord;\n        var fields = node.fields;\n\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case \"color\":\n              var colorNode = fieldValues[0];\n\n              if (colorNode !== null) {\n                color = getNode(colorNode);\n              }\n\n              break;\n\n            case \"coord\":\n              var coordNode = fieldValues[0];\n\n              if (coordNode !== null) {\n                coord = getNode(coordNode);\n              }\n\n              break;\n\n            default:\n              console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n              break;\n          }\n        }\n\n        var geometry = new BufferGeometry();\n        geometry.setAttribute(\"position\", new Float32BufferAttribute(coord, 3));\n        if (color) geometry.setAttribute(\"color\", new Float32BufferAttribute(color, 3));\n        geometry._type = \"points\";\n        return geometry;\n      }\n\n      function buildBoxNode(node) {\n        var size = new Vector3(2, 2, 2);\n        var fields = node.fields;\n\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case \"size\":\n              size.x = fieldValues[0];\n              size.y = fieldValues[1];\n              size.z = fieldValues[2];\n              break;\n\n            default:\n              console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n              break;\n          }\n        }\n\n        var geometry = new BoxGeometry(size.x, size.y, size.z);\n        return geometry;\n      }\n\n      function buildConeNode(node) {\n        var radius = 1,\n            height = 2,\n            openEnded = false;\n        var fields = node.fields;\n\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case \"bottom\":\n              openEnded = !fieldValues[0];\n              break;\n\n            case \"bottomRadius\":\n              radius = fieldValues[0];\n              break;\n\n            case \"height\":\n              height = fieldValues[0];\n              break;\n\n            case \"side\":\n              break;\n\n            default:\n              console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n              break;\n          }\n        }\n\n        var geometry = new ConeGeometry(radius, height, 16, 1, openEnded);\n        return geometry;\n      }\n\n      function buildCylinderNode(node) {\n        var radius = 1,\n            height = 2;\n        var fields = node.fields;\n\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case \"bottom\":\n              break;\n\n            case \"radius\":\n              radius = fieldValues[0];\n              break;\n\n            case \"height\":\n              height = fieldValues[0];\n              break;\n\n            case \"side\":\n              break;\n\n            case \"top\":\n              break;\n\n            default:\n              console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n              break;\n          }\n        }\n\n        var geometry = new CylinderGeometry(radius, radius, height, 16, 1);\n        return geometry;\n      }\n\n      function buildSphereNode(node) {\n        var radius = 1;\n        var fields = node.fields;\n\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case \"radius\":\n              radius = fieldValues[0];\n              break;\n\n            default:\n              console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n              break;\n          }\n        }\n\n        var geometry = new SphereGeometry(radius, 16, 16);\n        return geometry;\n      }\n\n      function buildElevationGridNode(node) {\n        var color;\n        var normal;\n        var texCoord;\n        var height;\n        var colorPerVertex = true;\n        var normalPerVertex = true;\n        var solid = true;\n        var ccw = true;\n        var creaseAngle = 0;\n        var xDimension = 2;\n        var zDimension = 2;\n        var xSpacing = 1;\n        var zSpacing = 1;\n        var fields = node.fields;\n\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case \"color\":\n              var colorNode = fieldValues[0];\n\n              if (colorNode !== null) {\n                color = getNode(colorNode);\n              }\n\n              break;\n\n            case \"normal\":\n              var normalNode = fieldValues[0];\n\n              if (normalNode !== null) {\n                normal = getNode(normalNode);\n              }\n\n              break;\n\n            case \"texCoord\":\n              var texCoordNode = fieldValues[0];\n\n              if (texCoordNode !== null) {\n                texCoord = getNode(texCoordNode);\n              }\n\n              break;\n\n            case \"height\":\n              height = fieldValues;\n              break;\n\n            case \"ccw\":\n              ccw = fieldValues[0];\n              break;\n\n            case \"colorPerVertex\":\n              colorPerVertex = fieldValues[0];\n              break;\n\n            case \"creaseAngle\":\n              creaseAngle = fieldValues[0];\n              break;\n\n            case \"normalPerVertex\":\n              normalPerVertex = fieldValues[0];\n              break;\n\n            case \"solid\":\n              solid = fieldValues[0];\n              break;\n\n            case \"xDimension\":\n              xDimension = fieldValues[0];\n              break;\n\n            case \"xSpacing\":\n              xSpacing = fieldValues[0];\n              break;\n\n            case \"zDimension\":\n              zDimension = fieldValues[0];\n              break;\n\n            case \"zSpacing\":\n              zSpacing = fieldValues[0];\n              break;\n\n            default:\n              console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n              break;\n          }\n        }\n\n        var vertices = [];\n        var normals = [];\n        var colors = [];\n        var uvs = [];\n\n        for (var _i9 = 0; _i9 < zDimension; _i9++) {\n          for (var j = 0; j < xDimension; j++) {\n            var index = _i9 * xDimension + j;\n            var x = xSpacing * _i9;\n            var y = height[index];\n            var z = zSpacing * j;\n            vertices.push(x, y, z);\n\n            if (color && colorPerVertex === true) {\n              var r = color[index * 3 + 0];\n              var g = color[index * 3 + 1];\n              var b = color[index * 3 + 2];\n              colors.push(r, g, b);\n            }\n\n            if (normal && normalPerVertex === true) {\n              var xn = normal[index * 3 + 0];\n              var yn = normal[index * 3 + 1];\n              var zn = normal[index * 3 + 2];\n              normals.push(xn, yn, zn);\n            }\n\n            if (texCoord) {\n              var s = texCoord[index * 2 + 0];\n              var t = texCoord[index * 2 + 1];\n              uvs.push(s, t);\n            } else {\n              uvs.push(_i9 / (xDimension - 1), j / (zDimension - 1));\n            }\n          }\n        }\n\n        var indices = [];\n\n        for (var _i10 = 0; _i10 < xDimension - 1; _i10++) {\n          for (var _j = 0; _j < zDimension - 1; _j++) {\n            var a = _i10 + _j * xDimension;\n\n            var _b = _i10 + (_j + 1) * xDimension;\n\n            var c = _i10 + 1 + (_j + 1) * xDimension;\n            var d = _i10 + 1 + _j * xDimension;\n\n            if (ccw === true) {\n              indices.push(a, c, _b);\n              indices.push(c, a, d);\n            } else {\n              indices.push(a, _b, c);\n              indices.push(c, d, a);\n            }\n          }\n        }\n\n        var positionAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(vertices, 3));\n        var uvAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(uvs, 2));\n        var colorAttribute;\n        var normalAttribute;\n\n        if (color) {\n          if (colorPerVertex === false) {\n            for (var _i11 = 0; _i11 < xDimension - 1; _i11++) {\n              for (var _j2 = 0; _j2 < zDimension - 1; _j2++) {\n                var _index = _i11 + _j2 * (xDimension - 1);\n\n                var _r = color[_index * 3 + 0];\n                var _g = color[_index * 3 + 1];\n                var _b2 = color[_index * 3 + 2];\n                colors.push(_r, _g, _b2);\n                colors.push(_r, _g, _b2);\n                colors.push(_r, _g, _b2);\n                colors.push(_r, _g, _b2);\n                colors.push(_r, _g, _b2);\n                colors.push(_r, _g, _b2);\n              }\n            }\n\n            colorAttribute = new Float32BufferAttribute(colors, 3);\n          } else {\n            colorAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(colors, 3));\n          }\n        }\n\n        if (normal) {\n          if (normalPerVertex === false) {\n            for (var _i12 = 0; _i12 < xDimension - 1; _i12++) {\n              for (var _j3 = 0; _j3 < zDimension - 1; _j3++) {\n                var _index2 = _i12 + _j3 * (xDimension - 1);\n\n                var _xn = normal[_index2 * 3 + 0];\n                var _yn = normal[_index2 * 3 + 1];\n                var _zn = normal[_index2 * 3 + 2];\n                normals.push(_xn, _yn, _zn);\n                normals.push(_xn, _yn, _zn);\n                normals.push(_xn, _yn, _zn);\n                normals.push(_xn, _yn, _zn);\n                normals.push(_xn, _yn, _zn);\n                normals.push(_xn, _yn, _zn);\n              }\n            }\n\n            normalAttribute = new Float32BufferAttribute(normals, 3);\n          } else {\n            normalAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(normals, 3));\n          }\n        } else {\n          normalAttribute = computeNormalAttribute(indices, vertices, creaseAngle);\n        }\n\n        var geometry = new BufferGeometry();\n        geometry.setAttribute(\"position\", positionAttribute);\n        geometry.setAttribute(\"normal\", normalAttribute);\n        geometry.setAttribute(\"uv\", uvAttribute);\n        if (colorAttribute) geometry.setAttribute(\"color\", colorAttribute);\n        geometry._solid = solid;\n        geometry._type = \"mesh\";\n        return geometry;\n      }\n\n      function buildExtrusionNode(node) {\n        var crossSection = [1, 1, 1, -1, -1, -1, -1, 1, 1, 1];\n        var spine = [0, 0, 0, 0, 1, 0];\n        var scale;\n        var orientation;\n        var beginCap = true;\n        var ccw = true;\n        var creaseAngle = 0;\n        var endCap = true;\n        var solid = true;\n        var fields = node.fields;\n\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case \"beginCap\":\n              beginCap = fieldValues[0];\n              break;\n\n            case \"ccw\":\n              ccw = fieldValues[0];\n              break;\n\n            case \"convex\":\n              break;\n\n            case \"creaseAngle\":\n              creaseAngle = fieldValues[0];\n              break;\n\n            case \"crossSection\":\n              crossSection = fieldValues;\n              break;\n\n            case \"endCap\":\n              endCap = fieldValues[0];\n              break;\n\n            case \"orientation\":\n              orientation = fieldValues;\n              break;\n\n            case \"scale\":\n              scale = fieldValues;\n              break;\n\n            case \"solid\":\n              solid = fieldValues[0];\n              break;\n\n            case \"spine\":\n              spine = fieldValues;\n              break;\n\n            default:\n              console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n              break;\n          }\n        }\n\n        var crossSectionClosed = crossSection[0] === crossSection[crossSection.length - 2] && crossSection[1] === crossSection[crossSection.length - 1];\n        var vertices = [];\n        var spineVector = new Vector3();\n        var scaling = new Vector3();\n        var axis = new Vector3();\n        var vertex = new Vector3();\n        var quaternion = new Quaternion();\n\n        for (var _i13 = 0, j = 0, o = 0, il = spine.length; _i13 < il; _i13 += 3, j += 2, o += 4) {\n          spineVector.fromArray(spine, _i13);\n          scaling.x = scale ? scale[j + 0] : 1;\n          scaling.y = 1;\n          scaling.z = scale ? scale[j + 1] : 1;\n          axis.x = orientation ? orientation[o + 0] : 0;\n          axis.y = orientation ? orientation[o + 1] : 0;\n          axis.z = orientation ? orientation[o + 2] : 1;\n          var angle = orientation ? orientation[o + 3] : 0;\n\n          for (var k = 0, kl = crossSection.length; k < kl; k += 2) {\n            vertex.x = crossSection[k + 0];\n            vertex.y = 0;\n            vertex.z = crossSection[k + 1];\n            vertex.multiply(scaling);\n            quaternion.setFromAxisAngle(axis, angle);\n            vertex.applyQuaternion(quaternion);\n            vertex.add(spineVector);\n            vertices.push(vertex.x, vertex.y, vertex.z);\n          }\n        }\n\n        var indices = [];\n        var spineCount = spine.length / 3;\n        var crossSectionCount = crossSection.length / 2;\n\n        for (var _i14 = 0; _i14 < spineCount - 1; _i14++) {\n          for (var _j4 = 0; _j4 < crossSectionCount - 1; _j4++) {\n            var a = _j4 + _i14 * crossSectionCount;\n            var b = _j4 + 1 + _i14 * crossSectionCount;\n            var c = _j4 + (_i14 + 1) * crossSectionCount;\n            var d = _j4 + 1 + (_i14 + 1) * crossSectionCount;\n\n            if (_j4 === crossSectionCount - 2 && crossSectionClosed === true) {\n              b = _i14 * crossSectionCount;\n              d = (_i14 + 1) * crossSectionCount;\n            }\n\n            if (ccw === true) {\n              indices.push(a, b, c);\n              indices.push(c, b, d);\n            } else {\n              indices.push(a, c, b);\n              indices.push(c, d, b);\n            }\n          }\n        }\n\n        if (beginCap === true || endCap === true) {\n          var contour = [];\n\n          for (var _i15 = 0, _l9 = crossSection.length; _i15 < _l9; _i15 += 2) {\n            contour.push(new Vector2(crossSection[_i15], crossSection[_i15 + 1]));\n          }\n\n          var faces = ShapeUtils.triangulateShape(contour, []);\n          var capIndices = [];\n\n          for (var _i16 = 0, _l10 = faces.length; _i16 < _l10; _i16++) {\n            var face = faces[_i16];\n            capIndices.push(face[0], face[1], face[2]);\n          }\n\n          if (beginCap === true) {\n            for (var _i17 = 0, _l11 = capIndices.length; _i17 < _l11; _i17 += 3) {\n              if (ccw === true) {\n                indices.push(capIndices[_i17 + 0], capIndices[_i17 + 1], capIndices[_i17 + 2]);\n              } else {\n                indices.push(capIndices[_i17 + 0], capIndices[_i17 + 2], capIndices[_i17 + 1]);\n              }\n            }\n          }\n\n          if (endCap === true) {\n            var indexOffset = crossSectionCount * (spineCount - 1);\n\n            for (var _i18 = 0, _l12 = capIndices.length; _i18 < _l12; _i18 += 3) {\n              if (ccw === true) {\n                indices.push(indexOffset + capIndices[_i18 + 0], indexOffset + capIndices[_i18 + 2], indexOffset + capIndices[_i18 + 1]);\n              } else {\n                indices.push(indexOffset + capIndices[_i18 + 0], indexOffset + capIndices[_i18 + 1], indexOffset + capIndices[_i18 + 2]);\n              }\n            }\n          }\n        }\n\n        var positionAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(vertices, 3));\n        var normalAttribute = computeNormalAttribute(indices, vertices, creaseAngle);\n        var geometry = new BufferGeometry();\n        geometry.setAttribute(\"position\", positionAttribute);\n        geometry.setAttribute(\"normal\", normalAttribute);\n        geometry._solid = solid;\n        geometry._type = \"mesh\";\n        return geometry;\n      }\n\n      function resolveUSE(identifier) {\n        var node = nodeMap[identifier];\n        var build = getNode(node);\n        return build.isObject3D || build.isMaterial ? build.clone() : build;\n      }\n\n      function parseFieldChildren(children, owner) {\n        for (var i = 0, l = children.length; i < l; i++) {\n          var object = getNode(children[i]);\n          if (object instanceof Object3D) owner.add(object);\n        }\n      }\n\n      function triangulateFaceIndex(index, ccw) {\n        var indices = [];\n        var start = 0;\n\n        for (var i = 0, l = index.length; i < l; i++) {\n          var i1 = index[start];\n          var i2 = index[i + (ccw ? 1 : 2)];\n          var i3 = index[i + (ccw ? 2 : 1)];\n          indices.push(i1, i2, i3);\n\n          if (index[i + 3] === -1 || i + 3 >= l) {\n            i += 3;\n            start = i + 1;\n          }\n        }\n\n        return indices;\n      }\n\n      function triangulateFaceData(data2, index) {\n        var triangulatedData = [];\n        var start = 0;\n\n        for (var i = 0, l = index.length; i < l; i++) {\n          var stride = start * 3;\n          var x = data2[stride];\n          var y = data2[stride + 1];\n          var z = data2[stride + 2];\n          triangulatedData.push(x, y, z);\n\n          if (index[i + 3] === -1 || i + 3 >= l) {\n            i += 3;\n            start++;\n          }\n        }\n\n        return triangulatedData;\n      }\n\n      function flattenData(data2, index) {\n        var flattenData2 = [];\n\n        for (var i = 0, l = index.length; i < l; i++) {\n          var i1 = index[i];\n          var stride = i1 * 3;\n          var x = data2[stride];\n          var y = data2[stride + 1];\n          var z = data2[stride + 2];\n          flattenData2.push(x, y, z);\n        }\n\n        return flattenData2;\n      }\n\n      function expandLineIndex(index) {\n        var indices = [];\n\n        for (var i = 0, l = index.length; i < l; i++) {\n          var i1 = index[i];\n          var i2 = index[i + 1];\n          indices.push(i1, i2);\n\n          if (index[i + 2] === -1 || i + 2 >= l) {\n            i += 2;\n          }\n        }\n\n        return indices;\n      }\n\n      function expandLineData(data2, index) {\n        var triangulatedData = [];\n        var start = 0;\n\n        for (var i = 0, l = index.length; i < l; i++) {\n          var stride = start * 3;\n          var x = data2[stride];\n          var y = data2[stride + 1];\n          var z = data2[stride + 2];\n          triangulatedData.push(x, y, z);\n\n          if (index[i + 2] === -1 || i + 2 >= l) {\n            i += 2;\n            start++;\n          }\n        }\n\n        return triangulatedData;\n      }\n\n      var vA = new Vector3();\n      var vB = new Vector3();\n      var vC = new Vector3();\n      var uvA = new Vector2();\n      var uvB = new Vector2();\n      var uvC = new Vector2();\n\n      function computeAttributeFromIndexedData(coordIndex, index, data2, itemSize) {\n        var array = [];\n\n        for (var i = 0, l = coordIndex.length; i < l; i += 3) {\n          var a = index[i];\n          var b = index[i + 1];\n          var c = index[i + 2];\n\n          if (itemSize === 2) {\n            uvA.fromArray(data2, a * itemSize);\n            uvB.fromArray(data2, b * itemSize);\n            uvC.fromArray(data2, c * itemSize);\n            array.push(uvA.x, uvA.y);\n            array.push(uvB.x, uvB.y);\n            array.push(uvC.x, uvC.y);\n          } else {\n            vA.fromArray(data2, a * itemSize);\n            vB.fromArray(data2, b * itemSize);\n            vC.fromArray(data2, c * itemSize);\n            array.push(vA.x, vA.y, vA.z);\n            array.push(vB.x, vB.y, vB.z);\n            array.push(vC.x, vC.y, vC.z);\n          }\n        }\n\n        return new Float32BufferAttribute(array, itemSize);\n      }\n\n      function computeAttributeFromFaceData(index, faceData) {\n        var array = [];\n\n        for (var i = 0, j = 0, l = index.length; i < l; i += 3, j++) {\n          vA.fromArray(faceData, j * 3);\n          array.push(vA.x, vA.y, vA.z);\n          array.push(vA.x, vA.y, vA.z);\n          array.push(vA.x, vA.y, vA.z);\n        }\n\n        return new Float32BufferAttribute(array, 3);\n      }\n\n      function computeAttributeFromLineData(index, lineData) {\n        var array = [];\n\n        for (var i = 0, j = 0, l = index.length; i < l; i += 2, j++) {\n          vA.fromArray(lineData, j * 3);\n          array.push(vA.x, vA.y, vA.z);\n          array.push(vA.x, vA.y, vA.z);\n        }\n\n        return new Float32BufferAttribute(array, 3);\n      }\n\n      function toNonIndexedAttribute(indices, attribute) {\n        var array = attribute.array;\n        var itemSize = attribute.itemSize;\n        var array2 = new array.constructor(indices.length * itemSize);\n        var index = 0,\n            index2 = 0;\n\n        for (var i = 0, l = indices.length; i < l; i++) {\n          index = indices[i] * itemSize;\n\n          for (var j = 0; j < itemSize; j++) {\n            array2[index2++] = array[index++];\n          }\n        }\n\n        return new Float32BufferAttribute(array2, itemSize);\n      }\n\n      var ab = new Vector3();\n      var cb = new Vector3();\n\n      function computeNormalAttribute(index, coord, creaseAngle) {\n        var faces = [];\n        var vertexNormals = {};\n\n        for (var i = 0, l = index.length; i < l; i += 3) {\n          var a = index[i];\n          var b = index[i + 1];\n          var c = index[i + 2];\n          var face = new Face(a, b, c);\n          vA.fromArray(coord, a * 3);\n          vB.fromArray(coord, b * 3);\n          vC.fromArray(coord, c * 3);\n          cb.subVectors(vC, vB);\n          ab.subVectors(vA, vB);\n          cb.cross(ab);\n          cb.normalize();\n          face.normal.copy(cb);\n          if (vertexNormals[a] === void 0) vertexNormals[a] = [];\n          if (vertexNormals[b] === void 0) vertexNormals[b] = [];\n          if (vertexNormals[c] === void 0) vertexNormals[c] = [];\n          vertexNormals[a].push(face.normal);\n          vertexNormals[b].push(face.normal);\n          vertexNormals[c].push(face.normal);\n          faces.push(face);\n        }\n\n        var normals = [];\n\n        for (var _i19 = 0, _l13 = faces.length; _i19 < _l13; _i19++) {\n          var _face = faces[_i19];\n          var nA = weightedNormal(vertexNormals[_face.a], _face.normal, creaseAngle);\n          var nB = weightedNormal(vertexNormals[_face.b], _face.normal, creaseAngle);\n          var nC = weightedNormal(vertexNormals[_face.c], _face.normal, creaseAngle);\n          vA.fromArray(coord, _face.a * 3);\n          vB.fromArray(coord, _face.b * 3);\n          vC.fromArray(coord, _face.c * 3);\n          normals.push(nA.x, nA.y, nA.z);\n          normals.push(nB.x, nB.y, nB.z);\n          normals.push(nC.x, nC.y, nC.z);\n        }\n\n        return new Float32BufferAttribute(normals, 3);\n      }\n\n      function weightedNormal(normals, vector, creaseAngle) {\n        var normal = new Vector3();\n\n        if (creaseAngle === 0) {\n          normal.copy(vector);\n        } else {\n          for (var i = 0, l = normals.length; i < l; i++) {\n            if (normals[i].angleTo(vector) < creaseAngle) {\n              normal.add(normals[i]);\n            }\n          }\n        }\n\n        return normal.normalize();\n      }\n\n      function toColorArray(colors) {\n        var array = [];\n\n        for (var i = 0, l = colors.length; i < l; i += 3) {\n          array.push(new Color(colors[i], colors[i + 1], colors[i + 2]));\n        }\n\n        return array;\n      }\n\n      function paintFaces(geometry, radius, angles, colors, topDown) {\n        var thresholds = [];\n        var startAngle = topDown === true ? 0 : Math.PI;\n\n        for (var i = 0, l = colors.length; i < l; i++) {\n          var angle = i === 0 ? 0 : angles[i - 1];\n          angle = topDown === true ? angle : startAngle - angle;\n          var point = new Vector3();\n          point.setFromSphericalCoords(radius, angle, 0);\n          thresholds.push(point);\n        }\n\n        var indices = geometry.index;\n        var positionAttribute = geometry.attributes.position;\n        var colorAttribute = new BufferAttribute(new Float32Array(geometry.attributes.position.count * 3), 3);\n        var position = new Vector3();\n        var color = new Color();\n\n        for (var _i20 = 0; _i20 < indices.count; _i20++) {\n          var index = indices.getX(_i20);\n          position.fromBufferAttribute(positionAttribute, index);\n          var thresholdIndexA = void 0,\n              thresholdIndexB = void 0;\n          var t = 1;\n\n          for (var j = 1; j < thresholds.length; j++) {\n            thresholdIndexA = j - 1;\n            thresholdIndexB = j;\n            var thresholdA = thresholds[thresholdIndexA];\n            var thresholdB = thresholds[thresholdIndexB];\n\n            if (topDown === true) {\n              if (position.y <= thresholdA.y && position.y > thresholdB.y) {\n                t = Math.abs(thresholdA.y - position.y) / Math.abs(thresholdA.y - thresholdB.y);\n                break;\n              }\n            } else {\n              if (position.y >= thresholdA.y && position.y < thresholdB.y) {\n                t = Math.abs(thresholdA.y - position.y) / Math.abs(thresholdA.y - thresholdB.y);\n                break;\n              }\n            }\n          }\n\n          var colorA = colors[thresholdIndexA];\n          var colorB = colors[thresholdIndexB];\n          color.copy(colorA).lerp(colorB, t);\n          colorAttribute.setXYZ(index, color.r, color.g, color.b);\n        }\n\n        geometry.setAttribute(\"color\", colorAttribute);\n      }\n\n      var textureLoader = new TextureLoader(this.manager);\n      textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n\n      if (data.indexOf(\"#VRML V2.0\") === -1) {\n        throw Error(\"THREE.VRMLLexer: Version of VRML asset not supported.\");\n      }\n\n      var tree = generateVRMLTree(data);\n      var scene = parseTree(tree);\n      return scene;\n    }\n  }]);\n\n  return VRMLLoader;\n}(Loader);\n\nvar VRMLLexer = /*#__PURE__*/function () {\n  function VRMLLexer(tokens) {\n    _classCallCheck(this, VRMLLexer);\n\n    this.lexer = new Lexer(tokens);\n  }\n\n  _createClass(VRMLLexer, [{\n    key: \"lex\",\n    value: function lex(inputText) {\n      var lexingResult = this.lexer.tokenize(inputText);\n\n      if (lexingResult.errors.length > 0) {\n        console.error(lexingResult.errors);\n        throw Error(\"THREE.VRMLLexer: Lexing errors detected.\");\n      }\n\n      return lexingResult;\n    }\n  }]);\n\n  return VRMLLexer;\n}();\n\nvar VRMLParser = /*#__PURE__*/function (_CstParser) {\n  _inherits(VRMLParser, _CstParser);\n\n  var _super2 = _createSuper(VRMLParser);\n\n  function VRMLParser(tokenVocabulary) {\n    var _this;\n\n    _classCallCheck(this, VRMLParser);\n\n    _this = _super2.call(this, tokenVocabulary);\n\n    var $ = _assertThisInitialized(_this);\n\n    var Version = tokenVocabulary[\"Version\"];\n    var LCurly = tokenVocabulary[\"LCurly\"];\n    var RCurly = tokenVocabulary[\"RCurly\"];\n    var LSquare = tokenVocabulary[\"LSquare\"];\n    var RSquare = tokenVocabulary[\"RSquare\"];\n    var Identifier = tokenVocabulary[\"Identifier\"];\n    var RouteIdentifier = tokenVocabulary[\"RouteIdentifier\"];\n    var StringLiteral = tokenVocabulary[\"StringLiteral\"];\n    var HexLiteral = tokenVocabulary[\"HexLiteral\"];\n    var NumberLiteral = tokenVocabulary[\"NumberLiteral\"];\n    var TrueLiteral = tokenVocabulary[\"TrueLiteral\"];\n    var FalseLiteral = tokenVocabulary[\"FalseLiteral\"];\n    var NullLiteral = tokenVocabulary[\"NullLiteral\"];\n    var DEF = tokenVocabulary[\"DEF\"];\n    var USE = tokenVocabulary[\"USE\"];\n    var ROUTE = tokenVocabulary[\"ROUTE\"];\n    var TO = tokenVocabulary[\"TO\"];\n    var NodeName = tokenVocabulary[\"NodeName\"];\n    $.RULE(\"vrml\", function () {\n      $.SUBRULE($.version);\n      $.AT_LEAST_ONE(function () {\n        $.SUBRULE($.node);\n      });\n      $.MANY(function () {\n        $.SUBRULE($.route);\n      });\n    });\n    $.RULE(\"version\", function () {\n      $.CONSUME(Version);\n    });\n    $.RULE(\"node\", function () {\n      $.OPTION(function () {\n        $.SUBRULE($.def);\n      });\n      $.CONSUME(NodeName);\n      $.CONSUME(LCurly);\n      $.MANY(function () {\n        $.SUBRULE($.field);\n      });\n      $.CONSUME(RCurly);\n    });\n    $.RULE(\"field\", function () {\n      $.CONSUME(Identifier);\n      $.OR2([{\n        ALT: function ALT() {\n          $.SUBRULE($.singleFieldValue);\n        }\n      }, {\n        ALT: function ALT() {\n          $.SUBRULE($.multiFieldValue);\n        }\n      }]);\n    });\n    $.RULE(\"def\", function () {\n      $.CONSUME(DEF);\n      $.OR([{\n        ALT: function ALT() {\n          $.CONSUME(Identifier);\n        }\n      }, {\n        ALT: function ALT() {\n          $.CONSUME(NodeName);\n        }\n      }]);\n    });\n    $.RULE(\"use\", function () {\n      $.CONSUME(USE);\n      $.OR([{\n        ALT: function ALT() {\n          $.CONSUME(Identifier);\n        }\n      }, {\n        ALT: function ALT() {\n          $.CONSUME(NodeName);\n        }\n      }]);\n    });\n    $.RULE(\"singleFieldValue\", function () {\n      $.AT_LEAST_ONE(function () {\n        $.OR([{\n          ALT: function ALT() {\n            $.SUBRULE($.node);\n          }\n        }, {\n          ALT: function ALT() {\n            $.SUBRULE($.use);\n          }\n        }, {\n          ALT: function ALT() {\n            $.CONSUME(StringLiteral);\n          }\n        }, {\n          ALT: function ALT() {\n            $.CONSUME(HexLiteral);\n          }\n        }, {\n          ALT: function ALT() {\n            $.CONSUME(NumberLiteral);\n          }\n        }, {\n          ALT: function ALT() {\n            $.CONSUME(TrueLiteral);\n          }\n        }, {\n          ALT: function ALT() {\n            $.CONSUME(FalseLiteral);\n          }\n        }, {\n          ALT: function ALT() {\n            $.CONSUME(NullLiteral);\n          }\n        }]);\n      });\n    });\n    $.RULE(\"multiFieldValue\", function () {\n      $.CONSUME(LSquare);\n      $.MANY(function () {\n        $.OR([{\n          ALT: function ALT() {\n            $.SUBRULE($.node);\n          }\n        }, {\n          ALT: function ALT() {\n            $.SUBRULE($.use);\n          }\n        }, {\n          ALT: function ALT() {\n            $.CONSUME(StringLiteral);\n          }\n        }, {\n          ALT: function ALT() {\n            $.CONSUME(HexLiteral);\n          }\n        }, {\n          ALT: function ALT() {\n            $.CONSUME(NumberLiteral);\n          }\n        }, {\n          ALT: function ALT() {\n            $.CONSUME(NullLiteral);\n          }\n        }]);\n      });\n      $.CONSUME(RSquare);\n    });\n    $.RULE(\"route\", function () {\n      $.CONSUME(ROUTE);\n      $.CONSUME(RouteIdentifier);\n      $.CONSUME(TO);\n      $.CONSUME2(RouteIdentifier);\n    });\n\n    _this.performSelfAnalysis();\n\n    return _this;\n  }\n\n  return VRMLParser;\n}(CstParser);\n\nvar Face = function Face(a, b, c) {\n  _classCallCheck(this, Face);\n\n  this.a = a;\n  this.b = b;\n  this.c = c;\n  this.normal = new Vector3();\n};\n\nvar TEXTURE_TYPE = {\n  INTENSITY: 1,\n  INTENSITY_ALPHA: 2,\n  RGB: 3,\n  RGBA: 4\n};\nexport { VRMLLoader };","map":{"version":3,"sources":["/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/three-stdlib/loaders/VRMLLoader.js"],"names":["Loader","LoaderUtils","FileLoader","Scene","Object3D","Group","Vector3","SphereGeometry","MeshBasicMaterial","BackSide","Mesh","PointsMaterial","Points","LineBasicMaterial","LineSegments","FrontSide","DoubleSide","MeshPhongMaterial","Color","RepeatWrapping","ClampToEdgeWrapping","DataTexture","Vector2","BufferGeometry","Float32BufferAttribute","BoxGeometry","ConeGeometry","CylinderGeometry","Quaternion","ShapeUtils","BufferAttribute","TextureLoader","createToken","Lexer","CstParser","VRMLLoader","manager","url","onLoad","onProgress","onError","scope","path","extractUrlBase","loader","setPath","setRequestHeader","requestHeader","setWithCredentials","withCredentials","load","text","parse","e","console","error","itemError","data","nodeMap","generateVRMLTree","data2","tokenData","createTokens","lexer","VRMLLexer","tokens","parser","VRMLParser","tokenVocabulary","visitor","createVisitor","getBaseCstVisitorConstructor","lexingResult","lex","input","cstOutput","vrml","errors","length","Error","ast","visit","RouteIdentifier","name","pattern","Identifier","longer_alt","nodeTypes","Version","NodeName","RegExp","join","DEF","USE","ROUTE","TO","StringLiteral","HexLiteral","NumberLiteral","TrueLiteral","FalseLiteral","NullLiteral","LSquare","RSquare","LCurly","RCurly","Comment","group","SKIPPED","WhiteSpace","i","l","token","BaseVRMLVisitor","VRMLToASTVisitor","call","validateVisitor","prototype","Object","assign","create","constructor","ctx","version","nodes","routes","node","push","route","image","fields","field","def","type","values","result","singleFieldValue","multiFieldValue","use","processField","FROM","stringLiteral","replace","numberLiteral","parseFloat","hexLiteral","trueLiteral","falseLiteral","forEach","parseTree","tree2","scene2","buildNodeMap","object","getNode","add","userData","worldInfo","fieldValues","j","jl","resolveUSE","build","buildNode","nodeName","buildGroupingNode","buildBackgroundNode","buildShapeNode","buildAppearanceNode","buildMaterialNode","buildImageTextureNode","buildPixelTextureNode","buildTextureTransformNode","buildIndexedFaceSetNode","buildIndexedLineSetNode","buildPointSetNode","buildBoxNode","buildConeNode","buildCylinderNode","buildSphereNode","buildElevationGridNode","buildExtrusionNode","buildGeometricNode","buildWorldInfoNode","warn","hasOwnProperty","fieldName","parseFieldChildren","axis","angle","quaternion","setFromAxisAngle","scale","set","position","groundAngle","groundColor","skyAngle","skyColor","radius","skyGeometry","skyMaterial","fog","side","depthWrite","depthTest","paintFaces","toColorArray","vertexColors","color","setRGB","sky","groundGeometry","Math","PI","groundMaterial","ground","renderOrder","Infinity","material","geometry","attributes","_type","pointsMaterial","isMeshPhongMaterial","copy","emissive","lineMaterial","_solid","visible","transformData","materialData","diffuseColor","emissiveColor","shininess","specularColor","specular","transparency","opacity","transparent","textureNode","map","__type","TEXTURE_TYPE","INTENSITY_ALPHA","RGB","RGBA","center","rotation","repeat","offset","translation","parseHexColor","hex","textureType","value","INTENSITY","parseInt","r","g","b","a","substring","getTextureType","num_components","texture","wrapS","wrapT","width","height","Uint8Array","k","stride","needsUpdate","textureLoader","title","info","coord","normal","texCoord","ccw","solid","creaseAngle","colorIndex","coordIndex","normalIndex","texCoordIndex","colorPerVertex","normalPerVertex","colorNode","coordNode","normalNode","texCoordNode","triangulatedCoordIndex","triangulateFaceIndex","colorAttribute","normalAttribute","uvAttribute","triangulatedColorIndex","computeAttributeFromIndexedData","toNonIndexedAttribute","flattenFaceColors","flattenData","triangulatedFaceColors","triangulateFaceData","computeAttributeFromFaceData","triangulatedNormalIndex","flattenFaceNormals","triangulatedFaceNormals","computeNormalAttribute","triangulatedTexCoordIndex","positionAttribute","setAttribute","expandedLineIndex","expandLineIndex","expandedColorIndex","flattenLineColors","expandedLineColors","expandLineData","computeAttributeFromLineData","size","x","y","z","openEnded","xDimension","zDimension","xSpacing","zSpacing","vertices","normals","colors","uvs","index","xn","yn","zn","s","t","indices","c","d","crossSection","spine","orientation","beginCap","endCap","crossSectionClosed","spineVector","scaling","vertex","o","il","fromArray","kl","multiply","applyQuaternion","spineCount","crossSectionCount","contour","faces","triangulateShape","capIndices","face","indexOffset","identifier","isObject3D","isMaterial","clone","children","owner","start","i1","i2","i3","triangulatedData","flattenData2","vA","vB","vC","uvA","uvB","uvC","itemSize","array","faceData","lineData","attribute","array2","index2","ab","cb","vertexNormals","Face","subVectors","cross","normalize","nA","weightedNormal","nB","nC","vector","angleTo","angles","topDown","thresholds","startAngle","point","setFromSphericalCoords","Float32Array","count","getX","fromBufferAttribute","thresholdIndexA","thresholdIndexB","thresholdA","thresholdB","abs","colorA","colorB","lerp","setXYZ","resourcePath","setCrossOrigin","crossOrigin","indexOf","tree","scene","inputText","tokenize","$","RULE","SUBRULE","AT_LEAST_ONE","MANY","CONSUME","OPTION","OR2","ALT","OR","CONSUME2","performSelfAnalysis"],"mappings":";;;;;AAAA,SAASA,MAAT,EAAiBC,WAAjB,EAA8BC,UAA9B,EAA0CC,KAA1C,EAAiDC,QAAjD,EAA2DC,KAA3D,EAAkEC,OAAlE,EAA2EC,cAA3E,EAA2FC,iBAA3F,EAA8GC,QAA9G,EAAwHC,IAAxH,EAA8HC,cAA9H,EAA8IC,MAA9I,EAAsJC,iBAAtJ,EAAyKC,YAAzK,EAAuLC,SAAvL,EAAkMC,UAAlM,EAA8MC,iBAA9M,EAAiOC,KAAjO,EAAwOC,cAAxO,EAAwPC,mBAAxP,EAA6QC,WAA7Q,EAA0RC,OAA1R,EAAmSC,cAAnS,EAAmTC,sBAAnT,EAA2UC,WAA3U,EAAwVC,YAAxV,EAAsWC,gBAAtW,EAAwXC,UAAxX,EAAoYC,UAApY,EAAgZC,eAAhZ,EAAiaC,aAAja,QAAsb,OAAtb;AACA,SAASC,WAAT,EAAsBC,KAAtB,EAA6BC,SAA7B,QAA8C,YAA9C;;IACMC,U;;;;;AACJ,sBAAYC,OAAZ,EAAqB;AAAA;;AAAA,6BACbA,OADa;AAEpB;;;;WACD,cAAKC,GAAL,EAAUC,MAAV,EAAkBC,UAAlB,EAA8BC,OAA9B,EAAuC;AACrC,UAAMC,KAAK,GAAG,IAAd;AACA,UAAMC,IAAI,GAAGD,KAAK,CAACC,IAAN,KAAe,EAAf,GAAoBzC,WAAW,CAAC0C,cAAZ,CAA2BN,GAA3B,CAApB,GAAsDI,KAAK,CAACC,IAAzE;AACA,UAAME,MAAM,GAAG,IAAI1C,UAAJ,CAAeuC,KAAK,CAACL,OAArB,CAAf;AACAQ,MAAAA,MAAM,CAACC,OAAP,CAAeJ,KAAK,CAACC,IAArB;AACAE,MAAAA,MAAM,CAACE,gBAAP,CAAwBL,KAAK,CAACM,aAA9B;AACAH,MAAAA,MAAM,CAACI,kBAAP,CAA0BP,KAAK,CAACQ,eAAhC;AACAL,MAAAA,MAAM,CAACM,IAAP,CACEb,GADF,EAEE,UAASc,IAAT,EAAe;AACb,YAAI;AACFb,UAAAA,MAAM,CAACG,KAAK,CAACW,KAAN,CAAYD,IAAZ,EAAkBT,IAAlB,CAAD,CAAN;AACD,SAFD,CAEE,OAAOW,CAAP,EAAU;AACV,cAAIb,OAAJ,EAAa;AACXA,YAAAA,OAAO,CAACa,CAAD,CAAP;AACD,WAFD,MAEO;AACLC,YAAAA,OAAO,CAACC,KAAR,CAAcF,CAAd;AACD;;AACDZ,UAAAA,KAAK,CAACL,OAAN,CAAcoB,SAAd,CAAwBnB,GAAxB;AACD;AACF,OAbH,EAcEE,UAdF,EAeEC,OAfF;AAiBD;;;WACD,eAAMiB,IAAN,EAAYf,IAAZ,EAAkB;AAChB,UAAMgB,OAAO,GAAG,EAAhB;;AACA,eAASC,gBAAT,CAA0BC,KAA1B,EAAiC;AAC/B,YAAMC,SAAS,GAAGC,YAAY,EAA9B;AACA,YAAMC,KAAK,GAAG,IAAIC,SAAJ,CAAcH,SAAS,CAACI,MAAxB,CAAd;AACA,YAAMC,MAAM,GAAG,IAAIC,UAAJ,CAAeN,SAAS,CAACO,eAAzB,CAAf;AACA,YAAMC,OAAO,GAAGC,aAAa,CAACJ,MAAM,CAACK,4BAAP,EAAD,CAA7B;AACA,YAAMC,YAAY,GAAGT,KAAK,CAACU,GAAN,CAAUb,KAAV,CAArB;AACAM,QAAAA,MAAM,CAACQ,KAAP,GAAeF,YAAY,CAACP,MAA5B;AACA,YAAMU,SAAS,GAAGT,MAAM,CAACU,IAAP,EAAlB;;AACA,YAAIV,MAAM,CAACW,MAAP,CAAcC,MAAd,GAAuB,CAA3B,EAA8B;AAC5BxB,UAAAA,OAAO,CAACC,KAAR,CAAcW,MAAM,CAACW,MAArB;AACA,gBAAME,KAAK,CAAC,4CAAD,CAAX;AACD;;AACD,YAAMC,GAAG,GAAGX,OAAO,CAACY,KAAR,CAAcN,SAAd,CAAZ;AACA,eAAOK,GAAP;AACD;;AACD,eAASlB,YAAT,GAAwB;AACtB,YAAMoB,eAAe,GAAGlD,WAAW,CAAC;AAClCmD,UAAAA,IAAI,EAAE,iBAD4B;AAElCC,UAAAA,OAAO,EAAE;AAFyB,SAAD,CAAnC;AAIA,YAAMC,UAAU,GAAGrD,WAAW,CAAC;AAC7BmD,UAAAA,IAAI,EAAE,YADuB;AAE7BC,UAAAA,OAAO,EAAE,gIAFoB;AAG7BE,UAAAA,UAAU,EAAEJ;AAHiB,SAAD,CAA9B;AAKA,YAAMK,SAAS,GAAG,CAChB,QADgB,EAEhB,WAFgB,EAGhB,WAHgB,EAIhB,OAJgB,EAKhB,WALgB,EAMhB;AACA,gBAPgB,EAQhB,KARgB,EAShB,QATgB,EAUhB;AACA,mBAXgB,EAYhB,kBAZgB,EAahB,YAbgB,EAchB,QAdgB,EAehB,OAfgB,EAgBhB,OAhBgB,EAiBhB,WAjBgB,EAkBhB,WAlBgB,EAmBhB;AACA,wBApBgB,EAqBhB,aArBgB,EAsBhB,iBAtBgB,EAuBhB,cAvBgB,EAwBhB,YAxBgB,EAyBhB,aAzBgB,EA0BhB,kBA1BgB,EA2BhB;AACA,aA5BgB,EA6BhB,MA7BgB,EA8BhB,UA9BgB,EA+BhB,eA/BgB,EAgChB,WAhCgB,EAiChB,gBAjCgB,EAkChB,gBAlCgB,EAmChB,UAnCgB,EAoChB,QApCgB,EAqChB;AACA,eAtCgB,EAuChB,YAvCgB,EAwChB,QAxCgB,EAyChB,mBAzCgB,EA0ChB;AACA,oBA3CgB,EA4ChB,WA5CgB,EA6ChB,cA7CgB,EA8ChB,UA9CgB,EA+ChB,cA/CgB,EAgDhB,cAhDgB,EAiDhB,kBAjDgB,EAkDhB;AACA,2BAnDgB,EAoDhB,wBApDgB,EAqDhB,oBArDgB,EAsDhB,yBAtDgB,EAuDhB,sBAvDgB,EAwDhB,oBAxDgB,EAyDhB;AACA,oBA1DgB,EA2DhB,KA3DgB,EA4DhB,gBA5DgB,EA6DhB,WA7DgB,EA8DhB;AACA,cA/DgB,CAgEhB;AAhEgB,SAAlB;AAkEA,YAAMC,OAAO,GAAGxD,WAAW,CAAC;AAC1BmD,UAAAA,IAAI,EAAE,SADoB;AAE1BC,UAAAA,OAAO,EAAE,SAFiB;AAG1BE,UAAAA,UAAU,EAAED;AAHc,SAAD,CAA3B;AAKA,YAAMI,QAAQ,GAAGzD,WAAW,CAAC;AAC3BmD,UAAAA,IAAI,EAAE,UADqB;AAE3BC,UAAAA,OAAO,EAAE,IAAIM,MAAJ,CAAWH,SAAS,CAACI,IAAV,CAAe,GAAf,CAAX,CAFkB;AAG3BL,UAAAA,UAAU,EAAED;AAHe,SAAD,CAA5B;AAKA,YAAMO,GAAG,GAAG5D,WAAW,CAAC;AACtBmD,UAAAA,IAAI,EAAE,KADgB;AAEtBC,UAAAA,OAAO,EAAE,KAFa;AAGtBE,UAAAA,UAAU,EAAED;AAHU,SAAD,CAAvB;AAKA,YAAMQ,GAAG,GAAG7D,WAAW,CAAC;AACtBmD,UAAAA,IAAI,EAAE,KADgB;AAEtBC,UAAAA,OAAO,EAAE,KAFa;AAGtBE,UAAAA,UAAU,EAAED;AAHU,SAAD,CAAvB;AAKA,YAAMS,KAAK,GAAG9D,WAAW,CAAC;AACxBmD,UAAAA,IAAI,EAAE,OADkB;AAExBC,UAAAA,OAAO,EAAE,OAFe;AAGxBE,UAAAA,UAAU,EAAED;AAHY,SAAD,CAAzB;AAKA,YAAMU,EAAE,GAAG/D,WAAW,CAAC;AACrBmD,UAAAA,IAAI,EAAE,IADe;AAErBC,UAAAA,OAAO,EAAE,IAFY;AAGrBE,UAAAA,UAAU,EAAED;AAHS,SAAD,CAAtB;AAKA,YAAMW,aAAa,GAAGhE,WAAW,CAAC;AAChCmD,UAAAA,IAAI,EAAE,eAD0B;AAEhCC,UAAAA,OAAO,EAAE;AAFuB,SAAD,CAAjC;AAIA,YAAMa,UAAU,GAAGjE,WAAW,CAAC;AAAEmD,UAAAA,IAAI,EAAE,YAAR;AAAsBC,UAAAA,OAAO,EAAE;AAA/B,SAAD,CAA9B;AACA,YAAMc,aAAa,GAAGlE,WAAW,CAAC;AAAEmD,UAAAA,IAAI,EAAE,eAAR;AAAyBC,UAAAA,OAAO,EAAE;AAAlC,SAAD,CAAjC;AACA,YAAMe,WAAW,GAAGnE,WAAW,CAAC;AAAEmD,UAAAA,IAAI,EAAE,aAAR;AAAuBC,UAAAA,OAAO,EAAE;AAAhC,SAAD,CAA/B;AACA,YAAMgB,YAAY,GAAGpE,WAAW,CAAC;AAAEmD,UAAAA,IAAI,EAAE,cAAR;AAAwBC,UAAAA,OAAO,EAAE;AAAjC,SAAD,CAAhC;AACA,YAAMiB,WAAW,GAAGrE,WAAW,CAAC;AAAEmD,UAAAA,IAAI,EAAE,aAAR;AAAuBC,UAAAA,OAAO,EAAE;AAAhC,SAAD,CAA/B;AACA,YAAMkB,OAAO,GAAGtE,WAAW,CAAC;AAAEmD,UAAAA,IAAI,EAAE,SAAR;AAAmBC,UAAAA,OAAO,EAAE;AAA5B,SAAD,CAA3B;AACA,YAAMmB,OAAO,GAAGvE,WAAW,CAAC;AAAEmD,UAAAA,IAAI,EAAE,SAAR;AAAmBC,UAAAA,OAAO,EAAE;AAA5B,SAAD,CAA3B;AACA,YAAMoB,MAAM,GAAGxE,WAAW,CAAC;AAAEmD,UAAAA,IAAI,EAAE,QAAR;AAAkBC,UAAAA,OAAO,EAAE;AAA3B,SAAD,CAA1B;AACA,YAAMqB,MAAM,GAAGzE,WAAW,CAAC;AAAEmD,UAAAA,IAAI,EAAE,QAAR;AAAkBC,UAAAA,OAAO,EAAE;AAA3B,SAAD,CAA1B;AACA,YAAMsB,OAAO,GAAG1E,WAAW,CAAC;AAC1BmD,UAAAA,IAAI,EAAE,SADoB;AAE1BC,UAAAA,OAAO,EAAE,KAFiB;AAG1BuB,UAAAA,KAAK,EAAE1E,KAAK,CAAC2E;AAHa,SAAD,CAA3B;AAKA,YAAMC,UAAU,GAAG7E,WAAW,CAAC;AAC7BmD,UAAAA,IAAI,EAAE,YADuB;AAE7BC,UAAAA,OAAO,EAAE,QAFoB;AAG7BuB,UAAAA,KAAK,EAAE1E,KAAK,CAAC2E;AAHgB,SAAD,CAA9B;AAKA,YAAM3C,MAAM,GAAG,CACb4C,UADa,EAEb;AACApB,QAAAA,QAHa,EAIbG,GAJa,EAKbC,GALa,EAMbC,KANa,EAObC,EAPa,EAQbI,WARa,EASbC,YATa,EAUbC,WAVa,EAWb;AACAb,QAAAA,OAZa,EAabH,UAba,EAcbH,eAda,EAebc,aAfa,EAgBbC,UAhBa,EAiBbC,aAjBa,EAkBbI,OAlBa,EAmBbC,OAnBa,EAoBbC,MApBa,EAqBbC,MArBa,EAsBbC,OAtBa,CAAf;AAwBA,YAAMtC,eAAe,GAAG,EAAxB;;AACA,aAAK,IAAI0C,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAG9C,MAAM,CAACa,MAA3B,EAAmCgC,CAAC,GAAGC,CAAvC,EAA0CD,CAAC,EAA3C,EAA+C;AAC7C,cAAME,KAAK,GAAG/C,MAAM,CAAC6C,CAAD,CAApB;AACA1C,UAAAA,eAAe,CAAC4C,KAAK,CAAC7B,IAAP,CAAf,GAA8B6B,KAA9B;AACD;;AACD,eAAO;AAAE/C,UAAAA,MAAM,EAANA,MAAF;AAAUG,UAAAA,eAAe,EAAfA;AAAV,SAAP;AACD;;AACD,eAASE,aAAT,CAAuB2C,eAAvB,EAAwC;AACtC,iBAASC,gBAAT,GAA4B;AAC1BD,UAAAA,eAAe,CAACE,IAAhB,CAAqB,IAArB;AACA,eAAKC,eAAL;AACD;;AACDF,QAAAA,gBAAgB,CAACG,SAAjB,GAA6BC,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACE,MAAP,CAAcP,eAAe,CAACI,SAA9B,CAAd,EAAwD;AACnFI,UAAAA,WAAW,EAAEP,gBADsE;AAEnFtC,UAAAA,IAAI,EAAE,cAAS8C,GAAT,EAAc;AAClB,gBAAM9D,KAAK,GAAG;AACZ+D,cAAAA,OAAO,EAAE,KAAK1C,KAAL,CAAWyC,GAAG,CAACC,OAAf,CADG;AAEZC,cAAAA,KAAK,EAAE,EAFK;AAGZC,cAAAA,MAAM,EAAE;AAHI,aAAd;;AAKA,iBAAK,IAAIf,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGW,GAAG,CAACI,IAAJ,CAAShD,MAA7B,EAAqCgC,CAAC,GAAGC,CAAzC,EAA4CD,CAAC,EAA7C,EAAiD;AAC/C,kBAAMgB,IAAI,GAAGJ,GAAG,CAACI,IAAJ,CAAShB,CAAT,CAAb;AACAlD,cAAAA,KAAK,CAACgE,KAAN,CAAYG,IAAZ,CAAiB,KAAK9C,KAAL,CAAW6C,IAAX,CAAjB;AACD;;AACD,gBAAIJ,GAAG,CAACM,KAAR,EAAe;AACb,mBAAK,IAAIlB,EAAC,GAAG,CAAR,EAAWC,EAAC,GAAGW,GAAG,CAACM,KAAJ,CAAUlD,MAA9B,EAAsCgC,EAAC,GAAGC,EAA1C,EAA6CD,EAAC,EAA9C,EAAkD;AAChD,oBAAMkB,KAAK,GAAGN,GAAG,CAACM,KAAJ,CAAUlB,EAAV,CAAd;AACAlD,gBAAAA,KAAK,CAACiE,MAAN,CAAaE,IAAb,CAAkB,KAAK9C,KAAL,CAAW+C,KAAX,CAAlB;AACD;AACF;;AACD,mBAAOpE,KAAP;AACD,WAnBkF;AAoBnF+D,UAAAA,OAAO,EAAE,iBAASD,GAAT,EAAc;AACrB,mBAAOA,GAAG,CAAClC,OAAJ,CAAY,CAAZ,EAAeyC,KAAtB;AACD,WAtBkF;AAuBnFH,UAAAA,IAAI,EAAE,cAASJ,GAAT,EAAc;AAClB,gBAAM9D,KAAK,GAAG;AACZuB,cAAAA,IAAI,EAAEuC,GAAG,CAACjC,QAAJ,CAAa,CAAb,EAAgBwC,KADV;AAEZC,cAAAA,MAAM,EAAE;AAFI,aAAd;;AAIA,gBAAIR,GAAG,CAACS,KAAR,EAAe;AACb,mBAAK,IAAIrB,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGW,GAAG,CAACS,KAAJ,CAAUrD,MAA9B,EAAsCgC,CAAC,GAAGC,CAA1C,EAA6CD,CAAC,EAA9C,EAAkD;AAChD,oBAAMqB,KAAK,GAAGT,GAAG,CAACS,KAAJ,CAAUrB,CAAV,CAAd;AACAlD,gBAAAA,KAAK,CAACsE,MAAN,CAAaH,IAAb,CAAkB,KAAK9C,KAAL,CAAWkD,KAAX,CAAlB;AACD;AACF;;AACD,gBAAIT,GAAG,CAACU,GAAR,EAAa;AACXxE,cAAAA,KAAK,CAACgC,GAAN,GAAY,KAAKX,KAAL,CAAWyC,GAAG,CAACU,GAAJ,CAAQ,CAAR,CAAX,CAAZ;AACD;;AACD,mBAAOxE,KAAP;AACD,WAtCkF;AAuCnFuE,UAAAA,KAAK,EAAE,eAAST,GAAT,EAAc;AACnB,gBAAM9D,KAAK,GAAG;AACZuB,cAAAA,IAAI,EAAEuC,GAAG,CAACrC,UAAJ,CAAe,CAAf,EAAkB4C,KADZ;AAEZI,cAAAA,IAAI,EAAE,IAFM;AAGZC,cAAAA,MAAM,EAAE;AAHI,aAAd;AAKA,gBAAIC,MAAJ;;AACA,gBAAIb,GAAG,CAACc,gBAAR,EAA0B;AACxBD,cAAAA,MAAM,GAAG,KAAKtD,KAAL,CAAWyC,GAAG,CAACc,gBAAJ,CAAqB,CAArB,CAAX,CAAT;AACD;;AACD,gBAAId,GAAG,CAACe,eAAR,EAAyB;AACvBF,cAAAA,MAAM,GAAG,KAAKtD,KAAL,CAAWyC,GAAG,CAACe,eAAJ,CAAoB,CAApB,CAAX,CAAT;AACD;;AACD7E,YAAAA,KAAK,CAACyE,IAAN,GAAaE,MAAM,CAACF,IAApB;AACAzE,YAAAA,KAAK,CAAC0E,MAAN,GAAeC,MAAM,CAACD,MAAtB;AACA,mBAAO1E,KAAP;AACD,WAvDkF;AAwDnFwE,UAAAA,GAAG,EAAE,aAASV,GAAT,EAAc;AACjB,mBAAO,CAACA,GAAG,CAACrC,UAAJ,IAAkBqC,GAAG,CAACjC,QAAvB,EAAiC,CAAjC,EAAoCwC,KAA3C;AACD,WA1DkF;AA2DnFS,UAAAA,GAAG,EAAE,aAAShB,GAAT,EAAc;AACjB,mBAAO;AAAE7B,cAAAA,GAAG,EAAE,CAAC6B,GAAG,CAACrC,UAAJ,IAAkBqC,GAAG,CAACjC,QAAvB,EAAiC,CAAjC,EAAoCwC;AAA3C,aAAP;AACD,WA7DkF;AA8DnFO,UAAAA,gBAAgB,EAAE,0BAASd,GAAT,EAAc;AAC9B,mBAAOiB,YAAY,CAAC,IAAD,EAAOjB,GAAP,CAAnB;AACD,WAhEkF;AAiEnFe,UAAAA,eAAe,EAAE,yBAASf,GAAT,EAAc;AAC7B,mBAAOiB,YAAY,CAAC,IAAD,EAAOjB,GAAP,CAAnB;AACD,WAnEkF;AAoEnFM,UAAAA,KAAK,EAAE,eAASN,GAAT,EAAc;AACnB,gBAAM9D,KAAK,GAAG;AACZgF,cAAAA,IAAI,EAAElB,GAAG,CAACxC,eAAJ,CAAoB,CAApB,EAAuB+C,KADjB;AAEZlC,cAAAA,EAAE,EAAE2B,GAAG,CAACxC,eAAJ,CAAoB,CAApB,EAAuB+C;AAFf,aAAd;AAIA,mBAAOrE,KAAP;AACD;AA1EkF,SAAxD,CAA7B;;AA4EA,iBAAS+E,YAAT,CAAsBlG,KAAtB,EAA6BiF,GAA7B,EAAkC;AAChC,cAAMS,KAAK,GAAG;AACZE,YAAAA,IAAI,EAAE,IADM;AAEZC,YAAAA,MAAM,EAAE;AAFI,WAAd;;AAIA,cAAIZ,GAAG,CAACI,IAAR,EAAc;AACZK,YAAAA,KAAK,CAACE,IAAN,GAAa,MAAb;;AACA,iBAAK,IAAIvB,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGW,GAAG,CAACI,IAAJ,CAAShD,MAA7B,EAAqCgC,CAAC,GAAGC,CAAzC,EAA4CD,CAAC,EAA7C,EAAiD;AAC/C,kBAAMgB,IAAI,GAAGJ,GAAG,CAACI,IAAJ,CAAShB,CAAT,CAAb;AACAqB,cAAAA,KAAK,CAACG,MAAN,CAAaP,IAAb,CAAkBtF,KAAK,CAACwC,KAAN,CAAY6C,IAAZ,CAAlB;AACD;AACF;;AACD,cAAIJ,GAAG,CAACgB,GAAR,EAAa;AACXP,YAAAA,KAAK,CAACE,IAAN,GAAa,KAAb;;AACA,iBAAK,IAAIvB,GAAC,GAAG,CAAR,EAAWC,GAAC,GAAGW,GAAG,CAACgB,GAAJ,CAAQ5D,MAA5B,EAAoCgC,GAAC,GAAGC,GAAxC,EAA2CD,GAAC,EAA5C,EAAgD;AAC9C,kBAAM4B,GAAG,GAAGhB,GAAG,CAACgB,GAAJ,CAAQ5B,GAAR,CAAZ;AACAqB,cAAAA,KAAK,CAACG,MAAN,CAAaP,IAAb,CAAkBtF,KAAK,CAACwC,KAAN,CAAYyD,GAAZ,CAAlB;AACD;AACF;;AACD,cAAIhB,GAAG,CAAC1B,aAAR,EAAuB;AACrBmC,YAAAA,KAAK,CAACE,IAAN,GAAa,QAAb;;AACA,iBAAK,IAAIvB,GAAC,GAAG,CAAR,EAAWC,GAAC,GAAGW,GAAG,CAAC1B,aAAJ,CAAkBlB,MAAtC,EAA8CgC,GAAC,GAAGC,GAAlD,EAAqDD,GAAC,EAAtD,EAA0D;AACxD,kBAAM+B,aAAa,GAAGnB,GAAG,CAAC1B,aAAJ,CAAkBc,GAAlB,CAAtB;AACAqB,cAAAA,KAAK,CAACG,MAAN,CAAaP,IAAb,CAAkBc,aAAa,CAACZ,KAAd,CAAoBa,OAApB,CAA4B,MAA5B,EAAoC,EAApC,CAAlB;AACD;AACF;;AACD,cAAIpB,GAAG,CAACxB,aAAR,EAAuB;AACrBiC,YAAAA,KAAK,CAACE,IAAN,GAAa,QAAb;;AACA,iBAAK,IAAIvB,GAAC,GAAG,CAAR,EAAWC,GAAC,GAAGW,GAAG,CAACxB,aAAJ,CAAkBpB,MAAtC,EAA8CgC,GAAC,GAAGC,GAAlD,EAAqDD,GAAC,EAAtD,EAA0D;AACxD,kBAAMiC,aAAa,GAAGrB,GAAG,CAACxB,aAAJ,CAAkBY,GAAlB,CAAtB;AACAqB,cAAAA,KAAK,CAACG,MAAN,CAAaP,IAAb,CAAkBiB,UAAU,CAACD,aAAa,CAACd,KAAf,CAA5B;AACD;AACF;;AACD,cAAIP,GAAG,CAACzB,UAAR,EAAoB;AAClBkC,YAAAA,KAAK,CAACE,IAAN,GAAa,KAAb;;AACA,iBAAK,IAAIvB,GAAC,GAAG,CAAR,EAAWC,GAAC,GAAGW,GAAG,CAACzB,UAAJ,CAAenB,MAAnC,EAA2CgC,GAAC,GAAGC,GAA/C,EAAkDD,GAAC,EAAnD,EAAuD;AACrD,kBAAMmC,UAAU,GAAGvB,GAAG,CAACzB,UAAJ,CAAea,GAAf,CAAnB;AACAqB,cAAAA,KAAK,CAACG,MAAN,CAAaP,IAAb,CAAkBkB,UAAU,CAAChB,KAA7B;AACD;AACF;;AACD,cAAIP,GAAG,CAACvB,WAAR,EAAqB;AACnBgC,YAAAA,KAAK,CAACE,IAAN,GAAa,SAAb;;AACA,iBAAK,IAAIvB,GAAC,GAAG,CAAR,EAAWC,GAAC,GAAGW,GAAG,CAACvB,WAAJ,CAAgBrB,MAApC,EAA4CgC,GAAC,GAAGC,GAAhD,EAAmDD,GAAC,EAApD,EAAwD;AACtD,kBAAMoC,WAAW,GAAGxB,GAAG,CAACvB,WAAJ,CAAgBW,GAAhB,CAApB;AACA,kBAAIoC,WAAW,CAACjB,KAAZ,KAAsB,MAA1B,EACEE,KAAK,CAACG,MAAN,CAAaP,IAAb,CAAkB,IAAlB;AACH;AACF;;AACD,cAAIL,GAAG,CAACtB,YAAR,EAAsB;AACpB+B,YAAAA,KAAK,CAACE,IAAN,GAAa,SAAb;;AACA,iBAAK,IAAIvB,GAAC,GAAG,CAAR,EAAWC,GAAC,GAAGW,GAAG,CAACtB,YAAJ,CAAiBtB,MAArC,EAA6CgC,GAAC,GAAGC,GAAjD,EAAoDD,GAAC,EAArD,EAAyD;AACvD,kBAAMqC,YAAY,GAAGzB,GAAG,CAACtB,YAAJ,CAAiBU,GAAjB,CAArB;AACA,kBAAIqC,YAAY,CAAClB,KAAb,KAAuB,OAA3B,EACEE,KAAK,CAACG,MAAN,CAAaP,IAAb,CAAkB,KAAlB;AACH;AACF;;AACD,cAAIL,GAAG,CAACrB,WAAR,EAAqB;AACnB8B,YAAAA,KAAK,CAACE,IAAN,GAAa,MAAb;AACAX,YAAAA,GAAG,CAACrB,WAAJ,CAAgB+C,OAAhB,CAAwB,YAAW;AACjCjB,cAAAA,KAAK,CAACG,MAAN,CAAaP,IAAb,CAAkB,IAAlB;AACD,aAFD;AAGD;;AACD,iBAAOI,KAAP;AACD;;AACD,eAAO,IAAIjB,gBAAJ,EAAP;AACD;;AACD,eAASmC,SAAT,CAAmBC,KAAnB,EAA0B;AACxB,YAAM1B,KAAK,GAAG0B,KAAK,CAAC1B,KAApB;AACA,YAAM2B,MAAM,GAAG,IAAIpJ,KAAJ,EAAf;;AACA,aAAK,IAAI2G,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGa,KAAK,CAAC9C,MAA1B,EAAkCgC,CAAC,GAAGC,CAAtC,EAAyCD,CAAC,EAA1C,EAA8C;AAC5C,cAAMgB,IAAI,GAAGF,KAAK,CAACd,CAAD,CAAlB;AACA0C,UAAAA,YAAY,CAAC1B,IAAD,CAAZ;AACD;;AACD,aAAK,IAAIhB,GAAC,GAAG,CAAR,EAAWC,GAAC,GAAGa,KAAK,CAAC9C,MAA1B,EAAkCgC,GAAC,GAAGC,GAAtC,EAAyCD,GAAC,EAA1C,EAA8C;AAC5C,cAAMgB,KAAI,GAAGF,KAAK,CAACd,GAAD,CAAlB;AACA,cAAM2C,MAAM,GAAGC,OAAO,CAAC5B,KAAD,CAAtB;AACA,cAAI2B,MAAM,YAAYrJ,QAAtB,EACEmJ,MAAM,CAACI,GAAP,CAAWF,MAAX;AACF,cAAI3B,KAAI,CAAC3C,IAAL,KAAc,WAAlB,EACEoE,MAAM,CAACK,QAAP,CAAgBC,SAAhB,GAA4BJ,MAA5B;AACH;;AACD,eAAOF,MAAP;AACD;;AACD,eAASC,YAAT,CAAsB1B,IAAtB,EAA4B;AAC1B,YAAIA,IAAI,CAAClC,GAAT,EAAc;AACZlC,UAAAA,OAAO,CAACoE,IAAI,CAAClC,GAAN,CAAP,GAAoBkC,IAApB;AACD;;AACD,YAAMI,MAAM,GAAGJ,IAAI,CAACI,MAApB;;AACA,aAAK,IAAIpB,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGmB,MAAM,CAACpD,MAA3B,EAAmCgC,CAAC,GAAGC,CAAvC,EAA0CD,CAAC,EAA3C,EAA+C;AAC7C,cAAMqB,KAAK,GAAGD,MAAM,CAACpB,CAAD,CAApB;;AACA,cAAIqB,KAAK,CAACE,IAAN,KAAe,MAAnB,EAA2B;AACzB,gBAAMyB,WAAW,GAAG3B,KAAK,CAACG,MAA1B;;AACA,iBAAK,IAAIyB,CAAC,GAAG,CAAR,EAAWC,EAAE,GAAGF,WAAW,CAAChF,MAAjC,EAAyCiF,CAAC,GAAGC,EAA7C,EAAiDD,CAAC,EAAlD,EAAsD;AACpDP,cAAAA,YAAY,CAACM,WAAW,CAACC,CAAD,CAAZ,CAAZ;AACD;AACF;AACF;AACF;;AACD,eAASL,OAAT,CAAiB5B,IAAjB,EAAuB;AACrB,YAAIA,IAAI,CAACjC,GAAT,EAAc;AACZ,iBAAOoE,UAAU,CAACnC,IAAI,CAACjC,GAAN,CAAjB;AACD;;AACD,YAAIiC,IAAI,CAACoC,KAAL,KAAe,KAAK,CAAxB,EACE,OAAOpC,IAAI,CAACoC,KAAZ;AACFpC,QAAAA,IAAI,CAACoC,KAAL,GAAaC,SAAS,CAACrC,IAAD,CAAtB;AACA,eAAOA,IAAI,CAACoC,KAAZ;AACD;;AACD,eAASC,SAAT,CAAmBrC,IAAnB,EAAyB;AACvB,YAAMsC,QAAQ,GAAGtC,IAAI,CAAC3C,IAAtB;AACA,YAAI+E,KAAJ;;AACA,gBAAQE,QAAR;AACE,eAAK,OAAL;AACA,eAAK,WAAL;AACA,eAAK,WAAL;AACEF,YAAAA,KAAK,GAAGG,iBAAiB,CAACvC,IAAD,CAAzB;AACA;;AACF,eAAK,YAAL;AACEoC,YAAAA,KAAK,GAAGI,mBAAmB,CAACxC,IAAD,CAA3B;AACA;;AACF,eAAK,OAAL;AACEoC,YAAAA,KAAK,GAAGK,cAAc,CAACzC,IAAD,CAAtB;AACA;;AACF,eAAK,YAAL;AACEoC,YAAAA,KAAK,GAAGM,mBAAmB,CAAC1C,IAAD,CAA3B;AACA;;AACF,eAAK,UAAL;AACEoC,YAAAA,KAAK,GAAGO,iBAAiB,CAAC3C,IAAD,CAAzB;AACA;;AACF,eAAK,cAAL;AACEoC,YAAAA,KAAK,GAAGQ,qBAAqB,CAAC5C,IAAD,CAA7B;AACA;;AACF,eAAK,cAAL;AACEoC,YAAAA,KAAK,GAAGS,qBAAqB,CAAC7C,IAAD,CAA7B;AACA;;AACF,eAAK,kBAAL;AACEoC,YAAAA,KAAK,GAAGU,yBAAyB,CAAC9C,IAAD,CAAjC;AACA;;AACF,eAAK,gBAAL;AACEoC,YAAAA,KAAK,GAAGW,uBAAuB,CAAC/C,IAAD,CAA/B;AACA;;AACF,eAAK,gBAAL;AACEoC,YAAAA,KAAK,GAAGY,uBAAuB,CAAChD,IAAD,CAA/B;AACA;;AACF,eAAK,UAAL;AACEoC,YAAAA,KAAK,GAAGa,iBAAiB,CAACjD,IAAD,CAAzB;AACA;;AACF,eAAK,KAAL;AACEoC,YAAAA,KAAK,GAAGc,YAAY,CAAClD,IAAD,CAApB;AACA;;AACF,eAAK,MAAL;AACEoC,YAAAA,KAAK,GAAGe,aAAa,CAACnD,IAAD,CAArB;AACA;;AACF,eAAK,UAAL;AACEoC,YAAAA,KAAK,GAAGgB,iBAAiB,CAACpD,IAAD,CAAzB;AACA;;AACF,eAAK,QAAL;AACEoC,YAAAA,KAAK,GAAGiB,eAAe,CAACrD,IAAD,CAAvB;AACA;;AACF,eAAK,eAAL;AACEoC,YAAAA,KAAK,GAAGkB,sBAAsB,CAACtD,IAAD,CAA9B;AACA;;AACF,eAAK,WAAL;AACEoC,YAAAA,KAAK,GAAGmB,kBAAkB,CAACvD,IAAD,CAA1B;AACA;;AACF,eAAK,OAAL;AACA,eAAK,YAAL;AACA,eAAK,QAAL;AACA,eAAK,mBAAL;AACEoC,YAAAA,KAAK,GAAGoB,kBAAkB,CAACxD,IAAD,CAA1B;AACA;;AACF,eAAK,WAAL;AACEoC,YAAAA,KAAK,GAAGqB,kBAAkB,CAACzD,IAAD,CAA1B;AACA;;AACF,eAAK,QAAL;AACA,eAAK,WAAL;AACA,eAAK,QAAL;AACA,eAAK,KAAL;AACA,eAAK,QAAL;AACA,eAAK,WAAL;AACA,eAAK,kBAAL;AACA,eAAK,YAAL;AACA,eAAK,QAAL;AACA,eAAK,OAAL;AACA,eAAK,WAAL;AACA,eAAK,gBAAL;AACA,eAAK,aAAL;AACA,eAAK,iBAAL;AACA,eAAK,cAAL;AACA,eAAK,YAAL;AACA,eAAK,aAAL;AACA,eAAK,kBAAL;AACA,eAAK,MAAL;AACA,eAAK,WAAL;AACA,eAAK,cAAL;AACA,eAAK,mBAAL;AACA,eAAK,wBAAL;AACA,eAAK,oBAAL;AACA,eAAK,yBAAL;AACA,eAAK,sBAAL;AACA,eAAK,oBAAL;AACA,eAAK,KAAL;AACA,eAAK,gBAAL;AACA,eAAK,WAAL;AACE;;AACF;AACExE,YAAAA,OAAO,CAACkI,IAAR,CAAa,iCAAb,EAAgDpB,QAAhD;AACA;AAhGJ;;AAkGA,YAAIF,KAAK,KAAK,KAAK,CAAf,IAAoBpC,IAAI,CAAClC,GAAL,KAAa,KAAK,CAAtC,IAA2CsE,KAAK,CAACuB,cAAN,CAAqB,MAArB,MAAiC,IAAhF,EAAsF;AACpFvB,UAAAA,KAAK,CAAC/E,IAAN,GAAa2C,IAAI,CAAClC,GAAlB;AACD;;AACD,eAAOsE,KAAP;AACD;;AACD,eAASG,iBAAT,CAA2BvC,IAA3B,EAAiC;AAC/B,YAAM2B,MAAM,GAAG,IAAIpJ,KAAJ,EAAf;AACA,YAAM6H,MAAM,GAAGJ,IAAI,CAACI,MAApB;;AACA,aAAK,IAAIpB,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGmB,MAAM,CAACpD,MAA3B,EAAmCgC,CAAC,GAAGC,CAAvC,EAA0CD,CAAC,EAA3C,EAA+C;AAC7C,cAAMqB,KAAK,GAAGD,MAAM,CAACpB,CAAD,CAApB;AACA,cAAM4E,SAAS,GAAGvD,KAAK,CAAChD,IAAxB;AACA,cAAM2E,WAAW,GAAG3B,KAAK,CAACG,MAA1B;;AACA,kBAAQoD,SAAR;AACE,iBAAK,YAAL;AACE;;AACF,iBAAK,UAAL;AACE;;AACF,iBAAK,QAAL;AACE;;AACF,iBAAK,UAAL;AACEC,cAAAA,kBAAkB,CAAC7B,WAAD,EAAcL,MAAd,CAAlB;AACA;;AACF,iBAAK,SAAL;AACE;;AACF,iBAAK,UAAL;AACE,kBAAMmC,IAAI,GAAG,IAAItL,OAAJ,CAAYwJ,WAAW,CAAC,CAAD,CAAvB,EAA4BA,WAAW,CAAC,CAAD,CAAvC,EAA4CA,WAAW,CAAC,CAAD,CAAvD,CAAb;AACA,kBAAM+B,KAAK,GAAG/B,WAAW,CAAC,CAAD,CAAzB;AACAL,cAAAA,MAAM,CAACqC,UAAP,CAAkBC,gBAAlB,CAAmCH,IAAnC,EAAyCC,KAAzC;AACA;;AACF,iBAAK,OAAL;AACEpC,cAAAA,MAAM,CAACuC,KAAP,CAAaC,GAAb,CAAiBnC,WAAW,CAAC,CAAD,CAA5B,EAAiCA,WAAW,CAAC,CAAD,CAA5C,EAAiDA,WAAW,CAAC,CAAD,CAA5D;AACA;;AACF,iBAAK,kBAAL;AACE;;AACF,iBAAK,aAAL;AACEL,cAAAA,MAAM,CAACyC,QAAP,CAAgBD,GAAhB,CAAoBnC,WAAW,CAAC,CAAD,CAA/B,EAAoCA,WAAW,CAAC,CAAD,CAA/C,EAAoDA,WAAW,CAAC,CAAD,CAA/D;AACA;;AACF,iBAAK,OAAL;AACE;;AACF;AACExG,cAAAA,OAAO,CAACkI,IAAR,CAAa,kCAAb,EAAiDE,SAAjD;AACA;AA7BJ;AA+BD;;AACD,eAAOjC,MAAP;AACD;;AACD,eAASa,mBAAT,CAA6BxC,IAA7B,EAAmC;AACjC,YAAMnB,KAAK,GAAG,IAAItG,KAAJ,EAAd;AACA,YAAI8L,WAAJ,EAAiBC,WAAjB;AACA,YAAIC,QAAJ,EAAcC,QAAd;AACA,YAAMpE,MAAM,GAAGJ,IAAI,CAACI,MAApB;;AACA,aAAK,IAAIpB,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGmB,MAAM,CAACpD,MAA3B,EAAmCgC,CAAC,GAAGC,CAAvC,EAA0CD,CAAC,EAA3C,EAA+C;AAC7C,cAAMqB,KAAK,GAAGD,MAAM,CAACpB,CAAD,CAApB;AACA,cAAM4E,SAAS,GAAGvD,KAAK,CAAChD,IAAxB;AACA,cAAM2E,WAAW,GAAG3B,KAAK,CAACG,MAA1B;;AACA,kBAAQoD,SAAR;AACE,iBAAK,aAAL;AACES,cAAAA,WAAW,GAAGrC,WAAd;AACA;;AACF,iBAAK,aAAL;AACEsC,cAAAA,WAAW,GAAGtC,WAAd;AACA;;AACF,iBAAK,SAAL;AACE;;AACF,iBAAK,WAAL;AACE;;AACF,iBAAK,UAAL;AACE;;AACF,iBAAK,SAAL;AACE;;AACF,iBAAK,UAAL;AACE;;AACF,iBAAK,QAAL;AACE;;AACF,iBAAK,UAAL;AACEuC,cAAAA,QAAQ,GAAGvC,WAAX;AACA;;AACF,iBAAK,UAAL;AACEwC,cAAAA,QAAQ,GAAGxC,WAAX;AACA;;AACF;AACExG,cAAAA,OAAO,CAACkI,IAAR,CAAa,kCAAb,EAAiDE,SAAjD;AACA;AA3BJ;AA6BD;;AACD,YAAMa,MAAM,GAAG,GAAf;;AACA,YAAID,QAAJ,EAAc;AACZ,cAAME,WAAW,GAAG,IAAIjM,cAAJ,CAAmBgM,MAAnB,EAA2B,EAA3B,EAA+B,EAA/B,CAApB;AACA,cAAME,WAAW,GAAG,IAAIjM,iBAAJ,CAAsB;AAAEkM,YAAAA,GAAG,EAAE,KAAP;AAAcC,YAAAA,IAAI,EAAElM,QAApB;AAA8BmM,YAAAA,UAAU,EAAE,KAA1C;AAAiDC,YAAAA,SAAS,EAAE;AAA5D,WAAtB,CAApB;;AACA,cAAIP,QAAQ,CAACxH,MAAT,GAAkB,CAAtB,EAAyB;AACvBgI,YAAAA,UAAU,CAACN,WAAD,EAAcD,MAAd,EAAsBF,QAAtB,EAAgCU,YAAY,CAACT,QAAD,CAA5C,EAAwD,IAAxD,CAAV;AACAG,YAAAA,WAAW,CAACO,YAAZ,GAA2B,IAA3B;AACD,WAHD,MAGO;AACLP,YAAAA,WAAW,CAACQ,KAAZ,CAAkBC,MAAlB,CAAyBZ,QAAQ,CAAC,CAAD,CAAjC,EAAsCA,QAAQ,CAAC,CAAD,CAA9C,EAAmDA,QAAQ,CAAC,CAAD,CAA3D;AACD;;AACD,cAAMa,GAAG,GAAG,IAAIzM,IAAJ,CAAS8L,WAAT,EAAsBC,WAAtB,CAAZ;AACA9F,UAAAA,KAAK,CAACgD,GAAN,CAAUwD,GAAV;AACD;;AACD,YAAIf,WAAJ,EAAiB;AACf,cAAIA,WAAW,CAACtH,MAAZ,GAAqB,CAAzB,EAA4B;AAC1B,gBAAMsI,cAAc,GAAG,IAAI7M,cAAJ,CAAmBgM,MAAnB,EAA2B,EAA3B,EAA+B,EAA/B,EAAmC,CAAnC,EAAsC,IAAIc,IAAI,CAACC,EAA/C,EAAmD,MAAMD,IAAI,CAACC,EAA9D,EAAkE,MAAMD,IAAI,CAACC,EAA7E,CAAvB;AACA,gBAAMC,cAAc,GAAG,IAAI/M,iBAAJ,CAAsB;AAC3CkM,cAAAA,GAAG,EAAE,KADsC;AAE3CC,cAAAA,IAAI,EAAElM,QAFqC;AAG3CuM,cAAAA,YAAY,EAAE,IAH6B;AAI3CJ,cAAAA,UAAU,EAAE,KAJ+B;AAK3CC,cAAAA,SAAS,EAAE;AALgC,aAAtB,CAAvB;AAOAC,YAAAA,UAAU,CAACM,cAAD,EAAiBb,MAAjB,EAAyBJ,WAAzB,EAAsCY,YAAY,CAACX,WAAD,CAAlD,EAAiE,KAAjE,CAAV;AACA,gBAAMoB,MAAM,GAAG,IAAI9M,IAAJ,CAAS0M,cAAT,EAAyBG,cAAzB,CAAf;AACA5G,YAAAA,KAAK,CAACgD,GAAN,CAAU6D,MAAV;AACD;AACF;;AACD7G,QAAAA,KAAK,CAAC8G,WAAN,GAAoB,CAACC,QAArB;AACA,eAAO/G,KAAP;AACD;;AACD,eAAS4D,cAAT,CAAwBzC,IAAxB,EAA8B;AAC5B,YAAMI,MAAM,GAAGJ,IAAI,CAACI,MAApB;AACA,YAAIyF,QAAQ,GAAG,IAAInN,iBAAJ,CAAsB;AAAEyM,UAAAA,KAAK,EAAE;AAAT,SAAtB,CAAf;AACA,YAAIW,QAAJ;;AACA,aAAK,IAAI9G,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGmB,MAAM,CAACpD,MAA3B,EAAmCgC,CAAC,GAAGC,CAAvC,EAA0CD,CAAC,EAA3C,EAA+C;AAC7C,cAAMqB,KAAK,GAAGD,MAAM,CAACpB,CAAD,CAApB;AACA,cAAM4E,SAAS,GAAGvD,KAAK,CAAChD,IAAxB;AACA,cAAM2E,WAAW,GAAG3B,KAAK,CAACG,MAA1B;;AACA,kBAAQoD,SAAR;AACE,iBAAK,YAAL;AACE,kBAAI5B,WAAW,CAAC,CAAD,CAAX,KAAmB,IAAvB,EAA6B;AAC3B6D,gBAAAA,QAAQ,GAAGjE,OAAO,CAACI,WAAW,CAAC,CAAD,CAAZ,CAAlB;AACD;;AACD;;AACF,iBAAK,UAAL;AACE,kBAAIA,WAAW,CAAC,CAAD,CAAX,KAAmB,IAAvB,EAA6B;AAC3B8D,gBAAAA,QAAQ,GAAGlE,OAAO,CAACI,WAAW,CAAC,CAAD,CAAZ,CAAlB;AACD;;AACD;;AACF;AACExG,cAAAA,OAAO,CAACkI,IAAR,CAAa,kCAAb,EAAiDE,SAAjD;AACA;AAbJ;AAeD;;AACD,YAAIjC,MAAJ;;AACA,YAAImE,QAAQ,IAAIA,QAAQ,CAACC,UAAT,CAAoB3B,QAApC,EAA8C;AAC5C,cAAM7D,IAAI,GAAGuF,QAAQ,CAACE,KAAtB;;AACA,cAAIzF,IAAI,KAAK,QAAb,EAAuB;AACrB,gBAAM0F,cAAc,GAAG,IAAIpN,cAAJ,CAAmB;AAAEsM,cAAAA,KAAK,EAAE;AAAT,aAAnB,CAAvB;;AACA,gBAAIW,QAAQ,CAACC,UAAT,CAAoBZ,KAApB,KAA8B,KAAK,CAAvC,EAA0C;AACxCc,cAAAA,cAAc,CAACf,YAAf,GAA8B,IAA9B;AACD,aAFD,MAEO;AACL,kBAAIW,QAAQ,CAACK,mBAAb,EAAkC;AAChCD,gBAAAA,cAAc,CAACd,KAAf,CAAqBgB,IAArB,CAA0BN,QAAQ,CAACO,QAAnC;AACD;AACF;;AACDzE,YAAAA,MAAM,GAAG,IAAI7I,MAAJ,CAAWgN,QAAX,EAAqBG,cAArB,CAAT;AACD,WAVD,MAUO,IAAI1F,IAAI,KAAK,MAAb,EAAqB;AAC1B,gBAAM8F,YAAY,GAAG,IAAItN,iBAAJ,CAAsB;AAAEoM,cAAAA,KAAK,EAAE;AAAT,aAAtB,CAArB;;AACA,gBAAIW,QAAQ,CAACC,UAAT,CAAoBZ,KAApB,KAA8B,KAAK,CAAvC,EAA0C;AACxCkB,cAAAA,YAAY,CAACnB,YAAb,GAA4B,IAA5B;AACD,aAFD,MAEO;AACL,kBAAIW,QAAQ,CAACK,mBAAb,EAAkC;AAChCG,gBAAAA,YAAY,CAAClB,KAAb,CAAmBgB,IAAnB,CAAwBN,QAAQ,CAACO,QAAjC;AACD;AACF;;AACDzE,YAAAA,MAAM,GAAG,IAAI3I,YAAJ,CAAiB8M,QAAjB,EAA2BO,YAA3B,CAAT;AACD,WAVM,MAUA;AACL,gBAAIP,QAAQ,CAACQ,MAAT,KAAoB,KAAK,CAA7B,EAAgC;AAC9BT,cAAAA,QAAQ,CAAChB,IAAT,GAAgBiB,QAAQ,CAACQ,MAAT,GAAkBrN,SAAlB,GAA8BC,UAA9C;AACD;;AACD,gBAAI4M,QAAQ,CAACC,UAAT,CAAoBZ,KAApB,KAA8B,KAAK,CAAvC,EAA0C;AACxCU,cAAAA,QAAQ,CAACX,YAAT,GAAwB,IAAxB;AACD;;AACDvD,YAAAA,MAAM,GAAG,IAAI/I,IAAJ,CAASkN,QAAT,EAAmBD,QAAnB,CAAT;AACD;AACF,SA/BD,MA+BO;AACLlE,UAAAA,MAAM,GAAG,IAAIrJ,QAAJ,EAAT;AACAqJ,UAAAA,MAAM,CAAC4E,OAAP,GAAiB,KAAjB;AACD;;AACD,eAAO5E,MAAP;AACD;;AACD,eAASe,mBAAT,CAA6B1C,IAA7B,EAAmC;AACjC,YAAI6F,QAAQ,GAAG,IAAI1M,iBAAJ,EAAf;AACA,YAAIqN,aAAJ;AACA,YAAMpG,MAAM,GAAGJ,IAAI,CAACI,MAApB;;AACA,aAAK,IAAIpB,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGmB,MAAM,CAACpD,MAA3B,EAAmCgC,CAAC,GAAGC,CAAvC,EAA0CD,CAAC,EAA3C,EAA+C;AAC7C,cAAMqB,KAAK,GAAGD,MAAM,CAACpB,CAAD,CAApB;AACA,cAAM4E,SAAS,GAAGvD,KAAK,CAAChD,IAAxB;AACA,cAAM2E,WAAW,GAAG3B,KAAK,CAACG,MAA1B;;AACA,kBAAQoD,SAAR;AACE,iBAAK,UAAL;AACE,kBAAI5B,WAAW,CAAC,CAAD,CAAX,KAAmB,IAAvB,EAA6B;AAC3B,oBAAMyE,YAAY,GAAG7E,OAAO,CAACI,WAAW,CAAC,CAAD,CAAZ,CAA5B;AACA,oBAAIyE,YAAY,CAACC,YAAjB,EACEb,QAAQ,CAACV,KAAT,CAAegB,IAAf,CAAoBM,YAAY,CAACC,YAAjC;AACF,oBAAID,YAAY,CAACE,aAAjB,EACEd,QAAQ,CAACO,QAAT,CAAkBD,IAAlB,CAAuBM,YAAY,CAACE,aAApC;AACF,oBAAIF,YAAY,CAACG,SAAjB,EACEf,QAAQ,CAACe,SAAT,GAAqBH,YAAY,CAACG,SAAlC;AACF,oBAAIH,YAAY,CAACI,aAAjB,EACEhB,QAAQ,CAACiB,QAAT,CAAkBX,IAAlB,CAAuBM,YAAY,CAACI,aAApC;AACF,oBAAIJ,YAAY,CAACM,YAAjB,EACElB,QAAQ,CAACmB,OAAT,GAAmB,IAAIP,YAAY,CAACM,YAApC;AACF,oBAAIN,YAAY,CAACM,YAAb,GAA4B,CAAhC,EACElB,QAAQ,CAACoB,WAAT,GAAuB,IAAvB;AACH,eAdD,MAcO;AACLpB,gBAAAA,QAAQ,GAAG,IAAInN,iBAAJ,CAAsB;AAAEyM,kBAAAA,KAAK,EAAE;AAAT,iBAAtB,CAAX;AACD;;AACD;;AACF,iBAAK,SAAL;AACE,kBAAM+B,WAAW,GAAGlF,WAAW,CAAC,CAAD,CAA/B;;AACA,kBAAIkF,WAAW,KAAK,IAApB,EAA0B;AACxB,oBAAIA,WAAW,CAAC7J,IAAZ,KAAqB,cAArB,IAAuC6J,WAAW,CAAC7J,IAAZ,KAAqB,cAAhE,EAAgF;AAC9EwI,kBAAAA,QAAQ,CAACsB,GAAT,GAAevF,OAAO,CAACsF,WAAD,CAAtB;AACD,iBAFD,MAEO,CACN;AACF;;AACD;;AACF,iBAAK,kBAAL;AACE,kBAAIlF,WAAW,CAAC,CAAD,CAAX,KAAmB,IAAvB,EAA6B;AAC3BwE,gBAAAA,aAAa,GAAG5E,OAAO,CAACI,WAAW,CAAC,CAAD,CAAZ,CAAvB;AACD;;AACD;;AACF;AACExG,cAAAA,OAAO,CAACkI,IAAR,CAAa,kCAAb,EAAiDE,SAAjD;AACA;AApCJ;AAsCD;;AACD,YAAIiC,QAAQ,CAACsB,GAAb,EAAkB;AAChB,cAAItB,QAAQ,CAACsB,GAAT,CAAaC,MAAjB,EAAyB;AACvB,oBAAQvB,QAAQ,CAACsB,GAAT,CAAaC,MAArB;AACE,mBAAKC,YAAY,CAACC,eAAlB;AACEzB,gBAAAA,QAAQ,CAACmB,OAAT,GAAmB,CAAnB;AACA;;AACF,mBAAKK,YAAY,CAACE,GAAlB;AACE1B,gBAAAA,QAAQ,CAACV,KAAT,CAAehB,GAAf,CAAmB,QAAnB;AACA;;AACF,mBAAKkD,YAAY,CAACG,IAAlB;AACE3B,gBAAAA,QAAQ,CAACV,KAAT,CAAehB,GAAf,CAAmB,QAAnB;AACA0B,gBAAAA,QAAQ,CAACmB,OAAT,GAAmB,CAAnB;AACA;;AACF;AAXF;;AAaA,mBAAOnB,QAAQ,CAACsB,GAAT,CAAaC,MAApB;AACD;;AACD,cAAIZ,aAAJ,EAAmB;AACjBX,YAAAA,QAAQ,CAACsB,GAAT,CAAaM,MAAb,CAAoBtB,IAApB,CAAyBK,aAAa,CAACiB,MAAvC;AACA5B,YAAAA,QAAQ,CAACsB,GAAT,CAAaO,QAAb,GAAwBlB,aAAa,CAACkB,QAAtC;AACA7B,YAAAA,QAAQ,CAACsB,GAAT,CAAaQ,MAAb,CAAoBxB,IAApB,CAAyBK,aAAa,CAACtC,KAAvC;AACA2B,YAAAA,QAAQ,CAACsB,GAAT,CAAaS,MAAb,CAAoBzB,IAApB,CAAyBK,aAAa,CAACqB,WAAvC;AACD;AACF;;AACD,eAAOhC,QAAP;AACD;;AACD,eAASlD,iBAAT,CAA2B3C,IAA3B,EAAiC;AAC/B,YAAMyG,YAAY,GAAG,EAArB;AACA,YAAMrG,MAAM,GAAGJ,IAAI,CAACI,MAApB;;AACA,aAAK,IAAIpB,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGmB,MAAM,CAACpD,MAA3B,EAAmCgC,CAAC,GAAGC,CAAvC,EAA0CD,CAAC,EAA3C,EAA+C;AAC7C,cAAMqB,KAAK,GAAGD,MAAM,CAACpB,CAAD,CAApB;AACA,cAAM4E,SAAS,GAAGvD,KAAK,CAAChD,IAAxB;AACA,cAAM2E,WAAW,GAAG3B,KAAK,CAACG,MAA1B;;AACA,kBAAQoD,SAAR;AACE,iBAAK,kBAAL;AACE;;AACF,iBAAK,cAAL;AACE6C,cAAAA,YAAY,CAACC,YAAb,GAA4B,IAAItN,KAAJ,CAAU4I,WAAW,CAAC,CAAD,CAArB,EAA0BA,WAAW,CAAC,CAAD,CAArC,EAA0CA,WAAW,CAAC,CAAD,CAArD,CAA5B;AACA;;AACF,iBAAK,eAAL;AACEyE,cAAAA,YAAY,CAACE,aAAb,GAA6B,IAAIvN,KAAJ,CAAU4I,WAAW,CAAC,CAAD,CAArB,EAA0BA,WAAW,CAAC,CAAD,CAArC,EAA0CA,WAAW,CAAC,CAAD,CAArD,CAA7B;AACA;;AACF,iBAAK,WAAL;AACEyE,cAAAA,YAAY,CAACG,SAAb,GAAyB5E,WAAW,CAAC,CAAD,CAApC;AACA;;AACF,iBAAK,eAAL;AACEyE,cAAAA,YAAY,CAACE,aAAb,GAA6B,IAAIvN,KAAJ,CAAU4I,WAAW,CAAC,CAAD,CAArB,EAA0BA,WAAW,CAAC,CAAD,CAArC,EAA0CA,WAAW,CAAC,CAAD,CAArD,CAA7B;AACA;;AACF,iBAAK,cAAL;AACEyE,cAAAA,YAAY,CAACM,YAAb,GAA4B/E,WAAW,CAAC,CAAD,CAAvC;AACA;;AACF;AACExG,cAAAA,OAAO,CAACkI,IAAR,CAAa,kCAAb,EAAiDE,SAAjD;AACA;AApBJ;AAsBD;;AACD,eAAO6C,YAAP;AACD;;AACD,eAASqB,aAAT,CAAuBC,GAAvB,EAA4BC,WAA5B,EAAyC7C,KAAzC,EAAgD;AAC9C,YAAI8C,KAAJ;;AACA,gBAAQD,WAAR;AACE,eAAKX,YAAY,CAACa,SAAlB;AACED,YAAAA,KAAK,GAAGE,QAAQ,CAACJ,GAAD,CAAhB;AACA5C,YAAAA,KAAK,CAACiD,CAAN,GAAUH,KAAV;AACA9C,YAAAA,KAAK,CAACkD,CAAN,GAAUJ,KAAV;AACA9C,YAAAA,KAAK,CAACmD,CAAN,GAAUL,KAAV;AACA9C,YAAAA,KAAK,CAACoD,CAAN,GAAU,CAAV;AACA;;AACF,eAAKlB,YAAY,CAACC,eAAlB;AACEW,YAAAA,KAAK,GAAGE,QAAQ,CAAC,OAAOJ,GAAG,CAACS,SAAJ,CAAc,CAAd,EAAiB,CAAjB,CAAR,CAAhB;AACArD,YAAAA,KAAK,CAACiD,CAAN,GAAUH,KAAV;AACA9C,YAAAA,KAAK,CAACkD,CAAN,GAAUJ,KAAV;AACA9C,YAAAA,KAAK,CAACmD,CAAN,GAAUL,KAAV;AACA9C,YAAAA,KAAK,CAACoD,CAAN,GAAUJ,QAAQ,CAAC,OAAOJ,GAAG,CAACS,SAAJ,CAAc,CAAd,EAAiB,CAAjB,CAAR,CAAlB;AACA;;AACF,eAAKnB,YAAY,CAACE,GAAlB;AACEpC,YAAAA,KAAK,CAACiD,CAAN,GAAUD,QAAQ,CAAC,OAAOJ,GAAG,CAACS,SAAJ,CAAc,CAAd,EAAiB,CAAjB,CAAR,CAAlB;AACArD,YAAAA,KAAK,CAACkD,CAAN,GAAUF,QAAQ,CAAC,OAAOJ,GAAG,CAACS,SAAJ,CAAc,CAAd,EAAiB,CAAjB,CAAR,CAAlB;AACArD,YAAAA,KAAK,CAACmD,CAAN,GAAUH,QAAQ,CAAC,OAAOJ,GAAG,CAACS,SAAJ,CAAc,CAAd,EAAiB,CAAjB,CAAR,CAAlB;AACArD,YAAAA,KAAK,CAACoD,CAAN,GAAU,CAAV;AACA;;AACF,eAAKlB,YAAY,CAACG,IAAlB;AACErC,YAAAA,KAAK,CAACiD,CAAN,GAAUD,QAAQ,CAAC,OAAOJ,GAAG,CAACS,SAAJ,CAAc,CAAd,EAAiB,CAAjB,CAAR,CAAlB;AACArD,YAAAA,KAAK,CAACkD,CAAN,GAAUF,QAAQ,CAAC,OAAOJ,GAAG,CAACS,SAAJ,CAAc,CAAd,EAAiB,CAAjB,CAAR,CAAlB;AACArD,YAAAA,KAAK,CAACmD,CAAN,GAAUH,QAAQ,CAAC,OAAOJ,GAAG,CAACS,SAAJ,CAAc,CAAd,EAAiB,CAAjB,CAAR,CAAlB;AACArD,YAAAA,KAAK,CAACoD,CAAN,GAAUJ,QAAQ,CAAC,OAAOJ,GAAG,CAACS,SAAJ,CAAc,CAAd,EAAiB,EAAjB,CAAR,CAAlB;AACA;;AACF;AA3BF;AA6BD;;AACD,eAASC,cAAT,CAAwBC,cAAxB,EAAwC;AACtC,YAAInI,IAAJ;;AACA,gBAAQmI,cAAR;AACE,eAAK,CAAL;AACEnI,YAAAA,IAAI,GAAG8G,YAAY,CAACa,SAApB;AACA;;AACF,eAAK,CAAL;AACE3H,YAAAA,IAAI,GAAG8G,YAAY,CAACC,eAApB;AACA;;AACF,eAAK,CAAL;AACE/G,YAAAA,IAAI,GAAG8G,YAAY,CAACE,GAApB;AACA;;AACF,eAAK,CAAL;AACEhH,YAAAA,IAAI,GAAG8G,YAAY,CAACG,IAApB;AACA;;AACF;AAbF;;AAeA,eAAOjH,IAAP;AACD;;AACD,eAASsC,qBAAT,CAA+B7C,IAA/B,EAAqC;AACnC,YAAI2I,OAAJ;AACA,YAAIC,KAAK,GAAGvP,cAAZ;AACA,YAAIwP,KAAK,GAAGxP,cAAZ;AACA,YAAM+G,MAAM,GAAGJ,IAAI,CAACI,MAApB;;AACA,aAAK,IAAIpB,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGmB,MAAM,CAACpD,MAA3B,EAAmCgC,CAAC,GAAGC,CAAvC,EAA0CD,CAAC,EAA3C,EAA+C;AAC7C,cAAMqB,KAAK,GAAGD,MAAM,CAACpB,CAAD,CAApB;AACA,cAAM4E,SAAS,GAAGvD,KAAK,CAAChD,IAAxB;AACA,cAAM2E,WAAW,GAAG3B,KAAK,CAACG,MAA1B;;AACA,kBAAQoD,SAAR;AACE,iBAAK,OAAL;AACE,kBAAMkF,KAAK,GAAG9G,WAAW,CAAC,CAAD,CAAzB;AACA,kBAAM+G,MAAM,GAAG/G,WAAW,CAAC,CAAD,CAA1B;AACA,kBAAM0G,cAAc,GAAG1G,WAAW,CAAC,CAAD,CAAlC;AACA,kBAAMgG,WAAW,GAAGS,cAAc,CAACC,cAAD,CAAlC;AACA,kBAAM5M,KAAK,GAAG,IAAIkN,UAAJ,CAAe,IAAIF,KAAJ,GAAYC,MAA3B,CAAd;AACA,kBAAM5D,KAAK,GAAG;AAAEiD,gBAAAA,CAAC,EAAE,CAAL;AAAQC,gBAAAA,CAAC,EAAE,CAAX;AAAcC,gBAAAA,CAAC,EAAE,CAAjB;AAAoBC,gBAAAA,CAAC,EAAE;AAAvB,eAAd;;AACA,mBAAK,IAAItG,CAAC,GAAG,CAAR,EAAWgH,CAAC,GAAG,CAAf,EAAkB/G,EAAE,GAAGF,WAAW,CAAChF,MAAxC,EAAgDiF,CAAC,GAAGC,EAApD,EAAwDD,CAAC,IAAIgH,CAAC,EAA9D,EAAkE;AAChEnB,gBAAAA,aAAa,CAAC9F,WAAW,CAACC,CAAD,CAAZ,EAAiB+F,WAAjB,EAA8B7C,KAA9B,CAAb;AACA,oBAAM+D,MAAM,GAAGD,CAAC,GAAG,CAAnB;AACAnN,gBAAAA,KAAK,CAACoN,MAAM,GAAG,CAAV,CAAL,GAAoB/D,KAAK,CAACiD,CAA1B;AACAtM,gBAAAA,KAAK,CAACoN,MAAM,GAAG,CAAV,CAAL,GAAoB/D,KAAK,CAACkD,CAA1B;AACAvM,gBAAAA,KAAK,CAACoN,MAAM,GAAG,CAAV,CAAL,GAAoB/D,KAAK,CAACmD,CAA1B;AACAxM,gBAAAA,KAAK,CAACoN,MAAM,GAAG,CAAV,CAAL,GAAoB/D,KAAK,CAACoD,CAA1B;AACD;;AACDI,cAAAA,OAAO,GAAG,IAAIpP,WAAJ,CAAgBuC,KAAhB,EAAuBgN,KAAvB,EAA8BC,MAA9B,CAAV;AACAJ,cAAAA,OAAO,CAACQ,WAAR,GAAsB,IAAtB;AACAR,cAAAA,OAAO,CAACvB,MAAR,GAAiBY,WAAjB;AACA;;AACF,iBAAK,SAAL;AACE,kBAAIhG,WAAW,CAAC,CAAD,CAAX,KAAmB,KAAvB,EACE4G,KAAK,GAAGtP,mBAAR;AACF;;AACF,iBAAK,SAAL;AACE,kBAAI0I,WAAW,CAAC,CAAD,CAAX,KAAmB,KAAvB,EACE6G,KAAK,GAAGvP,mBAAR;AACF;;AACF;AACEkC,cAAAA,OAAO,CAACkI,IAAR,CAAa,kCAAb,EAAiDE,SAAjD;AACA;AA9BJ;AAgCD;;AACD,YAAI+E,OAAJ,EAAa;AACXA,UAAAA,OAAO,CAACC,KAAR,GAAgBA,KAAhB;AACAD,UAAAA,OAAO,CAACE,KAAR,GAAgBA,KAAhB;AACD;;AACD,eAAOF,OAAP;AACD;;AACD,eAAS/F,qBAAT,CAA+B5C,IAA/B,EAAqC;AACnC,YAAI2I,OAAJ;AACA,YAAIC,KAAK,GAAGvP,cAAZ;AACA,YAAIwP,KAAK,GAAGxP,cAAZ;AACA,YAAM+G,MAAM,GAAGJ,IAAI,CAACI,MAApB;;AACA,aAAK,IAAIpB,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGmB,MAAM,CAACpD,MAA3B,EAAmCgC,CAAC,GAAGC,CAAvC,EAA0CD,CAAC,EAA3C,EAA+C;AAC7C,cAAMqB,KAAK,GAAGD,MAAM,CAACpB,CAAD,CAApB;AACA,cAAM4E,SAAS,GAAGvD,KAAK,CAAChD,IAAxB;AACA,cAAM2E,WAAW,GAAG3B,KAAK,CAACG,MAA1B;;AACA,kBAAQoD,SAAR;AACE,iBAAK,KAAL;AACE,kBAAMrJ,GAAG,GAAGyH,WAAW,CAAC,CAAD,CAAvB;AACA,kBAAIzH,GAAJ,EACEoO,OAAO,GAAGS,aAAa,CAAChO,IAAd,CAAmBb,GAAnB,CAAV;AACF;;AACF,iBAAK,SAAL;AACE,kBAAIyH,WAAW,CAAC,CAAD,CAAX,KAAmB,KAAvB,EACE4G,KAAK,GAAGtP,mBAAR;AACF;;AACF,iBAAK,SAAL;AACE,kBAAI0I,WAAW,CAAC,CAAD,CAAX,KAAmB,KAAvB,EACE6G,KAAK,GAAGvP,mBAAR;AACF;;AACF;AACEkC,cAAAA,OAAO,CAACkI,IAAR,CAAa,kCAAb,EAAiDE,SAAjD;AACA;AAhBJ;AAkBD;;AACD,YAAI+E,OAAJ,EAAa;AACXA,UAAAA,OAAO,CAACC,KAAR,GAAgBA,KAAhB;AACAD,UAAAA,OAAO,CAACE,KAAR,GAAgBA,KAAhB;AACD;;AACD,eAAOF,OAAP;AACD;;AACD,eAAS7F,yBAAT,CAAmC9C,IAAnC,EAAyC;AACvC,YAAMwG,aAAa,GAAG;AACpBiB,UAAAA,MAAM,EAAE,IAAIjO,OAAJ,EADY;AAEpBkO,UAAAA,QAAQ,EAAE,IAAIlO,OAAJ,EAFU;AAGpB0K,UAAAA,KAAK,EAAE,IAAI1K,OAAJ,EAHa;AAIpBqO,UAAAA,WAAW,EAAE,IAAIrO,OAAJ;AAJO,SAAtB;AAMA,YAAM4G,MAAM,GAAGJ,IAAI,CAACI,MAApB;;AACA,aAAK,IAAIpB,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGmB,MAAM,CAACpD,MAA3B,EAAmCgC,CAAC,GAAGC,CAAvC,EAA0CD,CAAC,EAA3C,EAA+C;AAC7C,cAAMqB,KAAK,GAAGD,MAAM,CAACpB,CAAD,CAApB;AACA,cAAM4E,SAAS,GAAGvD,KAAK,CAAChD,IAAxB;AACA,cAAM2E,WAAW,GAAG3B,KAAK,CAACG,MAA1B;;AACA,kBAAQoD,SAAR;AACE,iBAAK,QAAL;AACE4C,cAAAA,aAAa,CAACiB,MAAd,CAAqBtD,GAArB,CAAyBnC,WAAW,CAAC,CAAD,CAApC,EAAyCA,WAAW,CAAC,CAAD,CAApD;AACA;;AACF,iBAAK,UAAL;AACEwE,cAAAA,aAAa,CAACkB,QAAd,GAAyB1F,WAAW,CAAC,CAAD,CAApC;AACA;;AACF,iBAAK,OAAL;AACEwE,cAAAA,aAAa,CAACtC,KAAd,CAAoBC,GAApB,CAAwBnC,WAAW,CAAC,CAAD,CAAnC,EAAwCA,WAAW,CAAC,CAAD,CAAnD;AACA;;AACF,iBAAK,aAAL;AACEwE,cAAAA,aAAa,CAACqB,WAAd,CAA0B1D,GAA1B,CAA8BnC,WAAW,CAAC,CAAD,CAAzC,EAA8CA,WAAW,CAAC,CAAD,CAAzD;AACA;;AACF;AACExG,cAAAA,OAAO,CAACkI,IAAR,CAAa,kCAAb,EAAiDE,SAAjD;AACA;AAfJ;AAiBD;;AACD,eAAO4C,aAAP;AACD;;AACD,eAAShD,kBAAT,CAA4BxD,IAA5B,EAAkC;AAChC,eAAOA,IAAI,CAACI,MAAL,CAAY,CAAZ,EAAeI,MAAtB;AACD;;AACD,eAASiD,kBAAT,CAA4BzD,IAA5B,EAAkC;AAChC,YAAM+B,SAAS,GAAG,EAAlB;AACA,YAAM3B,MAAM,GAAGJ,IAAI,CAACI,MAApB;;AACA,aAAK,IAAIpB,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGmB,MAAM,CAACpD,MAA3B,EAAmCgC,CAAC,GAAGC,CAAvC,EAA0CD,CAAC,EAA3C,EAA+C;AAC7C,cAAMqB,KAAK,GAAGD,MAAM,CAACpB,CAAD,CAApB;AACA,cAAM4E,SAAS,GAAGvD,KAAK,CAAChD,IAAxB;AACA,cAAM2E,WAAW,GAAG3B,KAAK,CAACG,MAA1B;;AACA,kBAAQoD,SAAR;AACE,iBAAK,OAAL;AACE7B,cAAAA,SAAS,CAACsH,KAAV,GAAkBrH,WAAW,CAAC,CAAD,CAA7B;AACA;;AACF,iBAAK,MAAL;AACED,cAAAA,SAAS,CAACuH,IAAV,GAAiBtH,WAAjB;AACA;;AACF;AACExG,cAAAA,OAAO,CAACkI,IAAR,CAAa,kCAAb,EAAiDE,SAAjD;AACA;AATJ;AAWD;;AACD,eAAO7B,SAAP;AACD;;AACD,eAASgB,uBAAT,CAAiC/C,IAAjC,EAAuC;AACrC,YAAImF,KAAJ,EAAWoE,KAAX,EAAkBC,MAAlB,EAA0BC,QAA1B;AACA,YAAIC,GAAG,GAAG,IAAV;AAAA,YAAgBC,KAAK,GAAG,IAAxB;AAAA,YAA8BC,WAAW,GAAG,CAA5C;AACA,YAAIC,UAAJ,EAAgBC,UAAhB,EAA4BC,WAA5B,EAAyCC,aAAzC;AACA,YAAIC,cAAc,GAAG,IAArB;AAAA,YAA2BC,eAAe,GAAG,IAA7C;AACA,YAAM9J,MAAM,GAAGJ,IAAI,CAACI,MAApB;;AACA,aAAK,IAAIpB,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGmB,MAAM,CAACpD,MAA3B,EAAmCgC,CAAC,GAAGC,CAAvC,EAA0CD,CAAC,EAA3C,EAA+C;AAC7C,cAAMqB,KAAK,GAAGD,MAAM,CAACpB,CAAD,CAApB;AACA,cAAM4E,SAAS,GAAGvD,KAAK,CAAChD,IAAxB;AACA,cAAM2E,WAAW,GAAG3B,KAAK,CAACG,MAA1B;;AACA,kBAAQoD,SAAR;AACE,iBAAK,OAAL;AACE,kBAAMuG,SAAS,GAAGnI,WAAW,CAAC,CAAD,CAA7B;;AACA,kBAAImI,SAAS,KAAK,IAAlB,EAAwB;AACtBhF,gBAAAA,KAAK,GAAGvD,OAAO,CAACuI,SAAD,CAAf;AACD;;AACD;;AACF,iBAAK,OAAL;AACE,kBAAMC,SAAS,GAAGpI,WAAW,CAAC,CAAD,CAA7B;;AACA,kBAAIoI,SAAS,KAAK,IAAlB,EAAwB;AACtBb,gBAAAA,KAAK,GAAG3H,OAAO,CAACwI,SAAD,CAAf;AACD;;AACD;;AACF,iBAAK,QAAL;AACE,kBAAMC,UAAU,GAAGrI,WAAW,CAAC,CAAD,CAA9B;;AACA,kBAAIqI,UAAU,KAAK,IAAnB,EAAyB;AACvBb,gBAAAA,MAAM,GAAG5H,OAAO,CAACyI,UAAD,CAAhB;AACD;;AACD;;AACF,iBAAK,UAAL;AACE,kBAAMC,YAAY,GAAGtI,WAAW,CAAC,CAAD,CAAhC;;AACA,kBAAIsI,YAAY,KAAK,IAArB,EAA2B;AACzBb,gBAAAA,QAAQ,GAAG7H,OAAO,CAAC0I,YAAD,CAAlB;AACD;;AACD;;AACF,iBAAK,KAAL;AACEZ,cAAAA,GAAG,GAAG1H,WAAW,CAAC,CAAD,CAAjB;AACA;;AACF,iBAAK,YAAL;AACE6H,cAAAA,UAAU,GAAG7H,WAAb;AACA;;AACF,iBAAK,gBAAL;AACEiI,cAAAA,cAAc,GAAGjI,WAAW,CAAC,CAAD,CAA5B;AACA;;AACF,iBAAK,QAAL;AACE;;AACF,iBAAK,YAAL;AACE8H,cAAAA,UAAU,GAAG9H,WAAb;AACA;;AACF,iBAAK,aAAL;AACE4H,cAAAA,WAAW,GAAG5H,WAAW,CAAC,CAAD,CAAzB;AACA;;AACF,iBAAK,aAAL;AACE+H,cAAAA,WAAW,GAAG/H,WAAd;AACA;;AACF,iBAAK,iBAAL;AACEkI,cAAAA,eAAe,GAAGlI,WAAW,CAAC,CAAD,CAA7B;AACA;;AACF,iBAAK,OAAL;AACE2H,cAAAA,KAAK,GAAG3H,WAAW,CAAC,CAAD,CAAnB;AACA;;AACF,iBAAK,eAAL;AACEgI,cAAAA,aAAa,GAAGhI,WAAhB;AACA;;AACF;AACExG,cAAAA,OAAO,CAACkI,IAAR,CAAa,kCAAb,EAAiDE,SAAjD;AACA;AAxDJ;AA0DD;;AACD,YAAIkG,UAAU,KAAK,KAAK,CAAxB,EAA2B;AACzBtO,UAAAA,OAAO,CAACkI,IAAR,CAAa,uCAAb;AACA,iBAAO,IAAIjK,cAAJ,EAAP;AACD;;AACD,YAAM8Q,sBAAsB,GAAGC,oBAAoB,CAACV,UAAD,EAAaJ,GAAb,CAAnD;AACA,YAAIe,cAAJ;AACA,YAAIC,eAAJ;AACA,YAAIC,WAAJ;;AACA,YAAIxF,KAAJ,EAAW;AACT,cAAI8E,cAAc,KAAK,IAAvB,EAA6B;AAC3B,gBAAIJ,UAAU,IAAIA,UAAU,CAAC7M,MAAX,GAAoB,CAAtC,EAAyC;AACvC,kBAAM4N,sBAAsB,GAAGJ,oBAAoB,CAACX,UAAD,EAAaH,GAAb,CAAnD;AACAe,cAAAA,cAAc,GAAGI,+BAA+B,CAACN,sBAAD,EAAyBK,sBAAzB,EAAiDzF,KAAjD,EAAwD,CAAxD,CAAhD;AACD,aAHD,MAGO;AACLsF,cAAAA,cAAc,GAAGK,qBAAqB,CAACP,sBAAD,EAAyB,IAAI7Q,sBAAJ,CAA2ByL,KAA3B,EAAkC,CAAlC,CAAzB,CAAtC;AACD;AACF,WAPD,MAOO;AACL,gBAAI0E,UAAU,IAAIA,UAAU,CAAC7M,MAAX,GAAoB,CAAtC,EAAyC;AACvC,kBAAM+N,iBAAiB,GAAGC,WAAW,CAAC7F,KAAD,EAAQ0E,UAAR,CAArC;AACA,kBAAMoB,sBAAsB,GAAGC,mBAAmB,CAACH,iBAAD,EAAoBjB,UAApB,CAAlD;AACAW,cAAAA,cAAc,GAAGU,4BAA4B,CAACZ,sBAAD,EAAyBU,sBAAzB,CAA7C;AACD,aAJD,MAIO;AACL,kBAAMA,uBAAsB,GAAGC,mBAAmB,CAAC/F,KAAD,EAAQ2E,UAAR,CAAlD;;AACAW,cAAAA,cAAc,GAAGU,4BAA4B,CAACZ,sBAAD,EAAyBU,uBAAzB,CAA7C;AACD;AACF;AACF;;AACD,YAAIzB,MAAJ,EAAY;AACV,cAAIU,eAAe,KAAK,IAAxB,EAA8B;AAC5B,gBAAIH,WAAW,IAAIA,WAAW,CAAC/M,MAAZ,GAAqB,CAAxC,EAA2C;AACzC,kBAAMoO,uBAAuB,GAAGZ,oBAAoB,CAACT,WAAD,EAAcL,GAAd,CAApD;AACAgB,cAAAA,eAAe,GAAGG,+BAA+B,CAC/CN,sBAD+C,EAE/Ca,uBAF+C,EAG/C5B,MAH+C,EAI/C,CAJ+C,CAAjD;AAMD,aARD,MAQO;AACLkB,cAAAA,eAAe,GAAGI,qBAAqB,CAACP,sBAAD,EAAyB,IAAI7Q,sBAAJ,CAA2B8P,MAA3B,EAAmC,CAAnC,CAAzB,CAAvC;AACD;AACF,WAZD,MAYO;AACL,gBAAIO,WAAW,IAAIA,WAAW,CAAC/M,MAAZ,GAAqB,CAAxC,EAA2C;AACzC,kBAAMqO,kBAAkB,GAAGL,WAAW,CAACxB,MAAD,EAASO,WAAT,CAAtC;AACA,kBAAMuB,uBAAuB,GAAGJ,mBAAmB,CAACG,kBAAD,EAAqBvB,UAArB,CAAnD;AACAY,cAAAA,eAAe,GAAGS,4BAA4B,CAACZ,sBAAD,EAAyBe,uBAAzB,CAA9C;AACD,aAJD,MAIO;AACL,kBAAMA,wBAAuB,GAAGJ,mBAAmB,CAAC1B,MAAD,EAASM,UAAT,CAAnD;;AACAY,cAAAA,eAAe,GAAGS,4BAA4B,CAACZ,sBAAD,EAAyBe,wBAAzB,CAA9C;AACD;AACF;AACF,SAvBD,MAuBO;AACLZ,UAAAA,eAAe,GAAGa,sBAAsB,CAAChB,sBAAD,EAAyBhB,KAAzB,EAAgCK,WAAhC,CAAxC;AACD;;AACD,YAAIH,QAAJ,EAAc;AACZ,cAAIO,aAAa,IAAIA,aAAa,CAAChN,MAAd,GAAuB,CAA5C,EAA+C;AAC7C,gBAAMwO,yBAAyB,GAAGhB,oBAAoB,CAACR,aAAD,EAAgBN,GAAhB,CAAtD;AACAiB,YAAAA,WAAW,GAAGE,+BAA+B,CAACN,sBAAD,EAAyBiB,yBAAzB,EAAoD/B,QAApD,EAA8D,CAA9D,CAA7C;AACD,WAHD,MAGO;AACLkB,YAAAA,WAAW,GAAGG,qBAAqB,CAACP,sBAAD,EAAyB,IAAI7Q,sBAAJ,CAA2B+P,QAA3B,EAAqC,CAArC,CAAzB,CAAnC;AACD;AACF;;AACD,YAAM3D,QAAQ,GAAG,IAAIrM,cAAJ,EAAjB;AACA,YAAMgS,iBAAiB,GAAGX,qBAAqB,CAACP,sBAAD,EAAyB,IAAI7Q,sBAAJ,CAA2B6P,KAA3B,EAAkC,CAAlC,CAAzB,CAA/C;AACAzD,QAAAA,QAAQ,CAAC4F,YAAT,CAAsB,UAAtB,EAAkCD,iBAAlC;AACA3F,QAAAA,QAAQ,CAAC4F,YAAT,CAAsB,QAAtB,EAAgChB,eAAhC;AACA,YAAID,cAAJ,EACE3E,QAAQ,CAAC4F,YAAT,CAAsB,OAAtB,EAA+BjB,cAA/B;AACF,YAAIE,WAAJ,EACE7E,QAAQ,CAAC4F,YAAT,CAAsB,IAAtB,EAA4Bf,WAA5B;AACF7E,QAAAA,QAAQ,CAACQ,MAAT,GAAkBqD,KAAlB;AACA7D,QAAAA,QAAQ,CAACE,KAAT,GAAiB,MAAjB;AACA,eAAOF,QAAP;AACD;;AACD,eAAS9C,uBAAT,CAAiChD,IAAjC,EAAuC;AACrC,YAAImF,KAAJ,EAAWoE,KAAX;AACA,YAAIM,UAAJ,EAAgBC,UAAhB;AACA,YAAIG,cAAc,GAAG,IAArB;AACA,YAAM7J,MAAM,GAAGJ,IAAI,CAACI,MAApB;;AACA,aAAK,IAAIpB,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGmB,MAAM,CAACpD,MAA3B,EAAmCgC,CAAC,GAAGC,CAAvC,EAA0CD,CAAC,EAA3C,EAA+C;AAC7C,cAAMqB,KAAK,GAAGD,MAAM,CAACpB,CAAD,CAApB;AACA,cAAM4E,SAAS,GAAGvD,KAAK,CAAChD,IAAxB;AACA,cAAM2E,WAAW,GAAG3B,KAAK,CAACG,MAA1B;;AACA,kBAAQoD,SAAR;AACE,iBAAK,OAAL;AACE,kBAAMuG,SAAS,GAAGnI,WAAW,CAAC,CAAD,CAA7B;;AACA,kBAAImI,SAAS,KAAK,IAAlB,EAAwB;AACtBhF,gBAAAA,KAAK,GAAGvD,OAAO,CAACuI,SAAD,CAAf;AACD;;AACD;;AACF,iBAAK,OAAL;AACE,kBAAMC,SAAS,GAAGpI,WAAW,CAAC,CAAD,CAA7B;;AACA,kBAAIoI,SAAS,KAAK,IAAlB,EAAwB;AACtBb,gBAAAA,KAAK,GAAG3H,OAAO,CAACwI,SAAD,CAAf;AACD;;AACD;;AACF,iBAAK,YAAL;AACEP,cAAAA,UAAU,GAAG7H,WAAb;AACA;;AACF,iBAAK,gBAAL;AACEiI,cAAAA,cAAc,GAAGjI,WAAW,CAAC,CAAD,CAA5B;AACA;;AACF,iBAAK,YAAL;AACE8H,cAAAA,UAAU,GAAG9H,WAAb;AACA;;AACF;AACExG,cAAAA,OAAO,CAACkI,IAAR,CAAa,kCAAb,EAAiDE,SAAjD;AACA;AAxBJ;AA0BD;;AACD,YAAI6G,cAAJ;AACA,YAAMkB,iBAAiB,GAAGC,eAAe,CAAC9B,UAAD,CAAzC;;AACA,YAAI3E,KAAJ,EAAW;AACT,cAAI8E,cAAc,KAAK,IAAvB,EAA6B;AAC3B,gBAAIJ,UAAU,CAAC7M,MAAX,GAAoB,CAAxB,EAA2B;AACzB,kBAAM6O,kBAAkB,GAAGD,eAAe,CAAC/B,UAAD,CAA1C;AACAY,cAAAA,cAAc,GAAGI,+BAA+B,CAACc,iBAAD,EAAoBE,kBAApB,EAAwC1G,KAAxC,EAA+C,CAA/C,CAAhD;AACD,aAHD,MAGO;AACLsF,cAAAA,cAAc,GAAGK,qBAAqB,CAACa,iBAAD,EAAoB,IAAIjS,sBAAJ,CAA2ByL,KAA3B,EAAkC,CAAlC,CAApB,CAAtC;AACD;AACF,WAPD,MAOO;AACL,gBAAI0E,UAAU,CAAC7M,MAAX,GAAoB,CAAxB,EAA2B;AACzB,kBAAM8O,iBAAiB,GAAGd,WAAW,CAAC7F,KAAD,EAAQ0E,UAAR,CAArC;AACA,kBAAMkC,kBAAkB,GAAGC,cAAc,CAACF,iBAAD,EAAoBhC,UAApB,CAAzC;AACAW,cAAAA,cAAc,GAAGwB,4BAA4B,CAACN,iBAAD,EAAoBI,kBAApB,CAA7C;AACD,aAJD,MAIO;AACL,kBAAMA,mBAAkB,GAAGC,cAAc,CAAC7G,KAAD,EAAQ2E,UAAR,CAAzC;;AACAW,cAAAA,cAAc,GAAGwB,4BAA4B,CAACN,iBAAD,EAAoBI,mBAApB,CAA7C;AACD;AACF;AACF;;AACD,YAAMjG,QAAQ,GAAG,IAAIrM,cAAJ,EAAjB;AACA,YAAMgS,iBAAiB,GAAGX,qBAAqB,CAACa,iBAAD,EAAoB,IAAIjS,sBAAJ,CAA2B6P,KAA3B,EAAkC,CAAlC,CAApB,CAA/C;AACAzD,QAAAA,QAAQ,CAAC4F,YAAT,CAAsB,UAAtB,EAAkCD,iBAAlC;AACA,YAAIhB,cAAJ,EACE3E,QAAQ,CAAC4F,YAAT,CAAsB,OAAtB,EAA+BjB,cAA/B;AACF3E,QAAAA,QAAQ,CAACE,KAAT,GAAiB,MAAjB;AACA,eAAOF,QAAP;AACD;;AACD,eAAS7C,iBAAT,CAA2BjD,IAA3B,EAAiC;AAC/B,YAAImF,KAAJ,EAAWoE,KAAX;AACA,YAAMnJ,MAAM,GAAGJ,IAAI,CAACI,MAApB;;AACA,aAAK,IAAIpB,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGmB,MAAM,CAACpD,MAA3B,EAAmCgC,CAAC,GAAGC,CAAvC,EAA0CD,CAAC,EAA3C,EAA+C;AAC7C,cAAMqB,KAAK,GAAGD,MAAM,CAACpB,CAAD,CAApB;AACA,cAAM4E,SAAS,GAAGvD,KAAK,CAAChD,IAAxB;AACA,cAAM2E,WAAW,GAAG3B,KAAK,CAACG,MAA1B;;AACA,kBAAQoD,SAAR;AACE,iBAAK,OAAL;AACE,kBAAMuG,SAAS,GAAGnI,WAAW,CAAC,CAAD,CAA7B;;AACA,kBAAImI,SAAS,KAAK,IAAlB,EAAwB;AACtBhF,gBAAAA,KAAK,GAAGvD,OAAO,CAACuI,SAAD,CAAf;AACD;;AACD;;AACF,iBAAK,OAAL;AACE,kBAAMC,SAAS,GAAGpI,WAAW,CAAC,CAAD,CAA7B;;AACA,kBAAIoI,SAAS,KAAK,IAAlB,EAAwB;AACtBb,gBAAAA,KAAK,GAAG3H,OAAO,CAACwI,SAAD,CAAf;AACD;;AACD;;AACF;AACE5O,cAAAA,OAAO,CAACkI,IAAR,CAAa,kCAAb,EAAiDE,SAAjD;AACA;AAfJ;AAiBD;;AACD,YAAMkC,QAAQ,GAAG,IAAIrM,cAAJ,EAAjB;AACAqM,QAAAA,QAAQ,CAAC4F,YAAT,CAAsB,UAAtB,EAAkC,IAAIhS,sBAAJ,CAA2B6P,KAA3B,EAAkC,CAAlC,CAAlC;AACA,YAAIpE,KAAJ,EACEW,QAAQ,CAAC4F,YAAT,CAAsB,OAAtB,EAA+B,IAAIhS,sBAAJ,CAA2ByL,KAA3B,EAAkC,CAAlC,CAA/B;AACFW,QAAAA,QAAQ,CAACE,KAAT,GAAiB,QAAjB;AACA,eAAOF,QAAP;AACD;;AACD,eAAS5C,YAAT,CAAsBlD,IAAtB,EAA4B;AAC1B,YAAMkM,IAAI,GAAG,IAAI1T,OAAJ,CAAY,CAAZ,EAAe,CAAf,EAAkB,CAAlB,CAAb;AACA,YAAM4H,MAAM,GAAGJ,IAAI,CAACI,MAApB;;AACA,aAAK,IAAIpB,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGmB,MAAM,CAACpD,MAA3B,EAAmCgC,CAAC,GAAGC,CAAvC,EAA0CD,CAAC,EAA3C,EAA+C;AAC7C,cAAMqB,KAAK,GAAGD,MAAM,CAACpB,CAAD,CAApB;AACA,cAAM4E,SAAS,GAAGvD,KAAK,CAAChD,IAAxB;AACA,cAAM2E,WAAW,GAAG3B,KAAK,CAACG,MAA1B;;AACA,kBAAQoD,SAAR;AACE,iBAAK,MAAL;AACEsI,cAAAA,IAAI,CAACC,CAAL,GAASnK,WAAW,CAAC,CAAD,CAApB;AACAkK,cAAAA,IAAI,CAACE,CAAL,GAASpK,WAAW,CAAC,CAAD,CAApB;AACAkK,cAAAA,IAAI,CAACG,CAAL,GAASrK,WAAW,CAAC,CAAD,CAApB;AACA;;AACF;AACExG,cAAAA,OAAO,CAACkI,IAAR,CAAa,kCAAb,EAAiDE,SAAjD;AACA;AARJ;AAUD;;AACD,YAAMkC,QAAQ,GAAG,IAAInM,WAAJ,CAAgBuS,IAAI,CAACC,CAArB,EAAwBD,IAAI,CAACE,CAA7B,EAAgCF,IAAI,CAACG,CAArC,CAAjB;AACA,eAAOvG,QAAP;AACD;;AACD,eAAS3C,aAAT,CAAuBnD,IAAvB,EAA6B;AAC3B,YAAIyE,MAAM,GAAG,CAAb;AAAA,YAAgBsE,MAAM,GAAG,CAAzB;AAAA,YAA4BuD,SAAS,GAAG,KAAxC;AACA,YAAMlM,MAAM,GAAGJ,IAAI,CAACI,MAApB;;AACA,aAAK,IAAIpB,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGmB,MAAM,CAACpD,MAA3B,EAAmCgC,CAAC,GAAGC,CAAvC,EAA0CD,CAAC,EAA3C,EAA+C;AAC7C,cAAMqB,KAAK,GAAGD,MAAM,CAACpB,CAAD,CAApB;AACA,cAAM4E,SAAS,GAAGvD,KAAK,CAAChD,IAAxB;AACA,cAAM2E,WAAW,GAAG3B,KAAK,CAACG,MAA1B;;AACA,kBAAQoD,SAAR;AACE,iBAAK,QAAL;AACE0I,cAAAA,SAAS,GAAG,CAACtK,WAAW,CAAC,CAAD,CAAxB;AACA;;AACF,iBAAK,cAAL;AACEyC,cAAAA,MAAM,GAAGzC,WAAW,CAAC,CAAD,CAApB;AACA;;AACF,iBAAK,QAAL;AACE+G,cAAAA,MAAM,GAAG/G,WAAW,CAAC,CAAD,CAApB;AACA;;AACF,iBAAK,MAAL;AACE;;AACF;AACExG,cAAAA,OAAO,CAACkI,IAAR,CAAa,kCAAb,EAAiDE,SAAjD;AACA;AAdJ;AAgBD;;AACD,YAAMkC,QAAQ,GAAG,IAAIlM,YAAJ,CAAiB6K,MAAjB,EAAyBsE,MAAzB,EAAiC,EAAjC,EAAqC,CAArC,EAAwCuD,SAAxC,CAAjB;AACA,eAAOxG,QAAP;AACD;;AACD,eAAS1C,iBAAT,CAA2BpD,IAA3B,EAAiC;AAC/B,YAAIyE,MAAM,GAAG,CAAb;AAAA,YAAgBsE,MAAM,GAAG,CAAzB;AACA,YAAM3I,MAAM,GAAGJ,IAAI,CAACI,MAApB;;AACA,aAAK,IAAIpB,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGmB,MAAM,CAACpD,MAA3B,EAAmCgC,CAAC,GAAGC,CAAvC,EAA0CD,CAAC,EAA3C,EAA+C;AAC7C,cAAMqB,KAAK,GAAGD,MAAM,CAACpB,CAAD,CAApB;AACA,cAAM4E,SAAS,GAAGvD,KAAK,CAAChD,IAAxB;AACA,cAAM2E,WAAW,GAAG3B,KAAK,CAACG,MAA1B;;AACA,kBAAQoD,SAAR;AACE,iBAAK,QAAL;AACE;;AACF,iBAAK,QAAL;AACEa,cAAAA,MAAM,GAAGzC,WAAW,CAAC,CAAD,CAApB;AACA;;AACF,iBAAK,QAAL;AACE+G,cAAAA,MAAM,GAAG/G,WAAW,CAAC,CAAD,CAApB;AACA;;AACF,iBAAK,MAAL;AACE;;AACF,iBAAK,KAAL;AACE;;AACF;AACExG,cAAAA,OAAO,CAACkI,IAAR,CAAa,kCAAb,EAAiDE,SAAjD;AACA;AAfJ;AAiBD;;AACD,YAAMkC,QAAQ,GAAG,IAAIjM,gBAAJ,CAAqB4K,MAArB,EAA6BA,MAA7B,EAAqCsE,MAArC,EAA6C,EAA7C,EAAiD,CAAjD,CAAjB;AACA,eAAOjD,QAAP;AACD;;AACD,eAASzC,eAAT,CAAyBrD,IAAzB,EAA+B;AAC7B,YAAIyE,MAAM,GAAG,CAAb;AACA,YAAMrE,MAAM,GAAGJ,IAAI,CAACI,MAApB;;AACA,aAAK,IAAIpB,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGmB,MAAM,CAACpD,MAA3B,EAAmCgC,CAAC,GAAGC,CAAvC,EAA0CD,CAAC,EAA3C,EAA+C;AAC7C,cAAMqB,KAAK,GAAGD,MAAM,CAACpB,CAAD,CAApB;AACA,cAAM4E,SAAS,GAAGvD,KAAK,CAAChD,IAAxB;AACA,cAAM2E,WAAW,GAAG3B,KAAK,CAACG,MAA1B;;AACA,kBAAQoD,SAAR;AACE,iBAAK,QAAL;AACEa,cAAAA,MAAM,GAAGzC,WAAW,CAAC,CAAD,CAApB;AACA;;AACF;AACExG,cAAAA,OAAO,CAACkI,IAAR,CAAa,kCAAb,EAAiDE,SAAjD;AACA;AANJ;AAQD;;AACD,YAAMkC,QAAQ,GAAG,IAAIrN,cAAJ,CAAmBgM,MAAnB,EAA2B,EAA3B,EAA+B,EAA/B,CAAjB;AACA,eAAOqB,QAAP;AACD;;AACD,eAASxC,sBAAT,CAAgCtD,IAAhC,EAAsC;AACpC,YAAImF,KAAJ;AACA,YAAIqE,MAAJ;AACA,YAAIC,QAAJ;AACA,YAAIV,MAAJ;AACA,YAAIkB,cAAc,GAAG,IAArB;AACA,YAAIC,eAAe,GAAG,IAAtB;AACA,YAAIP,KAAK,GAAG,IAAZ;AACA,YAAID,GAAG,GAAG,IAAV;AACA,YAAIE,WAAW,GAAG,CAAlB;AACA,YAAI2C,UAAU,GAAG,CAAjB;AACA,YAAIC,UAAU,GAAG,CAAjB;AACA,YAAIC,QAAQ,GAAG,CAAf;AACA,YAAIC,QAAQ,GAAG,CAAf;AACA,YAAMtM,MAAM,GAAGJ,IAAI,CAACI,MAApB;;AACA,aAAK,IAAIpB,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGmB,MAAM,CAACpD,MAA3B,EAAmCgC,CAAC,GAAGC,CAAvC,EAA0CD,CAAC,EAA3C,EAA+C;AAC7C,cAAMqB,KAAK,GAAGD,MAAM,CAACpB,CAAD,CAApB;AACA,cAAM4E,SAAS,GAAGvD,KAAK,CAAChD,IAAxB;AACA,cAAM2E,WAAW,GAAG3B,KAAK,CAACG,MAA1B;;AACA,kBAAQoD,SAAR;AACE,iBAAK,OAAL;AACE,kBAAMuG,SAAS,GAAGnI,WAAW,CAAC,CAAD,CAA7B;;AACA,kBAAImI,SAAS,KAAK,IAAlB,EAAwB;AACtBhF,gBAAAA,KAAK,GAAGvD,OAAO,CAACuI,SAAD,CAAf;AACD;;AACD;;AACF,iBAAK,QAAL;AACE,kBAAME,UAAU,GAAGrI,WAAW,CAAC,CAAD,CAA9B;;AACA,kBAAIqI,UAAU,KAAK,IAAnB,EAAyB;AACvBb,gBAAAA,MAAM,GAAG5H,OAAO,CAACyI,UAAD,CAAhB;AACD;;AACD;;AACF,iBAAK,UAAL;AACE,kBAAMC,YAAY,GAAGtI,WAAW,CAAC,CAAD,CAAhC;;AACA,kBAAIsI,YAAY,KAAK,IAArB,EAA2B;AACzBb,gBAAAA,QAAQ,GAAG7H,OAAO,CAAC0I,YAAD,CAAlB;AACD;;AACD;;AACF,iBAAK,QAAL;AACEvB,cAAAA,MAAM,GAAG/G,WAAT;AACA;;AACF,iBAAK,KAAL;AACE0H,cAAAA,GAAG,GAAG1H,WAAW,CAAC,CAAD,CAAjB;AACA;;AACF,iBAAK,gBAAL;AACEiI,cAAAA,cAAc,GAAGjI,WAAW,CAAC,CAAD,CAA5B;AACA;;AACF,iBAAK,aAAL;AACE4H,cAAAA,WAAW,GAAG5H,WAAW,CAAC,CAAD,CAAzB;AACA;;AACF,iBAAK,iBAAL;AACEkI,cAAAA,eAAe,GAAGlI,WAAW,CAAC,CAAD,CAA7B;AACA;;AACF,iBAAK,OAAL;AACE2H,cAAAA,KAAK,GAAG3H,WAAW,CAAC,CAAD,CAAnB;AACA;;AACF,iBAAK,YAAL;AACEuK,cAAAA,UAAU,GAAGvK,WAAW,CAAC,CAAD,CAAxB;AACA;;AACF,iBAAK,UAAL;AACEyK,cAAAA,QAAQ,GAAGzK,WAAW,CAAC,CAAD,CAAtB;AACA;;AACF,iBAAK,YAAL;AACEwK,cAAAA,UAAU,GAAGxK,WAAW,CAAC,CAAD,CAAxB;AACA;;AACF,iBAAK,UAAL;AACE0K,cAAAA,QAAQ,GAAG1K,WAAW,CAAC,CAAD,CAAtB;AACA;;AACF;AACExG,cAAAA,OAAO,CAACkI,IAAR,CAAa,kCAAb,EAAiDE,SAAjD;AACA;AAnDJ;AAqDD;;AACD,YAAM+I,QAAQ,GAAG,EAAjB;AACA,YAAMC,OAAO,GAAG,EAAhB;AACA,YAAMC,MAAM,GAAG,EAAf;AACA,YAAMC,GAAG,GAAG,EAAZ;;AACA,aAAK,IAAI9N,GAAC,GAAG,CAAb,EAAgBA,GAAC,GAAGwN,UAApB,EAAgCxN,GAAC,EAAjC,EAAqC;AACnC,eAAK,IAAIiD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGsK,UAApB,EAAgCtK,CAAC,EAAjC,EAAqC;AACnC,gBAAM8K,KAAK,GAAG/N,GAAC,GAAGuN,UAAJ,GAAiBtK,CAA/B;AACA,gBAAMkK,CAAC,GAAGM,QAAQ,GAAGzN,GAArB;AACA,gBAAMoN,CAAC,GAAGrD,MAAM,CAACgE,KAAD,CAAhB;AACA,gBAAMV,CAAC,GAAGK,QAAQ,GAAGzK,CAArB;AACA0K,YAAAA,QAAQ,CAAC1M,IAAT,CAAckM,CAAd,EAAiBC,CAAjB,EAAoBC,CAApB;;AACA,gBAAIlH,KAAK,IAAI8E,cAAc,KAAK,IAAhC,EAAsC;AACpC,kBAAM7B,CAAC,GAAGjD,KAAK,CAAC4H,KAAK,GAAG,CAAR,GAAY,CAAb,CAAf;AACA,kBAAM1E,CAAC,GAAGlD,KAAK,CAAC4H,KAAK,GAAG,CAAR,GAAY,CAAb,CAAf;AACA,kBAAMzE,CAAC,GAAGnD,KAAK,CAAC4H,KAAK,GAAG,CAAR,GAAY,CAAb,CAAf;AACAF,cAAAA,MAAM,CAAC5M,IAAP,CAAYmI,CAAZ,EAAeC,CAAf,EAAkBC,CAAlB;AACD;;AACD,gBAAIkB,MAAM,IAAIU,eAAe,KAAK,IAAlC,EAAwC;AACtC,kBAAM8C,EAAE,GAAGxD,MAAM,CAACuD,KAAK,GAAG,CAAR,GAAY,CAAb,CAAjB;AACA,kBAAME,EAAE,GAAGzD,MAAM,CAACuD,KAAK,GAAG,CAAR,GAAY,CAAb,CAAjB;AACA,kBAAMG,EAAE,GAAG1D,MAAM,CAACuD,KAAK,GAAG,CAAR,GAAY,CAAb,CAAjB;AACAH,cAAAA,OAAO,CAAC3M,IAAR,CAAa+M,EAAb,EAAiBC,EAAjB,EAAqBC,EAArB;AACD;;AACD,gBAAIzD,QAAJ,EAAc;AACZ,kBAAM0D,CAAC,GAAG1D,QAAQ,CAACsD,KAAK,GAAG,CAAR,GAAY,CAAb,CAAlB;AACA,kBAAMK,CAAC,GAAG3D,QAAQ,CAACsD,KAAK,GAAG,CAAR,GAAY,CAAb,CAAlB;AACAD,cAAAA,GAAG,CAAC7M,IAAJ,CAASkN,CAAT,EAAYC,CAAZ;AACD,aAJD,MAIO;AACLN,cAAAA,GAAG,CAAC7M,IAAJ,CAASjB,GAAC,IAAIuN,UAAU,GAAG,CAAjB,CAAV,EAA+BtK,CAAC,IAAIuK,UAAU,GAAG,CAAjB,CAAhC;AACD;AACF;AACF;;AACD,YAAMa,OAAO,GAAG,EAAhB;;AACA,aAAK,IAAIrO,IAAC,GAAG,CAAb,EAAgBA,IAAC,GAAGuN,UAAU,GAAG,CAAjC,EAAoCvN,IAAC,EAArC,EAAyC;AACvC,eAAK,IAAIiD,EAAC,GAAG,CAAb,EAAgBA,EAAC,GAAGuK,UAAU,GAAG,CAAjC,EAAoCvK,EAAC,EAArC,EAAyC;AACvC,gBAAMsG,CAAC,GAAGvJ,IAAC,GAAGiD,EAAC,GAAGsK,UAAlB;;AACA,gBAAMjE,EAAC,GAAGtJ,IAAC,GAAG,CAACiD,EAAC,GAAG,CAAL,IAAUsK,UAAxB;;AACA,gBAAMe,CAAC,GAAGtO,IAAC,GAAG,CAAJ,GAAQ,CAACiD,EAAC,GAAG,CAAL,IAAUsK,UAA5B;AACA,gBAAMgB,CAAC,GAAGvO,IAAC,GAAG,CAAJ,GAAQiD,EAAC,GAAGsK,UAAtB;;AACA,gBAAI7C,GAAG,KAAK,IAAZ,EAAkB;AAChB2D,cAAAA,OAAO,CAACpN,IAAR,CAAasI,CAAb,EAAgB+E,CAAhB,EAAmBhF,EAAnB;AACA+E,cAAAA,OAAO,CAACpN,IAAR,CAAaqN,CAAb,EAAgB/E,CAAhB,EAAmBgF,CAAnB;AACD,aAHD,MAGO;AACLF,cAAAA,OAAO,CAACpN,IAAR,CAAasI,CAAb,EAAgBD,EAAhB,EAAmBgF,CAAnB;AACAD,cAAAA,OAAO,CAACpN,IAAR,CAAaqN,CAAb,EAAgBC,CAAhB,EAAmBhF,CAAnB;AACD;AACF;AACF;;AACD,YAAMkD,iBAAiB,GAAGX,qBAAqB,CAACuC,OAAD,EAAU,IAAI3T,sBAAJ,CAA2BiT,QAA3B,EAAqC,CAArC,CAAV,CAA/C;AACA,YAAMhC,WAAW,GAAGG,qBAAqB,CAACuC,OAAD,EAAU,IAAI3T,sBAAJ,CAA2BoT,GAA3B,EAAgC,CAAhC,CAAV,CAAzC;AACA,YAAIrC,cAAJ;AACA,YAAIC,eAAJ;;AACA,YAAIvF,KAAJ,EAAW;AACT,cAAI8E,cAAc,KAAK,KAAvB,EAA8B;AAC5B,iBAAK,IAAIjL,IAAC,GAAG,CAAb,EAAgBA,IAAC,GAAGuN,UAAU,GAAG,CAAjC,EAAoCvN,IAAC,EAArC,EAAyC;AACvC,mBAAK,IAAIiD,GAAC,GAAG,CAAb,EAAgBA,GAAC,GAAGuK,UAAU,GAAG,CAAjC,EAAoCvK,GAAC,EAArC,EAAyC;AACvC,oBAAM8K,MAAK,GAAG/N,IAAC,GAAGiD,GAAC,IAAIsK,UAAU,GAAG,CAAjB,CAAnB;;AACA,oBAAMnE,EAAC,GAAGjD,KAAK,CAAC4H,MAAK,GAAG,CAAR,GAAY,CAAb,CAAf;AACA,oBAAM1E,EAAC,GAAGlD,KAAK,CAAC4H,MAAK,GAAG,CAAR,GAAY,CAAb,CAAf;AACA,oBAAMzE,GAAC,GAAGnD,KAAK,CAAC4H,MAAK,GAAG,CAAR,GAAY,CAAb,CAAf;AACAF,gBAAAA,MAAM,CAAC5M,IAAP,CAAYmI,EAAZ,EAAeC,EAAf,EAAkBC,GAAlB;AACAuE,gBAAAA,MAAM,CAAC5M,IAAP,CAAYmI,EAAZ,EAAeC,EAAf,EAAkBC,GAAlB;AACAuE,gBAAAA,MAAM,CAAC5M,IAAP,CAAYmI,EAAZ,EAAeC,EAAf,EAAkBC,GAAlB;AACAuE,gBAAAA,MAAM,CAAC5M,IAAP,CAAYmI,EAAZ,EAAeC,EAAf,EAAkBC,GAAlB;AACAuE,gBAAAA,MAAM,CAAC5M,IAAP,CAAYmI,EAAZ,EAAeC,EAAf,EAAkBC,GAAlB;AACAuE,gBAAAA,MAAM,CAAC5M,IAAP,CAAYmI,EAAZ,EAAeC,EAAf,EAAkBC,GAAlB;AACD;AACF;;AACDmC,YAAAA,cAAc,GAAG,IAAI/Q,sBAAJ,CAA2BmT,MAA3B,EAAmC,CAAnC,CAAjB;AACD,WAhBD,MAgBO;AACLpC,YAAAA,cAAc,GAAGK,qBAAqB,CAACuC,OAAD,EAAU,IAAI3T,sBAAJ,CAA2BmT,MAA3B,EAAmC,CAAnC,CAAV,CAAtC;AACD;AACF;;AACD,YAAIrD,MAAJ,EAAY;AACV,cAAIU,eAAe,KAAK,KAAxB,EAA+B;AAC7B,iBAAK,IAAIlL,IAAC,GAAG,CAAb,EAAgBA,IAAC,GAAGuN,UAAU,GAAG,CAAjC,EAAoCvN,IAAC,EAArC,EAAyC;AACvC,mBAAK,IAAIiD,GAAC,GAAG,CAAb,EAAgBA,GAAC,GAAGuK,UAAU,GAAG,CAAjC,EAAoCvK,GAAC,EAArC,EAAyC;AACvC,oBAAM8K,OAAK,GAAG/N,IAAC,GAAGiD,GAAC,IAAIsK,UAAU,GAAG,CAAjB,CAAnB;;AACA,oBAAMS,GAAE,GAAGxD,MAAM,CAACuD,OAAK,GAAG,CAAR,GAAY,CAAb,CAAjB;AACA,oBAAME,GAAE,GAAGzD,MAAM,CAACuD,OAAK,GAAG,CAAR,GAAY,CAAb,CAAjB;AACA,oBAAMG,GAAE,GAAG1D,MAAM,CAACuD,OAAK,GAAG,CAAR,GAAY,CAAb,CAAjB;AACAH,gBAAAA,OAAO,CAAC3M,IAAR,CAAa+M,GAAb,EAAiBC,GAAjB,EAAqBC,GAArB;AACAN,gBAAAA,OAAO,CAAC3M,IAAR,CAAa+M,GAAb,EAAiBC,GAAjB,EAAqBC,GAArB;AACAN,gBAAAA,OAAO,CAAC3M,IAAR,CAAa+M,GAAb,EAAiBC,GAAjB,EAAqBC,GAArB;AACAN,gBAAAA,OAAO,CAAC3M,IAAR,CAAa+M,GAAb,EAAiBC,GAAjB,EAAqBC,GAArB;AACAN,gBAAAA,OAAO,CAAC3M,IAAR,CAAa+M,GAAb,EAAiBC,GAAjB,EAAqBC,GAArB;AACAN,gBAAAA,OAAO,CAAC3M,IAAR,CAAa+M,GAAb,EAAiBC,GAAjB,EAAqBC,GAArB;AACD;AACF;;AACDxC,YAAAA,eAAe,GAAG,IAAIhR,sBAAJ,CAA2BkT,OAA3B,EAAoC,CAApC,CAAlB;AACD,WAhBD,MAgBO;AACLlC,YAAAA,eAAe,GAAGI,qBAAqB,CAACuC,OAAD,EAAU,IAAI3T,sBAAJ,CAA2BkT,OAA3B,EAAoC,CAApC,CAAV,CAAvC;AACD;AACF,SApBD,MAoBO;AACLlC,UAAAA,eAAe,GAAGa,sBAAsB,CAAC8B,OAAD,EAAUV,QAAV,EAAoB/C,WAApB,CAAxC;AACD;;AACD,YAAM9D,QAAQ,GAAG,IAAIrM,cAAJ,EAAjB;AACAqM,QAAAA,QAAQ,CAAC4F,YAAT,CAAsB,UAAtB,EAAkCD,iBAAlC;AACA3F,QAAAA,QAAQ,CAAC4F,YAAT,CAAsB,QAAtB,EAAgChB,eAAhC;AACA5E,QAAAA,QAAQ,CAAC4F,YAAT,CAAsB,IAAtB,EAA4Bf,WAA5B;AACA,YAAIF,cAAJ,EACE3E,QAAQ,CAAC4F,YAAT,CAAsB,OAAtB,EAA+BjB,cAA/B;AACF3E,QAAAA,QAAQ,CAACQ,MAAT,GAAkBqD,KAAlB;AACA7D,QAAAA,QAAQ,CAACE,KAAT,GAAiB,MAAjB;AACA,eAAOF,QAAP;AACD;;AACD,eAASvC,kBAAT,CAA4BvD,IAA5B,EAAkC;AAChC,YAAIwN,YAAY,GAAG,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAC,CAAX,EAAc,CAAC,CAAf,EAAkB,CAAC,CAAnB,EAAsB,CAAC,CAAvB,EAA0B,CAA1B,EAA6B,CAA7B,EAAgC,CAAhC,CAAnB;AACA,YAAIC,KAAK,GAAG,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,EAAgB,CAAhB,CAAZ;AACA,YAAIvJ,KAAJ;AACA,YAAIwJ,WAAJ;AACA,YAAIC,QAAQ,GAAG,IAAf;AACA,YAAIjE,GAAG,GAAG,IAAV;AACA,YAAIE,WAAW,GAAG,CAAlB;AACA,YAAIgE,MAAM,GAAG,IAAb;AACA,YAAIjE,KAAK,GAAG,IAAZ;AACA,YAAMvJ,MAAM,GAAGJ,IAAI,CAACI,MAApB;;AACA,aAAK,IAAIpB,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGmB,MAAM,CAACpD,MAA3B,EAAmCgC,CAAC,GAAGC,CAAvC,EAA0CD,CAAC,EAA3C,EAA+C;AAC7C,cAAMqB,KAAK,GAAGD,MAAM,CAACpB,CAAD,CAApB;AACA,cAAM4E,SAAS,GAAGvD,KAAK,CAAChD,IAAxB;AACA,cAAM2E,WAAW,GAAG3B,KAAK,CAACG,MAA1B;;AACA,kBAAQoD,SAAR;AACE,iBAAK,UAAL;AACE+J,cAAAA,QAAQ,GAAG3L,WAAW,CAAC,CAAD,CAAtB;AACA;;AACF,iBAAK,KAAL;AACE0H,cAAAA,GAAG,GAAG1H,WAAW,CAAC,CAAD,CAAjB;AACA;;AACF,iBAAK,QAAL;AACE;;AACF,iBAAK,aAAL;AACE4H,cAAAA,WAAW,GAAG5H,WAAW,CAAC,CAAD,CAAzB;AACA;;AACF,iBAAK,cAAL;AACEwL,cAAAA,YAAY,GAAGxL,WAAf;AACA;;AACF,iBAAK,QAAL;AACE4L,cAAAA,MAAM,GAAG5L,WAAW,CAAC,CAAD,CAApB;AACA;;AACF,iBAAK,aAAL;AACE0L,cAAAA,WAAW,GAAG1L,WAAd;AACA;;AACF,iBAAK,OAAL;AACEkC,cAAAA,KAAK,GAAGlC,WAAR;AACA;;AACF,iBAAK,OAAL;AACE2H,cAAAA,KAAK,GAAG3H,WAAW,CAAC,CAAD,CAAnB;AACA;;AACF,iBAAK,OAAL;AACEyL,cAAAA,KAAK,GAAGzL,WAAR;AACA;;AACF;AACExG,cAAAA,OAAO,CAACkI,IAAR,CAAa,kCAAb,EAAiDE,SAAjD;AACA;AAhCJ;AAkCD;;AACD,YAAMiK,kBAAkB,GAAGL,YAAY,CAAC,CAAD,CAAZ,KAAoBA,YAAY,CAACA,YAAY,CAACxQ,MAAb,GAAsB,CAAvB,CAAhC,IAA6DwQ,YAAY,CAAC,CAAD,CAAZ,KAAoBA,YAAY,CAACA,YAAY,CAACxQ,MAAb,GAAsB,CAAvB,CAAxH;AACA,YAAM2P,QAAQ,GAAG,EAAjB;AACA,YAAMmB,WAAW,GAAG,IAAItV,OAAJ,EAApB;AACA,YAAMuV,OAAO,GAAG,IAAIvV,OAAJ,EAAhB;AACA,YAAMsL,IAAI,GAAG,IAAItL,OAAJ,EAAb;AACA,YAAMwV,MAAM,GAAG,IAAIxV,OAAJ,EAAf;AACA,YAAMwL,UAAU,GAAG,IAAIlK,UAAJ,EAAnB;;AACA,aAAK,IAAIkF,IAAC,GAAG,CAAR,EAAWiD,CAAC,GAAG,CAAf,EAAkBgM,CAAC,GAAG,CAAtB,EAAyBC,EAAE,GAAGT,KAAK,CAACzQ,MAAzC,EAAiDgC,IAAC,GAAGkP,EAArD,EAAyDlP,IAAC,IAAI,CAAL,EAAQiD,CAAC,IAAI,CAAb,EAAgBgM,CAAC,IAAI,CAA9E,EAAiF;AAC/EH,UAAAA,WAAW,CAACK,SAAZ,CAAsBV,KAAtB,EAA6BzO,IAA7B;AACA+O,UAAAA,OAAO,CAAC5B,CAAR,GAAYjI,KAAK,GAAGA,KAAK,CAACjC,CAAC,GAAG,CAAL,CAAR,GAAkB,CAAnC;AACA8L,UAAAA,OAAO,CAAC3B,CAAR,GAAY,CAAZ;AACA2B,UAAAA,OAAO,CAAC1B,CAAR,GAAYnI,KAAK,GAAGA,KAAK,CAACjC,CAAC,GAAG,CAAL,CAAR,GAAkB,CAAnC;AACA6B,UAAAA,IAAI,CAACqI,CAAL,GAASuB,WAAW,GAAGA,WAAW,CAACO,CAAC,GAAG,CAAL,CAAd,GAAwB,CAA5C;AACAnK,UAAAA,IAAI,CAACsI,CAAL,GAASsB,WAAW,GAAGA,WAAW,CAACO,CAAC,GAAG,CAAL,CAAd,GAAwB,CAA5C;AACAnK,UAAAA,IAAI,CAACuI,CAAL,GAASqB,WAAW,GAAGA,WAAW,CAACO,CAAC,GAAG,CAAL,CAAd,GAAwB,CAA5C;AACA,cAAMlK,KAAK,GAAG2J,WAAW,GAAGA,WAAW,CAACO,CAAC,GAAG,CAAL,CAAd,GAAwB,CAAjD;;AACA,eAAK,IAAIhF,CAAC,GAAG,CAAR,EAAWmF,EAAE,GAAGZ,YAAY,CAACxQ,MAAlC,EAA0CiM,CAAC,GAAGmF,EAA9C,EAAkDnF,CAAC,IAAI,CAAvD,EAA0D;AACxD+E,YAAAA,MAAM,CAAC7B,CAAP,GAAWqB,YAAY,CAACvE,CAAC,GAAG,CAAL,CAAvB;AACA+E,YAAAA,MAAM,CAAC5B,CAAP,GAAW,CAAX;AACA4B,YAAAA,MAAM,CAAC3B,CAAP,GAAWmB,YAAY,CAACvE,CAAC,GAAG,CAAL,CAAvB;AACA+E,YAAAA,MAAM,CAACK,QAAP,CAAgBN,OAAhB;AACA/J,YAAAA,UAAU,CAACC,gBAAX,CAA4BH,IAA5B,EAAkCC,KAAlC;AACAiK,YAAAA,MAAM,CAACM,eAAP,CAAuBtK,UAAvB;AACAgK,YAAAA,MAAM,CAACnM,GAAP,CAAWiM,WAAX;AACAnB,YAAAA,QAAQ,CAAC1M,IAAT,CAAc+N,MAAM,CAAC7B,CAArB,EAAwB6B,MAAM,CAAC5B,CAA/B,EAAkC4B,MAAM,CAAC3B,CAAzC;AACD;AACF;;AACD,YAAMgB,OAAO,GAAG,EAAhB;AACA,YAAMkB,UAAU,GAAGd,KAAK,CAACzQ,MAAN,GAAe,CAAlC;AACA,YAAMwR,iBAAiB,GAAGhB,YAAY,CAACxQ,MAAb,GAAsB,CAAhD;;AACA,aAAK,IAAIgC,IAAC,GAAG,CAAb,EAAgBA,IAAC,GAAGuP,UAAU,GAAG,CAAjC,EAAoCvP,IAAC,EAArC,EAAyC;AACvC,eAAK,IAAIiD,GAAC,GAAG,CAAb,EAAgBA,GAAC,GAAGuM,iBAAiB,GAAG,CAAxC,EAA2CvM,GAAC,EAA5C,EAAgD;AAC9C,gBAAMsG,CAAC,GAAGtG,GAAC,GAAGjD,IAAC,GAAGwP,iBAAlB;AACA,gBAAIlG,CAAC,GAAGrG,GAAC,GAAG,CAAJ,GAAQjD,IAAC,GAAGwP,iBAApB;AACA,gBAAMlB,CAAC,GAAGrL,GAAC,GAAG,CAACjD,IAAC,GAAG,CAAL,IAAUwP,iBAAxB;AACA,gBAAIjB,CAAC,GAAGtL,GAAC,GAAG,CAAJ,GAAQ,CAACjD,IAAC,GAAG,CAAL,IAAUwP,iBAA1B;;AACA,gBAAIvM,GAAC,KAAKuM,iBAAiB,GAAG,CAA1B,IAA+BX,kBAAkB,KAAK,IAA1D,EAAgE;AAC9DvF,cAAAA,CAAC,GAAGtJ,IAAC,GAAGwP,iBAAR;AACAjB,cAAAA,CAAC,GAAG,CAACvO,IAAC,GAAG,CAAL,IAAUwP,iBAAd;AACD;;AACD,gBAAI9E,GAAG,KAAK,IAAZ,EAAkB;AAChB2D,cAAAA,OAAO,CAACpN,IAAR,CAAasI,CAAb,EAAgBD,CAAhB,EAAmBgF,CAAnB;AACAD,cAAAA,OAAO,CAACpN,IAAR,CAAaqN,CAAb,EAAgBhF,CAAhB,EAAmBiF,CAAnB;AACD,aAHD,MAGO;AACLF,cAAAA,OAAO,CAACpN,IAAR,CAAasI,CAAb,EAAgB+E,CAAhB,EAAmBhF,CAAnB;AACA+E,cAAAA,OAAO,CAACpN,IAAR,CAAaqN,CAAb,EAAgBC,CAAhB,EAAmBjF,CAAnB;AACD;AACF;AACF;;AACD,YAAIqF,QAAQ,KAAK,IAAb,IAAqBC,MAAM,KAAK,IAApC,EAA0C;AACxC,cAAMa,OAAO,GAAG,EAAhB;;AACA,eAAK,IAAIzP,IAAC,GAAG,CAAR,EAAWC,GAAC,GAAGuO,YAAY,CAACxQ,MAAjC,EAAyCgC,IAAC,GAAGC,GAA7C,EAAgDD,IAAC,IAAI,CAArD,EAAwD;AACtDyP,YAAAA,OAAO,CAACxO,IAAR,CAAa,IAAIzG,OAAJ,CAAYgU,YAAY,CAACxO,IAAD,CAAxB,EAA6BwO,YAAY,CAACxO,IAAC,GAAG,CAAL,CAAzC,CAAb;AACD;;AACD,cAAM0P,KAAK,GAAG3U,UAAU,CAAC4U,gBAAX,CAA4BF,OAA5B,EAAqC,EAArC,CAAd;AACA,cAAMG,UAAU,GAAG,EAAnB;;AACA,eAAK,IAAI5P,IAAC,GAAG,CAAR,EAAWC,IAAC,GAAGyP,KAAK,CAAC1R,MAA1B,EAAkCgC,IAAC,GAAGC,IAAtC,EAAyCD,IAAC,EAA1C,EAA8C;AAC5C,gBAAM6P,IAAI,GAAGH,KAAK,CAAC1P,IAAD,CAAlB;AACA4P,YAAAA,UAAU,CAAC3O,IAAX,CAAgB4O,IAAI,CAAC,CAAD,CAApB,EAAyBA,IAAI,CAAC,CAAD,CAA7B,EAAkCA,IAAI,CAAC,CAAD,CAAtC;AACD;;AACD,cAAIlB,QAAQ,KAAK,IAAjB,EAAuB;AACrB,iBAAK,IAAI3O,IAAC,GAAG,CAAR,EAAWC,IAAC,GAAG2P,UAAU,CAAC5R,MAA/B,EAAuCgC,IAAC,GAAGC,IAA3C,EAA8CD,IAAC,IAAI,CAAnD,EAAsD;AACpD,kBAAI0K,GAAG,KAAK,IAAZ,EAAkB;AAChB2D,gBAAAA,OAAO,CAACpN,IAAR,CAAa2O,UAAU,CAAC5P,IAAC,GAAG,CAAL,CAAvB,EAAgC4P,UAAU,CAAC5P,IAAC,GAAG,CAAL,CAA1C,EAAmD4P,UAAU,CAAC5P,IAAC,GAAG,CAAL,CAA7D;AACD,eAFD,MAEO;AACLqO,gBAAAA,OAAO,CAACpN,IAAR,CAAa2O,UAAU,CAAC5P,IAAC,GAAG,CAAL,CAAvB,EAAgC4P,UAAU,CAAC5P,IAAC,GAAG,CAAL,CAA1C,EAAmD4P,UAAU,CAAC5P,IAAC,GAAG,CAAL,CAA7D;AACD;AACF;AACF;;AACD,cAAI4O,MAAM,KAAK,IAAf,EAAqB;AACnB,gBAAMkB,WAAW,GAAGN,iBAAiB,IAAID,UAAU,GAAG,CAAjB,CAArC;;AACA,iBAAK,IAAIvP,IAAC,GAAG,CAAR,EAAWC,IAAC,GAAG2P,UAAU,CAAC5R,MAA/B,EAAuCgC,IAAC,GAAGC,IAA3C,EAA8CD,IAAC,IAAI,CAAnD,EAAsD;AACpD,kBAAI0K,GAAG,KAAK,IAAZ,EAAkB;AAChB2D,gBAAAA,OAAO,CAACpN,IAAR,CACE6O,WAAW,GAAGF,UAAU,CAAC5P,IAAC,GAAG,CAAL,CAD1B,EAEE8P,WAAW,GAAGF,UAAU,CAAC5P,IAAC,GAAG,CAAL,CAF1B,EAGE8P,WAAW,GAAGF,UAAU,CAAC5P,IAAC,GAAG,CAAL,CAH1B;AAKD,eAND,MAMO;AACLqO,gBAAAA,OAAO,CAACpN,IAAR,CACE6O,WAAW,GAAGF,UAAU,CAAC5P,IAAC,GAAG,CAAL,CAD1B,EAEE8P,WAAW,GAAGF,UAAU,CAAC5P,IAAC,GAAG,CAAL,CAF1B,EAGE8P,WAAW,GAAGF,UAAU,CAAC5P,IAAC,GAAG,CAAL,CAH1B;AAKD;AACF;AACF;AACF;;AACD,YAAMyM,iBAAiB,GAAGX,qBAAqB,CAACuC,OAAD,EAAU,IAAI3T,sBAAJ,CAA2BiT,QAA3B,EAAqC,CAArC,CAAV,CAA/C;AACA,YAAMjC,eAAe,GAAGa,sBAAsB,CAAC8B,OAAD,EAAUV,QAAV,EAAoB/C,WAApB,CAA9C;AACA,YAAM9D,QAAQ,GAAG,IAAIrM,cAAJ,EAAjB;AACAqM,QAAAA,QAAQ,CAAC4F,YAAT,CAAsB,UAAtB,EAAkCD,iBAAlC;AACA3F,QAAAA,QAAQ,CAAC4F,YAAT,CAAsB,QAAtB,EAAgChB,eAAhC;AACA5E,QAAAA,QAAQ,CAACQ,MAAT,GAAkBqD,KAAlB;AACA7D,QAAAA,QAAQ,CAACE,KAAT,GAAiB,MAAjB;AACA,eAAOF,QAAP;AACD;;AACD,eAAS3D,UAAT,CAAoB4M,UAApB,EAAgC;AAC9B,YAAM/O,IAAI,GAAGpE,OAAO,CAACmT,UAAD,CAApB;AACA,YAAM3M,KAAK,GAAGR,OAAO,CAAC5B,IAAD,CAArB;AACA,eAAOoC,KAAK,CAAC4M,UAAN,IAAoB5M,KAAK,CAAC6M,UAA1B,GAAuC7M,KAAK,CAAC8M,KAAN,EAAvC,GAAuD9M,KAA9D;AACD;;AACD,eAASyB,kBAAT,CAA4BsL,QAA5B,EAAsCC,KAAtC,EAA6C;AAC3C,aAAK,IAAIpQ,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGkQ,QAAQ,CAACnS,MAA7B,EAAqCgC,CAAC,GAAGC,CAAzC,EAA4CD,CAAC,EAA7C,EAAiD;AAC/C,cAAM2C,MAAM,GAAGC,OAAO,CAACuN,QAAQ,CAACnQ,CAAD,CAAT,CAAtB;AACA,cAAI2C,MAAM,YAAYrJ,QAAtB,EACE8W,KAAK,CAACvN,GAAN,CAAUF,MAAV;AACH;AACF;;AACD,eAAS6I,oBAAT,CAA8BuC,KAA9B,EAAqCrD,GAArC,EAA0C;AACxC,YAAM2D,OAAO,GAAG,EAAhB;AACA,YAAIgC,KAAK,GAAG,CAAZ;;AACA,aAAK,IAAIrQ,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAG8N,KAAK,CAAC/P,MAA1B,EAAkCgC,CAAC,GAAGC,CAAtC,EAAyCD,CAAC,EAA1C,EAA8C;AAC5C,cAAMsQ,EAAE,GAAGvC,KAAK,CAACsC,KAAD,CAAhB;AACA,cAAME,EAAE,GAAGxC,KAAK,CAAC/N,CAAC,IAAI0K,GAAG,GAAG,CAAH,GAAO,CAAd,CAAF,CAAhB;AACA,cAAM8F,EAAE,GAAGzC,KAAK,CAAC/N,CAAC,IAAI0K,GAAG,GAAG,CAAH,GAAO,CAAd,CAAF,CAAhB;AACA2D,UAAAA,OAAO,CAACpN,IAAR,CAAaqP,EAAb,EAAiBC,EAAjB,EAAqBC,EAArB;;AACA,cAAIzC,KAAK,CAAC/N,CAAC,GAAG,CAAL,CAAL,KAAiB,CAAC,CAAlB,IAAuBA,CAAC,GAAG,CAAJ,IAASC,CAApC,EAAuC;AACrCD,YAAAA,CAAC,IAAI,CAAL;AACAqQ,YAAAA,KAAK,GAAGrQ,CAAC,GAAG,CAAZ;AACD;AACF;;AACD,eAAOqO,OAAP;AACD;;AACD,eAASnC,mBAAT,CAA6BpP,KAA7B,EAAoCiR,KAApC,EAA2C;AACzC,YAAM0C,gBAAgB,GAAG,EAAzB;AACA,YAAIJ,KAAK,GAAG,CAAZ;;AACA,aAAK,IAAIrQ,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAG8N,KAAK,CAAC/P,MAA1B,EAAkCgC,CAAC,GAAGC,CAAtC,EAAyCD,CAAC,EAA1C,EAA8C;AAC5C,cAAMkK,MAAM,GAAGmG,KAAK,GAAG,CAAvB;AACA,cAAMlD,CAAC,GAAGrQ,KAAK,CAACoN,MAAD,CAAf;AACA,cAAMkD,CAAC,GAAGtQ,KAAK,CAACoN,MAAM,GAAG,CAAV,CAAf;AACA,cAAMmD,CAAC,GAAGvQ,KAAK,CAACoN,MAAM,GAAG,CAAV,CAAf;AACAuG,UAAAA,gBAAgB,CAACxP,IAAjB,CAAsBkM,CAAtB,EAAyBC,CAAzB,EAA4BC,CAA5B;;AACA,cAAIU,KAAK,CAAC/N,CAAC,GAAG,CAAL,CAAL,KAAiB,CAAC,CAAlB,IAAuBA,CAAC,GAAG,CAAJ,IAASC,CAApC,EAAuC;AACrCD,YAAAA,CAAC,IAAI,CAAL;AACAqQ,YAAAA,KAAK;AACN;AACF;;AACD,eAAOI,gBAAP;AACD;;AACD,eAASzE,WAAT,CAAqBlP,KAArB,EAA4BiR,KAA5B,EAAmC;AACjC,YAAM2C,YAAY,GAAG,EAArB;;AACA,aAAK,IAAI1Q,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAG8N,KAAK,CAAC/P,MAA1B,EAAkCgC,CAAC,GAAGC,CAAtC,EAAyCD,CAAC,EAA1C,EAA8C;AAC5C,cAAMsQ,EAAE,GAAGvC,KAAK,CAAC/N,CAAD,CAAhB;AACA,cAAMkK,MAAM,GAAGoG,EAAE,GAAG,CAApB;AACA,cAAMnD,CAAC,GAAGrQ,KAAK,CAACoN,MAAD,CAAf;AACA,cAAMkD,CAAC,GAAGtQ,KAAK,CAACoN,MAAM,GAAG,CAAV,CAAf;AACA,cAAMmD,CAAC,GAAGvQ,KAAK,CAACoN,MAAM,GAAG,CAAV,CAAf;AACAwG,UAAAA,YAAY,CAACzP,IAAb,CAAkBkM,CAAlB,EAAqBC,CAArB,EAAwBC,CAAxB;AACD;;AACD,eAAOqD,YAAP;AACD;;AACD,eAAS9D,eAAT,CAAyBmB,KAAzB,EAAgC;AAC9B,YAAMM,OAAO,GAAG,EAAhB;;AACA,aAAK,IAAIrO,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAG8N,KAAK,CAAC/P,MAA1B,EAAkCgC,CAAC,GAAGC,CAAtC,EAAyCD,CAAC,EAA1C,EAA8C;AAC5C,cAAMsQ,EAAE,GAAGvC,KAAK,CAAC/N,CAAD,CAAhB;AACA,cAAMuQ,EAAE,GAAGxC,KAAK,CAAC/N,CAAC,GAAG,CAAL,CAAhB;AACAqO,UAAAA,OAAO,CAACpN,IAAR,CAAaqP,EAAb,EAAiBC,EAAjB;;AACA,cAAIxC,KAAK,CAAC/N,CAAC,GAAG,CAAL,CAAL,KAAiB,CAAC,CAAlB,IAAuBA,CAAC,GAAG,CAAJ,IAASC,CAApC,EAAuC;AACrCD,YAAAA,CAAC,IAAI,CAAL;AACD;AACF;;AACD,eAAOqO,OAAP;AACD;;AACD,eAASrB,cAAT,CAAwBlQ,KAAxB,EAA+BiR,KAA/B,EAAsC;AACpC,YAAM0C,gBAAgB,GAAG,EAAzB;AACA,YAAIJ,KAAK,GAAG,CAAZ;;AACA,aAAK,IAAIrQ,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAG8N,KAAK,CAAC/P,MAA1B,EAAkCgC,CAAC,GAAGC,CAAtC,EAAyCD,CAAC,EAA1C,EAA8C;AAC5C,cAAMkK,MAAM,GAAGmG,KAAK,GAAG,CAAvB;AACA,cAAMlD,CAAC,GAAGrQ,KAAK,CAACoN,MAAD,CAAf;AACA,cAAMkD,CAAC,GAAGtQ,KAAK,CAACoN,MAAM,GAAG,CAAV,CAAf;AACA,cAAMmD,CAAC,GAAGvQ,KAAK,CAACoN,MAAM,GAAG,CAAV,CAAf;AACAuG,UAAAA,gBAAgB,CAACxP,IAAjB,CAAsBkM,CAAtB,EAAyBC,CAAzB,EAA4BC,CAA5B;;AACA,cAAIU,KAAK,CAAC/N,CAAC,GAAG,CAAL,CAAL,KAAiB,CAAC,CAAlB,IAAuBA,CAAC,GAAG,CAAJ,IAASC,CAApC,EAAuC;AACrCD,YAAAA,CAAC,IAAI,CAAL;AACAqQ,YAAAA,KAAK;AACN;AACF;;AACD,eAAOI,gBAAP;AACD;;AACD,UAAME,EAAE,GAAG,IAAInX,OAAJ,EAAX;AACA,UAAMoX,EAAE,GAAG,IAAIpX,OAAJ,EAAX;AACA,UAAMqX,EAAE,GAAG,IAAIrX,OAAJ,EAAX;AACA,UAAMsX,GAAG,GAAG,IAAItW,OAAJ,EAAZ;AACA,UAAMuW,GAAG,GAAG,IAAIvW,OAAJ,EAAZ;AACA,UAAMwW,GAAG,GAAG,IAAIxW,OAAJ,EAAZ;;AACA,eAASqR,+BAAT,CAAyCf,UAAzC,EAAqDiD,KAArD,EAA4DjR,KAA5D,EAAmEmU,QAAnE,EAA6E;AAC3E,YAAMC,KAAK,GAAG,EAAd;;AACA,aAAK,IAAIlR,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAG6K,UAAU,CAAC9M,MAA/B,EAAuCgC,CAAC,GAAGC,CAA3C,EAA8CD,CAAC,IAAI,CAAnD,EAAsD;AACpD,cAAMuJ,CAAC,GAAGwE,KAAK,CAAC/N,CAAD,CAAf;AACA,cAAMsJ,CAAC,GAAGyE,KAAK,CAAC/N,CAAC,GAAG,CAAL,CAAf;AACA,cAAMsO,CAAC,GAAGP,KAAK,CAAC/N,CAAC,GAAG,CAAL,CAAf;;AACA,cAAIiR,QAAQ,KAAK,CAAjB,EAAoB;AAClBH,YAAAA,GAAG,CAAC3B,SAAJ,CAAcrS,KAAd,EAAqByM,CAAC,GAAG0H,QAAzB;AACAF,YAAAA,GAAG,CAAC5B,SAAJ,CAAcrS,KAAd,EAAqBwM,CAAC,GAAG2H,QAAzB;AACAD,YAAAA,GAAG,CAAC7B,SAAJ,CAAcrS,KAAd,EAAqBwR,CAAC,GAAG2C,QAAzB;AACAC,YAAAA,KAAK,CAACjQ,IAAN,CAAW6P,GAAG,CAAC3D,CAAf,EAAkB2D,GAAG,CAAC1D,CAAtB;AACA8D,YAAAA,KAAK,CAACjQ,IAAN,CAAW8P,GAAG,CAAC5D,CAAf,EAAkB4D,GAAG,CAAC3D,CAAtB;AACA8D,YAAAA,KAAK,CAACjQ,IAAN,CAAW+P,GAAG,CAAC7D,CAAf,EAAkB6D,GAAG,CAAC5D,CAAtB;AACD,WAPD,MAOO;AACLuD,YAAAA,EAAE,CAACxB,SAAH,CAAarS,KAAb,EAAoByM,CAAC,GAAG0H,QAAxB;AACAL,YAAAA,EAAE,CAACzB,SAAH,CAAarS,KAAb,EAAoBwM,CAAC,GAAG2H,QAAxB;AACAJ,YAAAA,EAAE,CAAC1B,SAAH,CAAarS,KAAb,EAAoBwR,CAAC,GAAG2C,QAAxB;AACAC,YAAAA,KAAK,CAACjQ,IAAN,CAAW0P,EAAE,CAACxD,CAAd,EAAiBwD,EAAE,CAACvD,CAApB,EAAuBuD,EAAE,CAACtD,CAA1B;AACA6D,YAAAA,KAAK,CAACjQ,IAAN,CAAW2P,EAAE,CAACzD,CAAd,EAAiByD,EAAE,CAACxD,CAApB,EAAuBwD,EAAE,CAACvD,CAA1B;AACA6D,YAAAA,KAAK,CAACjQ,IAAN,CAAW4P,EAAE,CAAC1D,CAAd,EAAiB0D,EAAE,CAACzD,CAApB,EAAuByD,EAAE,CAACxD,CAA1B;AACD;AACF;;AACD,eAAO,IAAI3S,sBAAJ,CAA2BwW,KAA3B,EAAkCD,QAAlC,CAAP;AACD;;AACD,eAAS9E,4BAAT,CAAsC4B,KAAtC,EAA6CoD,QAA7C,EAAuD;AACrD,YAAMD,KAAK,GAAG,EAAd;;AACA,aAAK,IAAIlR,CAAC,GAAG,CAAR,EAAWiD,CAAC,GAAG,CAAf,EAAkBhD,CAAC,GAAG8N,KAAK,CAAC/P,MAAjC,EAAyCgC,CAAC,GAAGC,CAA7C,EAAgDD,CAAC,IAAI,CAAL,EAAQiD,CAAC,EAAzD,EAA6D;AAC3D0N,UAAAA,EAAE,CAACxB,SAAH,CAAagC,QAAb,EAAuBlO,CAAC,GAAG,CAA3B;AACAiO,UAAAA,KAAK,CAACjQ,IAAN,CAAW0P,EAAE,CAACxD,CAAd,EAAiBwD,EAAE,CAACvD,CAApB,EAAuBuD,EAAE,CAACtD,CAA1B;AACA6D,UAAAA,KAAK,CAACjQ,IAAN,CAAW0P,EAAE,CAACxD,CAAd,EAAiBwD,EAAE,CAACvD,CAApB,EAAuBuD,EAAE,CAACtD,CAA1B;AACA6D,UAAAA,KAAK,CAACjQ,IAAN,CAAW0P,EAAE,CAACxD,CAAd,EAAiBwD,EAAE,CAACvD,CAApB,EAAuBuD,EAAE,CAACtD,CAA1B;AACD;;AACD,eAAO,IAAI3S,sBAAJ,CAA2BwW,KAA3B,EAAkC,CAAlC,CAAP;AACD;;AACD,eAASjE,4BAAT,CAAsCc,KAAtC,EAA6CqD,QAA7C,EAAuD;AACrD,YAAMF,KAAK,GAAG,EAAd;;AACA,aAAK,IAAIlR,CAAC,GAAG,CAAR,EAAWiD,CAAC,GAAG,CAAf,EAAkBhD,CAAC,GAAG8N,KAAK,CAAC/P,MAAjC,EAAyCgC,CAAC,GAAGC,CAA7C,EAAgDD,CAAC,IAAI,CAAL,EAAQiD,CAAC,EAAzD,EAA6D;AAC3D0N,UAAAA,EAAE,CAACxB,SAAH,CAAaiC,QAAb,EAAuBnO,CAAC,GAAG,CAA3B;AACAiO,UAAAA,KAAK,CAACjQ,IAAN,CAAW0P,EAAE,CAACxD,CAAd,EAAiBwD,EAAE,CAACvD,CAApB,EAAuBuD,EAAE,CAACtD,CAA1B;AACA6D,UAAAA,KAAK,CAACjQ,IAAN,CAAW0P,EAAE,CAACxD,CAAd,EAAiBwD,EAAE,CAACvD,CAApB,EAAuBuD,EAAE,CAACtD,CAA1B;AACD;;AACD,eAAO,IAAI3S,sBAAJ,CAA2BwW,KAA3B,EAAkC,CAAlC,CAAP;AACD;;AACD,eAASpF,qBAAT,CAA+BuC,OAA/B,EAAwCgD,SAAxC,EAAmD;AACjD,YAAMH,KAAK,GAAGG,SAAS,CAACH,KAAxB;AACA,YAAMD,QAAQ,GAAGI,SAAS,CAACJ,QAA3B;AACA,YAAMK,MAAM,GAAG,IAAIJ,KAAK,CAACvQ,WAAV,CAAsB0N,OAAO,CAACrQ,MAAR,GAAiBiT,QAAvC,CAAf;AACA,YAAIlD,KAAK,GAAG,CAAZ;AAAA,YAAewD,MAAM,GAAG,CAAxB;;AACA,aAAK,IAAIvR,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGoO,OAAO,CAACrQ,MAA5B,EAAoCgC,CAAC,GAAGC,CAAxC,EAA2CD,CAAC,EAA5C,EAAgD;AAC9C+N,UAAAA,KAAK,GAAGM,OAAO,CAACrO,CAAD,CAAP,GAAaiR,QAArB;;AACA,eAAK,IAAIhO,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGgO,QAApB,EAA8BhO,CAAC,EAA/B,EAAmC;AACjCqO,YAAAA,MAAM,CAACC,MAAM,EAAP,CAAN,GAAmBL,KAAK,CAACnD,KAAK,EAAN,CAAxB;AACD;AACF;;AACD,eAAO,IAAIrT,sBAAJ,CAA2B4W,MAA3B,EAAmCL,QAAnC,CAAP;AACD;;AACD,UAAMO,EAAE,GAAG,IAAIhY,OAAJ,EAAX;AACA,UAAMiY,EAAE,GAAG,IAAIjY,OAAJ,EAAX;;AACA,eAAS+S,sBAAT,CAAgCwB,KAAhC,EAAuCxD,KAAvC,EAA8CK,WAA9C,EAA2D;AACzD,YAAM8E,KAAK,GAAG,EAAd;AACA,YAAMgC,aAAa,GAAG,EAAtB;;AACA,aAAK,IAAI1R,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAG8N,KAAK,CAAC/P,MAA1B,EAAkCgC,CAAC,GAAGC,CAAtC,EAAyCD,CAAC,IAAI,CAA9C,EAAiD;AAC/C,cAAMuJ,CAAC,GAAGwE,KAAK,CAAC/N,CAAD,CAAf;AACA,cAAMsJ,CAAC,GAAGyE,KAAK,CAAC/N,CAAC,GAAG,CAAL,CAAf;AACA,cAAMsO,CAAC,GAAGP,KAAK,CAAC/N,CAAC,GAAG,CAAL,CAAf;AACA,cAAM6P,IAAI,GAAG,IAAI8B,IAAJ,CAASpI,CAAT,EAAYD,CAAZ,EAAegF,CAAf,CAAb;AACAqC,UAAAA,EAAE,CAACxB,SAAH,CAAa5E,KAAb,EAAoBhB,CAAC,GAAG,CAAxB;AACAqH,UAAAA,EAAE,CAACzB,SAAH,CAAa5E,KAAb,EAAoBjB,CAAC,GAAG,CAAxB;AACAuH,UAAAA,EAAE,CAAC1B,SAAH,CAAa5E,KAAb,EAAoB+D,CAAC,GAAG,CAAxB;AACAmD,UAAAA,EAAE,CAACG,UAAH,CAAcf,EAAd,EAAkBD,EAAlB;AACAY,UAAAA,EAAE,CAACI,UAAH,CAAcjB,EAAd,EAAkBC,EAAlB;AACAa,UAAAA,EAAE,CAACI,KAAH,CAASL,EAAT;AACAC,UAAAA,EAAE,CAACK,SAAH;AACAjC,UAAAA,IAAI,CAACrF,MAAL,CAAYrD,IAAZ,CAAiBsK,EAAjB;AACA,cAAIC,aAAa,CAACnI,CAAD,CAAb,KAAqB,KAAK,CAA9B,EACEmI,aAAa,CAACnI,CAAD,CAAb,GAAmB,EAAnB;AACF,cAAImI,aAAa,CAACpI,CAAD,CAAb,KAAqB,KAAK,CAA9B,EACEoI,aAAa,CAACpI,CAAD,CAAb,GAAmB,EAAnB;AACF,cAAIoI,aAAa,CAACpD,CAAD,CAAb,KAAqB,KAAK,CAA9B,EACEoD,aAAa,CAACpD,CAAD,CAAb,GAAmB,EAAnB;AACFoD,UAAAA,aAAa,CAACnI,CAAD,CAAb,CAAiBtI,IAAjB,CAAsB4O,IAAI,CAACrF,MAA3B;AACAkH,UAAAA,aAAa,CAACpI,CAAD,CAAb,CAAiBrI,IAAjB,CAAsB4O,IAAI,CAACrF,MAA3B;AACAkH,UAAAA,aAAa,CAACpD,CAAD,CAAb,CAAiBrN,IAAjB,CAAsB4O,IAAI,CAACrF,MAA3B;AACAkF,UAAAA,KAAK,CAACzO,IAAN,CAAW4O,IAAX;AACD;;AACD,YAAMjC,OAAO,GAAG,EAAhB;;AACA,aAAK,IAAI5N,IAAC,GAAG,CAAR,EAAWC,IAAC,GAAGyP,KAAK,CAAC1R,MAA1B,EAAkCgC,IAAC,GAAGC,IAAtC,EAAyCD,IAAC,EAA1C,EAA8C;AAC5C,cAAM6P,KAAI,GAAGH,KAAK,CAAC1P,IAAD,CAAlB;AACA,cAAM+R,EAAE,GAAGC,cAAc,CAACN,aAAa,CAAC7B,KAAI,CAACtG,CAAN,CAAd,EAAwBsG,KAAI,CAACrF,MAA7B,EAAqCI,WAArC,CAAzB;AACA,cAAMqH,EAAE,GAAGD,cAAc,CAACN,aAAa,CAAC7B,KAAI,CAACvG,CAAN,CAAd,EAAwBuG,KAAI,CAACrF,MAA7B,EAAqCI,WAArC,CAAzB;AACA,cAAMsH,EAAE,GAAGF,cAAc,CAACN,aAAa,CAAC7B,KAAI,CAACvB,CAAN,CAAd,EAAwBuB,KAAI,CAACrF,MAA7B,EAAqCI,WAArC,CAAzB;AACA+F,UAAAA,EAAE,CAACxB,SAAH,CAAa5E,KAAb,EAAoBsF,KAAI,CAACtG,CAAL,GAAS,CAA7B;AACAqH,UAAAA,EAAE,CAACzB,SAAH,CAAa5E,KAAb,EAAoBsF,KAAI,CAACvG,CAAL,GAAS,CAA7B;AACAuH,UAAAA,EAAE,CAAC1B,SAAH,CAAa5E,KAAb,EAAoBsF,KAAI,CAACvB,CAAL,GAAS,CAA7B;AACAV,UAAAA,OAAO,CAAC3M,IAAR,CAAa8Q,EAAE,CAAC5E,CAAhB,EAAmB4E,EAAE,CAAC3E,CAAtB,EAAyB2E,EAAE,CAAC1E,CAA5B;AACAO,UAAAA,OAAO,CAAC3M,IAAR,CAAagR,EAAE,CAAC9E,CAAhB,EAAmB8E,EAAE,CAAC7E,CAAtB,EAAyB6E,EAAE,CAAC5E,CAA5B;AACAO,UAAAA,OAAO,CAAC3M,IAAR,CAAaiR,EAAE,CAAC/E,CAAhB,EAAmB+E,EAAE,CAAC9E,CAAtB,EAAyB8E,EAAE,CAAC7E,CAA5B;AACD;;AACD,eAAO,IAAI3S,sBAAJ,CAA2BkT,OAA3B,EAAoC,CAApC,CAAP;AACD;;AACD,eAASoE,cAAT,CAAwBpE,OAAxB,EAAiCuE,MAAjC,EAAyCvH,WAAzC,EAAsD;AACpD,YAAMJ,MAAM,GAAG,IAAIhR,OAAJ,EAAf;;AACA,YAAIoR,WAAW,KAAK,CAApB,EAAuB;AACrBJ,UAAAA,MAAM,CAACrD,IAAP,CAAYgL,MAAZ;AACD,SAFD,MAEO;AACL,eAAK,IAAInS,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAG2N,OAAO,CAAC5P,MAA5B,EAAoCgC,CAAC,GAAGC,CAAxC,EAA2CD,CAAC,EAA5C,EAAgD;AAC9C,gBAAI4N,OAAO,CAAC5N,CAAD,CAAP,CAAWoS,OAAX,CAAmBD,MAAnB,IAA6BvH,WAAjC,EAA8C;AAC5CJ,cAAAA,MAAM,CAAC3H,GAAP,CAAW+K,OAAO,CAAC5N,CAAD,CAAlB;AACD;AACF;AACF;;AACD,eAAOwK,MAAM,CAACsH,SAAP,EAAP;AACD;;AACD,eAAS7L,YAAT,CAAsB4H,MAAtB,EAA8B;AAC5B,YAAMqD,KAAK,GAAG,EAAd;;AACA,aAAK,IAAIlR,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAG4N,MAAM,CAAC7P,MAA3B,EAAmCgC,CAAC,GAAGC,CAAvC,EAA0CD,CAAC,IAAI,CAA/C,EAAkD;AAChDkR,UAAAA,KAAK,CAACjQ,IAAN,CAAW,IAAI7G,KAAJ,CAAUyT,MAAM,CAAC7N,CAAD,CAAhB,EAAqB6N,MAAM,CAAC7N,CAAC,GAAG,CAAL,CAA3B,EAAoC6N,MAAM,CAAC7N,CAAC,GAAG,CAAL,CAA1C,CAAX;AACD;;AACD,eAAOkR,KAAP;AACD;;AACD,eAASlL,UAAT,CAAoBc,QAApB,EAA8BrB,MAA9B,EAAsC4M,MAAtC,EAA8CxE,MAA9C,EAAsDyE,OAAtD,EAA+D;AAC7D,YAAMC,UAAU,GAAG,EAAnB;AACA,YAAMC,UAAU,GAAGF,OAAO,KAAK,IAAZ,GAAmB,CAAnB,GAAuB/L,IAAI,CAACC,EAA/C;;AACA,aAAK,IAAIxG,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAG4N,MAAM,CAAC7P,MAA3B,EAAmCgC,CAAC,GAAGC,CAAvC,EAA0CD,CAAC,EAA3C,EAA+C;AAC7C,cAAI+E,KAAK,GAAG/E,CAAC,KAAK,CAAN,GAAU,CAAV,GAAcqS,MAAM,CAACrS,CAAC,GAAG,CAAL,CAAhC;AACA+E,UAAAA,KAAK,GAAGuN,OAAO,KAAK,IAAZ,GAAmBvN,KAAnB,GAA2ByN,UAAU,GAAGzN,KAAhD;AACA,cAAM0N,KAAK,GAAG,IAAIjZ,OAAJ,EAAd;AACAiZ,UAAAA,KAAK,CAACC,sBAAN,CAA6BjN,MAA7B,EAAqCV,KAArC,EAA4C,CAA5C;AACAwN,UAAAA,UAAU,CAACtR,IAAX,CAAgBwR,KAAhB;AACD;;AACD,YAAMpE,OAAO,GAAGvH,QAAQ,CAACiH,KAAzB;AACA,YAAMtB,iBAAiB,GAAG3F,QAAQ,CAACC,UAAT,CAAoB3B,QAA9C;AACA,YAAMqG,cAAc,GAAG,IAAIzQ,eAAJ,CAAoB,IAAI2X,YAAJ,CAAiB7L,QAAQ,CAACC,UAAT,CAAoB3B,QAApB,CAA6BwN,KAA7B,GAAqC,CAAtD,CAApB,EAA8E,CAA9E,CAAvB;AACA,YAAMxN,QAAQ,GAAG,IAAI5L,OAAJ,EAAjB;AACA,YAAM2M,KAAK,GAAG,IAAI/L,KAAJ,EAAd;;AACA,aAAK,IAAI4F,IAAC,GAAG,CAAb,EAAgBA,IAAC,GAAGqO,OAAO,CAACuE,KAA5B,EAAmC5S,IAAC,EAApC,EAAwC;AACtC,cAAM+N,KAAK,GAAGM,OAAO,CAACwE,IAAR,CAAa7S,IAAb,CAAd;AACAoF,UAAAA,QAAQ,CAAC0N,mBAAT,CAA6BrG,iBAA7B,EAAgDsB,KAAhD;AACA,cAAIgF,eAAe,SAAnB;AAAA,cAAqBC,eAAe,SAApC;AACA,cAAI5E,CAAC,GAAG,CAAR;;AACA,eAAK,IAAInL,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGsP,UAAU,CAACvU,MAA/B,EAAuCiF,CAAC,EAAxC,EAA4C;AAC1C8P,YAAAA,eAAe,GAAG9P,CAAC,GAAG,CAAtB;AACA+P,YAAAA,eAAe,GAAG/P,CAAlB;AACA,gBAAMgQ,UAAU,GAAGV,UAAU,CAACQ,eAAD,CAA7B;AACA,gBAAMG,UAAU,GAAGX,UAAU,CAACS,eAAD,CAA7B;;AACA,gBAAIV,OAAO,KAAK,IAAhB,EAAsB;AACpB,kBAAIlN,QAAQ,CAACgI,CAAT,IAAc6F,UAAU,CAAC7F,CAAzB,IAA8BhI,QAAQ,CAACgI,CAAT,GAAa8F,UAAU,CAAC9F,CAA1D,EAA6D;AAC3DgB,gBAAAA,CAAC,GAAG7H,IAAI,CAAC4M,GAAL,CAASF,UAAU,CAAC7F,CAAX,GAAehI,QAAQ,CAACgI,CAAjC,IAAsC7G,IAAI,CAAC4M,GAAL,CAASF,UAAU,CAAC7F,CAAX,GAAe8F,UAAU,CAAC9F,CAAnC,CAA1C;AACA;AACD;AACF,aALD,MAKO;AACL,kBAAIhI,QAAQ,CAACgI,CAAT,IAAc6F,UAAU,CAAC7F,CAAzB,IAA8BhI,QAAQ,CAACgI,CAAT,GAAa8F,UAAU,CAAC9F,CAA1D,EAA6D;AAC3DgB,gBAAAA,CAAC,GAAG7H,IAAI,CAAC4M,GAAL,CAASF,UAAU,CAAC7F,CAAX,GAAehI,QAAQ,CAACgI,CAAjC,IAAsC7G,IAAI,CAAC4M,GAAL,CAASF,UAAU,CAAC7F,CAAX,GAAe8F,UAAU,CAAC9F,CAAnC,CAA1C;AACA;AACD;AACF;AACF;;AACD,cAAMgG,MAAM,GAAGvF,MAAM,CAACkF,eAAD,CAArB;AACA,cAAMM,MAAM,GAAGxF,MAAM,CAACmF,eAAD,CAArB;AACA7M,UAAAA,KAAK,CAACgB,IAAN,CAAWiM,MAAX,EAAmBE,IAAnB,CAAwBD,MAAxB,EAAgCjF,CAAhC;AACA3C,UAAAA,cAAc,CAAC8H,MAAf,CAAsBxF,KAAtB,EAA6B5H,KAAK,CAACiD,CAAnC,EAAsCjD,KAAK,CAACkD,CAA5C,EAA+ClD,KAAK,CAACmD,CAArD;AACD;;AACDxC,QAAAA,QAAQ,CAAC4F,YAAT,CAAsB,OAAtB,EAA+BjB,cAA/B;AACD;;AACD,UAAMrB,aAAa,GAAG,IAAInP,aAAJ,CAAkB,KAAKK,OAAvB,CAAtB;AACA8O,MAAAA,aAAa,CAACrO,OAAd,CAAsB,KAAKyX,YAAL,IAAqB5X,IAA3C,EAAiD6X,cAAjD,CAAgE,KAAKC,WAArE;;AACA,UAAI/W,IAAI,CAACgX,OAAL,CAAa,YAAb,MAA+B,CAAC,CAApC,EAAuC;AACrC,cAAM1V,KAAK,CAAC,uDAAD,CAAX;AACD;;AACD,UAAM2V,IAAI,GAAG/W,gBAAgB,CAACF,IAAD,CAA7B;AACA,UAAMkX,KAAK,GAAGtR,SAAS,CAACqR,IAAD,CAAvB;AACA,aAAOC,KAAP;AACD;;;;EAh2DsB3a,M;;IAk2DnBgE,S;AACJ,qBAAYC,MAAZ,EAAoB;AAAA;;AAClB,SAAKF,KAAL,GAAa,IAAI9B,KAAJ,CAAUgC,MAAV,CAAb;AACD;;;;WACD,aAAI2W,SAAJ,EAAe;AACb,UAAMpW,YAAY,GAAG,KAAKT,KAAL,CAAW8W,QAAX,CAAoBD,SAApB,CAArB;;AACA,UAAIpW,YAAY,CAACK,MAAb,CAAoBC,MAApB,GAA6B,CAAjC,EAAoC;AAClCxB,QAAAA,OAAO,CAACC,KAAR,CAAciB,YAAY,CAACK,MAA3B;AACA,cAAME,KAAK,CAAC,0CAAD,CAAX;AACD;;AACD,aAAOP,YAAP;AACD;;;;;;IAEGL,U;;;;;AACJ,sBAAYC,eAAZ,EAA6B;AAAA;;AAAA;;AAC3B,+BAAMA,eAAN;;AACA,QAAM0W,CAAC,gCAAP;;AACA,QAAMtV,OAAO,GAAGpB,eAAe,CAAC,SAAD,CAA/B;AACA,QAAMoC,MAAM,GAAGpC,eAAe,CAAC,QAAD,CAA9B;AACA,QAAMqC,MAAM,GAAGrC,eAAe,CAAC,QAAD,CAA9B;AACA,QAAMkC,OAAO,GAAGlC,eAAe,CAAC,SAAD,CAA/B;AACA,QAAMmC,OAAO,GAAGnC,eAAe,CAAC,SAAD,CAA/B;AACA,QAAMiB,UAAU,GAAGjB,eAAe,CAAC,YAAD,CAAlC;AACA,QAAMc,eAAe,GAAGd,eAAe,CAAC,iBAAD,CAAvC;AACA,QAAM4B,aAAa,GAAG5B,eAAe,CAAC,eAAD,CAArC;AACA,QAAM6B,UAAU,GAAG7B,eAAe,CAAC,YAAD,CAAlC;AACA,QAAM8B,aAAa,GAAG9B,eAAe,CAAC,eAAD,CAArC;AACA,QAAM+B,WAAW,GAAG/B,eAAe,CAAC,aAAD,CAAnC;AACA,QAAMgC,YAAY,GAAGhC,eAAe,CAAC,cAAD,CAApC;AACA,QAAMiC,WAAW,GAAGjC,eAAe,CAAC,aAAD,CAAnC;AACA,QAAMwB,GAAG,GAAGxB,eAAe,CAAC,KAAD,CAA3B;AACA,QAAMyB,GAAG,GAAGzB,eAAe,CAAC,KAAD,CAA3B;AACA,QAAM0B,KAAK,GAAG1B,eAAe,CAAC,OAAD,CAA7B;AACA,QAAM2B,EAAE,GAAG3B,eAAe,CAAC,IAAD,CAA1B;AACA,QAAMqB,QAAQ,GAAGrB,eAAe,CAAC,UAAD,CAAhC;AACA0W,IAAAA,CAAC,CAACC,IAAF,CAAO,MAAP,EAAe,YAAW;AACxBD,MAAAA,CAAC,CAACE,OAAF,CAAUF,CAAC,CAACnT,OAAZ;AACAmT,MAAAA,CAAC,CAACG,YAAF,CAAe,YAAW;AACxBH,QAAAA,CAAC,CAACE,OAAF,CAAUF,CAAC,CAAChT,IAAZ;AACD,OAFD;AAGAgT,MAAAA,CAAC,CAACI,IAAF,CAAO,YAAW;AAChBJ,QAAAA,CAAC,CAACE,OAAF,CAAUF,CAAC,CAAC9S,KAAZ;AACD,OAFD;AAGD,KARD;AASA8S,IAAAA,CAAC,CAACC,IAAF,CAAO,SAAP,EAAkB,YAAW;AAC3BD,MAAAA,CAAC,CAACK,OAAF,CAAU3V,OAAV;AACD,KAFD;AAGAsV,IAAAA,CAAC,CAACC,IAAF,CAAO,MAAP,EAAe,YAAW;AACxBD,MAAAA,CAAC,CAACM,MAAF,CAAS,YAAW;AAClBN,QAAAA,CAAC,CAACE,OAAF,CAAUF,CAAC,CAAC1S,GAAZ;AACD,OAFD;AAGA0S,MAAAA,CAAC,CAACK,OAAF,CAAU1V,QAAV;AACAqV,MAAAA,CAAC,CAACK,OAAF,CAAU3U,MAAV;AACAsU,MAAAA,CAAC,CAACI,IAAF,CAAO,YAAW;AAChBJ,QAAAA,CAAC,CAACE,OAAF,CAAUF,CAAC,CAAC3S,KAAZ;AACD,OAFD;AAGA2S,MAAAA,CAAC,CAACK,OAAF,CAAU1U,MAAV;AACD,KAVD;AAWAqU,IAAAA,CAAC,CAACC,IAAF,CAAO,OAAP,EAAgB,YAAW;AACzBD,MAAAA,CAAC,CAACK,OAAF,CAAU9V,UAAV;AACAyV,MAAAA,CAAC,CAACO,GAAF,CAAM,CACJ;AACEC,QAAAA,GAAG,EAAE,eAAW;AACdR,UAAAA,CAAC,CAACE,OAAF,CAAUF,CAAC,CAACtS,gBAAZ;AACD;AAHH,OADI,EAMJ;AACE8S,QAAAA,GAAG,EAAE,eAAW;AACdR,UAAAA,CAAC,CAACE,OAAF,CAAUF,CAAC,CAACrS,eAAZ;AACD;AAHH,OANI,CAAN;AAYD,KAdD;AAeAqS,IAAAA,CAAC,CAACC,IAAF,CAAO,KAAP,EAAc,YAAW;AACvBD,MAAAA,CAAC,CAACK,OAAF,CAAUvV,GAAV;AACAkV,MAAAA,CAAC,CAACS,EAAF,CAAK,CACH;AACED,QAAAA,GAAG,EAAE,eAAW;AACdR,UAAAA,CAAC,CAACK,OAAF,CAAU9V,UAAV;AACD;AAHH,OADG,EAMH;AACEiW,QAAAA,GAAG,EAAE,eAAW;AACdR,UAAAA,CAAC,CAACK,OAAF,CAAU1V,QAAV;AACD;AAHH,OANG,CAAL;AAYD,KAdD;AAeAqV,IAAAA,CAAC,CAACC,IAAF,CAAO,KAAP,EAAc,YAAW;AACvBD,MAAAA,CAAC,CAACK,OAAF,CAAUtV,GAAV;AACAiV,MAAAA,CAAC,CAACS,EAAF,CAAK,CACH;AACED,QAAAA,GAAG,EAAE,eAAW;AACdR,UAAAA,CAAC,CAACK,OAAF,CAAU9V,UAAV;AACD;AAHH,OADG,EAMH;AACEiW,QAAAA,GAAG,EAAE,eAAW;AACdR,UAAAA,CAAC,CAACK,OAAF,CAAU1V,QAAV;AACD;AAHH,OANG,CAAL;AAYD,KAdD;AAeAqV,IAAAA,CAAC,CAACC,IAAF,CAAO,kBAAP,EAA2B,YAAW;AACpCD,MAAAA,CAAC,CAACG,YAAF,CAAe,YAAW;AACxBH,QAAAA,CAAC,CAACS,EAAF,CAAK,CACH;AACED,UAAAA,GAAG,EAAE,eAAW;AACdR,YAAAA,CAAC,CAACE,OAAF,CAAUF,CAAC,CAAChT,IAAZ;AACD;AAHH,SADG,EAMH;AACEwT,UAAAA,GAAG,EAAE,eAAW;AACdR,YAAAA,CAAC,CAACE,OAAF,CAAUF,CAAC,CAACpS,GAAZ;AACD;AAHH,SANG,EAWH;AACE4S,UAAAA,GAAG,EAAE,eAAW;AACdR,YAAAA,CAAC,CAACK,OAAF,CAAUnV,aAAV;AACD;AAHH,SAXG,EAgBH;AACEsV,UAAAA,GAAG,EAAE,eAAW;AACdR,YAAAA,CAAC,CAACK,OAAF,CAAUlV,UAAV;AACD;AAHH,SAhBG,EAqBH;AACEqV,UAAAA,GAAG,EAAE,eAAW;AACdR,YAAAA,CAAC,CAACK,OAAF,CAAUjV,aAAV;AACD;AAHH,SArBG,EA0BH;AACEoV,UAAAA,GAAG,EAAE,eAAW;AACdR,YAAAA,CAAC,CAACK,OAAF,CAAUhV,WAAV;AACD;AAHH,SA1BG,EA+BH;AACEmV,UAAAA,GAAG,EAAE,eAAW;AACdR,YAAAA,CAAC,CAACK,OAAF,CAAU/U,YAAV;AACD;AAHH,SA/BG,EAoCH;AACEkV,UAAAA,GAAG,EAAE,eAAW;AACdR,YAAAA,CAAC,CAACK,OAAF,CAAU9U,WAAV;AACD;AAHH,SApCG,CAAL;AA0CD,OA3CD;AA4CD,KA7CD;AA8CAyU,IAAAA,CAAC,CAACC,IAAF,CAAO,iBAAP,EAA0B,YAAW;AACnCD,MAAAA,CAAC,CAACK,OAAF,CAAU7U,OAAV;AACAwU,MAAAA,CAAC,CAACI,IAAF,CAAO,YAAW;AAChBJ,QAAAA,CAAC,CAACS,EAAF,CAAK,CACH;AACED,UAAAA,GAAG,EAAE,eAAW;AACdR,YAAAA,CAAC,CAACE,OAAF,CAAUF,CAAC,CAAChT,IAAZ;AACD;AAHH,SADG,EAMH;AACEwT,UAAAA,GAAG,EAAE,eAAW;AACdR,YAAAA,CAAC,CAACE,OAAF,CAAUF,CAAC,CAACpS,GAAZ;AACD;AAHH,SANG,EAWH;AACE4S,UAAAA,GAAG,EAAE,eAAW;AACdR,YAAAA,CAAC,CAACK,OAAF,CAAUnV,aAAV;AACD;AAHH,SAXG,EAgBH;AACEsV,UAAAA,GAAG,EAAE,eAAW;AACdR,YAAAA,CAAC,CAACK,OAAF,CAAUlV,UAAV;AACD;AAHH,SAhBG,EAqBH;AACEqV,UAAAA,GAAG,EAAE,eAAW;AACdR,YAAAA,CAAC,CAACK,OAAF,CAAUjV,aAAV;AACD;AAHH,SArBG,EA0BH;AACEoV,UAAAA,GAAG,EAAE,eAAW;AACdR,YAAAA,CAAC,CAACK,OAAF,CAAU9U,WAAV;AACD;AAHH,SA1BG,CAAL;AAgCD,OAjCD;AAkCAyU,MAAAA,CAAC,CAACK,OAAF,CAAU5U,OAAV;AACD,KArCD;AAsCAuU,IAAAA,CAAC,CAACC,IAAF,CAAO,OAAP,EAAgB,YAAW;AACzBD,MAAAA,CAAC,CAACK,OAAF,CAAUrV,KAAV;AACAgV,MAAAA,CAAC,CAACK,OAAF,CAAUjW,eAAV;AACA4V,MAAAA,CAAC,CAACK,OAAF,CAAUpV,EAAV;AACA+U,MAAAA,CAAC,CAACU,QAAF,CAAWtW,eAAX;AACD,KALD;;AAMA,UAAKuW,mBAAL;;AAnL2B;AAoL5B;;;EArLsBvZ,S;;IAuLnBuW,I,GACJ,cAAYpI,CAAZ,EAAeD,CAAf,EAAkBgF,CAAlB,EAAqB;AAAA;;AACnB,OAAK/E,CAAL,GAASA,CAAT;AACA,OAAKD,CAAL,GAASA,CAAT;AACA,OAAKgF,CAAL,GAASA,CAAT;AACA,OAAK9D,MAAL,GAAc,IAAIhR,OAAJ,EAAd;AACD,C;;AAEH,IAAM6O,YAAY,GAAG;AACnBa,EAAAA,SAAS,EAAE,CADQ;AAEnBZ,EAAAA,eAAe,EAAE,CAFE;AAGnBC,EAAAA,GAAG,EAAE,CAHc;AAInBC,EAAAA,IAAI,EAAE;AAJa,CAArB;AAMA,SACEnN,UADF","sourcesContent":["import { Loader, LoaderUtils, FileLoader, Scene, Object3D, Group, Vector3, SphereGeometry, MeshBasicMaterial, BackSide, Mesh, PointsMaterial, Points, LineBasicMaterial, LineSegments, FrontSide, DoubleSide, MeshPhongMaterial, Color, RepeatWrapping, ClampToEdgeWrapping, DataTexture, Vector2, BufferGeometry, Float32BufferAttribute, BoxGeometry, ConeGeometry, CylinderGeometry, Quaternion, ShapeUtils, BufferAttribute, TextureLoader } from \"three\";\nimport { createToken, Lexer, CstParser } from \"chevrotain\";\nclass VRMLLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const path = scope.path === \"\" ? LoaderUtils.extractUrlBase(url) : scope.path;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(\n      url,\n      function(text) {\n        try {\n          onLoad(scope.parse(text, path));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n          scope.manager.itemError(url);\n        }\n      },\n      onProgress,\n      onError\n    );\n  }\n  parse(data, path) {\n    const nodeMap = {};\n    function generateVRMLTree(data2) {\n      const tokenData = createTokens();\n      const lexer = new VRMLLexer(tokenData.tokens);\n      const parser = new VRMLParser(tokenData.tokenVocabulary);\n      const visitor = createVisitor(parser.getBaseCstVisitorConstructor());\n      const lexingResult = lexer.lex(data2);\n      parser.input = lexingResult.tokens;\n      const cstOutput = parser.vrml();\n      if (parser.errors.length > 0) {\n        console.error(parser.errors);\n        throw Error(\"THREE.VRMLLoader: Parsing errors detected.\");\n      }\n      const ast = visitor.visit(cstOutput);\n      return ast;\n    }\n    function createTokens() {\n      const RouteIdentifier = createToken({\n        name: \"RouteIdentifier\",\n        pattern: /[^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*[\\.][^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*/\n      });\n      const Identifier = createToken({\n        name: \"Identifier\",\n        pattern: /[^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*/,\n        longer_alt: RouteIdentifier\n      });\n      const nodeTypes = [\n        \"Anchor\",\n        \"Billboard\",\n        \"Collision\",\n        \"Group\",\n        \"Transform\",\n        // grouping nodes\n        \"Inline\",\n        \"LOD\",\n        \"Switch\",\n        // special groups\n        \"AudioClip\",\n        \"DirectionalLight\",\n        \"PointLight\",\n        \"Script\",\n        \"Shape\",\n        \"Sound\",\n        \"SpotLight\",\n        \"WorldInfo\",\n        // common nodes\n        \"CylinderSensor\",\n        \"PlaneSensor\",\n        \"ProximitySensor\",\n        \"SphereSensor\",\n        \"TimeSensor\",\n        \"TouchSensor\",\n        \"VisibilitySensor\",\n        // sensors\n        \"Box\",\n        \"Cone\",\n        \"Cylinder\",\n        \"ElevationGrid\",\n        \"Extrusion\",\n        \"IndexedFaceSet\",\n        \"IndexedLineSet\",\n        \"PointSet\",\n        \"Sphere\",\n        // geometries\n        \"Color\",\n        \"Coordinate\",\n        \"Normal\",\n        \"TextureCoordinate\",\n        // geometric properties\n        \"Appearance\",\n        \"FontStyle\",\n        \"ImageTexture\",\n        \"Material\",\n        \"MovieTexture\",\n        \"PixelTexture\",\n        \"TextureTransform\",\n        // appearance\n        \"ColorInterpolator\",\n        \"CoordinateInterpolator\",\n        \"NormalInterpolator\",\n        \"OrientationInterpolator\",\n        \"PositionInterpolator\",\n        \"ScalarInterpolator\",\n        // interpolators\n        \"Background\",\n        \"Fog\",\n        \"NavigationInfo\",\n        \"Viewpoint\",\n        // bindable nodes\n        \"Text\"\n        // Text must be placed at the end of the regex so there are no matches for TextureTransform and TextureCoordinate\n      ];\n      const Version = createToken({\n        name: \"Version\",\n        pattern: /#VRML.*/,\n        longer_alt: Identifier\n      });\n      const NodeName = createToken({\n        name: \"NodeName\",\n        pattern: new RegExp(nodeTypes.join(\"|\")),\n        longer_alt: Identifier\n      });\n      const DEF = createToken({\n        name: \"DEF\",\n        pattern: /DEF/,\n        longer_alt: Identifier\n      });\n      const USE = createToken({\n        name: \"USE\",\n        pattern: /USE/,\n        longer_alt: Identifier\n      });\n      const ROUTE = createToken({\n        name: \"ROUTE\",\n        pattern: /ROUTE/,\n        longer_alt: Identifier\n      });\n      const TO = createToken({\n        name: \"TO\",\n        pattern: /TO/,\n        longer_alt: Identifier\n      });\n      const StringLiteral = createToken({\n        name: \"StringLiteral\",\n        pattern: /\"(?:[^\\\\\"\\n\\r]|\\\\[bfnrtv\"\\\\/]|\\\\u[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F])*\"/\n      });\n      const HexLiteral = createToken({ name: \"HexLiteral\", pattern: /0[xX][0-9a-fA-F]+/ });\n      const NumberLiteral = createToken({ name: \"NumberLiteral\", pattern: /[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?/ });\n      const TrueLiteral = createToken({ name: \"TrueLiteral\", pattern: /TRUE/ });\n      const FalseLiteral = createToken({ name: \"FalseLiteral\", pattern: /FALSE/ });\n      const NullLiteral = createToken({ name: \"NullLiteral\", pattern: /NULL/ });\n      const LSquare = createToken({ name: \"LSquare\", pattern: /\\[/ });\n      const RSquare = createToken({ name: \"RSquare\", pattern: /]/ });\n      const LCurly = createToken({ name: \"LCurly\", pattern: /{/ });\n      const RCurly = createToken({ name: \"RCurly\", pattern: /}/ });\n      const Comment = createToken({\n        name: \"Comment\",\n        pattern: /#.*/,\n        group: Lexer.SKIPPED\n      });\n      const WhiteSpace = createToken({\n        name: \"WhiteSpace\",\n        pattern: /[ ,\\s]/,\n        group: Lexer.SKIPPED\n      });\n      const tokens = [\n        WhiteSpace,\n        // keywords appear before the Identifier\n        NodeName,\n        DEF,\n        USE,\n        ROUTE,\n        TO,\n        TrueLiteral,\n        FalseLiteral,\n        NullLiteral,\n        // the Identifier must appear after the keywords because all keywords are valid identifiers\n        Version,\n        Identifier,\n        RouteIdentifier,\n        StringLiteral,\n        HexLiteral,\n        NumberLiteral,\n        LSquare,\n        RSquare,\n        LCurly,\n        RCurly,\n        Comment\n      ];\n      const tokenVocabulary = {};\n      for (let i = 0, l = tokens.length; i < l; i++) {\n        const token = tokens[i];\n        tokenVocabulary[token.name] = token;\n      }\n      return { tokens, tokenVocabulary };\n    }\n    function createVisitor(BaseVRMLVisitor) {\n      function VRMLToASTVisitor() {\n        BaseVRMLVisitor.call(this);\n        this.validateVisitor();\n      }\n      VRMLToASTVisitor.prototype = Object.assign(Object.create(BaseVRMLVisitor.prototype), {\n        constructor: VRMLToASTVisitor,\n        vrml: function(ctx) {\n          const data2 = {\n            version: this.visit(ctx.version),\n            nodes: [],\n            routes: []\n          };\n          for (let i = 0, l = ctx.node.length; i < l; i++) {\n            const node = ctx.node[i];\n            data2.nodes.push(this.visit(node));\n          }\n          if (ctx.route) {\n            for (let i = 0, l = ctx.route.length; i < l; i++) {\n              const route = ctx.route[i];\n              data2.routes.push(this.visit(route));\n            }\n          }\n          return data2;\n        },\n        version: function(ctx) {\n          return ctx.Version[0].image;\n        },\n        node: function(ctx) {\n          const data2 = {\n            name: ctx.NodeName[0].image,\n            fields: []\n          };\n          if (ctx.field) {\n            for (let i = 0, l = ctx.field.length; i < l; i++) {\n              const field = ctx.field[i];\n              data2.fields.push(this.visit(field));\n            }\n          }\n          if (ctx.def) {\n            data2.DEF = this.visit(ctx.def[0]);\n          }\n          return data2;\n        },\n        field: function(ctx) {\n          const data2 = {\n            name: ctx.Identifier[0].image,\n            type: null,\n            values: null\n          };\n          let result;\n          if (ctx.singleFieldValue) {\n            result = this.visit(ctx.singleFieldValue[0]);\n          }\n          if (ctx.multiFieldValue) {\n            result = this.visit(ctx.multiFieldValue[0]);\n          }\n          data2.type = result.type;\n          data2.values = result.values;\n          return data2;\n        },\n        def: function(ctx) {\n          return (ctx.Identifier || ctx.NodeName)[0].image;\n        },\n        use: function(ctx) {\n          return { USE: (ctx.Identifier || ctx.NodeName)[0].image };\n        },\n        singleFieldValue: function(ctx) {\n          return processField(this, ctx);\n        },\n        multiFieldValue: function(ctx) {\n          return processField(this, ctx);\n        },\n        route: function(ctx) {\n          const data2 = {\n            FROM: ctx.RouteIdentifier[0].image,\n            TO: ctx.RouteIdentifier[1].image\n          };\n          return data2;\n        }\n      });\n      function processField(scope, ctx) {\n        const field = {\n          type: null,\n          values: []\n        };\n        if (ctx.node) {\n          field.type = \"node\";\n          for (let i = 0, l = ctx.node.length; i < l; i++) {\n            const node = ctx.node[i];\n            field.values.push(scope.visit(node));\n          }\n        }\n        if (ctx.use) {\n          field.type = \"use\";\n          for (let i = 0, l = ctx.use.length; i < l; i++) {\n            const use = ctx.use[i];\n            field.values.push(scope.visit(use));\n          }\n        }\n        if (ctx.StringLiteral) {\n          field.type = \"string\";\n          for (let i = 0, l = ctx.StringLiteral.length; i < l; i++) {\n            const stringLiteral = ctx.StringLiteral[i];\n            field.values.push(stringLiteral.image.replace(/'|\"/g, \"\"));\n          }\n        }\n        if (ctx.NumberLiteral) {\n          field.type = \"number\";\n          for (let i = 0, l = ctx.NumberLiteral.length; i < l; i++) {\n            const numberLiteral = ctx.NumberLiteral[i];\n            field.values.push(parseFloat(numberLiteral.image));\n          }\n        }\n        if (ctx.HexLiteral) {\n          field.type = \"hex\";\n          for (let i = 0, l = ctx.HexLiteral.length; i < l; i++) {\n            const hexLiteral = ctx.HexLiteral[i];\n            field.values.push(hexLiteral.image);\n          }\n        }\n        if (ctx.TrueLiteral) {\n          field.type = \"boolean\";\n          for (let i = 0, l = ctx.TrueLiteral.length; i < l; i++) {\n            const trueLiteral = ctx.TrueLiteral[i];\n            if (trueLiteral.image === \"TRUE\")\n              field.values.push(true);\n          }\n        }\n        if (ctx.FalseLiteral) {\n          field.type = \"boolean\";\n          for (let i = 0, l = ctx.FalseLiteral.length; i < l; i++) {\n            const falseLiteral = ctx.FalseLiteral[i];\n            if (falseLiteral.image === \"FALSE\")\n              field.values.push(false);\n          }\n        }\n        if (ctx.NullLiteral) {\n          field.type = \"null\";\n          ctx.NullLiteral.forEach(function() {\n            field.values.push(null);\n          });\n        }\n        return field;\n      }\n      return new VRMLToASTVisitor();\n    }\n    function parseTree(tree2) {\n      const nodes = tree2.nodes;\n      const scene2 = new Scene();\n      for (let i = 0, l = nodes.length; i < l; i++) {\n        const node = nodes[i];\n        buildNodeMap(node);\n      }\n      for (let i = 0, l = nodes.length; i < l; i++) {\n        const node = nodes[i];\n        const object = getNode(node);\n        if (object instanceof Object3D)\n          scene2.add(object);\n        if (node.name === \"WorldInfo\")\n          scene2.userData.worldInfo = object;\n      }\n      return scene2;\n    }\n    function buildNodeMap(node) {\n      if (node.DEF) {\n        nodeMap[node.DEF] = node;\n      }\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        if (field.type === \"node\") {\n          const fieldValues = field.values;\n          for (let j = 0, jl = fieldValues.length; j < jl; j++) {\n            buildNodeMap(fieldValues[j]);\n          }\n        }\n      }\n    }\n    function getNode(node) {\n      if (node.USE) {\n        return resolveUSE(node.USE);\n      }\n      if (node.build !== void 0)\n        return node.build;\n      node.build = buildNode(node);\n      return node.build;\n    }\n    function buildNode(node) {\n      const nodeName = node.name;\n      let build;\n      switch (nodeName) {\n        case \"Group\":\n        case \"Transform\":\n        case \"Collision\":\n          build = buildGroupingNode(node);\n          break;\n        case \"Background\":\n          build = buildBackgroundNode(node);\n          break;\n        case \"Shape\":\n          build = buildShapeNode(node);\n          break;\n        case \"Appearance\":\n          build = buildAppearanceNode(node);\n          break;\n        case \"Material\":\n          build = buildMaterialNode(node);\n          break;\n        case \"ImageTexture\":\n          build = buildImageTextureNode(node);\n          break;\n        case \"PixelTexture\":\n          build = buildPixelTextureNode(node);\n          break;\n        case \"TextureTransform\":\n          build = buildTextureTransformNode(node);\n          break;\n        case \"IndexedFaceSet\":\n          build = buildIndexedFaceSetNode(node);\n          break;\n        case \"IndexedLineSet\":\n          build = buildIndexedLineSetNode(node);\n          break;\n        case \"PointSet\":\n          build = buildPointSetNode(node);\n          break;\n        case \"Box\":\n          build = buildBoxNode(node);\n          break;\n        case \"Cone\":\n          build = buildConeNode(node);\n          break;\n        case \"Cylinder\":\n          build = buildCylinderNode(node);\n          break;\n        case \"Sphere\":\n          build = buildSphereNode(node);\n          break;\n        case \"ElevationGrid\":\n          build = buildElevationGridNode(node);\n          break;\n        case \"Extrusion\":\n          build = buildExtrusionNode(node);\n          break;\n        case \"Color\":\n        case \"Coordinate\":\n        case \"Normal\":\n        case \"TextureCoordinate\":\n          build = buildGeometricNode(node);\n          break;\n        case \"WorldInfo\":\n          build = buildWorldInfoNode(node);\n          break;\n        case \"Anchor\":\n        case \"Billboard\":\n        case \"Inline\":\n        case \"LOD\":\n        case \"Switch\":\n        case \"AudioClip\":\n        case \"DirectionalLight\":\n        case \"PointLight\":\n        case \"Script\":\n        case \"Sound\":\n        case \"SpotLight\":\n        case \"CylinderSensor\":\n        case \"PlaneSensor\":\n        case \"ProximitySensor\":\n        case \"SphereSensor\":\n        case \"TimeSensor\":\n        case \"TouchSensor\":\n        case \"VisibilitySensor\":\n        case \"Text\":\n        case \"FontStyle\":\n        case \"MovieTexture\":\n        case \"ColorInterpolator\":\n        case \"CoordinateInterpolator\":\n        case \"NormalInterpolator\":\n        case \"OrientationInterpolator\":\n        case \"PositionInterpolator\":\n        case \"ScalarInterpolator\":\n        case \"Fog\":\n        case \"NavigationInfo\":\n        case \"Viewpoint\":\n          break;\n        default:\n          console.warn(\"THREE.VRMLLoader: Unknown node:\", nodeName);\n          break;\n      }\n      if (build !== void 0 && node.DEF !== void 0 && build.hasOwnProperty(\"name\") === true) {\n        build.name = node.DEF;\n      }\n      return build;\n    }\n    function buildGroupingNode(node) {\n      const object = new Group();\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"bboxCenter\":\n            break;\n          case \"bboxSize\":\n            break;\n          case \"center\":\n            break;\n          case \"children\":\n            parseFieldChildren(fieldValues, object);\n            break;\n          case \"collide\":\n            break;\n          case \"rotation\":\n            const axis = new Vector3(fieldValues[0], fieldValues[1], fieldValues[2]);\n            const angle = fieldValues[3];\n            object.quaternion.setFromAxisAngle(axis, angle);\n            break;\n          case \"scale\":\n            object.scale.set(fieldValues[0], fieldValues[1], fieldValues[2]);\n            break;\n          case \"scaleOrientation\":\n            break;\n          case \"translation\":\n            object.position.set(fieldValues[0], fieldValues[1], fieldValues[2]);\n            break;\n          case \"proxy\":\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      return object;\n    }\n    function buildBackgroundNode(node) {\n      const group = new Group();\n      let groundAngle, groundColor;\n      let skyAngle, skyColor;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"groundAngle\":\n            groundAngle = fieldValues;\n            break;\n          case \"groundColor\":\n            groundColor = fieldValues;\n            break;\n          case \"backUrl\":\n            break;\n          case \"bottomUrl\":\n            break;\n          case \"frontUrl\":\n            break;\n          case \"leftUrl\":\n            break;\n          case \"rightUrl\":\n            break;\n          case \"topUrl\":\n            break;\n          case \"skyAngle\":\n            skyAngle = fieldValues;\n            break;\n          case \"skyColor\":\n            skyColor = fieldValues;\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      const radius = 1e4;\n      if (skyColor) {\n        const skyGeometry = new SphereGeometry(radius, 32, 16);\n        const skyMaterial = new MeshBasicMaterial({ fog: false, side: BackSide, depthWrite: false, depthTest: false });\n        if (skyColor.length > 3) {\n          paintFaces(skyGeometry, radius, skyAngle, toColorArray(skyColor), true);\n          skyMaterial.vertexColors = true;\n        } else {\n          skyMaterial.color.setRGB(skyColor[0], skyColor[1], skyColor[2]);\n        }\n        const sky = new Mesh(skyGeometry, skyMaterial);\n        group.add(sky);\n      }\n      if (groundColor) {\n        if (groundColor.length > 0) {\n          const groundGeometry = new SphereGeometry(radius, 32, 16, 0, 2 * Math.PI, 0.5 * Math.PI, 1.5 * Math.PI);\n          const groundMaterial = new MeshBasicMaterial({\n            fog: false,\n            side: BackSide,\n            vertexColors: true,\n            depthWrite: false,\n            depthTest: false\n          });\n          paintFaces(groundGeometry, radius, groundAngle, toColorArray(groundColor), false);\n          const ground = new Mesh(groundGeometry, groundMaterial);\n          group.add(ground);\n        }\n      }\n      group.renderOrder = -Infinity;\n      return group;\n    }\n    function buildShapeNode(node) {\n      const fields = node.fields;\n      let material = new MeshBasicMaterial({ color: 0 });\n      let geometry;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"appearance\":\n            if (fieldValues[0] !== null) {\n              material = getNode(fieldValues[0]);\n            }\n            break;\n          case \"geometry\":\n            if (fieldValues[0] !== null) {\n              geometry = getNode(fieldValues[0]);\n            }\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      let object;\n      if (geometry && geometry.attributes.position) {\n        const type = geometry._type;\n        if (type === \"points\") {\n          const pointsMaterial = new PointsMaterial({ color: 16777215 });\n          if (geometry.attributes.color !== void 0) {\n            pointsMaterial.vertexColors = true;\n          } else {\n            if (material.isMeshPhongMaterial) {\n              pointsMaterial.color.copy(material.emissive);\n            }\n          }\n          object = new Points(geometry, pointsMaterial);\n        } else if (type === \"line\") {\n          const lineMaterial = new LineBasicMaterial({ color: 16777215 });\n          if (geometry.attributes.color !== void 0) {\n            lineMaterial.vertexColors = true;\n          } else {\n            if (material.isMeshPhongMaterial) {\n              lineMaterial.color.copy(material.emissive);\n            }\n          }\n          object = new LineSegments(geometry, lineMaterial);\n        } else {\n          if (geometry._solid !== void 0) {\n            material.side = geometry._solid ? FrontSide : DoubleSide;\n          }\n          if (geometry.attributes.color !== void 0) {\n            material.vertexColors = true;\n          }\n          object = new Mesh(geometry, material);\n        }\n      } else {\n        object = new Object3D();\n        object.visible = false;\n      }\n      return object;\n    }\n    function buildAppearanceNode(node) {\n      let material = new MeshPhongMaterial();\n      let transformData;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"material\":\n            if (fieldValues[0] !== null) {\n              const materialData = getNode(fieldValues[0]);\n              if (materialData.diffuseColor)\n                material.color.copy(materialData.diffuseColor);\n              if (materialData.emissiveColor)\n                material.emissive.copy(materialData.emissiveColor);\n              if (materialData.shininess)\n                material.shininess = materialData.shininess;\n              if (materialData.specularColor)\n                material.specular.copy(materialData.specularColor);\n              if (materialData.transparency)\n                material.opacity = 1 - materialData.transparency;\n              if (materialData.transparency > 0)\n                material.transparent = true;\n            } else {\n              material = new MeshBasicMaterial({ color: 0 });\n            }\n            break;\n          case \"texture\":\n            const textureNode = fieldValues[0];\n            if (textureNode !== null) {\n              if (textureNode.name === \"ImageTexture\" || textureNode.name === \"PixelTexture\") {\n                material.map = getNode(textureNode);\n              } else {\n              }\n            }\n            break;\n          case \"textureTransform\":\n            if (fieldValues[0] !== null) {\n              transformData = getNode(fieldValues[0]);\n            }\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      if (material.map) {\n        if (material.map.__type) {\n          switch (material.map.__type) {\n            case TEXTURE_TYPE.INTENSITY_ALPHA:\n              material.opacity = 1;\n              break;\n            case TEXTURE_TYPE.RGB:\n              material.color.set(16777215);\n              break;\n            case TEXTURE_TYPE.RGBA:\n              material.color.set(16777215);\n              material.opacity = 1;\n              break;\n            default:\n          }\n          delete material.map.__type;\n        }\n        if (transformData) {\n          material.map.center.copy(transformData.center);\n          material.map.rotation = transformData.rotation;\n          material.map.repeat.copy(transformData.scale);\n          material.map.offset.copy(transformData.translation);\n        }\n      }\n      return material;\n    }\n    function buildMaterialNode(node) {\n      const materialData = {};\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"ambientIntensity\":\n            break;\n          case \"diffuseColor\":\n            materialData.diffuseColor = new Color(fieldValues[0], fieldValues[1], fieldValues[2]);\n            break;\n          case \"emissiveColor\":\n            materialData.emissiveColor = new Color(fieldValues[0], fieldValues[1], fieldValues[2]);\n            break;\n          case \"shininess\":\n            materialData.shininess = fieldValues[0];\n            break;\n          case \"specularColor\":\n            materialData.emissiveColor = new Color(fieldValues[0], fieldValues[1], fieldValues[2]);\n            break;\n          case \"transparency\":\n            materialData.transparency = fieldValues[0];\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      return materialData;\n    }\n    function parseHexColor(hex, textureType, color) {\n      let value;\n      switch (textureType) {\n        case TEXTURE_TYPE.INTENSITY:\n          value = parseInt(hex);\n          color.r = value;\n          color.g = value;\n          color.b = value;\n          color.a = 1;\n          break;\n        case TEXTURE_TYPE.INTENSITY_ALPHA:\n          value = parseInt(\"0x\" + hex.substring(2, 4));\n          color.r = value;\n          color.g = value;\n          color.b = value;\n          color.a = parseInt(\"0x\" + hex.substring(4, 6));\n          break;\n        case TEXTURE_TYPE.RGB:\n          color.r = parseInt(\"0x\" + hex.substring(2, 4));\n          color.g = parseInt(\"0x\" + hex.substring(4, 6));\n          color.b = parseInt(\"0x\" + hex.substring(6, 8));\n          color.a = 1;\n          break;\n        case TEXTURE_TYPE.RGBA:\n          color.r = parseInt(\"0x\" + hex.substring(2, 4));\n          color.g = parseInt(\"0x\" + hex.substring(4, 6));\n          color.b = parseInt(\"0x\" + hex.substring(6, 8));\n          color.a = parseInt(\"0x\" + hex.substring(8, 10));\n          break;\n        default:\n      }\n    }\n    function getTextureType(num_components) {\n      let type;\n      switch (num_components) {\n        case 1:\n          type = TEXTURE_TYPE.INTENSITY;\n          break;\n        case 2:\n          type = TEXTURE_TYPE.INTENSITY_ALPHA;\n          break;\n        case 3:\n          type = TEXTURE_TYPE.RGB;\n          break;\n        case 4:\n          type = TEXTURE_TYPE.RGBA;\n          break;\n        default:\n      }\n      return type;\n    }\n    function buildPixelTextureNode(node) {\n      let texture;\n      let wrapS = RepeatWrapping;\n      let wrapT = RepeatWrapping;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"image\":\n            const width = fieldValues[0];\n            const height = fieldValues[1];\n            const num_components = fieldValues[2];\n            const textureType = getTextureType(num_components);\n            const data2 = new Uint8Array(4 * width * height);\n            const color = { r: 0, g: 0, b: 0, a: 0 };\n            for (let j = 3, k = 0, jl = fieldValues.length; j < jl; j++, k++) {\n              parseHexColor(fieldValues[j], textureType, color);\n              const stride = k * 4;\n              data2[stride + 0] = color.r;\n              data2[stride + 1] = color.g;\n              data2[stride + 2] = color.b;\n              data2[stride + 3] = color.a;\n            }\n            texture = new DataTexture(data2, width, height);\n            texture.needsUpdate = true;\n            texture.__type = textureType;\n            break;\n          case \"repeatS\":\n            if (fieldValues[0] === false)\n              wrapS = ClampToEdgeWrapping;\n            break;\n          case \"repeatT\":\n            if (fieldValues[0] === false)\n              wrapT = ClampToEdgeWrapping;\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      if (texture) {\n        texture.wrapS = wrapS;\n        texture.wrapT = wrapT;\n      }\n      return texture;\n    }\n    function buildImageTextureNode(node) {\n      let texture;\n      let wrapS = RepeatWrapping;\n      let wrapT = RepeatWrapping;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"url\":\n            const url = fieldValues[0];\n            if (url)\n              texture = textureLoader.load(url);\n            break;\n          case \"repeatS\":\n            if (fieldValues[0] === false)\n              wrapS = ClampToEdgeWrapping;\n            break;\n          case \"repeatT\":\n            if (fieldValues[0] === false)\n              wrapT = ClampToEdgeWrapping;\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      if (texture) {\n        texture.wrapS = wrapS;\n        texture.wrapT = wrapT;\n      }\n      return texture;\n    }\n    function buildTextureTransformNode(node) {\n      const transformData = {\n        center: new Vector2(),\n        rotation: new Vector2(),\n        scale: new Vector2(),\n        translation: new Vector2()\n      };\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"center\":\n            transformData.center.set(fieldValues[0], fieldValues[1]);\n            break;\n          case \"rotation\":\n            transformData.rotation = fieldValues[0];\n            break;\n          case \"scale\":\n            transformData.scale.set(fieldValues[0], fieldValues[1]);\n            break;\n          case \"translation\":\n            transformData.translation.set(fieldValues[0], fieldValues[1]);\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      return transformData;\n    }\n    function buildGeometricNode(node) {\n      return node.fields[0].values;\n    }\n    function buildWorldInfoNode(node) {\n      const worldInfo = {};\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"title\":\n            worldInfo.title = fieldValues[0];\n            break;\n          case \"info\":\n            worldInfo.info = fieldValues;\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      return worldInfo;\n    }\n    function buildIndexedFaceSetNode(node) {\n      let color, coord, normal, texCoord;\n      let ccw = true, solid = true, creaseAngle = 0;\n      let colorIndex, coordIndex, normalIndex, texCoordIndex;\n      let colorPerVertex = true, normalPerVertex = true;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"color\":\n            const colorNode = fieldValues[0];\n            if (colorNode !== null) {\n              color = getNode(colorNode);\n            }\n            break;\n          case \"coord\":\n            const coordNode = fieldValues[0];\n            if (coordNode !== null) {\n              coord = getNode(coordNode);\n            }\n            break;\n          case \"normal\":\n            const normalNode = fieldValues[0];\n            if (normalNode !== null) {\n              normal = getNode(normalNode);\n            }\n            break;\n          case \"texCoord\":\n            const texCoordNode = fieldValues[0];\n            if (texCoordNode !== null) {\n              texCoord = getNode(texCoordNode);\n            }\n            break;\n          case \"ccw\":\n            ccw = fieldValues[0];\n            break;\n          case \"colorIndex\":\n            colorIndex = fieldValues;\n            break;\n          case \"colorPerVertex\":\n            colorPerVertex = fieldValues[0];\n            break;\n          case \"convex\":\n            break;\n          case \"coordIndex\":\n            coordIndex = fieldValues;\n            break;\n          case \"creaseAngle\":\n            creaseAngle = fieldValues[0];\n            break;\n          case \"normalIndex\":\n            normalIndex = fieldValues;\n            break;\n          case \"normalPerVertex\":\n            normalPerVertex = fieldValues[0];\n            break;\n          case \"solid\":\n            solid = fieldValues[0];\n            break;\n          case \"texCoordIndex\":\n            texCoordIndex = fieldValues;\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      if (coordIndex === void 0) {\n        console.warn(\"THREE.VRMLLoader: Missing coordIndex.\");\n        return new BufferGeometry();\n      }\n      const triangulatedCoordIndex = triangulateFaceIndex(coordIndex, ccw);\n      let colorAttribute;\n      let normalAttribute;\n      let uvAttribute;\n      if (color) {\n        if (colorPerVertex === true) {\n          if (colorIndex && colorIndex.length > 0) {\n            const triangulatedColorIndex = triangulateFaceIndex(colorIndex, ccw);\n            colorAttribute = computeAttributeFromIndexedData(triangulatedCoordIndex, triangulatedColorIndex, color, 3);\n          } else {\n            colorAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(color, 3));\n          }\n        } else {\n          if (colorIndex && colorIndex.length > 0) {\n            const flattenFaceColors = flattenData(color, colorIndex);\n            const triangulatedFaceColors = triangulateFaceData(flattenFaceColors, coordIndex);\n            colorAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceColors);\n          } else {\n            const triangulatedFaceColors = triangulateFaceData(color, coordIndex);\n            colorAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceColors);\n          }\n        }\n      }\n      if (normal) {\n        if (normalPerVertex === true) {\n          if (normalIndex && normalIndex.length > 0) {\n            const triangulatedNormalIndex = triangulateFaceIndex(normalIndex, ccw);\n            normalAttribute = computeAttributeFromIndexedData(\n              triangulatedCoordIndex,\n              triangulatedNormalIndex,\n              normal,\n              3\n            );\n          } else {\n            normalAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(normal, 3));\n          }\n        } else {\n          if (normalIndex && normalIndex.length > 0) {\n            const flattenFaceNormals = flattenData(normal, normalIndex);\n            const triangulatedFaceNormals = triangulateFaceData(flattenFaceNormals, coordIndex);\n            normalAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceNormals);\n          } else {\n            const triangulatedFaceNormals = triangulateFaceData(normal, coordIndex);\n            normalAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceNormals);\n          }\n        }\n      } else {\n        normalAttribute = computeNormalAttribute(triangulatedCoordIndex, coord, creaseAngle);\n      }\n      if (texCoord) {\n        if (texCoordIndex && texCoordIndex.length > 0) {\n          const triangulatedTexCoordIndex = triangulateFaceIndex(texCoordIndex, ccw);\n          uvAttribute = computeAttributeFromIndexedData(triangulatedCoordIndex, triangulatedTexCoordIndex, texCoord, 2);\n        } else {\n          uvAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(texCoord, 2));\n        }\n      }\n      const geometry = new BufferGeometry();\n      const positionAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(coord, 3));\n      geometry.setAttribute(\"position\", positionAttribute);\n      geometry.setAttribute(\"normal\", normalAttribute);\n      if (colorAttribute)\n        geometry.setAttribute(\"color\", colorAttribute);\n      if (uvAttribute)\n        geometry.setAttribute(\"uv\", uvAttribute);\n      geometry._solid = solid;\n      geometry._type = \"mesh\";\n      return geometry;\n    }\n    function buildIndexedLineSetNode(node) {\n      let color, coord;\n      let colorIndex, coordIndex;\n      let colorPerVertex = true;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"color\":\n            const colorNode = fieldValues[0];\n            if (colorNode !== null) {\n              color = getNode(colorNode);\n            }\n            break;\n          case \"coord\":\n            const coordNode = fieldValues[0];\n            if (coordNode !== null) {\n              coord = getNode(coordNode);\n            }\n            break;\n          case \"colorIndex\":\n            colorIndex = fieldValues;\n            break;\n          case \"colorPerVertex\":\n            colorPerVertex = fieldValues[0];\n            break;\n          case \"coordIndex\":\n            coordIndex = fieldValues;\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      let colorAttribute;\n      const expandedLineIndex = expandLineIndex(coordIndex);\n      if (color) {\n        if (colorPerVertex === true) {\n          if (colorIndex.length > 0) {\n            const expandedColorIndex = expandLineIndex(colorIndex);\n            colorAttribute = computeAttributeFromIndexedData(expandedLineIndex, expandedColorIndex, color, 3);\n          } else {\n            colorAttribute = toNonIndexedAttribute(expandedLineIndex, new Float32BufferAttribute(color, 3));\n          }\n        } else {\n          if (colorIndex.length > 0) {\n            const flattenLineColors = flattenData(color, colorIndex);\n            const expandedLineColors = expandLineData(flattenLineColors, coordIndex);\n            colorAttribute = computeAttributeFromLineData(expandedLineIndex, expandedLineColors);\n          } else {\n            const expandedLineColors = expandLineData(color, coordIndex);\n            colorAttribute = computeAttributeFromLineData(expandedLineIndex, expandedLineColors);\n          }\n        }\n      }\n      const geometry = new BufferGeometry();\n      const positionAttribute = toNonIndexedAttribute(expandedLineIndex, new Float32BufferAttribute(coord, 3));\n      geometry.setAttribute(\"position\", positionAttribute);\n      if (colorAttribute)\n        geometry.setAttribute(\"color\", colorAttribute);\n      geometry._type = \"line\";\n      return geometry;\n    }\n    function buildPointSetNode(node) {\n      let color, coord;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"color\":\n            const colorNode = fieldValues[0];\n            if (colorNode !== null) {\n              color = getNode(colorNode);\n            }\n            break;\n          case \"coord\":\n            const coordNode = fieldValues[0];\n            if (coordNode !== null) {\n              coord = getNode(coordNode);\n            }\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      const geometry = new BufferGeometry();\n      geometry.setAttribute(\"position\", new Float32BufferAttribute(coord, 3));\n      if (color)\n        geometry.setAttribute(\"color\", new Float32BufferAttribute(color, 3));\n      geometry._type = \"points\";\n      return geometry;\n    }\n    function buildBoxNode(node) {\n      const size = new Vector3(2, 2, 2);\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"size\":\n            size.x = fieldValues[0];\n            size.y = fieldValues[1];\n            size.z = fieldValues[2];\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      const geometry = new BoxGeometry(size.x, size.y, size.z);\n      return geometry;\n    }\n    function buildConeNode(node) {\n      let radius = 1, height = 2, openEnded = false;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"bottom\":\n            openEnded = !fieldValues[0];\n            break;\n          case \"bottomRadius\":\n            radius = fieldValues[0];\n            break;\n          case \"height\":\n            height = fieldValues[0];\n            break;\n          case \"side\":\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      const geometry = new ConeGeometry(radius, height, 16, 1, openEnded);\n      return geometry;\n    }\n    function buildCylinderNode(node) {\n      let radius = 1, height = 2;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"bottom\":\n            break;\n          case \"radius\":\n            radius = fieldValues[0];\n            break;\n          case \"height\":\n            height = fieldValues[0];\n            break;\n          case \"side\":\n            break;\n          case \"top\":\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      const geometry = new CylinderGeometry(radius, radius, height, 16, 1);\n      return geometry;\n    }\n    function buildSphereNode(node) {\n      let radius = 1;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"radius\":\n            radius = fieldValues[0];\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      const geometry = new SphereGeometry(radius, 16, 16);\n      return geometry;\n    }\n    function buildElevationGridNode(node) {\n      let color;\n      let normal;\n      let texCoord;\n      let height;\n      let colorPerVertex = true;\n      let normalPerVertex = true;\n      let solid = true;\n      let ccw = true;\n      let creaseAngle = 0;\n      let xDimension = 2;\n      let zDimension = 2;\n      let xSpacing = 1;\n      let zSpacing = 1;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"color\":\n            const colorNode = fieldValues[0];\n            if (colorNode !== null) {\n              color = getNode(colorNode);\n            }\n            break;\n          case \"normal\":\n            const normalNode = fieldValues[0];\n            if (normalNode !== null) {\n              normal = getNode(normalNode);\n            }\n            break;\n          case \"texCoord\":\n            const texCoordNode = fieldValues[0];\n            if (texCoordNode !== null) {\n              texCoord = getNode(texCoordNode);\n            }\n            break;\n          case \"height\":\n            height = fieldValues;\n            break;\n          case \"ccw\":\n            ccw = fieldValues[0];\n            break;\n          case \"colorPerVertex\":\n            colorPerVertex = fieldValues[0];\n            break;\n          case \"creaseAngle\":\n            creaseAngle = fieldValues[0];\n            break;\n          case \"normalPerVertex\":\n            normalPerVertex = fieldValues[0];\n            break;\n          case \"solid\":\n            solid = fieldValues[0];\n            break;\n          case \"xDimension\":\n            xDimension = fieldValues[0];\n            break;\n          case \"xSpacing\":\n            xSpacing = fieldValues[0];\n            break;\n          case \"zDimension\":\n            zDimension = fieldValues[0];\n            break;\n          case \"zSpacing\":\n            zSpacing = fieldValues[0];\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      const vertices = [];\n      const normals = [];\n      const colors = [];\n      const uvs = [];\n      for (let i = 0; i < zDimension; i++) {\n        for (let j = 0; j < xDimension; j++) {\n          const index = i * xDimension + j;\n          const x = xSpacing * i;\n          const y = height[index];\n          const z = zSpacing * j;\n          vertices.push(x, y, z);\n          if (color && colorPerVertex === true) {\n            const r = color[index * 3 + 0];\n            const g = color[index * 3 + 1];\n            const b = color[index * 3 + 2];\n            colors.push(r, g, b);\n          }\n          if (normal && normalPerVertex === true) {\n            const xn = normal[index * 3 + 0];\n            const yn = normal[index * 3 + 1];\n            const zn = normal[index * 3 + 2];\n            normals.push(xn, yn, zn);\n          }\n          if (texCoord) {\n            const s = texCoord[index * 2 + 0];\n            const t = texCoord[index * 2 + 1];\n            uvs.push(s, t);\n          } else {\n            uvs.push(i / (xDimension - 1), j / (zDimension - 1));\n          }\n        }\n      }\n      const indices = [];\n      for (let i = 0; i < xDimension - 1; i++) {\n        for (let j = 0; j < zDimension - 1; j++) {\n          const a = i + j * xDimension;\n          const b = i + (j + 1) * xDimension;\n          const c = i + 1 + (j + 1) * xDimension;\n          const d = i + 1 + j * xDimension;\n          if (ccw === true) {\n            indices.push(a, c, b);\n            indices.push(c, a, d);\n          } else {\n            indices.push(a, b, c);\n            indices.push(c, d, a);\n          }\n        }\n      }\n      const positionAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(vertices, 3));\n      const uvAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(uvs, 2));\n      let colorAttribute;\n      let normalAttribute;\n      if (color) {\n        if (colorPerVertex === false) {\n          for (let i = 0; i < xDimension - 1; i++) {\n            for (let j = 0; j < zDimension - 1; j++) {\n              const index = i + j * (xDimension - 1);\n              const r = color[index * 3 + 0];\n              const g = color[index * 3 + 1];\n              const b = color[index * 3 + 2];\n              colors.push(r, g, b);\n              colors.push(r, g, b);\n              colors.push(r, g, b);\n              colors.push(r, g, b);\n              colors.push(r, g, b);\n              colors.push(r, g, b);\n            }\n          }\n          colorAttribute = new Float32BufferAttribute(colors, 3);\n        } else {\n          colorAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(colors, 3));\n        }\n      }\n      if (normal) {\n        if (normalPerVertex === false) {\n          for (let i = 0; i < xDimension - 1; i++) {\n            for (let j = 0; j < zDimension - 1; j++) {\n              const index = i + j * (xDimension - 1);\n              const xn = normal[index * 3 + 0];\n              const yn = normal[index * 3 + 1];\n              const zn = normal[index * 3 + 2];\n              normals.push(xn, yn, zn);\n              normals.push(xn, yn, zn);\n              normals.push(xn, yn, zn);\n              normals.push(xn, yn, zn);\n              normals.push(xn, yn, zn);\n              normals.push(xn, yn, zn);\n            }\n          }\n          normalAttribute = new Float32BufferAttribute(normals, 3);\n        } else {\n          normalAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(normals, 3));\n        }\n      } else {\n        normalAttribute = computeNormalAttribute(indices, vertices, creaseAngle);\n      }\n      const geometry = new BufferGeometry();\n      geometry.setAttribute(\"position\", positionAttribute);\n      geometry.setAttribute(\"normal\", normalAttribute);\n      geometry.setAttribute(\"uv\", uvAttribute);\n      if (colorAttribute)\n        geometry.setAttribute(\"color\", colorAttribute);\n      geometry._solid = solid;\n      geometry._type = \"mesh\";\n      return geometry;\n    }\n    function buildExtrusionNode(node) {\n      let crossSection = [1, 1, 1, -1, -1, -1, -1, 1, 1, 1];\n      let spine = [0, 0, 0, 0, 1, 0];\n      let scale;\n      let orientation;\n      let beginCap = true;\n      let ccw = true;\n      let creaseAngle = 0;\n      let endCap = true;\n      let solid = true;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"beginCap\":\n            beginCap = fieldValues[0];\n            break;\n          case \"ccw\":\n            ccw = fieldValues[0];\n            break;\n          case \"convex\":\n            break;\n          case \"creaseAngle\":\n            creaseAngle = fieldValues[0];\n            break;\n          case \"crossSection\":\n            crossSection = fieldValues;\n            break;\n          case \"endCap\":\n            endCap = fieldValues[0];\n            break;\n          case \"orientation\":\n            orientation = fieldValues;\n            break;\n          case \"scale\":\n            scale = fieldValues;\n            break;\n          case \"solid\":\n            solid = fieldValues[0];\n            break;\n          case \"spine\":\n            spine = fieldValues;\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      const crossSectionClosed = crossSection[0] === crossSection[crossSection.length - 2] && crossSection[1] === crossSection[crossSection.length - 1];\n      const vertices = [];\n      const spineVector = new Vector3();\n      const scaling = new Vector3();\n      const axis = new Vector3();\n      const vertex = new Vector3();\n      const quaternion = new Quaternion();\n      for (let i = 0, j = 0, o = 0, il = spine.length; i < il; i += 3, j += 2, o += 4) {\n        spineVector.fromArray(spine, i);\n        scaling.x = scale ? scale[j + 0] : 1;\n        scaling.y = 1;\n        scaling.z = scale ? scale[j + 1] : 1;\n        axis.x = orientation ? orientation[o + 0] : 0;\n        axis.y = orientation ? orientation[o + 1] : 0;\n        axis.z = orientation ? orientation[o + 2] : 1;\n        const angle = orientation ? orientation[o + 3] : 0;\n        for (let k = 0, kl = crossSection.length; k < kl; k += 2) {\n          vertex.x = crossSection[k + 0];\n          vertex.y = 0;\n          vertex.z = crossSection[k + 1];\n          vertex.multiply(scaling);\n          quaternion.setFromAxisAngle(axis, angle);\n          vertex.applyQuaternion(quaternion);\n          vertex.add(spineVector);\n          vertices.push(vertex.x, vertex.y, vertex.z);\n        }\n      }\n      const indices = [];\n      const spineCount = spine.length / 3;\n      const crossSectionCount = crossSection.length / 2;\n      for (let i = 0; i < spineCount - 1; i++) {\n        for (let j = 0; j < crossSectionCount - 1; j++) {\n          const a = j + i * crossSectionCount;\n          let b = j + 1 + i * crossSectionCount;\n          const c = j + (i + 1) * crossSectionCount;\n          let d = j + 1 + (i + 1) * crossSectionCount;\n          if (j === crossSectionCount - 2 && crossSectionClosed === true) {\n            b = i * crossSectionCount;\n            d = (i + 1) * crossSectionCount;\n          }\n          if (ccw === true) {\n            indices.push(a, b, c);\n            indices.push(c, b, d);\n          } else {\n            indices.push(a, c, b);\n            indices.push(c, d, b);\n          }\n        }\n      }\n      if (beginCap === true || endCap === true) {\n        const contour = [];\n        for (let i = 0, l = crossSection.length; i < l; i += 2) {\n          contour.push(new Vector2(crossSection[i], crossSection[i + 1]));\n        }\n        const faces = ShapeUtils.triangulateShape(contour, []);\n        const capIndices = [];\n        for (let i = 0, l = faces.length; i < l; i++) {\n          const face = faces[i];\n          capIndices.push(face[0], face[1], face[2]);\n        }\n        if (beginCap === true) {\n          for (let i = 0, l = capIndices.length; i < l; i += 3) {\n            if (ccw === true) {\n              indices.push(capIndices[i + 0], capIndices[i + 1], capIndices[i + 2]);\n            } else {\n              indices.push(capIndices[i + 0], capIndices[i + 2], capIndices[i + 1]);\n            }\n          }\n        }\n        if (endCap === true) {\n          const indexOffset = crossSectionCount * (spineCount - 1);\n          for (let i = 0, l = capIndices.length; i < l; i += 3) {\n            if (ccw === true) {\n              indices.push(\n                indexOffset + capIndices[i + 0],\n                indexOffset + capIndices[i + 2],\n                indexOffset + capIndices[i + 1]\n              );\n            } else {\n              indices.push(\n                indexOffset + capIndices[i + 0],\n                indexOffset + capIndices[i + 1],\n                indexOffset + capIndices[i + 2]\n              );\n            }\n          }\n        }\n      }\n      const positionAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(vertices, 3));\n      const normalAttribute = computeNormalAttribute(indices, vertices, creaseAngle);\n      const geometry = new BufferGeometry();\n      geometry.setAttribute(\"position\", positionAttribute);\n      geometry.setAttribute(\"normal\", normalAttribute);\n      geometry._solid = solid;\n      geometry._type = \"mesh\";\n      return geometry;\n    }\n    function resolveUSE(identifier) {\n      const node = nodeMap[identifier];\n      const build = getNode(node);\n      return build.isObject3D || build.isMaterial ? build.clone() : build;\n    }\n    function parseFieldChildren(children, owner) {\n      for (let i = 0, l = children.length; i < l; i++) {\n        const object = getNode(children[i]);\n        if (object instanceof Object3D)\n          owner.add(object);\n      }\n    }\n    function triangulateFaceIndex(index, ccw) {\n      const indices = [];\n      let start = 0;\n      for (let i = 0, l = index.length; i < l; i++) {\n        const i1 = index[start];\n        const i2 = index[i + (ccw ? 1 : 2)];\n        const i3 = index[i + (ccw ? 2 : 1)];\n        indices.push(i1, i2, i3);\n        if (index[i + 3] === -1 || i + 3 >= l) {\n          i += 3;\n          start = i + 1;\n        }\n      }\n      return indices;\n    }\n    function triangulateFaceData(data2, index) {\n      const triangulatedData = [];\n      let start = 0;\n      for (let i = 0, l = index.length; i < l; i++) {\n        const stride = start * 3;\n        const x = data2[stride];\n        const y = data2[stride + 1];\n        const z = data2[stride + 2];\n        triangulatedData.push(x, y, z);\n        if (index[i + 3] === -1 || i + 3 >= l) {\n          i += 3;\n          start++;\n        }\n      }\n      return triangulatedData;\n    }\n    function flattenData(data2, index) {\n      const flattenData2 = [];\n      for (let i = 0, l = index.length; i < l; i++) {\n        const i1 = index[i];\n        const stride = i1 * 3;\n        const x = data2[stride];\n        const y = data2[stride + 1];\n        const z = data2[stride + 2];\n        flattenData2.push(x, y, z);\n      }\n      return flattenData2;\n    }\n    function expandLineIndex(index) {\n      const indices = [];\n      for (let i = 0, l = index.length; i < l; i++) {\n        const i1 = index[i];\n        const i2 = index[i + 1];\n        indices.push(i1, i2);\n        if (index[i + 2] === -1 || i + 2 >= l) {\n          i += 2;\n        }\n      }\n      return indices;\n    }\n    function expandLineData(data2, index) {\n      const triangulatedData = [];\n      let start = 0;\n      for (let i = 0, l = index.length; i < l; i++) {\n        const stride = start * 3;\n        const x = data2[stride];\n        const y = data2[stride + 1];\n        const z = data2[stride + 2];\n        triangulatedData.push(x, y, z);\n        if (index[i + 2] === -1 || i + 2 >= l) {\n          i += 2;\n          start++;\n        }\n      }\n      return triangulatedData;\n    }\n    const vA = new Vector3();\n    const vB = new Vector3();\n    const vC = new Vector3();\n    const uvA = new Vector2();\n    const uvB = new Vector2();\n    const uvC = new Vector2();\n    function computeAttributeFromIndexedData(coordIndex, index, data2, itemSize) {\n      const array = [];\n      for (let i = 0, l = coordIndex.length; i < l; i += 3) {\n        const a = index[i];\n        const b = index[i + 1];\n        const c = index[i + 2];\n        if (itemSize === 2) {\n          uvA.fromArray(data2, a * itemSize);\n          uvB.fromArray(data2, b * itemSize);\n          uvC.fromArray(data2, c * itemSize);\n          array.push(uvA.x, uvA.y);\n          array.push(uvB.x, uvB.y);\n          array.push(uvC.x, uvC.y);\n        } else {\n          vA.fromArray(data2, a * itemSize);\n          vB.fromArray(data2, b * itemSize);\n          vC.fromArray(data2, c * itemSize);\n          array.push(vA.x, vA.y, vA.z);\n          array.push(vB.x, vB.y, vB.z);\n          array.push(vC.x, vC.y, vC.z);\n        }\n      }\n      return new Float32BufferAttribute(array, itemSize);\n    }\n    function computeAttributeFromFaceData(index, faceData) {\n      const array = [];\n      for (let i = 0, j = 0, l = index.length; i < l; i += 3, j++) {\n        vA.fromArray(faceData, j * 3);\n        array.push(vA.x, vA.y, vA.z);\n        array.push(vA.x, vA.y, vA.z);\n        array.push(vA.x, vA.y, vA.z);\n      }\n      return new Float32BufferAttribute(array, 3);\n    }\n    function computeAttributeFromLineData(index, lineData) {\n      const array = [];\n      for (let i = 0, j = 0, l = index.length; i < l; i += 2, j++) {\n        vA.fromArray(lineData, j * 3);\n        array.push(vA.x, vA.y, vA.z);\n        array.push(vA.x, vA.y, vA.z);\n      }\n      return new Float32BufferAttribute(array, 3);\n    }\n    function toNonIndexedAttribute(indices, attribute) {\n      const array = attribute.array;\n      const itemSize = attribute.itemSize;\n      const array2 = new array.constructor(indices.length * itemSize);\n      let index = 0, index2 = 0;\n      for (let i = 0, l = indices.length; i < l; i++) {\n        index = indices[i] * itemSize;\n        for (let j = 0; j < itemSize; j++) {\n          array2[index2++] = array[index++];\n        }\n      }\n      return new Float32BufferAttribute(array2, itemSize);\n    }\n    const ab = new Vector3();\n    const cb = new Vector3();\n    function computeNormalAttribute(index, coord, creaseAngle) {\n      const faces = [];\n      const vertexNormals = {};\n      for (let i = 0, l = index.length; i < l; i += 3) {\n        const a = index[i];\n        const b = index[i + 1];\n        const c = index[i + 2];\n        const face = new Face(a, b, c);\n        vA.fromArray(coord, a * 3);\n        vB.fromArray(coord, b * 3);\n        vC.fromArray(coord, c * 3);\n        cb.subVectors(vC, vB);\n        ab.subVectors(vA, vB);\n        cb.cross(ab);\n        cb.normalize();\n        face.normal.copy(cb);\n        if (vertexNormals[a] === void 0)\n          vertexNormals[a] = [];\n        if (vertexNormals[b] === void 0)\n          vertexNormals[b] = [];\n        if (vertexNormals[c] === void 0)\n          vertexNormals[c] = [];\n        vertexNormals[a].push(face.normal);\n        vertexNormals[b].push(face.normal);\n        vertexNormals[c].push(face.normal);\n        faces.push(face);\n      }\n      const normals = [];\n      for (let i = 0, l = faces.length; i < l; i++) {\n        const face = faces[i];\n        const nA = weightedNormal(vertexNormals[face.a], face.normal, creaseAngle);\n        const nB = weightedNormal(vertexNormals[face.b], face.normal, creaseAngle);\n        const nC = weightedNormal(vertexNormals[face.c], face.normal, creaseAngle);\n        vA.fromArray(coord, face.a * 3);\n        vB.fromArray(coord, face.b * 3);\n        vC.fromArray(coord, face.c * 3);\n        normals.push(nA.x, nA.y, nA.z);\n        normals.push(nB.x, nB.y, nB.z);\n        normals.push(nC.x, nC.y, nC.z);\n      }\n      return new Float32BufferAttribute(normals, 3);\n    }\n    function weightedNormal(normals, vector, creaseAngle) {\n      const normal = new Vector3();\n      if (creaseAngle === 0) {\n        normal.copy(vector);\n      } else {\n        for (let i = 0, l = normals.length; i < l; i++) {\n          if (normals[i].angleTo(vector) < creaseAngle) {\n            normal.add(normals[i]);\n          }\n        }\n      }\n      return normal.normalize();\n    }\n    function toColorArray(colors) {\n      const array = [];\n      for (let i = 0, l = colors.length; i < l; i += 3) {\n        array.push(new Color(colors[i], colors[i + 1], colors[i + 2]));\n      }\n      return array;\n    }\n    function paintFaces(geometry, radius, angles, colors, topDown) {\n      const thresholds = [];\n      const startAngle = topDown === true ? 0 : Math.PI;\n      for (let i = 0, l = colors.length; i < l; i++) {\n        let angle = i === 0 ? 0 : angles[i - 1];\n        angle = topDown === true ? angle : startAngle - angle;\n        const point = new Vector3();\n        point.setFromSphericalCoords(radius, angle, 0);\n        thresholds.push(point);\n      }\n      const indices = geometry.index;\n      const positionAttribute = geometry.attributes.position;\n      const colorAttribute = new BufferAttribute(new Float32Array(geometry.attributes.position.count * 3), 3);\n      const position = new Vector3();\n      const color = new Color();\n      for (let i = 0; i < indices.count; i++) {\n        const index = indices.getX(i);\n        position.fromBufferAttribute(positionAttribute, index);\n        let thresholdIndexA, thresholdIndexB;\n        let t = 1;\n        for (let j = 1; j < thresholds.length; j++) {\n          thresholdIndexA = j - 1;\n          thresholdIndexB = j;\n          const thresholdA = thresholds[thresholdIndexA];\n          const thresholdB = thresholds[thresholdIndexB];\n          if (topDown === true) {\n            if (position.y <= thresholdA.y && position.y > thresholdB.y) {\n              t = Math.abs(thresholdA.y - position.y) / Math.abs(thresholdA.y - thresholdB.y);\n              break;\n            }\n          } else {\n            if (position.y >= thresholdA.y && position.y < thresholdB.y) {\n              t = Math.abs(thresholdA.y - position.y) / Math.abs(thresholdA.y - thresholdB.y);\n              break;\n            }\n          }\n        }\n        const colorA = colors[thresholdIndexA];\n        const colorB = colors[thresholdIndexB];\n        color.copy(colorA).lerp(colorB, t);\n        colorAttribute.setXYZ(index, color.r, color.g, color.b);\n      }\n      geometry.setAttribute(\"color\", colorAttribute);\n    }\n    const textureLoader = new TextureLoader(this.manager);\n    textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n    if (data.indexOf(\"#VRML V2.0\") === -1) {\n      throw Error(\"THREE.VRMLLexer: Version of VRML asset not supported.\");\n    }\n    const tree = generateVRMLTree(data);\n    const scene = parseTree(tree);\n    return scene;\n  }\n}\nclass VRMLLexer {\n  constructor(tokens) {\n    this.lexer = new Lexer(tokens);\n  }\n  lex(inputText) {\n    const lexingResult = this.lexer.tokenize(inputText);\n    if (lexingResult.errors.length > 0) {\n      console.error(lexingResult.errors);\n      throw Error(\"THREE.VRMLLexer: Lexing errors detected.\");\n    }\n    return lexingResult;\n  }\n}\nclass VRMLParser extends CstParser {\n  constructor(tokenVocabulary) {\n    super(tokenVocabulary);\n    const $ = this;\n    const Version = tokenVocabulary[\"Version\"];\n    const LCurly = tokenVocabulary[\"LCurly\"];\n    const RCurly = tokenVocabulary[\"RCurly\"];\n    const LSquare = tokenVocabulary[\"LSquare\"];\n    const RSquare = tokenVocabulary[\"RSquare\"];\n    const Identifier = tokenVocabulary[\"Identifier\"];\n    const RouteIdentifier = tokenVocabulary[\"RouteIdentifier\"];\n    const StringLiteral = tokenVocabulary[\"StringLiteral\"];\n    const HexLiteral = tokenVocabulary[\"HexLiteral\"];\n    const NumberLiteral = tokenVocabulary[\"NumberLiteral\"];\n    const TrueLiteral = tokenVocabulary[\"TrueLiteral\"];\n    const FalseLiteral = tokenVocabulary[\"FalseLiteral\"];\n    const NullLiteral = tokenVocabulary[\"NullLiteral\"];\n    const DEF = tokenVocabulary[\"DEF\"];\n    const USE = tokenVocabulary[\"USE\"];\n    const ROUTE = tokenVocabulary[\"ROUTE\"];\n    const TO = tokenVocabulary[\"TO\"];\n    const NodeName = tokenVocabulary[\"NodeName\"];\n    $.RULE(\"vrml\", function() {\n      $.SUBRULE($.version);\n      $.AT_LEAST_ONE(function() {\n        $.SUBRULE($.node);\n      });\n      $.MANY(function() {\n        $.SUBRULE($.route);\n      });\n    });\n    $.RULE(\"version\", function() {\n      $.CONSUME(Version);\n    });\n    $.RULE(\"node\", function() {\n      $.OPTION(function() {\n        $.SUBRULE($.def);\n      });\n      $.CONSUME(NodeName);\n      $.CONSUME(LCurly);\n      $.MANY(function() {\n        $.SUBRULE($.field);\n      });\n      $.CONSUME(RCurly);\n    });\n    $.RULE(\"field\", function() {\n      $.CONSUME(Identifier);\n      $.OR2([\n        {\n          ALT: function() {\n            $.SUBRULE($.singleFieldValue);\n          }\n        },\n        {\n          ALT: function() {\n            $.SUBRULE($.multiFieldValue);\n          }\n        }\n      ]);\n    });\n    $.RULE(\"def\", function() {\n      $.CONSUME(DEF);\n      $.OR([\n        {\n          ALT: function() {\n            $.CONSUME(Identifier);\n          }\n        },\n        {\n          ALT: function() {\n            $.CONSUME(NodeName);\n          }\n        }\n      ]);\n    });\n    $.RULE(\"use\", function() {\n      $.CONSUME(USE);\n      $.OR([\n        {\n          ALT: function() {\n            $.CONSUME(Identifier);\n          }\n        },\n        {\n          ALT: function() {\n            $.CONSUME(NodeName);\n          }\n        }\n      ]);\n    });\n    $.RULE(\"singleFieldValue\", function() {\n      $.AT_LEAST_ONE(function() {\n        $.OR([\n          {\n            ALT: function() {\n              $.SUBRULE($.node);\n            }\n          },\n          {\n            ALT: function() {\n              $.SUBRULE($.use);\n            }\n          },\n          {\n            ALT: function() {\n              $.CONSUME(StringLiteral);\n            }\n          },\n          {\n            ALT: function() {\n              $.CONSUME(HexLiteral);\n            }\n          },\n          {\n            ALT: function() {\n              $.CONSUME(NumberLiteral);\n            }\n          },\n          {\n            ALT: function() {\n              $.CONSUME(TrueLiteral);\n            }\n          },\n          {\n            ALT: function() {\n              $.CONSUME(FalseLiteral);\n            }\n          },\n          {\n            ALT: function() {\n              $.CONSUME(NullLiteral);\n            }\n          }\n        ]);\n      });\n    });\n    $.RULE(\"multiFieldValue\", function() {\n      $.CONSUME(LSquare);\n      $.MANY(function() {\n        $.OR([\n          {\n            ALT: function() {\n              $.SUBRULE($.node);\n            }\n          },\n          {\n            ALT: function() {\n              $.SUBRULE($.use);\n            }\n          },\n          {\n            ALT: function() {\n              $.CONSUME(StringLiteral);\n            }\n          },\n          {\n            ALT: function() {\n              $.CONSUME(HexLiteral);\n            }\n          },\n          {\n            ALT: function() {\n              $.CONSUME(NumberLiteral);\n            }\n          },\n          {\n            ALT: function() {\n              $.CONSUME(NullLiteral);\n            }\n          }\n        ]);\n      });\n      $.CONSUME(RSquare);\n    });\n    $.RULE(\"route\", function() {\n      $.CONSUME(ROUTE);\n      $.CONSUME(RouteIdentifier);\n      $.CONSUME(TO);\n      $.CONSUME2(RouteIdentifier);\n    });\n    this.performSelfAnalysis();\n  }\n}\nclass Face {\n  constructor(a, b, c) {\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.normal = new Vector3();\n  }\n}\nconst TEXTURE_TYPE = {\n  INTENSITY: 1,\n  INTENSITY_ALPHA: 2,\n  RGB: 3,\n  RGBA: 4\n};\nexport {\n  VRMLLoader\n};\n"]},"metadata":{},"sourceType":"module"}