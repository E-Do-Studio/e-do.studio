{"ast":null,"code":"var __defProp = Object.defineProperty;\n\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\n\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n\n  return value;\n};\n\nimport { Mesh, PerspectiveCamera, Color, Plane, Vector3, Matrix4, Vector4, WebGLRenderTarget, HalfFloatType, ShaderMaterial, UniformsUtils, NoToneMapping } from \"three\";\n\nconst _Reflector = class extends Mesh {\n  constructor(geometry, options = {}) {\n    super(geometry);\n    this.isReflector = true;\n    this.type = \"Reflector\";\n    this.camera = new PerspectiveCamera();\n    const scope = this;\n    const color = options.color !== void 0 ? new Color(options.color) : new Color(8355711);\n    const textureWidth = options.textureWidth || 512;\n    const textureHeight = options.textureHeight || 512;\n    const clipBias = options.clipBias || 0;\n    const shader = options.shader || _Reflector.ReflectorShader;\n    const multisample = options.multisample !== void 0 ? options.multisample : 4;\n    const reflectorPlane = new Plane();\n    const normal = new Vector3();\n    const reflectorWorldPosition = new Vector3();\n    const cameraWorldPosition = new Vector3();\n    const rotationMatrix = new Matrix4();\n    const lookAtPosition = new Vector3(0, 0, -1);\n    const clipPlane = new Vector4();\n    const view = new Vector3();\n    const target = new Vector3();\n    const q = new Vector4();\n    const textureMatrix = new Matrix4();\n    const virtualCamera = this.camera;\n    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, {\n      samples: multisample,\n      type: HalfFloatType\n    });\n    const material = new ShaderMaterial({\n      uniforms: UniformsUtils.clone(shader.uniforms),\n      fragmentShader: shader.fragmentShader,\n      vertexShader: shader.vertexShader\n    });\n    material.uniforms[\"tDiffuse\"].value = renderTarget.texture;\n    material.uniforms[\"color\"].value = color;\n    material.uniforms[\"textureMatrix\"].value = textureMatrix;\n    this.material = material;\n\n    this.onBeforeRender = function (renderer, scene, camera) {\n      reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n      rotationMatrix.extractRotation(scope.matrixWorld);\n      normal.set(0, 0, 1);\n      normal.applyMatrix4(rotationMatrix);\n      view.subVectors(reflectorWorldPosition, cameraWorldPosition);\n      if (view.dot(normal) > 0) return;\n      view.reflect(normal).negate();\n      view.add(reflectorWorldPosition);\n      rotationMatrix.extractRotation(camera.matrixWorld);\n      lookAtPosition.set(0, 0, -1);\n      lookAtPosition.applyMatrix4(rotationMatrix);\n      lookAtPosition.add(cameraWorldPosition);\n      target.subVectors(reflectorWorldPosition, lookAtPosition);\n      target.reflect(normal).negate();\n      target.add(reflectorWorldPosition);\n      virtualCamera.position.copy(view);\n      virtualCamera.up.set(0, 1, 0);\n      virtualCamera.up.applyMatrix4(rotationMatrix);\n      virtualCamera.up.reflect(normal);\n      virtualCamera.lookAt(target);\n      virtualCamera.far = camera.far;\n      virtualCamera.updateMatrixWorld();\n      virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\n      textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);\n      textureMatrix.multiply(virtualCamera.projectionMatrix);\n      textureMatrix.multiply(virtualCamera.matrixWorldInverse);\n      textureMatrix.multiply(scope.matrixWorld);\n      reflectorPlane.setFromNormalAndCoplanarPoint(normal, reflectorWorldPosition);\n      reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\n      clipPlane.set(reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant);\n      const projectionMatrix = virtualCamera.projectionMatrix;\n      q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n      q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n      q.z = -1;\n      q.w = (1 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];\n      clipPlane.multiplyScalar(2 / clipPlane.dot(q));\n      projectionMatrix.elements[2] = clipPlane.x;\n      projectionMatrix.elements[6] = clipPlane.y;\n      projectionMatrix.elements[10] = clipPlane.z + 1 - clipBias;\n      projectionMatrix.elements[14] = clipPlane.w;\n      scope.visible = false;\n      const currentRenderTarget = renderer.getRenderTarget();\n      const currentXrEnabled = renderer.xr.enabled;\n      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n      const currentToneMapping = renderer.toneMapping;\n      let isSRGB = false;\n      if (\"outputColorSpace\" in renderer) isSRGB = renderer.outputColorSpace === \"srgb\";else isSRGB = renderer.outputEncoding === 3001;\n      renderer.xr.enabled = false;\n      renderer.shadowMap.autoUpdate = false;\n      if (\"outputColorSpace\" in renderer) renderer.outputColorSpace = \"linear-srgb\";else renderer.outputEncoding = 3e3;\n      renderer.toneMapping = NoToneMapping;\n      renderer.setRenderTarget(renderTarget);\n      renderer.state.buffers.depth.setMask(true);\n      if (renderer.autoClear === false) renderer.clear();\n      renderer.render(scene, virtualCamera);\n      renderer.xr.enabled = currentXrEnabled;\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n      renderer.toneMapping = currentToneMapping;\n      if (\"outputColorSpace\" in renderer) renderer.outputColorSpace = isSRGB ? \"srgb\" : \"srgb-linear\";else renderer.outputEncoding = isSRGB ? 3001 : 3e3;\n      renderer.setRenderTarget(currentRenderTarget);\n      const viewport = camera.viewport;\n\n      if (viewport !== void 0) {\n        renderer.state.viewport(viewport);\n      }\n\n      scope.visible = true;\n    };\n\n    this.getRenderTarget = function () {\n      return renderTarget;\n    };\n\n    this.dispose = function () {\n      renderTarget.dispose();\n      scope.material.dispose();\n    };\n  }\n\n};\n\nlet Reflector = _Reflector;\n\n__publicField(Reflector, \"ReflectorShader\", {\n  uniforms: {\n    color: {\n      value: null\n    },\n    tDiffuse: {\n      value: null\n    },\n    textureMatrix: {\n      value: null\n    }\n  },\n  vertexShader:\n  /* glsl */\n  `\n\t\tuniform mat4 textureMatrix;\n\t\tvarying vec4 vUv;\n\n\t\t#include <common>\n\t\t#include <logdepthbuf_pars_vertex>\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t#include <logdepthbuf_vertex>\n\n\t\t}`,\n  fragmentShader:\n  /* glsl */\n  `\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tvarying vec4 vUv;\n\n\t\t#include <logdepthbuf_pars_fragment>\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <logdepthbuf_fragment>\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\n\t\t}`\n});\n\nexport { Reflector };","map":{"version":3,"sources":["/Users/theodaguier/_workdir/dev/pro/e-do/E-Do-Studio/node_modules/three-stdlib/objects/Reflector.js"],"names":["__defProp","Object","defineProperty","__defNormalProp","obj","key","value","enumerable","configurable","writable","__publicField","Mesh","PerspectiveCamera","Color","Plane","Vector3","Matrix4","Vector4","WebGLRenderTarget","HalfFloatType","ShaderMaterial","UniformsUtils","NoToneMapping","_Reflector","constructor","geometry","options","isReflector","type","camera","scope","color","textureWidth","textureHeight","clipBias","shader","ReflectorShader","multisample","reflectorPlane","normal","reflectorWorldPosition","cameraWorldPosition","rotationMatrix","lookAtPosition","clipPlane","view","target","q","textureMatrix","virtualCamera","renderTarget","samples","material","uniforms","clone","fragmentShader","vertexShader","texture","onBeforeRender","renderer","scene","setFromMatrixPosition","matrixWorld","extractRotation","set","applyMatrix4","subVectors","dot","reflect","negate","add","position","copy","up","lookAt","far","updateMatrixWorld","projectionMatrix","multiply","matrixWorldInverse","setFromNormalAndCoplanarPoint","x","y","z","constant","Math","sign","elements","w","multiplyScalar","visible","currentRenderTarget","getRenderTarget","currentXrEnabled","xr","enabled","currentShadowAutoUpdate","shadowMap","autoUpdate","currentToneMapping","toneMapping","isSRGB","outputColorSpace","outputEncoding","setRenderTarget","state","buffers","depth","setMask","autoClear","clear","render","viewport","dispose","Reflector","tDiffuse"],"mappings":"AAAA,IAAIA,SAAS,GAAGC,MAAM,CAACC,cAAvB;;AACA,IAAIC,eAAe,GAAG,CAACC,GAAD,EAAMC,GAAN,EAAWC,KAAX,KAAqBD,GAAG,IAAID,GAAP,GAAaJ,SAAS,CAACI,GAAD,EAAMC,GAAN,EAAW;AAAEE,EAAAA,UAAU,EAAE,IAAd;AAAoBC,EAAAA,YAAY,EAAE,IAAlC;AAAwCC,EAAAA,QAAQ,EAAE,IAAlD;AAAwDH,EAAAA;AAAxD,CAAX,CAAtB,GAAoGF,GAAG,CAACC,GAAD,CAAH,GAAWC,KAA1J;;AACA,IAAII,aAAa,GAAG,CAACN,GAAD,EAAMC,GAAN,EAAWC,KAAX,KAAqB;AACvCH,EAAAA,eAAe,CAACC,GAAD,EAAM,OAAOC,GAAP,KAAe,QAAf,GAA0BA,GAAG,GAAG,EAAhC,GAAqCA,GAA3C,EAAgDC,KAAhD,CAAf;;AACA,SAAOA,KAAP;AACD,CAHD;;AAIA,SAASK,IAAT,EAAeC,iBAAf,EAAkCC,KAAlC,EAAyCC,KAAzC,EAAgDC,OAAhD,EAAyDC,OAAzD,EAAkEC,OAAlE,EAA2EC,iBAA3E,EAA8FC,aAA9F,EAA6GC,cAA7G,EAA6HC,aAA7H,EAA4IC,aAA5I,QAAiK,OAAjK;;AACA,MAAMC,UAAU,GAAG,cAAcZ,IAAd,CAAmB;AACpCa,EAAAA,WAAW,CAACC,QAAD,EAAWC,OAAO,GAAG,EAArB,EAAyB;AAClC,UAAMD,QAAN;AACA,SAAKE,WAAL,GAAmB,IAAnB;AACA,SAAKC,IAAL,GAAY,WAAZ;AACA,SAAKC,MAAL,GAAc,IAAIjB,iBAAJ,EAAd;AACA,UAAMkB,KAAK,GAAG,IAAd;AACA,UAAMC,KAAK,GAAGL,OAAO,CAACK,KAAR,KAAkB,KAAK,CAAvB,GAA2B,IAAIlB,KAAJ,CAAUa,OAAO,CAACK,KAAlB,CAA3B,GAAsD,IAAIlB,KAAJ,CAAU,OAAV,CAApE;AACA,UAAMmB,YAAY,GAAGN,OAAO,CAACM,YAAR,IAAwB,GAA7C;AACA,UAAMC,aAAa,GAAGP,OAAO,CAACO,aAAR,IAAyB,GAA/C;AACA,UAAMC,QAAQ,GAAGR,OAAO,CAACQ,QAAR,IAAoB,CAArC;AACA,UAAMC,MAAM,GAAGT,OAAO,CAACS,MAAR,IAAkBZ,UAAU,CAACa,eAA5C;AACA,UAAMC,WAAW,GAAGX,OAAO,CAACW,WAAR,KAAwB,KAAK,CAA7B,GAAiCX,OAAO,CAACW,WAAzC,GAAuD,CAA3E;AACA,UAAMC,cAAc,GAAG,IAAIxB,KAAJ,EAAvB;AACA,UAAMyB,MAAM,GAAG,IAAIxB,OAAJ,EAAf;AACA,UAAMyB,sBAAsB,GAAG,IAAIzB,OAAJ,EAA/B;AACA,UAAM0B,mBAAmB,GAAG,IAAI1B,OAAJ,EAA5B;AACA,UAAM2B,cAAc,GAAG,IAAI1B,OAAJ,EAAvB;AACA,UAAM2B,cAAc,GAAG,IAAI5B,OAAJ,CAAY,CAAZ,EAAe,CAAf,EAAkB,CAAC,CAAnB,CAAvB;AACA,UAAM6B,SAAS,GAAG,IAAI3B,OAAJ,EAAlB;AACA,UAAM4B,IAAI,GAAG,IAAI9B,OAAJ,EAAb;AACA,UAAM+B,MAAM,GAAG,IAAI/B,OAAJ,EAAf;AACA,UAAMgC,CAAC,GAAG,IAAI9B,OAAJ,EAAV;AACA,UAAM+B,aAAa,GAAG,IAAIhC,OAAJ,EAAtB;AACA,UAAMiC,aAAa,GAAG,KAAKpB,MAA3B;AACA,UAAMqB,YAAY,GAAG,IAAIhC,iBAAJ,CAAsBc,YAAtB,EAAoCC,aAApC,EAAmD;AACtEkB,MAAAA,OAAO,EAAEd,WAD6D;AAEtET,MAAAA,IAAI,EAAET;AAFgE,KAAnD,CAArB;AAIA,UAAMiC,QAAQ,GAAG,IAAIhC,cAAJ,CAAmB;AAClCiC,MAAAA,QAAQ,EAAEhC,aAAa,CAACiC,KAAd,CAAoBnB,MAAM,CAACkB,QAA3B,CADwB;AAElCE,MAAAA,cAAc,EAAEpB,MAAM,CAACoB,cAFW;AAGlCC,MAAAA,YAAY,EAAErB,MAAM,CAACqB;AAHa,KAAnB,CAAjB;AAKAJ,IAAAA,QAAQ,CAACC,QAAT,CAAkB,UAAlB,EAA8B/C,KAA9B,GAAsC4C,YAAY,CAACO,OAAnD;AACAL,IAAAA,QAAQ,CAACC,QAAT,CAAkB,OAAlB,EAA2B/C,KAA3B,GAAmCyB,KAAnC;AACAqB,IAAAA,QAAQ,CAACC,QAAT,CAAkB,eAAlB,EAAmC/C,KAAnC,GAA2C0C,aAA3C;AACA,SAAKI,QAAL,GAAgBA,QAAhB;;AACA,SAAKM,cAAL,GAAsB,UAASC,QAAT,EAAmBC,KAAnB,EAA0B/B,MAA1B,EAAkC;AACtDW,MAAAA,sBAAsB,CAACqB,qBAAvB,CAA6C/B,KAAK,CAACgC,WAAnD;AACArB,MAAAA,mBAAmB,CAACoB,qBAApB,CAA0ChC,MAAM,CAACiC,WAAjD;AACApB,MAAAA,cAAc,CAACqB,eAAf,CAA+BjC,KAAK,CAACgC,WAArC;AACAvB,MAAAA,MAAM,CAACyB,GAAP,CAAW,CAAX,EAAc,CAAd,EAAiB,CAAjB;AACAzB,MAAAA,MAAM,CAAC0B,YAAP,CAAoBvB,cAApB;AACAG,MAAAA,IAAI,CAACqB,UAAL,CAAgB1B,sBAAhB,EAAwCC,mBAAxC;AACA,UAAII,IAAI,CAACsB,GAAL,CAAS5B,MAAT,IAAmB,CAAvB,EACE;AACFM,MAAAA,IAAI,CAACuB,OAAL,CAAa7B,MAAb,EAAqB8B,MAArB;AACAxB,MAAAA,IAAI,CAACyB,GAAL,CAAS9B,sBAAT;AACAE,MAAAA,cAAc,CAACqB,eAAf,CAA+BlC,MAAM,CAACiC,WAAtC;AACAnB,MAAAA,cAAc,CAACqB,GAAf,CAAmB,CAAnB,EAAsB,CAAtB,EAAyB,CAAC,CAA1B;AACArB,MAAAA,cAAc,CAACsB,YAAf,CAA4BvB,cAA5B;AACAC,MAAAA,cAAc,CAAC2B,GAAf,CAAmB7B,mBAAnB;AACAK,MAAAA,MAAM,CAACoB,UAAP,CAAkB1B,sBAAlB,EAA0CG,cAA1C;AACAG,MAAAA,MAAM,CAACsB,OAAP,CAAe7B,MAAf,EAAuB8B,MAAvB;AACAvB,MAAAA,MAAM,CAACwB,GAAP,CAAW9B,sBAAX;AACAS,MAAAA,aAAa,CAACsB,QAAd,CAAuBC,IAAvB,CAA4B3B,IAA5B;AACAI,MAAAA,aAAa,CAACwB,EAAd,CAAiBT,GAAjB,CAAqB,CAArB,EAAwB,CAAxB,EAA2B,CAA3B;AACAf,MAAAA,aAAa,CAACwB,EAAd,CAAiBR,YAAjB,CAA8BvB,cAA9B;AACAO,MAAAA,aAAa,CAACwB,EAAd,CAAiBL,OAAjB,CAAyB7B,MAAzB;AACAU,MAAAA,aAAa,CAACyB,MAAd,CAAqB5B,MAArB;AACAG,MAAAA,aAAa,CAAC0B,GAAd,GAAoB9C,MAAM,CAAC8C,GAA3B;AACA1B,MAAAA,aAAa,CAAC2B,iBAAd;AACA3B,MAAAA,aAAa,CAAC4B,gBAAd,CAA+BL,IAA/B,CAAoC3C,MAAM,CAACgD,gBAA3C;AACA7B,MAAAA,aAAa,CAACgB,GAAd,CAAkB,GAAlB,EAAuB,CAAvB,EAA0B,CAA1B,EAA6B,GAA7B,EAAkC,CAAlC,EAAqC,GAArC,EAA0C,CAA1C,EAA6C,GAA7C,EAAkD,CAAlD,EAAqD,CAArD,EAAwD,GAAxD,EAA6D,GAA7D,EAAkE,CAAlE,EAAqE,CAArE,EAAwE,CAAxE,EAA2E,CAA3E;AACAhB,MAAAA,aAAa,CAAC8B,QAAd,CAAuB7B,aAAa,CAAC4B,gBAArC;AACA7B,MAAAA,aAAa,CAAC8B,QAAd,CAAuB7B,aAAa,CAAC8B,kBAArC;AACA/B,MAAAA,aAAa,CAAC8B,QAAd,CAAuBhD,KAAK,CAACgC,WAA7B;AACAxB,MAAAA,cAAc,CAAC0C,6BAAf,CAA6CzC,MAA7C,EAAqDC,sBAArD;AACAF,MAAAA,cAAc,CAAC2B,YAAf,CAA4BhB,aAAa,CAAC8B,kBAA1C;AACAnC,MAAAA,SAAS,CAACoB,GAAV,CAAc1B,cAAc,CAACC,MAAf,CAAsB0C,CAApC,EAAuC3C,cAAc,CAACC,MAAf,CAAsB2C,CAA7D,EAAgE5C,cAAc,CAACC,MAAf,CAAsB4C,CAAtF,EAAyF7C,cAAc,CAAC8C,QAAxG;AACA,YAAMP,gBAAgB,GAAG5B,aAAa,CAAC4B,gBAAvC;AACA9B,MAAAA,CAAC,CAACkC,CAAF,GAAM,CAACI,IAAI,CAACC,IAAL,CAAU1C,SAAS,CAACqC,CAApB,IAAyBJ,gBAAgB,CAACU,QAAjB,CAA0B,CAA1B,CAA1B,IAA0DV,gBAAgB,CAACU,QAAjB,CAA0B,CAA1B,CAAhE;AACAxC,MAAAA,CAAC,CAACmC,CAAF,GAAM,CAACG,IAAI,CAACC,IAAL,CAAU1C,SAAS,CAACsC,CAApB,IAAyBL,gBAAgB,CAACU,QAAjB,CAA0B,CAA1B,CAA1B,IAA0DV,gBAAgB,CAACU,QAAjB,CAA0B,CAA1B,CAAhE;AACAxC,MAAAA,CAAC,CAACoC,CAAF,GAAM,CAAC,CAAP;AACApC,MAAAA,CAAC,CAACyC,CAAF,GAAM,CAAC,IAAIX,gBAAgB,CAACU,QAAjB,CAA0B,EAA1B,CAAL,IAAsCV,gBAAgB,CAACU,QAAjB,CAA0B,EAA1B,CAA5C;AACA3C,MAAAA,SAAS,CAAC6C,cAAV,CAAyB,IAAI7C,SAAS,CAACuB,GAAV,CAAcpB,CAAd,CAA7B;AACA8B,MAAAA,gBAAgB,CAACU,QAAjB,CAA0B,CAA1B,IAA+B3C,SAAS,CAACqC,CAAzC;AACAJ,MAAAA,gBAAgB,CAACU,QAAjB,CAA0B,CAA1B,IAA+B3C,SAAS,CAACsC,CAAzC;AACAL,MAAAA,gBAAgB,CAACU,QAAjB,CAA0B,EAA1B,IAAgC3C,SAAS,CAACuC,CAAV,GAAc,CAAd,GAAkBjD,QAAlD;AACA2C,MAAAA,gBAAgB,CAACU,QAAjB,CAA0B,EAA1B,IAAgC3C,SAAS,CAAC4C,CAA1C;AACA1D,MAAAA,KAAK,CAAC4D,OAAN,GAAgB,KAAhB;AACA,YAAMC,mBAAmB,GAAGhC,QAAQ,CAACiC,eAAT,EAA5B;AACA,YAAMC,gBAAgB,GAAGlC,QAAQ,CAACmC,EAAT,CAAYC,OAArC;AACA,YAAMC,uBAAuB,GAAGrC,QAAQ,CAACsC,SAAT,CAAmBC,UAAnD;AACA,YAAMC,kBAAkB,GAAGxC,QAAQ,CAACyC,WAApC;AACA,UAAIC,MAAM,GAAG,KAAb;AACA,UAAI,sBAAsB1C,QAA1B,EACE0C,MAAM,GAAG1C,QAAQ,CAAC2C,gBAAT,KAA8B,MAAvC,CADF,KAGED,MAAM,GAAG1C,QAAQ,CAAC4C,cAAT,KAA4B,IAArC;AACF5C,MAAAA,QAAQ,CAACmC,EAAT,CAAYC,OAAZ,GAAsB,KAAtB;AACApC,MAAAA,QAAQ,CAACsC,SAAT,CAAmBC,UAAnB,GAAgC,KAAhC;AACA,UAAI,sBAAsBvC,QAA1B,EACEA,QAAQ,CAAC2C,gBAAT,GAA4B,aAA5B,CADF,KAGE3C,QAAQ,CAAC4C,cAAT,GAA0B,GAA1B;AACF5C,MAAAA,QAAQ,CAACyC,WAAT,GAAuB9E,aAAvB;AACAqC,MAAAA,QAAQ,CAAC6C,eAAT,CAAyBtD,YAAzB;AACAS,MAAAA,QAAQ,CAAC8C,KAAT,CAAeC,OAAf,CAAuBC,KAAvB,CAA6BC,OAA7B,CAAqC,IAArC;AACA,UAAIjD,QAAQ,CAACkD,SAAT,KAAuB,KAA3B,EACElD,QAAQ,CAACmD,KAAT;AACFnD,MAAAA,QAAQ,CAACoD,MAAT,CAAgBnD,KAAhB,EAAuBX,aAAvB;AACAU,MAAAA,QAAQ,CAACmC,EAAT,CAAYC,OAAZ,GAAsBF,gBAAtB;AACAlC,MAAAA,QAAQ,CAACsC,SAAT,CAAmBC,UAAnB,GAAgCF,uBAAhC;AACArC,MAAAA,QAAQ,CAACyC,WAAT,GAAuBD,kBAAvB;AACA,UAAI,sBAAsBxC,QAA1B,EACEA,QAAQ,CAAC2C,gBAAT,GAA4BD,MAAM,GAAG,MAAH,GAAY,aAA9C,CADF,KAGE1C,QAAQ,CAAC4C,cAAT,GAA0BF,MAAM,GAAG,IAAH,GAAU,GAA1C;AACF1C,MAAAA,QAAQ,CAAC6C,eAAT,CAAyBb,mBAAzB;AACA,YAAMqB,QAAQ,GAAGnF,MAAM,CAACmF,QAAxB;;AACA,UAAIA,QAAQ,KAAK,KAAK,CAAtB,EAAyB;AACvBrD,QAAAA,QAAQ,CAAC8C,KAAT,CAAeO,QAAf,CAAwBA,QAAxB;AACD;;AACDlF,MAAAA,KAAK,CAAC4D,OAAN,GAAgB,IAAhB;AACD,KA9ED;;AA+EA,SAAKE,eAAL,GAAuB,YAAW;AAChC,aAAO1C,YAAP;AACD,KAFD;;AAGA,SAAK+D,OAAL,GAAe,YAAW;AACxB/D,MAAAA,YAAY,CAAC+D,OAAb;AACAnF,MAAAA,KAAK,CAACsB,QAAN,CAAe6D,OAAf;AACD,KAHD;AAID;;AA5HmC,CAAtC;;AA8HA,IAAIC,SAAS,GAAG3F,UAAhB;;AACAb,aAAa,CAACwG,SAAD,EAAY,iBAAZ,EAA+B;AAC1C7D,EAAAA,QAAQ,EAAE;AACRtB,IAAAA,KAAK,EAAE;AACLzB,MAAAA,KAAK,EAAE;AADF,KADC;AAIR6G,IAAAA,QAAQ,EAAE;AACR7G,MAAAA,KAAK,EAAE;AADC,KAJF;AAOR0C,IAAAA,aAAa,EAAE;AACb1C,MAAAA,KAAK,EAAE;AADM;AAPP,GADgC;AAY1CkD,EAAAA,YAAY;AACV;AACC;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IA7B4C;AA+B1CD,EAAAA,cAAc;AACZ;AACC;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA9D4C,CAA/B,CAAb;;AAiEA,SACE2D,SADF","sourcesContent":["var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Mesh, PerspectiveCamera, Color, Plane, Vector3, Matrix4, Vector4, WebGLRenderTarget, HalfFloatType, ShaderMaterial, UniformsUtils, NoToneMapping } from \"three\";\nconst _Reflector = class extends Mesh {\n  constructor(geometry, options = {}) {\n    super(geometry);\n    this.isReflector = true;\n    this.type = \"Reflector\";\n    this.camera = new PerspectiveCamera();\n    const scope = this;\n    const color = options.color !== void 0 ? new Color(options.color) : new Color(8355711);\n    const textureWidth = options.textureWidth || 512;\n    const textureHeight = options.textureHeight || 512;\n    const clipBias = options.clipBias || 0;\n    const shader = options.shader || _Reflector.ReflectorShader;\n    const multisample = options.multisample !== void 0 ? options.multisample : 4;\n    const reflectorPlane = new Plane();\n    const normal = new Vector3();\n    const reflectorWorldPosition = new Vector3();\n    const cameraWorldPosition = new Vector3();\n    const rotationMatrix = new Matrix4();\n    const lookAtPosition = new Vector3(0, 0, -1);\n    const clipPlane = new Vector4();\n    const view = new Vector3();\n    const target = new Vector3();\n    const q = new Vector4();\n    const textureMatrix = new Matrix4();\n    const virtualCamera = this.camera;\n    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, {\n      samples: multisample,\n      type: HalfFloatType\n    });\n    const material = new ShaderMaterial({\n      uniforms: UniformsUtils.clone(shader.uniforms),\n      fragmentShader: shader.fragmentShader,\n      vertexShader: shader.vertexShader\n    });\n    material.uniforms[\"tDiffuse\"].value = renderTarget.texture;\n    material.uniforms[\"color\"].value = color;\n    material.uniforms[\"textureMatrix\"].value = textureMatrix;\n    this.material = material;\n    this.onBeforeRender = function(renderer, scene, camera) {\n      reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n      rotationMatrix.extractRotation(scope.matrixWorld);\n      normal.set(0, 0, 1);\n      normal.applyMatrix4(rotationMatrix);\n      view.subVectors(reflectorWorldPosition, cameraWorldPosition);\n      if (view.dot(normal) > 0)\n        return;\n      view.reflect(normal).negate();\n      view.add(reflectorWorldPosition);\n      rotationMatrix.extractRotation(camera.matrixWorld);\n      lookAtPosition.set(0, 0, -1);\n      lookAtPosition.applyMatrix4(rotationMatrix);\n      lookAtPosition.add(cameraWorldPosition);\n      target.subVectors(reflectorWorldPosition, lookAtPosition);\n      target.reflect(normal).negate();\n      target.add(reflectorWorldPosition);\n      virtualCamera.position.copy(view);\n      virtualCamera.up.set(0, 1, 0);\n      virtualCamera.up.applyMatrix4(rotationMatrix);\n      virtualCamera.up.reflect(normal);\n      virtualCamera.lookAt(target);\n      virtualCamera.far = camera.far;\n      virtualCamera.updateMatrixWorld();\n      virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\n      textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);\n      textureMatrix.multiply(virtualCamera.projectionMatrix);\n      textureMatrix.multiply(virtualCamera.matrixWorldInverse);\n      textureMatrix.multiply(scope.matrixWorld);\n      reflectorPlane.setFromNormalAndCoplanarPoint(normal, reflectorWorldPosition);\n      reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\n      clipPlane.set(reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant);\n      const projectionMatrix = virtualCamera.projectionMatrix;\n      q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n      q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n      q.z = -1;\n      q.w = (1 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];\n      clipPlane.multiplyScalar(2 / clipPlane.dot(q));\n      projectionMatrix.elements[2] = clipPlane.x;\n      projectionMatrix.elements[6] = clipPlane.y;\n      projectionMatrix.elements[10] = clipPlane.z + 1 - clipBias;\n      projectionMatrix.elements[14] = clipPlane.w;\n      scope.visible = false;\n      const currentRenderTarget = renderer.getRenderTarget();\n      const currentXrEnabled = renderer.xr.enabled;\n      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n      const currentToneMapping = renderer.toneMapping;\n      let isSRGB = false;\n      if (\"outputColorSpace\" in renderer)\n        isSRGB = renderer.outputColorSpace === \"srgb\";\n      else\n        isSRGB = renderer.outputEncoding === 3001;\n      renderer.xr.enabled = false;\n      renderer.shadowMap.autoUpdate = false;\n      if (\"outputColorSpace\" in renderer)\n        renderer.outputColorSpace = \"linear-srgb\";\n      else\n        renderer.outputEncoding = 3e3;\n      renderer.toneMapping = NoToneMapping;\n      renderer.setRenderTarget(renderTarget);\n      renderer.state.buffers.depth.setMask(true);\n      if (renderer.autoClear === false)\n        renderer.clear();\n      renderer.render(scene, virtualCamera);\n      renderer.xr.enabled = currentXrEnabled;\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n      renderer.toneMapping = currentToneMapping;\n      if (\"outputColorSpace\" in renderer)\n        renderer.outputColorSpace = isSRGB ? \"srgb\" : \"srgb-linear\";\n      else\n        renderer.outputEncoding = isSRGB ? 3001 : 3e3;\n      renderer.setRenderTarget(currentRenderTarget);\n      const viewport = camera.viewport;\n      if (viewport !== void 0) {\n        renderer.state.viewport(viewport);\n      }\n      scope.visible = true;\n    };\n    this.getRenderTarget = function() {\n      return renderTarget;\n    };\n    this.dispose = function() {\n      renderTarget.dispose();\n      scope.material.dispose();\n    };\n  }\n};\nlet Reflector = _Reflector;\n__publicField(Reflector, \"ReflectorShader\", {\n  uniforms: {\n    color: {\n      value: null\n    },\n    tDiffuse: {\n      value: null\n    },\n    textureMatrix: {\n      value: null\n    }\n  },\n  vertexShader: (\n    /* glsl */\n    `\n\t\tuniform mat4 textureMatrix;\n\t\tvarying vec4 vUv;\n\n\t\t#include <common>\n\t\t#include <logdepthbuf_pars_vertex>\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t#include <logdepthbuf_vertex>\n\n\t\t}`\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tvarying vec4 vUv;\n\n\t\t#include <logdepthbuf_pars_fragment>\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <logdepthbuf_fragment>\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\n\t\t}`\n  )\n});\nexport {\n  Reflector\n};\n"]},"metadata":{},"sourceType":"module"}