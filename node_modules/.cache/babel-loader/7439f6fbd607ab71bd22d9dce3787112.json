{"ast":null,"code":"import { Frustum, Vector3 } from \"three\";\nconst frustum = /* @__PURE__ */new Frustum();\nconst center = /* @__PURE__ */new Vector3();\nconst tmpPoint = /* @__PURE__ */new Vector3();\nconst vecNear = /* @__PURE__ */new Vector3();\nconst vecTopLeft = /* @__PURE__ */new Vector3();\nconst vecTopRight = /* @__PURE__ */new Vector3();\nconst vecDownRight = /* @__PURE__ */new Vector3();\nconst vecDownLeft = /* @__PURE__ */new Vector3();\nconst vecFarTopLeft = /* @__PURE__ */new Vector3();\nconst vecFarTopRight = /* @__PURE__ */new Vector3();\nconst vecFarDownRight = /* @__PURE__ */new Vector3();\nconst vecFarDownLeft = /* @__PURE__ */new Vector3();\nconst vectemp1 = /* @__PURE__ */new Vector3();\nconst vectemp2 = /* @__PURE__ */new Vector3();\nconst vectemp3 = /* @__PURE__ */new Vector3();\n\nclass SelectionBox {\n  constructor(camera, scene, deep) {\n    this.camera = camera;\n    this.scene = scene;\n    this.startPoint = new Vector3();\n    this.endPoint = new Vector3();\n    this.collection = [];\n    this.deep = deep || Number.MAX_VALUE;\n  }\n\n  select(startPoint, endPoint) {\n    this.startPoint = startPoint || this.startPoint;\n    this.endPoint = endPoint || this.endPoint;\n    this.collection = [];\n    this.updateFrustum(this.startPoint, this.endPoint);\n    this.searchChildInFrustum(frustum, this.scene);\n    return this.collection;\n  }\n\n  updateFrustum(startPoint, endPoint) {\n    startPoint = startPoint || this.startPoint;\n    endPoint = endPoint || this.endPoint;\n\n    if (startPoint.x === endPoint.x) {\n      endPoint.x += Number.EPSILON;\n    }\n\n    if (startPoint.y === endPoint.y) {\n      endPoint.y += Number.EPSILON;\n    }\n\n    this.camera.updateProjectionMatrix();\n    this.camera.updateMatrixWorld();\n\n    if (this.camera.isPerspectiveCamera) {\n      tmpPoint.copy(startPoint);\n      tmpPoint.x = Math.min(startPoint.x, endPoint.x);\n      tmpPoint.y = Math.max(startPoint.y, endPoint.y);\n      endPoint.x = Math.max(startPoint.x, endPoint.x);\n      endPoint.y = Math.min(startPoint.y, endPoint.y);\n      vecNear.setFromMatrixPosition(this.camera.matrixWorld);\n      vecTopLeft.copy(tmpPoint);\n      vecTopRight.set(endPoint.x, tmpPoint.y, 0);\n      vecDownRight.copy(endPoint);\n      vecDownLeft.set(tmpPoint.x, endPoint.y, 0);\n      vecTopLeft.unproject(this.camera);\n      vecTopRight.unproject(this.camera);\n      vecDownRight.unproject(this.camera);\n      vecDownLeft.unproject(this.camera);\n      vectemp1.copy(vecTopLeft).sub(vecNear);\n      vectemp2.copy(vecTopRight).sub(vecNear);\n      vectemp3.copy(vecDownRight).sub(vecNear);\n      vectemp1.normalize();\n      vectemp2.normalize();\n      vectemp3.normalize();\n      vectemp1.multiplyScalar(this.deep);\n      vectemp2.multiplyScalar(this.deep);\n      vectemp3.multiplyScalar(this.deep);\n      vectemp1.add(vecNear);\n      vectemp2.add(vecNear);\n      vectemp3.add(vecNear);\n      var planes = frustum.planes;\n      planes[0].setFromCoplanarPoints(vecNear, vecTopLeft, vecTopRight);\n      planes[1].setFromCoplanarPoints(vecNear, vecTopRight, vecDownRight);\n      planes[2].setFromCoplanarPoints(vecDownRight, vecDownLeft, vecNear);\n      planes[3].setFromCoplanarPoints(vecDownLeft, vecTopLeft, vecNear);\n      planes[4].setFromCoplanarPoints(vecTopRight, vecDownRight, vecDownLeft);\n      planes[5].setFromCoplanarPoints(vectemp3, vectemp2, vectemp1);\n      planes[5].normal.multiplyScalar(-1);\n    } else if (this.camera.isOrthographicCamera) {\n      const left = Math.min(startPoint.x, endPoint.x);\n      const top = Math.max(startPoint.y, endPoint.y);\n      const right = Math.max(startPoint.x, endPoint.x);\n      const down = Math.min(startPoint.y, endPoint.y);\n      vecTopLeft.set(left, top, -1);\n      vecTopRight.set(right, top, -1);\n      vecDownRight.set(right, down, -1);\n      vecDownLeft.set(left, down, -1);\n      vecFarTopLeft.set(left, top, 1);\n      vecFarTopRight.set(right, top, 1);\n      vecFarDownRight.set(right, down, 1);\n      vecFarDownLeft.set(left, down, 1);\n      vecTopLeft.unproject(this.camera);\n      vecTopRight.unproject(this.camera);\n      vecDownRight.unproject(this.camera);\n      vecDownLeft.unproject(this.camera);\n      vecFarTopLeft.unproject(this.camera);\n      vecFarTopRight.unproject(this.camera);\n      vecFarDownRight.unproject(this.camera);\n      vecFarDownLeft.unproject(this.camera);\n      var planes = frustum.planes;\n      planes[0].setFromCoplanarPoints(vecTopLeft, vecFarTopLeft, vecFarTopRight);\n      planes[1].setFromCoplanarPoints(vecTopRight, vecFarTopRight, vecFarDownRight);\n      planes[2].setFromCoplanarPoints(vecFarDownRight, vecFarDownLeft, vecDownLeft);\n      planes[3].setFromCoplanarPoints(vecFarDownLeft, vecFarTopLeft, vecTopLeft);\n      planes[4].setFromCoplanarPoints(vecTopRight, vecDownRight, vecDownLeft);\n      planes[5].setFromCoplanarPoints(vecFarDownRight, vecFarTopRight, vecFarTopLeft);\n      planes[5].normal.multiplyScalar(-1);\n    } else {\n      console.error(\"THREE.SelectionBox: Unsupported camera type.\");\n    }\n  }\n\n  searchChildInFrustum(frustum2, object) {\n    if (object.isMesh || object.isLine || object.isPoints) {\n      if (object.material !== void 0) {\n        if (object.geometry.boundingSphere === null) object.geometry.computeBoundingSphere();\n        center.copy(object.geometry.boundingSphere.center);\n        center.applyMatrix4(object.matrixWorld);\n\n        if (frustum2.containsPoint(center)) {\n          this.collection.push(object);\n        }\n      }\n    }\n\n    if (object.children.length > 0) {\n      for (let x = 0; x < object.children.length; x++) {\n        this.searchChildInFrustum(frustum2, object.children[x]);\n      }\n    }\n  }\n\n}\n\nexport { SelectionBox };","map":{"version":3,"sources":["/Users/theodaguier/Repositories/E-Do-Studio/node_modules/three-stdlib/interactive/SelectionBox.js"],"names":["Frustum","Vector3","frustum","center","tmpPoint","vecNear","vecTopLeft","vecTopRight","vecDownRight","vecDownLeft","vecFarTopLeft","vecFarTopRight","vecFarDownRight","vecFarDownLeft","vectemp1","vectemp2","vectemp3","SelectionBox","constructor","camera","scene","deep","startPoint","endPoint","collection","Number","MAX_VALUE","select","updateFrustum","searchChildInFrustum","x","EPSILON","y","updateProjectionMatrix","updateMatrixWorld","isPerspectiveCamera","copy","Math","min","max","setFromMatrixPosition","matrixWorld","set","unproject","sub","normalize","multiplyScalar","add","planes","setFromCoplanarPoints","normal","isOrthographicCamera","left","top","right","down","console","error","frustum2","object","isMesh","isLine","isPoints","material","geometry","boundingSphere","computeBoundingSphere","applyMatrix4","containsPoint","push","children","length"],"mappings":"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","sourcesContent":["import { Frustum, Vector3 } from \"three\";\nconst frustum = /* @__PURE__ */ new Frustum();\nconst center = /* @__PURE__ */ new Vector3();\nconst tmpPoint = /* @__PURE__ */ new Vector3();\nconst vecNear = /* @__PURE__ */ new Vector3();\nconst vecTopLeft = /* @__PURE__ */ new Vector3();\nconst vecTopRight = /* @__PURE__ */ new Vector3();\nconst vecDownRight = /* @__PURE__ */ new Vector3();\nconst vecDownLeft = /* @__PURE__ */ new Vector3();\nconst vecFarTopLeft = /* @__PURE__ */ new Vector3();\nconst vecFarTopRight = /* @__PURE__ */ new Vector3();\nconst vecFarDownRight = /* @__PURE__ */ new Vector3();\nconst vecFarDownLeft = /* @__PURE__ */ new Vector3();\nconst vectemp1 = /* @__PURE__ */ new Vector3();\nconst vectemp2 = /* @__PURE__ */ new Vector3();\nconst vectemp3 = /* @__PURE__ */ new Vector3();\nclass SelectionBox {\n  constructor(camera, scene, deep) {\n    this.camera = camera;\n    this.scene = scene;\n    this.startPoint = new Vector3();\n    this.endPoint = new Vector3();\n    this.collection = [];\n    this.deep = deep || Number.MAX_VALUE;\n  }\n  select(startPoint, endPoint) {\n    this.startPoint = startPoint || this.startPoint;\n    this.endPoint = endPoint || this.endPoint;\n    this.collection = [];\n    this.updateFrustum(this.startPoint, this.endPoint);\n    this.searchChildInFrustum(frustum, this.scene);\n    return this.collection;\n  }\n  updateFrustum(startPoint, endPoint) {\n    startPoint = startPoint || this.startPoint;\n    endPoint = endPoint || this.endPoint;\n    if (startPoint.x === endPoint.x) {\n      endPoint.x += Number.EPSILON;\n    }\n    if (startPoint.y === endPoint.y) {\n      endPoint.y += Number.EPSILON;\n    }\n    this.camera.updateProjectionMatrix();\n    this.camera.updateMatrixWorld();\n    if (this.camera.isPerspectiveCamera) {\n      tmpPoint.copy(startPoint);\n      tmpPoint.x = Math.min(startPoint.x, endPoint.x);\n      tmpPoint.y = Math.max(startPoint.y, endPoint.y);\n      endPoint.x = Math.max(startPoint.x, endPoint.x);\n      endPoint.y = Math.min(startPoint.y, endPoint.y);\n      vecNear.setFromMatrixPosition(this.camera.matrixWorld);\n      vecTopLeft.copy(tmpPoint);\n      vecTopRight.set(endPoint.x, tmpPoint.y, 0);\n      vecDownRight.copy(endPoint);\n      vecDownLeft.set(tmpPoint.x, endPoint.y, 0);\n      vecTopLeft.unproject(this.camera);\n      vecTopRight.unproject(this.camera);\n      vecDownRight.unproject(this.camera);\n      vecDownLeft.unproject(this.camera);\n      vectemp1.copy(vecTopLeft).sub(vecNear);\n      vectemp2.copy(vecTopRight).sub(vecNear);\n      vectemp3.copy(vecDownRight).sub(vecNear);\n      vectemp1.normalize();\n      vectemp2.normalize();\n      vectemp3.normalize();\n      vectemp1.multiplyScalar(this.deep);\n      vectemp2.multiplyScalar(this.deep);\n      vectemp3.multiplyScalar(this.deep);\n      vectemp1.add(vecNear);\n      vectemp2.add(vecNear);\n      vectemp3.add(vecNear);\n      var planes = frustum.planes;\n      planes[0].setFromCoplanarPoints(vecNear, vecTopLeft, vecTopRight);\n      planes[1].setFromCoplanarPoints(vecNear, vecTopRight, vecDownRight);\n      planes[2].setFromCoplanarPoints(vecDownRight, vecDownLeft, vecNear);\n      planes[3].setFromCoplanarPoints(vecDownLeft, vecTopLeft, vecNear);\n      planes[4].setFromCoplanarPoints(vecTopRight, vecDownRight, vecDownLeft);\n      planes[5].setFromCoplanarPoints(vectemp3, vectemp2, vectemp1);\n      planes[5].normal.multiplyScalar(-1);\n    } else if (this.camera.isOrthographicCamera) {\n      const left = Math.min(startPoint.x, endPoint.x);\n      const top = Math.max(startPoint.y, endPoint.y);\n      const right = Math.max(startPoint.x, endPoint.x);\n      const down = Math.min(startPoint.y, endPoint.y);\n      vecTopLeft.set(left, top, -1);\n      vecTopRight.set(right, top, -1);\n      vecDownRight.set(right, down, -1);\n      vecDownLeft.set(left, down, -1);\n      vecFarTopLeft.set(left, top, 1);\n      vecFarTopRight.set(right, top, 1);\n      vecFarDownRight.set(right, down, 1);\n      vecFarDownLeft.set(left, down, 1);\n      vecTopLeft.unproject(this.camera);\n      vecTopRight.unproject(this.camera);\n      vecDownRight.unproject(this.camera);\n      vecDownLeft.unproject(this.camera);\n      vecFarTopLeft.unproject(this.camera);\n      vecFarTopRight.unproject(this.camera);\n      vecFarDownRight.unproject(this.camera);\n      vecFarDownLeft.unproject(this.camera);\n      var planes = frustum.planes;\n      planes[0].setFromCoplanarPoints(vecTopLeft, vecFarTopLeft, vecFarTopRight);\n      planes[1].setFromCoplanarPoints(vecTopRight, vecFarTopRight, vecFarDownRight);\n      planes[2].setFromCoplanarPoints(vecFarDownRight, vecFarDownLeft, vecDownLeft);\n      planes[3].setFromCoplanarPoints(vecFarDownLeft, vecFarTopLeft, vecTopLeft);\n      planes[4].setFromCoplanarPoints(vecTopRight, vecDownRight, vecDownLeft);\n      planes[5].setFromCoplanarPoints(vecFarDownRight, vecFarTopRight, vecFarTopLeft);\n      planes[5].normal.multiplyScalar(-1);\n    } else {\n      console.error(\"THREE.SelectionBox: Unsupported camera type.\");\n    }\n  }\n  searchChildInFrustum(frustum2, object) {\n    if (object.isMesh || object.isLine || object.isPoints) {\n      if (object.material !== void 0) {\n        if (object.geometry.boundingSphere === null)\n          object.geometry.computeBoundingSphere();\n        center.copy(object.geometry.boundingSphere.center);\n        center.applyMatrix4(object.matrixWorld);\n        if (frustum2.containsPoint(center)) {\n          this.collection.push(object);\n        }\n      }\n    }\n    if (object.children.length > 0) {\n      for (let x = 0; x < object.children.length; x++) {\n        this.searchChildInFrustum(frustum2, object.children[x]);\n      }\n    }\n  }\n}\nexport {\n  SelectionBox\n};\n"]},"metadata":{},"sourceType":"module"}