{"ast":null,"code":"import _assertThisInitialized from \"/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _classCallCheck from \"/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nvar __defProp = Object.defineProperty;\n\nvar __defNormalProp = function __defNormalProp(obj, key, value) {\n  return key in obj ? __defProp(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\n\nvar __publicField = function __publicField(obj, key, value) {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n\n  return value;\n};\n\nimport { DataTexture, RGBAFormat, FloatType, RepeatWrapping, NearestFilter, Mesh, InstancedMesh, Matrix4, DynamicDrawUsage } from \"three\";\nvar CHANNELS = 4;\nvar TEXTURE_WIDTH = 1024;\nvar TEXTURE_HEIGHT = 4;\n\nvar initSplineTexture = function initSplineTexture() {\n  var numberOfCurves = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n  var dataArray = new Float32Array(TEXTURE_WIDTH * TEXTURE_HEIGHT * numberOfCurves * CHANNELS);\n  var dataTexture = new DataTexture(dataArray, TEXTURE_WIDTH, TEXTURE_HEIGHT * numberOfCurves, RGBAFormat, FloatType);\n  dataTexture.wrapS = RepeatWrapping;\n  dataTexture.wrapT = RepeatWrapping;\n  dataTexture.magFilter = NearestFilter;\n  dataTexture.needsUpdate = true;\n  return dataTexture;\n};\n\nvar updateSplineTexture = function updateSplineTexture(texture, splineCurve) {\n  var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var numberOfPoints = Math.floor(TEXTURE_WIDTH * (TEXTURE_HEIGHT / 4));\n  splineCurve.arcLengthDivisions = numberOfPoints / 2;\n  splineCurve.updateArcLengths();\n  var points = splineCurve.getSpacedPoints(numberOfPoints);\n  var frenetFrames = splineCurve.computeFrenetFrames(numberOfPoints, true);\n\n  for (var i = 0; i < numberOfPoints; i++) {\n    var rowOffset = Math.floor(i / TEXTURE_WIDTH);\n    var rowIndex = i % TEXTURE_WIDTH;\n    var pt = points[i];\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 0 + rowOffset + TEXTURE_HEIGHT * offset);\n    pt = frenetFrames.tangents[i];\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 1 + rowOffset + TEXTURE_HEIGHT * offset);\n    pt = frenetFrames.normals[i];\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 2 + rowOffset + TEXTURE_HEIGHT * offset);\n    pt = frenetFrames.binormals[i];\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 3 + rowOffset + TEXTURE_HEIGHT * offset);\n  }\n\n  texture.needsUpdate = true;\n};\n\nvar setTextureValue = function setTextureValue(texture, index, x, y, z, o) {\n  var image = texture.image;\n  var data = image.data;\n  var i = CHANNELS * TEXTURE_WIDTH * o;\n  data[index * CHANNELS + i + 0] = x;\n  data[index * CHANNELS + i + 1] = y;\n  data[index * CHANNELS + i + 2] = z;\n  data[index * CHANNELS + i + 3] = 1;\n};\n\nvar getUniforms = function getUniforms(splineTexture) {\n  return {\n    spineTexture: {\n      value: splineTexture\n    },\n    pathOffset: {\n      type: \"f\",\n      value: 0\n    },\n    // time of path curve\n    pathSegment: {\n      type: \"f\",\n      value: 1\n    },\n    // fractional length of path\n    spineOffset: {\n      type: \"f\",\n      value: 161\n    },\n    spineLength: {\n      type: \"f\",\n      value: 400\n    },\n    flow: {\n      type: \"i\",\n      value: 1\n    }\n  };\n};\n\nfunction modifyShader(material, uniforms) {\n  var numberOfCurves = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  if (material.__ok) return;\n  material.__ok = true;\n\n  material.onBeforeCompile = function (shader) {\n    if (shader.__modified) return;\n    shader.__modified = true;\n    Object.assign(shader.uniforms, uniforms);\n    var vertexShader =\n    /* glsl */\n    \"\\n\\t\\tuniform sampler2D spineTexture;\\n\\t\\tuniform float pathOffset;\\n\\t\\tuniform float pathSegment;\\n\\t\\tuniform float spineOffset;\\n\\t\\tuniform float spineLength;\\n\\t\\tuniform int flow;\\n\\n\\t\\tfloat textureLayers = \".concat(TEXTURE_HEIGHT * numberOfCurves, \".;\\n\\t\\tfloat textureStacks = \").concat(TEXTURE_HEIGHT / 4, \".;\\n\\n\\t\\t\").concat(shader.vertexShader, \"\\n\\t\\t\").replace(\"#include <beginnormal_vertex>\", \"\").replace(\"#include <defaultnormal_vertex>\", \"\").replace(\"#include <begin_vertex>\", \"\").replace(/void\\s*main\\s*\\(\\)\\s*\\{/,\n    /* glsl */\n    \"\\n        void main() {\\n        #include <beginnormal_vertex>\\n\\n        vec4 worldPos = modelMatrix * vec4(position, 1.);\\n\\n        bool bend = flow > 0;\\n        float xWeight = bend ? 0. : 1.;\\n\\n        #ifdef USE_INSTANCING\\n        float pathOffsetFromInstanceMatrix = instanceMatrix[3][2];\\n        float spineLengthFromInstanceMatrix = instanceMatrix[3][0];\\n        float spinePortion = bend ? (worldPos.x + spineOffset) / spineLengthFromInstanceMatrix : 0.;\\n        float mt = (spinePortion * pathSegment + pathOffset + pathOffsetFromInstanceMatrix)*textureStacks;\\n        #else\\n        float spinePortion = bend ? (worldPos.x + spineOffset) / spineLength : 0.;\\n        float mt = (spinePortion * pathSegment + pathOffset)*textureStacks;\\n        #endif\\n\\n        mt = mod(mt, textureStacks);\\n        float rowOffset = floor(mt);\\n\\n        #ifdef USE_INSTANCING\\n        rowOffset += instanceMatrix[3][1] * \".concat(TEXTURE_HEIGHT, \".;\\n        #endif\\n\\n        vec3 spinePos = texture2D(spineTexture, vec2(mt, (0. + rowOffset + 0.5) / textureLayers)).xyz;\\n        vec3 a =        texture2D(spineTexture, vec2(mt, (1. + rowOffset + 0.5) / textureLayers)).xyz;\\n        vec3 b =        texture2D(spineTexture, vec2(mt, (2. + rowOffset + 0.5) / textureLayers)).xyz;\\n        vec3 c =        texture2D(spineTexture, vec2(mt, (3. + rowOffset + 0.5) / textureLayers)).xyz;\\n        mat3 basis = mat3(a, b, c);\\n\\n        vec3 transformed = basis\\n          * vec3(worldPos.x * xWeight, worldPos.y * 1., worldPos.z * 1.)\\n          + spinePos;\\n\\n        vec3 transformedNormal = normalMatrix * (basis * objectNormal);\\n\\t\\t\\t\")).replace(\"#include <project_vertex>\",\n    /* glsl */\n    \"vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\\n\\t\\t\\t\\tgl_Position = projectionMatrix * mvPosition;\");\n    shader.vertexShader = vertexShader;\n  };\n}\n\nvar Flow = /*#__PURE__*/function () {\n  /**\n   * @param {Mesh} mesh The mesh to clone and modify to bend around the curve\n   * @param {number} numberOfCurves The amount of space that should preallocated for additional curves\n   */\n  function Flow(mesh) {\n    var numberOfCurves = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n    _classCallCheck(this, Flow);\n\n    __publicField(this, \"curveArray\");\n\n    __publicField(this, \"curveLengthArray\");\n\n    __publicField(this, \"object3D\");\n\n    __publicField(this, \"splineTexure\");\n\n    __publicField(this, \"uniforms\");\n\n    var obj3D = mesh.clone();\n    var splineTexure = initSplineTexture(numberOfCurves);\n    var uniforms = getUniforms(splineTexure);\n    obj3D.traverse(function (child) {\n      if (child instanceof Mesh || child instanceof InstancedMesh) {\n        child.material = child.material.clone();\n        modifyShader(child.material, uniforms, numberOfCurves);\n      }\n    });\n    this.curveArray = new Array(numberOfCurves);\n    this.curveLengthArray = new Array(numberOfCurves);\n    this.object3D = obj3D;\n    this.splineTexure = splineTexure;\n    this.uniforms = uniforms;\n  }\n\n  _createClass(Flow, [{\n    key: \"updateCurve\",\n    value: function updateCurve(index, curve) {\n      if (index >= this.curveArray.length) throw Error(\"Index out of range for Flow\");\n      var curveLength = curve.getLength();\n      this.uniforms.spineLength.value = curveLength;\n      this.curveLengthArray[index] = curveLength;\n      this.curveArray[index] = curve;\n      updateSplineTexture(this.splineTexure, curve, index);\n    }\n  }, {\n    key: \"moveAlongCurve\",\n    value: function moveAlongCurve(amount) {\n      this.uniforms.pathOffset.value += amount;\n    }\n  }]);\n\n  return Flow;\n}();\n\nvar matrix = /* @__PURE__ */new Matrix4();\n\nvar InstancedFlow = /*#__PURE__*/function (_Flow) {\n  _inherits(InstancedFlow, _Flow);\n\n  var _super = _createSuper(InstancedFlow);\n\n  /**\n   *\n   * @param {number} count The number of instanced elements\n   * @param {number} curveCount The number of curves to preallocate for\n   * @param {Geometry} geometry The geometry to use for the instanced mesh\n   * @param {Material} material The material to use for the instanced mesh\n   */\n  function InstancedFlow(count, curveCount, geometry, material) {\n    var _this;\n\n    _classCallCheck(this, InstancedFlow);\n\n    var mesh = new InstancedMesh(geometry, material, count);\n    mesh.instanceMatrix.setUsage(DynamicDrawUsage);\n    mesh.frustumCulled = false;\n    _this = _super.call(this, mesh, curveCount);\n\n    __publicField(_assertThisInitialized(_this), \"offsets\");\n\n    __publicField(_assertThisInitialized(_this), \"whichCurve\");\n\n    _this.offsets = new Array(count).fill(0);\n    _this.whichCurve = new Array(count).fill(0);\n    return _this;\n  }\n  /**\n   * The extra information about which curve and curve position is stored in the translation components of the matrix for the instanced objects\n   * This writes that information to the matrix and marks it as needing update.\n   *\n   * @param {number} index of the instanced element to update\n   */\n\n\n  _createClass(InstancedFlow, [{\n    key: \"writeChanges\",\n    value: function writeChanges(index) {\n      matrix.makeTranslation(this.curveLengthArray[this.whichCurve[index]], this.whichCurve[index], this.offsets[index]);\n      this.object3D.setMatrixAt(index, matrix);\n      this.object3D.instanceMatrix.needsUpdate = true;\n    }\n    /**\n     * Move an individual element along the curve by a specific amount\n     *\n     * @param {number} index Which element to update\n     * @param {number} offset Move by how much\n     */\n\n  }, {\n    key: \"moveIndividualAlongCurve\",\n    value: function moveIndividualAlongCurve(index, offset) {\n      this.offsets[index] += offset;\n      this.writeChanges(index);\n    }\n    /**\n     * Select which curve to use for an element\n     *\n     * @param {number} index the index of the instanced element to update\n     * @param {number} curveNo the index of the curve it should use\n     */\n\n  }, {\n    key: \"setCurve\",\n    value: function setCurve(index, curveNo) {\n      if (isNaN(curveNo)) throw Error(\"curve index being set is Not a Number (NaN)\");\n      this.whichCurve[index] = curveNo;\n      this.writeChanges(index);\n    }\n  }]);\n\n  return InstancedFlow;\n}(Flow);\n\nexport { Flow, InstancedFlow, getUniforms, initSplineTexture, modifyShader, updateSplineTexture };","map":{"version":3,"sources":["/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/three-stdlib/modifiers/CurveModifier.js"],"names":["__defProp","Object","defineProperty","__defNormalProp","obj","key","value","enumerable","configurable","writable","__publicField","DataTexture","RGBAFormat","FloatType","RepeatWrapping","NearestFilter","Mesh","InstancedMesh","Matrix4","DynamicDrawUsage","CHANNELS","TEXTURE_WIDTH","TEXTURE_HEIGHT","initSplineTexture","numberOfCurves","dataArray","Float32Array","dataTexture","wrapS","wrapT","magFilter","needsUpdate","updateSplineTexture","texture","splineCurve","offset","numberOfPoints","Math","floor","arcLengthDivisions","updateArcLengths","points","getSpacedPoints","frenetFrames","computeFrenetFrames","i","rowOffset","rowIndex","pt","setTextureValue","x","y","z","tangents","normals","binormals","index","o","image","data","getUniforms","splineTexture","spineTexture","pathOffset","type","pathSegment","spineOffset","spineLength","flow","modifyShader","material","uniforms","__ok","onBeforeCompile","shader","__modified","assign","vertexShader","replace","Flow","mesh","obj3D","clone","splineTexure","traverse","child","curveArray","Array","curveLengthArray","object3D","curve","length","Error","curveLength","getLength","amount","matrix","InstancedFlow","count","curveCount","geometry","instanceMatrix","setUsage","frustumCulled","offsets","fill","whichCurve","makeTranslation","setMatrixAt","writeChanges","curveNo","isNaN"],"mappings":"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","sourcesContent":["var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { DataTexture, RGBAFormat, FloatType, RepeatWrapping, NearestFilter, Mesh, InstancedMesh, Matrix4, DynamicDrawUsage } from \"three\";\nconst CHANNELS = 4;\nconst TEXTURE_WIDTH = 1024;\nconst TEXTURE_HEIGHT = 4;\nconst initSplineTexture = (numberOfCurves = 1) => {\n  const dataArray = new Float32Array(TEXTURE_WIDTH * TEXTURE_HEIGHT * numberOfCurves * CHANNELS);\n  const dataTexture = new DataTexture(dataArray, TEXTURE_WIDTH, TEXTURE_HEIGHT * numberOfCurves, RGBAFormat, FloatType);\n  dataTexture.wrapS = RepeatWrapping;\n  dataTexture.wrapT = RepeatWrapping;\n  dataTexture.magFilter = NearestFilter;\n  dataTexture.needsUpdate = true;\n  return dataTexture;\n};\nconst updateSplineTexture = (texture, splineCurve, offset = 0) => {\n  const numberOfPoints = Math.floor(TEXTURE_WIDTH * (TEXTURE_HEIGHT / 4));\n  splineCurve.arcLengthDivisions = numberOfPoints / 2;\n  splineCurve.updateArcLengths();\n  const points = splineCurve.getSpacedPoints(numberOfPoints);\n  const frenetFrames = splineCurve.computeFrenetFrames(numberOfPoints, true);\n  for (let i = 0; i < numberOfPoints; i++) {\n    const rowOffset = Math.floor(i / TEXTURE_WIDTH);\n    const rowIndex = i % TEXTURE_WIDTH;\n    let pt = points[i];\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 0 + rowOffset + TEXTURE_HEIGHT * offset);\n    pt = frenetFrames.tangents[i];\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 1 + rowOffset + TEXTURE_HEIGHT * offset);\n    pt = frenetFrames.normals[i];\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 2 + rowOffset + TEXTURE_HEIGHT * offset);\n    pt = frenetFrames.binormals[i];\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 3 + rowOffset + TEXTURE_HEIGHT * offset);\n  }\n  texture.needsUpdate = true;\n};\nconst setTextureValue = (texture, index, x, y, z, o) => {\n  const image = texture.image;\n  const { data } = image;\n  const i = CHANNELS * TEXTURE_WIDTH * o;\n  data[index * CHANNELS + i + 0] = x;\n  data[index * CHANNELS + i + 1] = y;\n  data[index * CHANNELS + i + 2] = z;\n  data[index * CHANNELS + i + 3] = 1;\n};\nconst getUniforms = (splineTexture) => ({\n  spineTexture: { value: splineTexture },\n  pathOffset: { type: \"f\", value: 0 },\n  // time of path curve\n  pathSegment: { type: \"f\", value: 1 },\n  // fractional length of path\n  spineOffset: { type: \"f\", value: 161 },\n  spineLength: { type: \"f\", value: 400 },\n  flow: { type: \"i\", value: 1 }\n});\nfunction modifyShader(material, uniforms, numberOfCurves = 1) {\n  if (material.__ok)\n    return;\n  material.__ok = true;\n  material.onBeforeCompile = (shader) => {\n    if (shader.__modified)\n      return;\n    shader.__modified = true;\n    Object.assign(shader.uniforms, uniforms);\n    const vertexShader = (\n      /* glsl */\n      `\n\t\tuniform sampler2D spineTexture;\n\t\tuniform float pathOffset;\n\t\tuniform float pathSegment;\n\t\tuniform float spineOffset;\n\t\tuniform float spineLength;\n\t\tuniform int flow;\n\n\t\tfloat textureLayers = ${TEXTURE_HEIGHT * numberOfCurves}.;\n\t\tfloat textureStacks = ${TEXTURE_HEIGHT / 4}.;\n\n\t\t${shader.vertexShader}\n\t\t`.replace(\"#include <beginnormal_vertex>\", \"\").replace(\"#include <defaultnormal_vertex>\", \"\").replace(\"#include <begin_vertex>\", \"\").replace(\n        /void\\s*main\\s*\\(\\)\\s*\\{/,\n        /* glsl */\n        `\n        void main() {\n        #include <beginnormal_vertex>\n\n        vec4 worldPos = modelMatrix * vec4(position, 1.);\n\n        bool bend = flow > 0;\n        float xWeight = bend ? 0. : 1.;\n\n        #ifdef USE_INSTANCING\n        float pathOffsetFromInstanceMatrix = instanceMatrix[3][2];\n        float spineLengthFromInstanceMatrix = instanceMatrix[3][0];\n        float spinePortion = bend ? (worldPos.x + spineOffset) / spineLengthFromInstanceMatrix : 0.;\n        float mt = (spinePortion * pathSegment + pathOffset + pathOffsetFromInstanceMatrix)*textureStacks;\n        #else\n        float spinePortion = bend ? (worldPos.x + spineOffset) / spineLength : 0.;\n        float mt = (spinePortion * pathSegment + pathOffset)*textureStacks;\n        #endif\n\n        mt = mod(mt, textureStacks);\n        float rowOffset = floor(mt);\n\n        #ifdef USE_INSTANCING\n        rowOffset += instanceMatrix[3][1] * ${TEXTURE_HEIGHT}.;\n        #endif\n\n        vec3 spinePos = texture2D(spineTexture, vec2(mt, (0. + rowOffset + 0.5) / textureLayers)).xyz;\n        vec3 a =        texture2D(spineTexture, vec2(mt, (1. + rowOffset + 0.5) / textureLayers)).xyz;\n        vec3 b =        texture2D(spineTexture, vec2(mt, (2. + rowOffset + 0.5) / textureLayers)).xyz;\n        vec3 c =        texture2D(spineTexture, vec2(mt, (3. + rowOffset + 0.5) / textureLayers)).xyz;\n        mat3 basis = mat3(a, b, c);\n\n        vec3 transformed = basis\n          * vec3(worldPos.x * xWeight, worldPos.y * 1., worldPos.z * 1.)\n          + spinePos;\n\n        vec3 transformedNormal = normalMatrix * (basis * objectNormal);\n\t\t\t`\n      ).replace(\n        \"#include <project_vertex>\",\n        /* glsl */\n        `vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n\t\t\t\tgl_Position = projectionMatrix * mvPosition;`\n      )\n    );\n    shader.vertexShader = vertexShader;\n  };\n}\nclass Flow {\n  /**\n   * @param {Mesh} mesh The mesh to clone and modify to bend around the curve\n   * @param {number} numberOfCurves The amount of space that should preallocated for additional curves\n   */\n  constructor(mesh, numberOfCurves = 1) {\n    __publicField(this, \"curveArray\");\n    __publicField(this, \"curveLengthArray\");\n    __publicField(this, \"object3D\");\n    __publicField(this, \"splineTexure\");\n    __publicField(this, \"uniforms\");\n    const obj3D = mesh.clone();\n    const splineTexure = initSplineTexture(numberOfCurves);\n    const uniforms = getUniforms(splineTexure);\n    obj3D.traverse((child) => {\n      if (child instanceof Mesh || child instanceof InstancedMesh) {\n        child.material = child.material.clone();\n        modifyShader(child.material, uniforms, numberOfCurves);\n      }\n    });\n    this.curveArray = new Array(numberOfCurves);\n    this.curveLengthArray = new Array(numberOfCurves);\n    this.object3D = obj3D;\n    this.splineTexure = splineTexure;\n    this.uniforms = uniforms;\n  }\n  updateCurve(index, curve) {\n    if (index >= this.curveArray.length)\n      throw Error(\"Index out of range for Flow\");\n    const curveLength = curve.getLength();\n    this.uniforms.spineLength.value = curveLength;\n    this.curveLengthArray[index] = curveLength;\n    this.curveArray[index] = curve;\n    updateSplineTexture(this.splineTexure, curve, index);\n  }\n  moveAlongCurve(amount) {\n    this.uniforms.pathOffset.value += amount;\n  }\n}\nconst matrix = /* @__PURE__ */ new Matrix4();\nclass InstancedFlow extends Flow {\n  /**\n   *\n   * @param {number} count The number of instanced elements\n   * @param {number} curveCount The number of curves to preallocate for\n   * @param {Geometry} geometry The geometry to use for the instanced mesh\n   * @param {Material} material The material to use for the instanced mesh\n   */\n  constructor(count, curveCount, geometry, material) {\n    const mesh = new InstancedMesh(geometry, material, count);\n    mesh.instanceMatrix.setUsage(DynamicDrawUsage);\n    mesh.frustumCulled = false;\n    super(mesh, curveCount);\n    __publicField(this, \"offsets\");\n    __publicField(this, \"whichCurve\");\n    this.offsets = new Array(count).fill(0);\n    this.whichCurve = new Array(count).fill(0);\n  }\n  /**\n   * The extra information about which curve and curve position is stored in the translation components of the matrix for the instanced objects\n   * This writes that information to the matrix and marks it as needing update.\n   *\n   * @param {number} index of the instanced element to update\n   */\n  writeChanges(index) {\n    matrix.makeTranslation(this.curveLengthArray[this.whichCurve[index]], this.whichCurve[index], this.offsets[index]);\n    this.object3D.setMatrixAt(index, matrix);\n    this.object3D.instanceMatrix.needsUpdate = true;\n  }\n  /**\n   * Move an individual element along the curve by a specific amount\n   *\n   * @param {number} index Which element to update\n   * @param {number} offset Move by how much\n   */\n  moveIndividualAlongCurve(index, offset) {\n    this.offsets[index] += offset;\n    this.writeChanges(index);\n  }\n  /**\n   * Select which curve to use for an element\n   *\n   * @param {number} index the index of the instanced element to update\n   * @param {number} curveNo the index of the curve it should use\n   */\n  setCurve(index, curveNo) {\n    if (isNaN(curveNo))\n      throw Error(\"curve index being set is Not a Number (NaN)\");\n    this.whichCurve[index] = curveNo;\n    this.writeChanges(index);\n  }\n}\nexport {\n  Flow,\n  InstancedFlow,\n  getUniforms,\n  initSplineTexture,\n  modifyShader,\n  updateSplineTexture\n};\n"]},"metadata":{},"sourceType":"module"}