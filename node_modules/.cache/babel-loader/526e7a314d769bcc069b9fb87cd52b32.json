{"ast":null,"code":"import { BufferGeometry, BufferAttribute, InterleavedBuffer, InterleavedBufferAttribute, TrianglesDrawMode, TriangleFanDrawMode, TriangleStripDrawMode, Vector3, Float32BufferAttribute } from \"three\";\nimport { getWithKey } from \"../types/helpers.js\";\n\nconst mergeBufferGeometries = (geometries, useGroups) => {\n  const isIndexed = geometries[0].index !== null;\n  const attributesUsed = new Set(Object.keys(geometries[0].attributes));\n  const morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));\n  const attributes = {};\n  const morphAttributes = {};\n  const morphTargetsRelative = geometries[0].morphTargetsRelative;\n  const mergedGeometry = new BufferGeometry();\n  let offset = 0;\n  geometries.forEach((geom, i) => {\n    let attributesCount = 0;\n\n    if (isIndexed !== (geom.index !== null)) {\n      console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.\");\n      return null;\n    }\n\n    for (let name in geom.attributes) {\n      if (!attributesUsed.has(name)) {\n        console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.');\n        return null;\n      }\n\n      if (attributes[name] === void 0) {\n        attributes[name] = [];\n      }\n\n      attributes[name].push(geom.attributes[name]);\n      attributesCount++;\n    }\n\n    if (attributesCount !== attributesUsed.size) {\n      console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". Make sure all geometries have the same number of attributes.\");\n      return null;\n    }\n\n    if (morphTargetsRelative !== geom.morphTargetsRelative) {\n      console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". .morphTargetsRelative must be consistent throughout all geometries.\");\n      return null;\n    }\n\n    for (let name in geom.morphAttributes) {\n      if (!morphAttributesUsed.has(name)) {\n        console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \".  .morphAttributes must be consistent throughout all geometries.\");\n        return null;\n      }\n\n      if (morphAttributes[name] === void 0) morphAttributes[name] = [];\n      morphAttributes[name].push(geom.morphAttributes[name]);\n    }\n\n    mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];\n    mergedGeometry.userData.mergedUserData.push(geom.userData);\n\n    if (useGroups) {\n      let count;\n\n      if (geom.index) {\n        count = geom.index.count;\n      } else if (geom.attributes.position !== void 0) {\n        count = geom.attributes.position.count;\n      } else {\n        console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". The geometry must have either an index or a position attribute\");\n        return null;\n      }\n\n      mergedGeometry.addGroup(offset, count, i);\n      offset += count;\n    }\n  });\n\n  if (isIndexed) {\n    let indexOffset = 0;\n    const mergedIndex = [];\n    geometries.forEach(geom => {\n      const index = geom.index;\n\n      for (let j = 0; j < index.count; ++j) {\n        mergedIndex.push(index.getX(j) + indexOffset);\n      }\n\n      indexOffset += geom.attributes.position.count;\n    });\n    mergedGeometry.setIndex(mergedIndex);\n  }\n\n  for (let name in attributes) {\n    const mergedAttribute = mergeBufferAttributes(attributes[name]);\n\n    if (!mergedAttribute) {\n      console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the \" + name + \" attribute.\");\n      return null;\n    }\n\n    mergedGeometry.setAttribute(name, mergedAttribute);\n  }\n\n  for (let name in morphAttributes) {\n    const numMorphTargets = morphAttributes[name][0].length;\n    if (numMorphTargets === 0) break;\n    mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n    mergedGeometry.morphAttributes[name] = [];\n\n    for (let i = 0; i < numMorphTargets; ++i) {\n      const morphAttributesToMerge = [];\n\n      for (let j = 0; j < morphAttributes[name].length; ++j) {\n        morphAttributesToMerge.push(morphAttributes[name][j][i]);\n      }\n\n      const mergedMorphAttribute = mergeBufferAttributes(morphAttributesToMerge);\n\n      if (!mergedMorphAttribute) {\n        console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the \" + name + \" morphAttribute.\");\n        return null;\n      }\n\n      mergedGeometry.morphAttributes[name].push(mergedMorphAttribute);\n    }\n  }\n\n  return mergedGeometry;\n};\n\nconst mergeBufferAttributes = attributes => {\n  let TypedArray = void 0;\n  let itemSize = void 0;\n  let normalized = void 0;\n  let arrayLength = 0;\n  attributes.forEach(attr => {\n    if (TypedArray === void 0) {\n      TypedArray = attr.array.constructor;\n    }\n\n    if (TypedArray !== attr.array.constructor) {\n      console.error(\"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.\");\n      return null;\n    }\n\n    if (itemSize === void 0) itemSize = attr.itemSize;\n\n    if (itemSize !== attr.itemSize) {\n      console.error(\"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.\");\n      return null;\n    }\n\n    if (normalized === void 0) normalized = attr.normalized;\n\n    if (normalized !== attr.normalized) {\n      console.error(\"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.\");\n      return null;\n    }\n\n    arrayLength += attr.array.length;\n  });\n\n  if (TypedArray && itemSize) {\n    const array = new TypedArray(arrayLength);\n    let offset = 0;\n    attributes.forEach(attr => {\n      array.set(attr.array, offset);\n      offset += attr.array.length;\n    });\n    return new BufferAttribute(array, itemSize, normalized);\n  }\n};\n\nconst interleaveAttributes = attributes => {\n  let TypedArray = void 0;\n  let arrayLength = 0;\n  let stride = 0;\n\n  for (let i = 0, l = attributes.length; i < l; ++i) {\n    const attribute = attributes[i];\n    if (TypedArray === void 0) TypedArray = attribute.array.constructor;\n\n    if (TypedArray !== attribute.array.constructor) {\n      console.error(\"AttributeBuffers of different types cannot be interleaved\");\n      return null;\n    }\n\n    arrayLength += attribute.array.length;\n    stride += attribute.itemSize;\n  }\n\n  const interleavedBuffer = new InterleavedBuffer(new TypedArray(arrayLength), stride);\n  let offset = 0;\n  const res = [];\n  const getters = [\"getX\", \"getY\", \"getZ\", \"getW\"];\n  const setters = [\"setX\", \"setY\", \"setZ\", \"setW\"];\n\n  for (let j = 0, l = attributes.length; j < l; j++) {\n    const attribute = attributes[j];\n    const itemSize = attribute.itemSize;\n    const count = attribute.count;\n    const iba = new InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, attribute.normalized);\n    res.push(iba);\n    offset += itemSize;\n\n    for (let c = 0; c < count; c++) {\n      for (let k = 0; k < itemSize; k++) {\n        const set = getWithKey(iba, setters[k]);\n        const get = getWithKey(attribute, getters[k]);\n        set(c, get(c));\n      }\n    }\n  }\n\n  return res;\n};\n\nfunction estimateBytesUsed(geometry) {\n  let mem = 0;\n\n  for (let name in geometry.attributes) {\n    const attr = geometry.getAttribute(name);\n    mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n  }\n\n  const indices = geometry.getIndex();\n  mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n  return mem;\n}\n\nfunction mergeVertices(geometry, tolerance = 1e-4) {\n  tolerance = Math.max(tolerance, Number.EPSILON);\n  const hashToIndex = {};\n  const indices = geometry.getIndex();\n  const positions = geometry.getAttribute(\"position\");\n  const vertexCount = indices ? indices.count : positions.count;\n  let nextIndex = 0;\n  const attributeNames = Object.keys(geometry.attributes);\n  const attrArrays = {};\n  const morphAttrsArrays = {};\n  const newIndices = [];\n  const getters = [\"getX\", \"getY\", \"getZ\", \"getW\"];\n\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i];\n    attrArrays[name] = [];\n    const morphAttr = geometry.morphAttributes[name];\n\n    if (morphAttr) {\n      morphAttrsArrays[name] = new Array(morphAttr.length).fill(0).map(() => []);\n    }\n  }\n\n  const decimalShift = Math.log10(1 / tolerance);\n  const shiftMultiplier = Math.pow(10, decimalShift);\n\n  for (let i = 0; i < vertexCount; i++) {\n    const index = indices ? indices.getX(i) : i;\n    let hash = \"\";\n\n    for (let j = 0, l = attributeNames.length; j < l; j++) {\n      const name = attributeNames[j];\n      const attribute = geometry.getAttribute(name);\n      const itemSize = attribute.itemSize;\n\n      for (let k = 0; k < itemSize; k++) {\n        hash += `${~~(attribute[getters[k]](index) * shiftMultiplier)},`;\n      }\n    }\n\n    if (hash in hashToIndex) {\n      newIndices.push(hashToIndex[hash]);\n    } else {\n      for (let j = 0, l = attributeNames.length; j < l; j++) {\n        const name = attributeNames[j];\n        const attribute = geometry.getAttribute(name);\n        const morphAttr = geometry.morphAttributes[name];\n        const itemSize = attribute.itemSize;\n        const newarray = attrArrays[name];\n        const newMorphArrays = morphAttrsArrays[name];\n\n        for (let k = 0; k < itemSize; k++) {\n          const getterFunc = getters[k];\n          newarray.push(attribute[getterFunc](index));\n\n          if (morphAttr) {\n            for (let m = 0, ml = morphAttr.length; m < ml; m++) {\n              newMorphArrays[m].push(morphAttr[m][getterFunc](index));\n            }\n          }\n        }\n      }\n\n      hashToIndex[hash] = nextIndex;\n      newIndices.push(nextIndex);\n      nextIndex++;\n    }\n  }\n\n  const result = geometry.clone();\n\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i];\n    const oldAttribute = geometry.getAttribute(name);\n    const buffer = new oldAttribute.array.constructor(attrArrays[name]);\n    const attribute = new BufferAttribute(buffer, oldAttribute.itemSize, oldAttribute.normalized);\n    result.setAttribute(name, attribute);\n\n    if (name in morphAttrsArrays) {\n      for (let j = 0; j < morphAttrsArrays[name].length; j++) {\n        const oldMorphAttribute = geometry.morphAttributes[name][j];\n        const buffer2 = new oldMorphAttribute.array.constructor(morphAttrsArrays[name][j]);\n        const morphAttribute = new BufferAttribute(buffer2, oldMorphAttribute.itemSize, oldMorphAttribute.normalized);\n        result.morphAttributes[name][j] = morphAttribute;\n      }\n    }\n  }\n\n  result.setIndex(newIndices);\n  return result;\n}\n\nfunction toTrianglesDrawMode(geometry, drawMode) {\n  if (drawMode === TrianglesDrawMode) {\n    console.warn(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.\");\n    return geometry;\n  }\n\n  if (drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode) {\n    let index = geometry.getIndex();\n\n    if (index === null) {\n      const indices = [];\n      const position = geometry.getAttribute(\"position\");\n\n      if (position !== void 0) {\n        for (let i = 0; i < position.count; i++) {\n          indices.push(i);\n        }\n\n        geometry.setIndex(indices);\n        index = geometry.getIndex();\n      } else {\n        console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.\");\n        return geometry;\n      }\n    }\n\n    const numberOfTriangles = index.count - 2;\n    const newIndices = [];\n\n    if (index) {\n      if (drawMode === TriangleFanDrawMode) {\n        for (let i = 1; i <= numberOfTriangles; i++) {\n          newIndices.push(index.getX(0));\n          newIndices.push(index.getX(i));\n          newIndices.push(index.getX(i + 1));\n        }\n      } else {\n        for (let i = 0; i < numberOfTriangles; i++) {\n          if (i % 2 === 0) {\n            newIndices.push(index.getX(i));\n            newIndices.push(index.getX(i + 1));\n            newIndices.push(index.getX(i + 2));\n          } else {\n            newIndices.push(index.getX(i + 2));\n            newIndices.push(index.getX(i + 1));\n            newIndices.push(index.getX(i));\n          }\n        }\n      }\n    }\n\n    if (newIndices.length / 3 !== numberOfTriangles) {\n      console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.\");\n    }\n\n    const newGeometry = geometry.clone();\n    newGeometry.setIndex(newIndices);\n    newGeometry.clearGroups();\n    return newGeometry;\n  } else {\n    console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:\", drawMode);\n    return geometry;\n  }\n}\n\nfunction computeMorphedAttributes(object) {\n  if (object.geometry.isBufferGeometry !== true) {\n    console.error(\"THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.\");\n    return null;\n  }\n\n  const _vA = new Vector3();\n\n  const _vB = new Vector3();\n\n  const _vC = new Vector3();\n\n  const _tempA = new Vector3();\n\n  const _tempB = new Vector3();\n\n  const _tempC = new Vector3();\n\n  const _morphA = new Vector3();\n\n  const _morphB = new Vector3();\n\n  const _morphC = new Vector3();\n\n  function _calculateMorphedAttributeData(object2, material2, attribute, morphAttribute, morphTargetsRelative2, a2, b2, c2, modifiedAttributeArray) {\n    _vA.fromBufferAttribute(attribute, a2);\n\n    _vB.fromBufferAttribute(attribute, b2);\n\n    _vC.fromBufferAttribute(attribute, c2);\n\n    const morphInfluences = object2.morphTargetInfluences;\n\n    if ( // @ts-ignore\n    material2.morphTargets && morphAttribute && morphInfluences) {\n      _morphA.set(0, 0, 0);\n\n      _morphB.set(0, 0, 0);\n\n      _morphC.set(0, 0, 0);\n\n      for (let i2 = 0, il2 = morphAttribute.length; i2 < il2; i2++) {\n        const influence = morphInfluences[i2];\n        const morph = morphAttribute[i2];\n        if (influence === 0) continue;\n\n        _tempA.fromBufferAttribute(morph, a2);\n\n        _tempB.fromBufferAttribute(morph, b2);\n\n        _tempC.fromBufferAttribute(morph, c2);\n\n        if (morphTargetsRelative2) {\n          _morphA.addScaledVector(_tempA, influence);\n\n          _morphB.addScaledVector(_tempB, influence);\n\n          _morphC.addScaledVector(_tempC, influence);\n        } else {\n          _morphA.addScaledVector(_tempA.sub(_vA), influence);\n\n          _morphB.addScaledVector(_tempB.sub(_vB), influence);\n\n          _morphC.addScaledVector(_tempC.sub(_vC), influence);\n        }\n      }\n\n      _vA.add(_morphA);\n\n      _vB.add(_morphB);\n\n      _vC.add(_morphC);\n    }\n\n    if (object2.isSkinnedMesh) {\n      object2.boneTransform(a2, _vA);\n      object2.boneTransform(b2, _vB);\n      object2.boneTransform(c2, _vC);\n    }\n\n    modifiedAttributeArray[a2 * 3 + 0] = _vA.x;\n    modifiedAttributeArray[a2 * 3 + 1] = _vA.y;\n    modifiedAttributeArray[a2 * 3 + 2] = _vA.z;\n    modifiedAttributeArray[b2 * 3 + 0] = _vB.x;\n    modifiedAttributeArray[b2 * 3 + 1] = _vB.y;\n    modifiedAttributeArray[b2 * 3 + 2] = _vB.z;\n    modifiedAttributeArray[c2 * 3 + 0] = _vC.x;\n    modifiedAttributeArray[c2 * 3 + 1] = _vC.y;\n    modifiedAttributeArray[c2 * 3 + 2] = _vC.z;\n  }\n\n  const geometry = object.geometry;\n  const material = object.material;\n  let a, b, c;\n  const index = geometry.index;\n  const positionAttribute = geometry.attributes.position;\n  const morphPosition = geometry.morphAttributes.position;\n  const morphTargetsRelative = geometry.morphTargetsRelative;\n  const normalAttribute = geometry.attributes.normal;\n  const morphNormal = geometry.morphAttributes.position;\n  const groups = geometry.groups;\n  const drawRange = geometry.drawRange;\n  let i, j, il, jl;\n  let group, groupMaterial;\n  let start, end;\n  const modifiedPosition = new Float32Array(positionAttribute.count * positionAttribute.itemSize);\n  const modifiedNormal = new Float32Array(normalAttribute.count * normalAttribute.itemSize);\n\n  if (index !== null) {\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i];\n        groupMaterial = material[group.materialIndex];\n        start = Math.max(group.start, drawRange.start);\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = index.getX(j);\n          b = index.getX(j + 1);\n          c = index.getX(j + 2);\n\n          _calculateMorphedAttributeData(object, groupMaterial, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n\n          _calculateMorphedAttributeData(object, groupMaterial, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start);\n      end = Math.min(index.count, drawRange.start + drawRange.count);\n\n      for (i = start, il = end; i < il; i += 3) {\n        a = index.getX(i);\n        b = index.getX(i + 1);\n        c = index.getX(i + 2);\n\n        _calculateMorphedAttributeData(object, material, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n\n        _calculateMorphedAttributeData(object, material, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n      }\n    }\n  } else if (positionAttribute !== void 0) {\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i];\n        groupMaterial = material[group.materialIndex];\n        start = Math.max(group.start, drawRange.start);\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = j;\n          b = j + 1;\n          c = j + 2;\n\n          _calculateMorphedAttributeData(object, groupMaterial, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n\n          _calculateMorphedAttributeData(object, groupMaterial, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start);\n      end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);\n\n      for (i = start, il = end; i < il; i += 3) {\n        a = i;\n        b = i + 1;\n        c = i + 2;\n\n        _calculateMorphedAttributeData(object, material, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n\n        _calculateMorphedAttributeData(object, material, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n      }\n    }\n  }\n\n  const morphedPositionAttribute = new Float32BufferAttribute(modifiedPosition, 3);\n  const morphedNormalAttribute = new Float32BufferAttribute(modifiedNormal, 3);\n  return {\n    positionAttribute,\n    normalAttribute,\n    morphedPositionAttribute,\n    morphedNormalAttribute\n  };\n}\n\nfunction toCreasedNormals(geometry, creaseAngle = Math.PI / 3) {\n  const creaseDot = Math.cos(creaseAngle);\n  const hashMultiplier = (1 + 1e-10) * 100;\n  const verts = [new Vector3(), new Vector3(), new Vector3()];\n  const tempVec1 = new Vector3();\n  const tempVec2 = new Vector3();\n  const tempNorm = new Vector3();\n  const tempNorm2 = new Vector3();\n\n  function hashVertex(v) {\n    const x = ~~(v.x * hashMultiplier);\n    const y = ~~(v.y * hashMultiplier);\n    const z = ~~(v.z * hashMultiplier);\n    return `${x},${y},${z}`;\n  }\n\n  const resultGeometry = geometry.toNonIndexed();\n  const posAttr = resultGeometry.attributes.position;\n  const vertexMap = {};\n\n  for (let i = 0, l = posAttr.count / 3; i < l; i++) {\n    const i3 = 3 * i;\n    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);\n    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);\n    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);\n    tempVec1.subVectors(c, b);\n    tempVec2.subVectors(a, b);\n    const normal = new Vector3().crossVectors(tempVec1, tempVec2).normalize();\n\n    for (let n = 0; n < 3; n++) {\n      const vert = verts[n];\n      const hash = hashVertex(vert);\n\n      if (!(hash in vertexMap)) {\n        vertexMap[hash] = [];\n      }\n\n      vertexMap[hash].push(normal);\n    }\n  }\n\n  const normalArray = new Float32Array(posAttr.count * 3);\n  const normAttr = new BufferAttribute(normalArray, 3, false);\n\n  for (let i = 0, l = posAttr.count / 3; i < l; i++) {\n    const i3 = 3 * i;\n    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);\n    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);\n    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);\n    tempVec1.subVectors(c, b);\n    tempVec2.subVectors(a, b);\n    tempNorm.crossVectors(tempVec1, tempVec2).normalize();\n\n    for (let n = 0; n < 3; n++) {\n      const vert = verts[n];\n      const hash = hashVertex(vert);\n      const otherNormals = vertexMap[hash];\n      tempNorm2.set(0, 0, 0);\n\n      for (let k = 0, lk = otherNormals.length; k < lk; k++) {\n        const otherNorm = otherNormals[k];\n\n        if (tempNorm.dot(otherNorm) > creaseDot) {\n          tempNorm2.add(otherNorm);\n        }\n      }\n\n      tempNorm2.normalize();\n      normAttr.setXYZ(i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z);\n    }\n  }\n\n  resultGeometry.setAttribute(\"normal\", normAttr);\n  return resultGeometry;\n}\n\nexport { computeMorphedAttributes, estimateBytesUsed, interleaveAttributes, mergeBufferAttributes, mergeBufferGeometries, mergeVertices, toCreasedNormals, toTrianglesDrawMode };","map":{"version":3,"sources":["/Users/theodaguier/Repositories/E-Do-Studio/node_modules/three-stdlib/utils/BufferGeometryUtils.js"],"names":["BufferGeometry","BufferAttribute","InterleavedBuffer","InterleavedBufferAttribute","TrianglesDrawMode","TriangleFanDrawMode","TriangleStripDrawMode","Vector3","Float32BufferAttribute","getWithKey","mergeBufferGeometries","geometries","useGroups","isIndexed","index","attributesUsed","Set","Object","keys","attributes","morphAttributesUsed","morphAttributes","morphTargetsRelative","mergedGeometry","offset","forEach","geom","i","attributesCount","console","error","name","has","push","size","userData","mergedUserData","count","position","addGroup","indexOffset","mergedIndex","j","getX","setIndex","mergedAttribute","mergeBufferAttributes","setAttribute","numMorphTargets","length","morphAttributesToMerge","mergedMorphAttribute","TypedArray","itemSize","normalized","arrayLength","attr","array","constructor","set","interleaveAttributes","stride","l","attribute","interleavedBuffer","res","getters","setters","iba","c","k","get","estimateBytesUsed","geometry","mem","getAttribute","BYTES_PER_ELEMENT","indices","getIndex","mergeVertices","tolerance","Math","max","Number","EPSILON","hashToIndex","positions","vertexCount","nextIndex","attributeNames","attrArrays","morphAttrsArrays","newIndices","morphAttr","Array","fill","map","decimalShift","log10","shiftMultiplier","pow","hash","newarray","newMorphArrays","getterFunc","m","ml","result","clone","oldAttribute","buffer","oldMorphAttribute","buffer2","morphAttribute","toTrianglesDrawMode","drawMode","warn","numberOfTriangles","newGeometry","clearGroups","computeMorphedAttributes","object","isBufferGeometry","_vA","_vB","_vC","_tempA","_tempB","_tempC","_morphA","_morphB","_morphC","_calculateMorphedAttributeData","object2","material2","morphTargetsRelative2","a2","b2","c2","modifiedAttributeArray","fromBufferAttribute","morphInfluences","morphTargetInfluences","morphTargets","i2","il2","influence","morph","addScaledVector","sub","add","isSkinnedMesh","boneTransform","x","y","z","material","a","b","positionAttribute","morphPosition","normalAttribute","normal","morphNormal","groups","drawRange","il","jl","group","groupMaterial","start","end","modifiedPosition","Float32Array","modifiedNormal","isArray","materialIndex","min","morphedPositionAttribute","morphedNormalAttribute","toCreasedNormals","creaseAngle","PI","creaseDot","cos","hashMultiplier","verts","tempVec1","tempVec2","tempNorm","tempNorm2","hashVertex","v","resultGeometry","toNonIndexed","posAttr","vertexMap","i3","subVectors","crossVectors","normalize","n","vert","normalArray","normAttr","otherNormals","lk","otherNorm","dot","setXYZ"],"mappings":"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","sourcesContent":["import { BufferGeometry, BufferAttribute, InterleavedBuffer, InterleavedBufferAttribute, TrianglesDrawMode, TriangleFanDrawMode, TriangleStripDrawMode, Vector3, Float32BufferAttribute } from \"three\";\nimport { getWithKey } from \"../types/helpers.js\";\nconst mergeBufferGeometries = (geometries, useGroups) => {\n  const isIndexed = geometries[0].index !== null;\n  const attributesUsed = new Set(Object.keys(geometries[0].attributes));\n  const morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));\n  const attributes = {};\n  const morphAttributes = {};\n  const morphTargetsRelative = geometries[0].morphTargetsRelative;\n  const mergedGeometry = new BufferGeometry();\n  let offset = 0;\n  geometries.forEach((geom, i) => {\n    let attributesCount = 0;\n    if (isIndexed !== (geom.index !== null)) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.\"\n      );\n      return null;\n    }\n    for (let name in geom.attributes) {\n      if (!attributesUsed.has(name)) {\n        console.error(\n          \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.'\n        );\n        return null;\n      }\n      if (attributes[name] === void 0) {\n        attributes[name] = [];\n      }\n      attributes[name].push(geom.attributes[name]);\n      attributesCount++;\n    }\n    if (attributesCount !== attributesUsed.size) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". Make sure all geometries have the same number of attributes.\"\n      );\n      return null;\n    }\n    if (morphTargetsRelative !== geom.morphTargetsRelative) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". .morphTargetsRelative must be consistent throughout all geometries.\"\n      );\n      return null;\n    }\n    for (let name in geom.morphAttributes) {\n      if (!morphAttributesUsed.has(name)) {\n        console.error(\n          \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \".  .morphAttributes must be consistent throughout all geometries.\"\n        );\n        return null;\n      }\n      if (morphAttributes[name] === void 0)\n        morphAttributes[name] = [];\n      morphAttributes[name].push(geom.morphAttributes[name]);\n    }\n    mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];\n    mergedGeometry.userData.mergedUserData.push(geom.userData);\n    if (useGroups) {\n      let count;\n      if (geom.index) {\n        count = geom.index.count;\n      } else if (geom.attributes.position !== void 0) {\n        count = geom.attributes.position.count;\n      } else {\n        console.error(\n          \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". The geometry must have either an index or a position attribute\"\n        );\n        return null;\n      }\n      mergedGeometry.addGroup(offset, count, i);\n      offset += count;\n    }\n  });\n  if (isIndexed) {\n    let indexOffset = 0;\n    const mergedIndex = [];\n    geometries.forEach((geom) => {\n      const index = geom.index;\n      for (let j = 0; j < index.count; ++j) {\n        mergedIndex.push(index.getX(j) + indexOffset);\n      }\n      indexOffset += geom.attributes.position.count;\n    });\n    mergedGeometry.setIndex(mergedIndex);\n  }\n  for (let name in attributes) {\n    const mergedAttribute = mergeBufferAttributes(attributes[name]);\n    if (!mergedAttribute) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the \" + name + \" attribute.\"\n      );\n      return null;\n    }\n    mergedGeometry.setAttribute(name, mergedAttribute);\n  }\n  for (let name in morphAttributes) {\n    const numMorphTargets = morphAttributes[name][0].length;\n    if (numMorphTargets === 0)\n      break;\n    mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n    mergedGeometry.morphAttributes[name] = [];\n    for (let i = 0; i < numMorphTargets; ++i) {\n      const morphAttributesToMerge = [];\n      for (let j = 0; j < morphAttributes[name].length; ++j) {\n        morphAttributesToMerge.push(morphAttributes[name][j][i]);\n      }\n      const mergedMorphAttribute = mergeBufferAttributes(morphAttributesToMerge);\n      if (!mergedMorphAttribute) {\n        console.error(\n          \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the \" + name + \" morphAttribute.\"\n        );\n        return null;\n      }\n      mergedGeometry.morphAttributes[name].push(mergedMorphAttribute);\n    }\n  }\n  return mergedGeometry;\n};\nconst mergeBufferAttributes = (attributes) => {\n  let TypedArray = void 0;\n  let itemSize = void 0;\n  let normalized = void 0;\n  let arrayLength = 0;\n  attributes.forEach((attr) => {\n    if (TypedArray === void 0) {\n      TypedArray = attr.array.constructor;\n    }\n    if (TypedArray !== attr.array.constructor) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.\"\n      );\n      return null;\n    }\n    if (itemSize === void 0)\n      itemSize = attr.itemSize;\n    if (itemSize !== attr.itemSize) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.\"\n      );\n      return null;\n    }\n    if (normalized === void 0)\n      normalized = attr.normalized;\n    if (normalized !== attr.normalized) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.\"\n      );\n      return null;\n    }\n    arrayLength += attr.array.length;\n  });\n  if (TypedArray && itemSize) {\n    const array = new TypedArray(arrayLength);\n    let offset = 0;\n    attributes.forEach((attr) => {\n      array.set(attr.array, offset);\n      offset += attr.array.length;\n    });\n    return new BufferAttribute(array, itemSize, normalized);\n  }\n};\nconst interleaveAttributes = (attributes) => {\n  let TypedArray = void 0;\n  let arrayLength = 0;\n  let stride = 0;\n  for (let i = 0, l = attributes.length; i < l; ++i) {\n    const attribute = attributes[i];\n    if (TypedArray === void 0)\n      TypedArray = attribute.array.constructor;\n    if (TypedArray !== attribute.array.constructor) {\n      console.error(\"AttributeBuffers of different types cannot be interleaved\");\n      return null;\n    }\n    arrayLength += attribute.array.length;\n    stride += attribute.itemSize;\n  }\n  const interleavedBuffer = new InterleavedBuffer(new TypedArray(arrayLength), stride);\n  let offset = 0;\n  const res = [];\n  const getters = [\"getX\", \"getY\", \"getZ\", \"getW\"];\n  const setters = [\"setX\", \"setY\", \"setZ\", \"setW\"];\n  for (let j = 0, l = attributes.length; j < l; j++) {\n    const attribute = attributes[j];\n    const itemSize = attribute.itemSize;\n    const count = attribute.count;\n    const iba = new InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, attribute.normalized);\n    res.push(iba);\n    offset += itemSize;\n    for (let c = 0; c < count; c++) {\n      for (let k = 0; k < itemSize; k++) {\n        const set = getWithKey(iba, setters[k]);\n        const get = getWithKey(attribute, getters[k]);\n        set(c, get(c));\n      }\n    }\n  }\n  return res;\n};\nfunction estimateBytesUsed(geometry) {\n  let mem = 0;\n  for (let name in geometry.attributes) {\n    const attr = geometry.getAttribute(name);\n    mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n  }\n  const indices = geometry.getIndex();\n  mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n  return mem;\n}\nfunction mergeVertices(geometry, tolerance = 1e-4) {\n  tolerance = Math.max(tolerance, Number.EPSILON);\n  const hashToIndex = {};\n  const indices = geometry.getIndex();\n  const positions = geometry.getAttribute(\"position\");\n  const vertexCount = indices ? indices.count : positions.count;\n  let nextIndex = 0;\n  const attributeNames = Object.keys(geometry.attributes);\n  const attrArrays = {};\n  const morphAttrsArrays = {};\n  const newIndices = [];\n  const getters = [\"getX\", \"getY\", \"getZ\", \"getW\"];\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i];\n    attrArrays[name] = [];\n    const morphAttr = geometry.morphAttributes[name];\n    if (morphAttr) {\n      morphAttrsArrays[name] = new Array(morphAttr.length).fill(0).map(() => []);\n    }\n  }\n  const decimalShift = Math.log10(1 / tolerance);\n  const shiftMultiplier = Math.pow(10, decimalShift);\n  for (let i = 0; i < vertexCount; i++) {\n    const index = indices ? indices.getX(i) : i;\n    let hash = \"\";\n    for (let j = 0, l = attributeNames.length; j < l; j++) {\n      const name = attributeNames[j];\n      const attribute = geometry.getAttribute(name);\n      const itemSize = attribute.itemSize;\n      for (let k = 0; k < itemSize; k++) {\n        hash += `${~~(attribute[getters[k]](index) * shiftMultiplier)},`;\n      }\n    }\n    if (hash in hashToIndex) {\n      newIndices.push(hashToIndex[hash]);\n    } else {\n      for (let j = 0, l = attributeNames.length; j < l; j++) {\n        const name = attributeNames[j];\n        const attribute = geometry.getAttribute(name);\n        const morphAttr = geometry.morphAttributes[name];\n        const itemSize = attribute.itemSize;\n        const newarray = attrArrays[name];\n        const newMorphArrays = morphAttrsArrays[name];\n        for (let k = 0; k < itemSize; k++) {\n          const getterFunc = getters[k];\n          newarray.push(attribute[getterFunc](index));\n          if (morphAttr) {\n            for (let m = 0, ml = morphAttr.length; m < ml; m++) {\n              newMorphArrays[m].push(morphAttr[m][getterFunc](index));\n            }\n          }\n        }\n      }\n      hashToIndex[hash] = nextIndex;\n      newIndices.push(nextIndex);\n      nextIndex++;\n    }\n  }\n  const result = geometry.clone();\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i];\n    const oldAttribute = geometry.getAttribute(name);\n    const buffer = new oldAttribute.array.constructor(attrArrays[name]);\n    const attribute = new BufferAttribute(buffer, oldAttribute.itemSize, oldAttribute.normalized);\n    result.setAttribute(name, attribute);\n    if (name in morphAttrsArrays) {\n      for (let j = 0; j < morphAttrsArrays[name].length; j++) {\n        const oldMorphAttribute = geometry.morphAttributes[name][j];\n        const buffer2 = new oldMorphAttribute.array.constructor(morphAttrsArrays[name][j]);\n        const morphAttribute = new BufferAttribute(buffer2, oldMorphAttribute.itemSize, oldMorphAttribute.normalized);\n        result.morphAttributes[name][j] = morphAttribute;\n      }\n    }\n  }\n  result.setIndex(newIndices);\n  return result;\n}\nfunction toTrianglesDrawMode(geometry, drawMode) {\n  if (drawMode === TrianglesDrawMode) {\n    console.warn(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.\");\n    return geometry;\n  }\n  if (drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode) {\n    let index = geometry.getIndex();\n    if (index === null) {\n      const indices = [];\n      const position = geometry.getAttribute(\"position\");\n      if (position !== void 0) {\n        for (let i = 0; i < position.count; i++) {\n          indices.push(i);\n        }\n        geometry.setIndex(indices);\n        index = geometry.getIndex();\n      } else {\n        console.error(\n          \"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.\"\n        );\n        return geometry;\n      }\n    }\n    const numberOfTriangles = index.count - 2;\n    const newIndices = [];\n    if (index) {\n      if (drawMode === TriangleFanDrawMode) {\n        for (let i = 1; i <= numberOfTriangles; i++) {\n          newIndices.push(index.getX(0));\n          newIndices.push(index.getX(i));\n          newIndices.push(index.getX(i + 1));\n        }\n      } else {\n        for (let i = 0; i < numberOfTriangles; i++) {\n          if (i % 2 === 0) {\n            newIndices.push(index.getX(i));\n            newIndices.push(index.getX(i + 1));\n            newIndices.push(index.getX(i + 2));\n          } else {\n            newIndices.push(index.getX(i + 2));\n            newIndices.push(index.getX(i + 1));\n            newIndices.push(index.getX(i));\n          }\n        }\n      }\n    }\n    if (newIndices.length / 3 !== numberOfTriangles) {\n      console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.\");\n    }\n    const newGeometry = geometry.clone();\n    newGeometry.setIndex(newIndices);\n    newGeometry.clearGroups();\n    return newGeometry;\n  } else {\n    console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:\", drawMode);\n    return geometry;\n  }\n}\nfunction computeMorphedAttributes(object) {\n  if (object.geometry.isBufferGeometry !== true) {\n    console.error(\"THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.\");\n    return null;\n  }\n  const _vA = new Vector3();\n  const _vB = new Vector3();\n  const _vC = new Vector3();\n  const _tempA = new Vector3();\n  const _tempB = new Vector3();\n  const _tempC = new Vector3();\n  const _morphA = new Vector3();\n  const _morphB = new Vector3();\n  const _morphC = new Vector3();\n  function _calculateMorphedAttributeData(object2, material2, attribute, morphAttribute, morphTargetsRelative2, a2, b2, c2, modifiedAttributeArray) {\n    _vA.fromBufferAttribute(attribute, a2);\n    _vB.fromBufferAttribute(attribute, b2);\n    _vC.fromBufferAttribute(attribute, c2);\n    const morphInfluences = object2.morphTargetInfluences;\n    if (\n      // @ts-ignore\n      material2.morphTargets && morphAttribute && morphInfluences\n    ) {\n      _morphA.set(0, 0, 0);\n      _morphB.set(0, 0, 0);\n      _morphC.set(0, 0, 0);\n      for (let i2 = 0, il2 = morphAttribute.length; i2 < il2; i2++) {\n        const influence = morphInfluences[i2];\n        const morph = morphAttribute[i2];\n        if (influence === 0)\n          continue;\n        _tempA.fromBufferAttribute(morph, a2);\n        _tempB.fromBufferAttribute(morph, b2);\n        _tempC.fromBufferAttribute(morph, c2);\n        if (morphTargetsRelative2) {\n          _morphA.addScaledVector(_tempA, influence);\n          _morphB.addScaledVector(_tempB, influence);\n          _morphC.addScaledVector(_tempC, influence);\n        } else {\n          _morphA.addScaledVector(_tempA.sub(_vA), influence);\n          _morphB.addScaledVector(_tempB.sub(_vB), influence);\n          _morphC.addScaledVector(_tempC.sub(_vC), influence);\n        }\n      }\n      _vA.add(_morphA);\n      _vB.add(_morphB);\n      _vC.add(_morphC);\n    }\n    if (object2.isSkinnedMesh) {\n      object2.boneTransform(a2, _vA);\n      object2.boneTransform(b2, _vB);\n      object2.boneTransform(c2, _vC);\n    }\n    modifiedAttributeArray[a2 * 3 + 0] = _vA.x;\n    modifiedAttributeArray[a2 * 3 + 1] = _vA.y;\n    modifiedAttributeArray[a2 * 3 + 2] = _vA.z;\n    modifiedAttributeArray[b2 * 3 + 0] = _vB.x;\n    modifiedAttributeArray[b2 * 3 + 1] = _vB.y;\n    modifiedAttributeArray[b2 * 3 + 2] = _vB.z;\n    modifiedAttributeArray[c2 * 3 + 0] = _vC.x;\n    modifiedAttributeArray[c2 * 3 + 1] = _vC.y;\n    modifiedAttributeArray[c2 * 3 + 2] = _vC.z;\n  }\n  const geometry = object.geometry;\n  const material = object.material;\n  let a, b, c;\n  const index = geometry.index;\n  const positionAttribute = geometry.attributes.position;\n  const morphPosition = geometry.morphAttributes.position;\n  const morphTargetsRelative = geometry.morphTargetsRelative;\n  const normalAttribute = geometry.attributes.normal;\n  const morphNormal = geometry.morphAttributes.position;\n  const groups = geometry.groups;\n  const drawRange = geometry.drawRange;\n  let i, j, il, jl;\n  let group, groupMaterial;\n  let start, end;\n  const modifiedPosition = new Float32Array(positionAttribute.count * positionAttribute.itemSize);\n  const modifiedNormal = new Float32Array(normalAttribute.count * normalAttribute.itemSize);\n  if (index !== null) {\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i];\n        groupMaterial = material[group.materialIndex];\n        start = Math.max(group.start, drawRange.start);\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = index.getX(j);\n          b = index.getX(j + 1);\n          c = index.getX(j + 2);\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            positionAttribute,\n            morphPosition,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedPosition\n          );\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            normalAttribute,\n            morphNormal,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedNormal\n          );\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start);\n      end = Math.min(index.count, drawRange.start + drawRange.count);\n      for (i = start, il = end; i < il; i += 3) {\n        a = index.getX(i);\n        b = index.getX(i + 1);\n        c = index.getX(i + 2);\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          positionAttribute,\n          morphPosition,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedPosition\n        );\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          normalAttribute,\n          morphNormal,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedNormal\n        );\n      }\n    }\n  } else if (positionAttribute !== void 0) {\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i];\n        groupMaterial = material[group.materialIndex];\n        start = Math.max(group.start, drawRange.start);\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = j;\n          b = j + 1;\n          c = j + 2;\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            positionAttribute,\n            morphPosition,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedPosition\n          );\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            normalAttribute,\n            morphNormal,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedNormal\n          );\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start);\n      end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);\n      for (i = start, il = end; i < il; i += 3) {\n        a = i;\n        b = i + 1;\n        c = i + 2;\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          positionAttribute,\n          morphPosition,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedPosition\n        );\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          normalAttribute,\n          morphNormal,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedNormal\n        );\n      }\n    }\n  }\n  const morphedPositionAttribute = new Float32BufferAttribute(modifiedPosition, 3);\n  const morphedNormalAttribute = new Float32BufferAttribute(modifiedNormal, 3);\n  return {\n    positionAttribute,\n    normalAttribute,\n    morphedPositionAttribute,\n    morphedNormalAttribute\n  };\n}\nfunction toCreasedNormals(geometry, creaseAngle = Math.PI / 3) {\n  const creaseDot = Math.cos(creaseAngle);\n  const hashMultiplier = (1 + 1e-10) * 100;\n  const verts = [new Vector3(), new Vector3(), new Vector3()];\n  const tempVec1 = new Vector3();\n  const tempVec2 = new Vector3();\n  const tempNorm = new Vector3();\n  const tempNorm2 = new Vector3();\n  function hashVertex(v) {\n    const x = ~~(v.x * hashMultiplier);\n    const y = ~~(v.y * hashMultiplier);\n    const z = ~~(v.z * hashMultiplier);\n    return `${x},${y},${z}`;\n  }\n  const resultGeometry = geometry.toNonIndexed();\n  const posAttr = resultGeometry.attributes.position;\n  const vertexMap = {};\n  for (let i = 0, l = posAttr.count / 3; i < l; i++) {\n    const i3 = 3 * i;\n    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);\n    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);\n    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);\n    tempVec1.subVectors(c, b);\n    tempVec2.subVectors(a, b);\n    const normal = new Vector3().crossVectors(tempVec1, tempVec2).normalize();\n    for (let n = 0; n < 3; n++) {\n      const vert = verts[n];\n      const hash = hashVertex(vert);\n      if (!(hash in vertexMap)) {\n        vertexMap[hash] = [];\n      }\n      vertexMap[hash].push(normal);\n    }\n  }\n  const normalArray = new Float32Array(posAttr.count * 3);\n  const normAttr = new BufferAttribute(normalArray, 3, false);\n  for (let i = 0, l = posAttr.count / 3; i < l; i++) {\n    const i3 = 3 * i;\n    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);\n    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);\n    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);\n    tempVec1.subVectors(c, b);\n    tempVec2.subVectors(a, b);\n    tempNorm.crossVectors(tempVec1, tempVec2).normalize();\n    for (let n = 0; n < 3; n++) {\n      const vert = verts[n];\n      const hash = hashVertex(vert);\n      const otherNormals = vertexMap[hash];\n      tempNorm2.set(0, 0, 0);\n      for (let k = 0, lk = otherNormals.length; k < lk; k++) {\n        const otherNorm = otherNormals[k];\n        if (tempNorm.dot(otherNorm) > creaseDot) {\n          tempNorm2.add(otherNorm);\n        }\n      }\n      tempNorm2.normalize();\n      normAttr.setXYZ(i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z);\n    }\n  }\n  resultGeometry.setAttribute(\"normal\", normAttr);\n  return resultGeometry;\n}\nexport {\n  computeMorphedAttributes,\n  estimateBytesUsed,\n  interleaveAttributes,\n  mergeBufferAttributes,\n  mergeBufferGeometries,\n  mergeVertices,\n  toCreasedNormals,\n  toTrianglesDrawMode\n};\n"]},"metadata":{},"sourceType":"module"}