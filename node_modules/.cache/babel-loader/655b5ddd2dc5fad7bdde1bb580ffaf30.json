{"ast":null,"code":"import { Mesh, MathUtils } from \"three\";\n\nclass MorphBlendMesh extends Mesh {\n  constructor(geometry, material) {\n    super(geometry, material);\n    this.animationsMap = {};\n    this.animationsList = [];\n    const numFrames = Object.keys(this.morphTargetDictionary).length;\n    const name = \"__default\";\n    const startFrame = 0;\n    const endFrame = numFrames - 1;\n    const fps = numFrames / 1;\n    this.createAnimation(name, startFrame, endFrame, fps);\n    this.setAnimationWeight(name, 1);\n  }\n\n  createAnimation(name, start, end, fps) {\n    const animation = {\n      start,\n      end,\n      length: end - start + 1,\n      fps,\n      duration: (end - start) / fps,\n      lastFrame: 0,\n      currentFrame: 0,\n      active: false,\n      time: 0,\n      direction: 1,\n      weight: 1,\n      directionBackwards: false,\n      mirroredLoop: false\n    };\n    this.animationsMap[name] = animation;\n    this.animationsList.push(animation);\n  }\n\n  autoCreateAnimations(fps) {\n    const pattern = /([a-z]+)_?(\\d+)/i;\n    let firstAnimation;\n    const frameRanges = {};\n    let i = 0;\n\n    for (const key in this.morphTargetDictionary) {\n      const chunks = key.match(pattern);\n\n      if (chunks && chunks.length > 1) {\n        const name = chunks[1];\n        if (!frameRanges[name]) frameRanges[name] = {\n          start: Infinity,\n          end: -Infinity\n        };\n        const range = frameRanges[name];\n        if (i < range.start) range.start = i;\n        if (i > range.end) range.end = i;\n        if (!firstAnimation) firstAnimation = name;\n      }\n\n      i++;\n    }\n\n    for (const name in frameRanges) {\n      const range = frameRanges[name];\n      this.createAnimation(name, range.start, range.end, fps);\n    }\n\n    this.firstAnimation = firstAnimation;\n  }\n\n  setAnimationDirectionForward(name) {\n    const animation = this.animationsMap[name];\n\n    if (animation) {\n      animation.direction = 1;\n      animation.directionBackwards = false;\n    }\n  }\n\n  setAnimationDirectionBackward(name) {\n    const animation = this.animationsMap[name];\n\n    if (animation) {\n      animation.direction = -1;\n      animation.directionBackwards = true;\n    }\n  }\n\n  setAnimationFPS(name, fps) {\n    const animation = this.animationsMap[name];\n\n    if (animation) {\n      animation.fps = fps;\n      animation.duration = (animation.end - animation.start) / animation.fps;\n    }\n  }\n\n  setAnimationDuration(name, duration) {\n    const animation = this.animationsMap[name];\n\n    if (animation) {\n      animation.duration = duration;\n      animation.fps = (animation.end - animation.start) / animation.duration;\n    }\n  }\n\n  setAnimationWeight(name, weight) {\n    const animation = this.animationsMap[name];\n\n    if (animation) {\n      animation.weight = weight;\n    }\n  }\n\n  setAnimationTime(name, time) {\n    const animation = this.animationsMap[name];\n\n    if (animation) {\n      animation.time = time;\n    }\n  }\n\n  getAnimationTime(name) {\n    let time = 0;\n    const animation = this.animationsMap[name];\n\n    if (animation) {\n      time = animation.time;\n    }\n\n    return time;\n  }\n\n  getAnimationDuration(name) {\n    let duration = -1;\n    const animation = this.animationsMap[name];\n\n    if (animation) {\n      duration = animation.duration;\n    }\n\n    return duration;\n  }\n\n  playAnimation(name) {\n    const animation = this.animationsMap[name];\n\n    if (animation) {\n      animation.time = 0;\n      animation.active = true;\n    } else {\n      console.warn(\"THREE.MorphBlendMesh: animation[\" + name + \"] undefined in .playAnimation()\");\n    }\n  }\n\n  stopAnimation(name) {\n    const animation = this.animationsMap[name];\n\n    if (animation) {\n      animation.active = false;\n    }\n  }\n\n  update(delta) {\n    for (let i = 0, il = this.animationsList.length; i < il; i++) {\n      const animation = this.animationsList[i];\n      if (!animation.active) continue;\n      const frameTime = animation.duration / animation.length;\n      animation.time += animation.direction * delta;\n\n      if (animation.mirroredLoop) {\n        if (animation.time > animation.duration || animation.time < 0) {\n          animation.direction *= -1;\n\n          if (animation.time > animation.duration) {\n            animation.time = animation.duration;\n            animation.directionBackwards = true;\n          }\n\n          if (animation.time < 0) {\n            animation.time = 0;\n            animation.directionBackwards = false;\n          }\n        }\n      } else {\n        animation.time = animation.time % animation.duration;\n        if (animation.time < 0) animation.time += animation.duration;\n      }\n\n      const keyframe = animation.start + MathUtils.clamp(Math.floor(animation.time / frameTime), 0, animation.length - 1);\n      const weight = animation.weight;\n\n      if (keyframe !== animation.currentFrame) {\n        this.morphTargetInfluences[animation.lastFrame] = 0;\n        this.morphTargetInfluences[animation.currentFrame] = 1 * weight;\n        this.morphTargetInfluences[keyframe] = 0;\n        animation.lastFrame = animation.currentFrame;\n        animation.currentFrame = keyframe;\n      }\n\n      let mix = animation.time % frameTime / frameTime;\n      if (animation.directionBackwards) mix = 1 - mix;\n\n      if (animation.currentFrame !== animation.lastFrame) {\n        this.morphTargetInfluences[animation.currentFrame] = mix * weight;\n        this.morphTargetInfluences[animation.lastFrame] = (1 - mix) * weight;\n      } else {\n        this.morphTargetInfluences[animation.currentFrame] = weight;\n      }\n    }\n  }\n\n}\n\nexport { MorphBlendMesh };","map":{"version":3,"sources":["/Users/theodaguier/Developer/old/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/three-stdlib/misc/MorphBlendMesh.js"],"names":["Mesh","MathUtils","MorphBlendMesh","constructor","geometry","material","animationsMap","animationsList","numFrames","Object","keys","morphTargetDictionary","length","name","startFrame","endFrame","fps","createAnimation","setAnimationWeight","start","end","animation","duration","lastFrame","currentFrame","active","time","direction","weight","directionBackwards","mirroredLoop","push","autoCreateAnimations","pattern","firstAnimation","frameRanges","i","key","chunks","match","Infinity","range","setAnimationDirectionForward","setAnimationDirectionBackward","setAnimationFPS","setAnimationDuration","setAnimationTime","getAnimationTime","getAnimationDuration","playAnimation","console","warn","stopAnimation","update","delta","il","frameTime","keyframe","clamp","Math","floor","morphTargetInfluences","mix"],"mappings":"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","sourcesContent":["import { Mesh, MathUtils } from \"three\";\nclass MorphBlendMesh extends Mesh {\n  constructor(geometry, material) {\n    super(geometry, material);\n    this.animationsMap = {};\n    this.animationsList = [];\n    const numFrames = Object.keys(this.morphTargetDictionary).length;\n    const name = \"__default\";\n    const startFrame = 0;\n    const endFrame = numFrames - 1;\n    const fps = numFrames / 1;\n    this.createAnimation(name, startFrame, endFrame, fps);\n    this.setAnimationWeight(name, 1);\n  }\n  createAnimation(name, start, end, fps) {\n    const animation = {\n      start,\n      end,\n      length: end - start + 1,\n      fps,\n      duration: (end - start) / fps,\n      lastFrame: 0,\n      currentFrame: 0,\n      active: false,\n      time: 0,\n      direction: 1,\n      weight: 1,\n      directionBackwards: false,\n      mirroredLoop: false\n    };\n    this.animationsMap[name] = animation;\n    this.animationsList.push(animation);\n  }\n  autoCreateAnimations(fps) {\n    const pattern = /([a-z]+)_?(\\d+)/i;\n    let firstAnimation;\n    const frameRanges = {};\n    let i = 0;\n    for (const key in this.morphTargetDictionary) {\n      const chunks = key.match(pattern);\n      if (chunks && chunks.length > 1) {\n        const name = chunks[1];\n        if (!frameRanges[name])\n          frameRanges[name] = { start: Infinity, end: -Infinity };\n        const range = frameRanges[name];\n        if (i < range.start)\n          range.start = i;\n        if (i > range.end)\n          range.end = i;\n        if (!firstAnimation)\n          firstAnimation = name;\n      }\n      i++;\n    }\n    for (const name in frameRanges) {\n      const range = frameRanges[name];\n      this.createAnimation(name, range.start, range.end, fps);\n    }\n    this.firstAnimation = firstAnimation;\n  }\n  setAnimationDirectionForward(name) {\n    const animation = this.animationsMap[name];\n    if (animation) {\n      animation.direction = 1;\n      animation.directionBackwards = false;\n    }\n  }\n  setAnimationDirectionBackward(name) {\n    const animation = this.animationsMap[name];\n    if (animation) {\n      animation.direction = -1;\n      animation.directionBackwards = true;\n    }\n  }\n  setAnimationFPS(name, fps) {\n    const animation = this.animationsMap[name];\n    if (animation) {\n      animation.fps = fps;\n      animation.duration = (animation.end - animation.start) / animation.fps;\n    }\n  }\n  setAnimationDuration(name, duration) {\n    const animation = this.animationsMap[name];\n    if (animation) {\n      animation.duration = duration;\n      animation.fps = (animation.end - animation.start) / animation.duration;\n    }\n  }\n  setAnimationWeight(name, weight) {\n    const animation = this.animationsMap[name];\n    if (animation) {\n      animation.weight = weight;\n    }\n  }\n  setAnimationTime(name, time) {\n    const animation = this.animationsMap[name];\n    if (animation) {\n      animation.time = time;\n    }\n  }\n  getAnimationTime(name) {\n    let time = 0;\n    const animation = this.animationsMap[name];\n    if (animation) {\n      time = animation.time;\n    }\n    return time;\n  }\n  getAnimationDuration(name) {\n    let duration = -1;\n    const animation = this.animationsMap[name];\n    if (animation) {\n      duration = animation.duration;\n    }\n    return duration;\n  }\n  playAnimation(name) {\n    const animation = this.animationsMap[name];\n    if (animation) {\n      animation.time = 0;\n      animation.active = true;\n    } else {\n      console.warn(\"THREE.MorphBlendMesh: animation[\" + name + \"] undefined in .playAnimation()\");\n    }\n  }\n  stopAnimation(name) {\n    const animation = this.animationsMap[name];\n    if (animation) {\n      animation.active = false;\n    }\n  }\n  update(delta) {\n    for (let i = 0, il = this.animationsList.length; i < il; i++) {\n      const animation = this.animationsList[i];\n      if (!animation.active)\n        continue;\n      const frameTime = animation.duration / animation.length;\n      animation.time += animation.direction * delta;\n      if (animation.mirroredLoop) {\n        if (animation.time > animation.duration || animation.time < 0) {\n          animation.direction *= -1;\n          if (animation.time > animation.duration) {\n            animation.time = animation.duration;\n            animation.directionBackwards = true;\n          }\n          if (animation.time < 0) {\n            animation.time = 0;\n            animation.directionBackwards = false;\n          }\n        }\n      } else {\n        animation.time = animation.time % animation.duration;\n        if (animation.time < 0)\n          animation.time += animation.duration;\n      }\n      const keyframe = animation.start + MathUtils.clamp(Math.floor(animation.time / frameTime), 0, animation.length - 1);\n      const weight = animation.weight;\n      if (keyframe !== animation.currentFrame) {\n        this.morphTargetInfluences[animation.lastFrame] = 0;\n        this.morphTargetInfluences[animation.currentFrame] = 1 * weight;\n        this.morphTargetInfluences[keyframe] = 0;\n        animation.lastFrame = animation.currentFrame;\n        animation.currentFrame = keyframe;\n      }\n      let mix = animation.time % frameTime / frameTime;\n      if (animation.directionBackwards)\n        mix = 1 - mix;\n      if (animation.currentFrame !== animation.lastFrame) {\n        this.morphTargetInfluences[animation.currentFrame] = mix * weight;\n        this.morphTargetInfluences[animation.lastFrame] = (1 - mix) * weight;\n      } else {\n        this.morphTargetInfluences[animation.currentFrame] = weight;\n      }\n    }\n  }\n}\nexport {\n  MorphBlendMesh\n};\n"]},"metadata":{},"sourceType":"module"}