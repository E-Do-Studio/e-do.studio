{"ast":null,"code":"import { Matrix4, Object3D, Vector3, EventDispatcher, BufferGeometry, Float32BufferAttribute, MathUtils, Matrix3, Color, Vector2, Box3, Sphere, BufferAttribute } from \"three\";\n\nconst _m1 = /* @__PURE__ */new Matrix4();\n\nconst _obj = /* @__PURE__ */new Object3D();\n\nconst _offset = /* @__PURE__ */new Vector3();\n\nclass Geometry extends EventDispatcher {\n  static createBufferGeometryFromObject(object) {\n    let buffergeometry = new BufferGeometry();\n    const geometry = object.geometry;\n\n    if (object.isPoints || object.isLine) {\n      const positions = new Float32BufferAttribute(geometry.vertices.length * 3, 3);\n      const colors = new Float32BufferAttribute(geometry.colors.length * 3, 3);\n      buffergeometry.setAttribute(\"position\", positions.copyVector3sArray(geometry.vertices));\n      buffergeometry.setAttribute(\"color\", colors.copyColorsArray(geometry.colors));\n\n      if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {\n        const lineDistances = new Float32BufferAttribute(geometry.lineDistances.length, 1);\n        buffergeometry.setAttribute(\"lineDistance\", lineDistances.copyArray(geometry.lineDistances));\n      }\n\n      if (geometry.boundingSphere !== null) {\n        buffergeometry.boundingSphere = geometry.boundingSphere.clone();\n      }\n\n      if (geometry.boundingBox !== null) {\n        buffergeometry.boundingBox = geometry.boundingBox.clone();\n      }\n    } else if (object.isMesh) {\n      buffergeometry = geometry.toBufferGeometry();\n    }\n\n    return buffergeometry;\n  }\n\n  constructor() {\n    super();\n    this.isGeometry = true;\n    this.uuid = MathUtils.generateUUID();\n    this.name = \"\";\n    this.type = \"Geometry\";\n    this.vertices = [];\n    this.colors = [];\n    this.faces = [];\n    this.faceVertexUvs = [[]];\n    this.morphTargets = [];\n    this.morphNormals = [];\n    this.skinWeights = [];\n    this.skinIndices = [];\n    this.lineDistances = [];\n    this.boundingBox = null;\n    this.boundingSphere = null;\n    this.elementsNeedUpdate = false;\n    this.verticesNeedUpdate = false;\n    this.uvsNeedUpdate = false;\n    this.normalsNeedUpdate = false;\n    this.colorsNeedUpdate = false;\n    this.lineDistancesNeedUpdate = false;\n    this.groupsNeedUpdate = false;\n  }\n\n  applyMatrix4(matrix) {\n    const normalMatrix = new Matrix3().getNormalMatrix(matrix);\n\n    for (let i = 0, il = this.vertices.length; i < il; i++) {\n      const vertex = this.vertices[i];\n      vertex.applyMatrix4(matrix);\n    }\n\n    for (let i = 0, il = this.faces.length; i < il; i++) {\n      const face = this.faces[i];\n      face.normal.applyMatrix3(normalMatrix).normalize();\n\n      for (let j = 0, jl = face.vertexNormals.length; j < jl; j++) {\n        face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();\n      }\n    }\n\n    if (this.boundingBox !== null) {\n      this.computeBoundingBox();\n    }\n\n    if (this.boundingSphere !== null) {\n      this.computeBoundingSphere();\n    }\n\n    this.verticesNeedUpdate = true;\n    this.normalsNeedUpdate = true;\n    return this;\n  }\n\n  rotateX(angle) {\n    _m1.makeRotationX(angle);\n\n    this.applyMatrix4(_m1);\n    return this;\n  }\n\n  rotateY(angle) {\n    _m1.makeRotationY(angle);\n\n    this.applyMatrix4(_m1);\n    return this;\n  }\n\n  rotateZ(angle) {\n    _m1.makeRotationZ(angle);\n\n    this.applyMatrix4(_m1);\n    return this;\n  }\n\n  translate(x, y, z) {\n    _m1.makeTranslation(x, y, z);\n\n    this.applyMatrix4(_m1);\n    return this;\n  }\n\n  scale(x, y, z) {\n    _m1.makeScale(x, y, z);\n\n    this.applyMatrix4(_m1);\n    return this;\n  }\n\n  lookAt(vector) {\n    _obj.lookAt(vector);\n\n    _obj.updateMatrix();\n\n    this.applyMatrix4(_obj.matrix);\n    return this;\n  }\n\n  fromBufferGeometry(geometry) {\n    const scope = this;\n    const index = geometry.index !== null ? geometry.index : void 0;\n    const attributes = geometry.attributes;\n\n    if (attributes.position === void 0) {\n      console.error(\"THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.\");\n      return this;\n    }\n\n    const position = attributes.position;\n    const normal = attributes.normal;\n    const color = attributes.color;\n    const uv = attributes.uv;\n    const uv2 = attributes.uv2;\n    if (uv2 !== void 0) this.faceVertexUvs[1] = [];\n\n    for (let i = 0; i < position.count; i++) {\n      scope.vertices.push(new Vector3().fromBufferAttribute(position, i));\n\n      if (color !== void 0) {\n        scope.colors.push(new Color().fromBufferAttribute(color, i));\n      }\n    }\n\n    function addFace(a, b, c, materialIndex) {\n      const vertexColors = color === void 0 ? [] : [scope.colors[a].clone(), scope.colors[b].clone(), scope.colors[c].clone()];\n      const vertexNormals = normal === void 0 ? [] : [new Vector3().fromBufferAttribute(normal, a), new Vector3().fromBufferAttribute(normal, b), new Vector3().fromBufferAttribute(normal, c)];\n      const face = new Face3(a, b, c, vertexNormals, vertexColors, materialIndex);\n      scope.faces.push(face);\n\n      if (uv !== void 0) {\n        scope.faceVertexUvs[0].push([new Vector2().fromBufferAttribute(uv, a), new Vector2().fromBufferAttribute(uv, b), new Vector2().fromBufferAttribute(uv, c)]);\n      }\n\n      if (uv2 !== void 0) {\n        scope.faceVertexUvs[1].push([new Vector2().fromBufferAttribute(uv2, a), new Vector2().fromBufferAttribute(uv2, b), new Vector2().fromBufferAttribute(uv2, c)]);\n      }\n    }\n\n    const groups = geometry.groups;\n\n    if (groups.length > 0) {\n      for (let i = 0; i < groups.length; i++) {\n        const group = groups[i];\n        const start = group.start;\n        const count = group.count;\n\n        for (let j = start, jl = start + count; j < jl; j += 3) {\n          if (index !== void 0) {\n            addFace(index.getX(j), index.getX(j + 1), index.getX(j + 2), group.materialIndex);\n          } else {\n            addFace(j, j + 1, j + 2, group.materialIndex);\n          }\n        }\n      }\n    } else {\n      if (index !== void 0) {\n        for (let i = 0; i < index.count; i += 3) {\n          addFace(index.getX(i), index.getX(i + 1), index.getX(i + 2));\n        }\n      } else {\n        for (let i = 0; i < position.count; i += 3) {\n          addFace(i, i + 1, i + 2);\n        }\n      }\n    }\n\n    this.computeFaceNormals();\n\n    if (geometry.boundingBox !== null) {\n      this.boundingBox = geometry.boundingBox.clone();\n    }\n\n    if (geometry.boundingSphere !== null) {\n      this.boundingSphere = geometry.boundingSphere.clone();\n    }\n\n    return this;\n  }\n\n  center() {\n    this.computeBoundingBox();\n    this.boundingBox.getCenter(_offset).negate();\n    this.translate(_offset.x, _offset.y, _offset.z);\n    return this;\n  }\n\n  normalize() {\n    this.computeBoundingSphere();\n    const center = this.boundingSphere.center;\n    const radius = this.boundingSphere.radius;\n    const s = radius === 0 ? 1 : 1 / radius;\n    const matrix = new Matrix4();\n    matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1);\n    this.applyMatrix4(matrix);\n    return this;\n  }\n\n  computeFaceNormals() {\n    const cb = new Vector3(),\n          ab = new Vector3();\n\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n      const vA = this.vertices[face.a];\n      const vB = this.vertices[face.b];\n      const vC = this.vertices[face.c];\n      cb.subVectors(vC, vB);\n      ab.subVectors(vA, vB);\n      cb.cross(ab);\n      cb.normalize();\n      face.normal.copy(cb);\n    }\n  }\n\n  computeVertexNormals(areaWeighted = true) {\n    const vertices = new Array(this.vertices.length);\n\n    for (let v = 0, vl = this.vertices.length; v < vl; v++) {\n      vertices[v] = new Vector3();\n    }\n\n    if (areaWeighted) {\n      const cb = new Vector3(),\n            ab = new Vector3();\n\n      for (let f = 0, fl = this.faces.length; f < fl; f++) {\n        const face = this.faces[f];\n        const vA = this.vertices[face.a];\n        const vB = this.vertices[face.b];\n        const vC = this.vertices[face.c];\n        cb.subVectors(vC, vB);\n        ab.subVectors(vA, vB);\n        cb.cross(ab);\n        vertices[face.a].add(cb);\n        vertices[face.b].add(cb);\n        vertices[face.c].add(cb);\n      }\n    } else {\n      this.computeFaceNormals();\n\n      for (let f = 0, fl = this.faces.length; f < fl; f++) {\n        const face = this.faces[f];\n        vertices[face.a].add(face.normal);\n        vertices[face.b].add(face.normal);\n        vertices[face.c].add(face.normal);\n      }\n    }\n\n    for (let v = 0, vl = this.vertices.length; v < vl; v++) {\n      vertices[v].normalize();\n    }\n\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n      const vertexNormals = face.vertexNormals;\n\n      if (vertexNormals.length === 3) {\n        vertexNormals[0].copy(vertices[face.a]);\n        vertexNormals[1].copy(vertices[face.b]);\n        vertexNormals[2].copy(vertices[face.c]);\n      } else {\n        vertexNormals[0] = vertices[face.a].clone();\n        vertexNormals[1] = vertices[face.b].clone();\n        vertexNormals[2] = vertices[face.c].clone();\n      }\n    }\n\n    if (this.faces.length > 0) {\n      this.normalsNeedUpdate = true;\n    }\n  }\n\n  computeFlatVertexNormals() {\n    this.computeFaceNormals();\n\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n      const vertexNormals = face.vertexNormals;\n\n      if (vertexNormals.length === 3) {\n        vertexNormals[0].copy(face.normal);\n        vertexNormals[1].copy(face.normal);\n        vertexNormals[2].copy(face.normal);\n      } else {\n        vertexNormals[0] = face.normal.clone();\n        vertexNormals[1] = face.normal.clone();\n        vertexNormals[2] = face.normal.clone();\n      }\n    }\n\n    if (this.faces.length > 0) {\n      this.normalsNeedUpdate = true;\n    }\n  }\n\n  computeMorphNormals() {\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n\n      if (!face.__originalFaceNormal) {\n        face.__originalFaceNormal = face.normal.clone();\n      } else {\n        face.__originalFaceNormal.copy(face.normal);\n      }\n\n      if (!face.__originalVertexNormals) face.__originalVertexNormals = [];\n\n      for (let i = 0, il = face.vertexNormals.length; i < il; i++) {\n        if (!face.__originalVertexNormals[i]) {\n          face.__originalVertexNormals[i] = face.vertexNormals[i].clone();\n        } else {\n          face.__originalVertexNormals[i].copy(face.vertexNormals[i]);\n        }\n      }\n    }\n\n    const tmpGeo = new Geometry();\n    tmpGeo.faces = this.faces;\n\n    for (let i = 0, il = this.morphTargets.length; i < il; i++) {\n      if (!this.morphNormals[i]) {\n        this.morphNormals[i] = {};\n        this.morphNormals[i].faceNormals = [];\n        this.morphNormals[i].vertexNormals = [];\n        const dstNormalsFace = this.morphNormals[i].faceNormals;\n        const dstNormalsVertex = this.morphNormals[i].vertexNormals;\n\n        for (let f = 0, fl = this.faces.length; f < fl; f++) {\n          const faceNormal = new Vector3();\n          const vertexNormals = {\n            a: new Vector3(),\n            b: new Vector3(),\n            c: new Vector3()\n          };\n          dstNormalsFace.push(faceNormal);\n          dstNormalsVertex.push(vertexNormals);\n        }\n      }\n\n      const morphNormals = this.morphNormals[i];\n      tmpGeo.vertices = this.morphTargets[i].vertices;\n      tmpGeo.computeFaceNormals();\n      tmpGeo.computeVertexNormals();\n\n      for (let f = 0, fl = this.faces.length; f < fl; f++) {\n        const face = this.faces[f];\n        const faceNormal = morphNormals.faceNormals[f];\n        const vertexNormals = morphNormals.vertexNormals[f];\n        faceNormal.copy(face.normal);\n        vertexNormals.a.copy(face.vertexNormals[0]);\n        vertexNormals.b.copy(face.vertexNormals[1]);\n        vertexNormals.c.copy(face.vertexNormals[2]);\n      }\n    }\n\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n      face.normal = face.__originalFaceNormal;\n      face.vertexNormals = face.__originalVertexNormals;\n    }\n  }\n\n  computeBoundingBox() {\n    if (this.boundingBox === null) {\n      this.boundingBox = new Box3();\n    }\n\n    this.boundingBox.setFromPoints(this.vertices);\n  }\n\n  computeBoundingSphere() {\n    if (this.boundingSphere === null) {\n      this.boundingSphere = new Sphere();\n    }\n\n    this.boundingSphere.setFromPoints(this.vertices);\n  }\n\n  merge(geometry, matrix, materialIndexOffset = 0) {\n    if (!(geometry && geometry.isGeometry)) {\n      console.error(\"THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.\", geometry);\n      return;\n    }\n\n    let normalMatrix;\n    const vertexOffset = this.vertices.length,\n          vertices1 = this.vertices,\n          vertices2 = geometry.vertices,\n          faces1 = this.faces,\n          faces2 = geometry.faces,\n          colors1 = this.colors,\n          colors2 = geometry.colors;\n\n    if (matrix !== void 0) {\n      normalMatrix = new Matrix3().getNormalMatrix(matrix);\n    }\n\n    for (let i = 0, il = vertices2.length; i < il; i++) {\n      const vertex = vertices2[i];\n      const vertexCopy = vertex.clone();\n      if (matrix !== void 0) vertexCopy.applyMatrix4(matrix);\n      vertices1.push(vertexCopy);\n    }\n\n    for (let i = 0, il = colors2.length; i < il; i++) {\n      colors1.push(colors2[i].clone());\n    }\n\n    for (let i = 0, il = faces2.length; i < il; i++) {\n      const face = faces2[i];\n      let normal, color;\n      const faceVertexNormals = face.vertexNormals,\n            faceVertexColors = face.vertexColors;\n      const faceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);\n      faceCopy.normal.copy(face.normal);\n\n      if (normalMatrix !== void 0) {\n        faceCopy.normal.applyMatrix3(normalMatrix).normalize();\n      }\n\n      for (let j = 0, jl = faceVertexNormals.length; j < jl; j++) {\n        normal = faceVertexNormals[j].clone();\n\n        if (normalMatrix !== void 0) {\n          normal.applyMatrix3(normalMatrix).normalize();\n        }\n\n        faceCopy.vertexNormals.push(normal);\n      }\n\n      faceCopy.color.copy(face.color);\n\n      for (let j = 0, jl = faceVertexColors.length; j < jl; j++) {\n        color = faceVertexColors[j];\n        faceCopy.vertexColors.push(color.clone());\n      }\n\n      faceCopy.materialIndex = face.materialIndex + materialIndexOffset;\n      faces1.push(faceCopy);\n    }\n\n    for (let i = 0, il = geometry.faceVertexUvs.length; i < il; i++) {\n      const faceVertexUvs2 = geometry.faceVertexUvs[i];\n      if (this.faceVertexUvs[i] === void 0) this.faceVertexUvs[i] = [];\n\n      for (let j = 0, jl = faceVertexUvs2.length; j < jl; j++) {\n        const uvs2 = faceVertexUvs2[j],\n              uvsCopy = [];\n\n        for (let k = 0, kl = uvs2.length; k < kl; k++) {\n          uvsCopy.push(uvs2[k].clone());\n        }\n\n        this.faceVertexUvs[i].push(uvsCopy);\n      }\n    }\n  }\n\n  mergeMesh(mesh) {\n    if (!(mesh && mesh.isMesh)) {\n      console.error(\"THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.\", mesh);\n      return;\n    }\n\n    if (mesh.matrixAutoUpdate) mesh.updateMatrix();\n    this.merge(mesh.geometry, mesh.matrix);\n  }\n  /*\n   * Checks for duplicate vertices with hashmap.\n   * Duplicated vertices are removed\n   * and faces' vertices are updated.\n   */\n\n\n  mergeVertices(precisionPoints = 4) {\n    const verticesMap = {};\n    const unique = [],\n          changes = [];\n    const precision = Math.pow(10, precisionPoints);\n\n    for (let i = 0, il = this.vertices.length; i < il; i++) {\n      const v = this.vertices[i];\n      const key = `${Math.round(v.x * precision)}_${Math.round(v.y * precision)}_${Math.round(v.z * precision)}`;\n\n      if (verticesMap[key] === void 0) {\n        verticesMap[key] = i;\n        unique.push(this.vertices[i]);\n        changes[i] = unique.length - 1;\n      } else {\n        changes[i] = changes[verticesMap[key]];\n      }\n    }\n\n    const faceIndicesToRemove = [];\n\n    for (let i = 0, il = this.faces.length; i < il; i++) {\n      const face = this.faces[i];\n      face.a = changes[face.a];\n      face.b = changes[face.b];\n      face.c = changes[face.c];\n      const indices = [face.a, face.b, face.c];\n\n      for (let n = 0; n < 3; n++) {\n        if (indices[n] === indices[(n + 1) % 3]) {\n          faceIndicesToRemove.push(i);\n          break;\n        }\n      }\n    }\n\n    for (let i = faceIndicesToRemove.length - 1; i >= 0; i--) {\n      const idx = faceIndicesToRemove[i];\n      this.faces.splice(idx, 1);\n\n      for (let j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {\n        this.faceVertexUvs[j].splice(idx, 1);\n      }\n    }\n\n    const diff = this.vertices.length - unique.length;\n    this.vertices = unique;\n    return diff;\n  }\n\n  setFromPoints(points) {\n    this.vertices = [];\n\n    for (let i = 0, l = points.length; i < l; i++) {\n      const point = points[i];\n      this.vertices.push(new Vector3(point.x, point.y, point.z || 0));\n    }\n\n    return this;\n  }\n\n  sortFacesByMaterialIndex() {\n    const faces = this.faces;\n    const length = faces.length;\n\n    for (let i = 0; i < length; i++) {\n      faces[i]._id = i;\n    }\n\n    function materialIndexSort(a, b) {\n      return a.materialIndex - b.materialIndex;\n    }\n\n    faces.sort(materialIndexSort);\n    const uvs1 = this.faceVertexUvs[0];\n    const uvs2 = this.faceVertexUvs[1];\n    let newUvs1, newUvs2;\n    if (uvs1 && uvs1.length === length) newUvs1 = [];\n    if (uvs2 && uvs2.length === length) newUvs2 = [];\n\n    for (let i = 0; i < length; i++) {\n      const id = faces[i]._id;\n      if (newUvs1) newUvs1.push(uvs1[id]);\n      if (newUvs2) newUvs2.push(uvs2[id]);\n    }\n\n    if (newUvs1) this.faceVertexUvs[0] = newUvs1;\n    if (newUvs2) this.faceVertexUvs[1] = newUvs2;\n  }\n\n  toJSON() {\n    const data = {\n      metadata: {\n        version: 4.5,\n        type: \"Geometry\",\n        generator: \"Geometry.toJSON\"\n      }\n    };\n    data.uuid = this.uuid;\n    data.type = this.type;\n    if (this.name !== \"\") data.name = this.name;\n\n    if (this.parameters !== void 0) {\n      const parameters = this.parameters;\n\n      for (let key in parameters) {\n        if (parameters[key] !== void 0) data[key] = parameters[key];\n      }\n\n      return data;\n    }\n\n    const vertices = [];\n\n    for (let i = 0; i < this.vertices.length; i++) {\n      const vertex = this.vertices[i];\n      vertices.push(vertex.x, vertex.y, vertex.z);\n    }\n\n    const faces = [];\n    const normals = [];\n    const normalsHash = {};\n    const colors = [];\n    const colorsHash = {};\n    const uvs = [];\n    const uvsHash = {};\n\n    for (let i = 0; i < this.faces.length; i++) {\n      const face = this.faces[i];\n      const hasMaterial = true;\n      const hasFaceUv = false;\n      const hasFaceVertexUv = this.faceVertexUvs[0][i] !== void 0;\n      const hasFaceNormal = face.normal.length() > 0;\n      const hasFaceVertexNormal = face.vertexNormals.length > 0;\n      const hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\n      const hasFaceVertexColor = face.vertexColors.length > 0;\n      let faceType = 0;\n      faceType = setBit(faceType, 0, 0);\n      faceType = setBit(faceType, 1, hasMaterial);\n      faceType = setBit(faceType, 2, hasFaceUv);\n      faceType = setBit(faceType, 3, hasFaceVertexUv);\n      faceType = setBit(faceType, 4, hasFaceNormal);\n      faceType = setBit(faceType, 5, hasFaceVertexNormal);\n      faceType = setBit(faceType, 6, hasFaceColor);\n      faceType = setBit(faceType, 7, hasFaceVertexColor);\n      faces.push(faceType);\n      faces.push(face.a, face.b, face.c);\n      faces.push(face.materialIndex);\n\n      if (hasFaceVertexUv) {\n        const faceVertexUvs = this.faceVertexUvs[0][i];\n        faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));\n      }\n\n      if (hasFaceNormal) {\n        faces.push(getNormalIndex(face.normal));\n      }\n\n      if (hasFaceVertexNormal) {\n        const vertexNormals = face.vertexNormals;\n        faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));\n      }\n\n      if (hasFaceColor) {\n        faces.push(getColorIndex(face.color));\n      }\n\n      if (hasFaceVertexColor) {\n        const vertexColors = face.vertexColors;\n        faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));\n      }\n    }\n\n    function setBit(value, position, enabled) {\n      return enabled ? value | 1 << position : value & ~(1 << position);\n    }\n\n    function getNormalIndex(normal) {\n      const hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\n\n      if (normalsHash[hash] !== void 0) {\n        return normalsHash[hash];\n      }\n\n      normalsHash[hash] = normals.length / 3;\n      normals.push(normal.x, normal.y, normal.z);\n      return normalsHash[hash];\n    }\n\n    function getColorIndex(color) {\n      const hash = color.r.toString() + color.g.toString() + color.b.toString();\n\n      if (colorsHash[hash] !== void 0) {\n        return colorsHash[hash];\n      }\n\n      colorsHash[hash] = colors.length;\n      colors.push(color.getHex());\n      return colorsHash[hash];\n    }\n\n    function getUvIndex(uv) {\n      const hash = uv.x.toString() + uv.y.toString();\n\n      if (uvsHash[hash] !== void 0) {\n        return uvsHash[hash];\n      }\n\n      uvsHash[hash] = uvs.length / 2;\n      uvs.push(uv.x, uv.y);\n      return uvsHash[hash];\n    }\n\n    data.data = {};\n    data.data.vertices = vertices;\n    data.data.normals = normals;\n    if (colors.length > 0) data.data.colors = colors;\n    if (uvs.length > 0) data.data.uvs = [uvs];\n    data.data.faces = faces;\n    return data;\n  }\n\n  clone() {\n    return new Geometry().copy(this);\n  }\n\n  copy(source) {\n    this.vertices = [];\n    this.colors = [];\n    this.faces = [];\n    this.faceVertexUvs = [[]];\n    this.morphTargets = [];\n    this.morphNormals = [];\n    this.skinWeights = [];\n    this.skinIndices = [];\n    this.lineDistances = [];\n    this.boundingBox = null;\n    this.boundingSphere = null;\n    this.name = source.name;\n    const vertices = source.vertices;\n\n    for (let i = 0, il = vertices.length; i < il; i++) {\n      this.vertices.push(vertices[i].clone());\n    }\n\n    const colors = source.colors;\n\n    for (let i = 0, il = colors.length; i < il; i++) {\n      this.colors.push(colors[i].clone());\n    }\n\n    const faces = source.faces;\n\n    for (let i = 0, il = faces.length; i < il; i++) {\n      this.faces.push(faces[i].clone());\n    }\n\n    for (let i = 0, il = source.faceVertexUvs.length; i < il; i++) {\n      const faceVertexUvs = source.faceVertexUvs[i];\n\n      if (this.faceVertexUvs[i] === void 0) {\n        this.faceVertexUvs[i] = [];\n      }\n\n      for (let j = 0, jl = faceVertexUvs.length; j < jl; j++) {\n        const uvs = faceVertexUvs[j],\n              uvsCopy = [];\n\n        for (let k = 0, kl = uvs.length; k < kl; k++) {\n          const uv = uvs[k];\n          uvsCopy.push(uv.clone());\n        }\n\n        this.faceVertexUvs[i].push(uvsCopy);\n      }\n    }\n\n    const morphTargets = source.morphTargets;\n\n    for (let i = 0, il = morphTargets.length; i < il; i++) {\n      const morphTarget = {};\n      morphTarget.name = morphTargets[i].name;\n\n      if (morphTargets[i].vertices !== void 0) {\n        morphTarget.vertices = [];\n\n        for (let j = 0, jl = morphTargets[i].vertices.length; j < jl; j++) {\n          morphTarget.vertices.push(morphTargets[i].vertices[j].clone());\n        }\n      }\n\n      if (morphTargets[i].normals !== void 0) {\n        morphTarget.normals = [];\n\n        for (let j = 0, jl = morphTargets[i].normals.length; j < jl; j++) {\n          morphTarget.normals.push(morphTargets[i].normals[j].clone());\n        }\n      }\n\n      this.morphTargets.push(morphTarget);\n    }\n\n    const morphNormals = source.morphNormals;\n\n    for (let i = 0, il = morphNormals.length; i < il; i++) {\n      const morphNormal = {};\n\n      if (morphNormals[i].vertexNormals !== void 0) {\n        morphNormal.vertexNormals = [];\n\n        for (let j = 0, jl = morphNormals[i].vertexNormals.length; j < jl; j++) {\n          const srcVertexNormal = morphNormals[i].vertexNormals[j];\n          const destVertexNormal = {};\n          destVertexNormal.a = srcVertexNormal.a.clone();\n          destVertexNormal.b = srcVertexNormal.b.clone();\n          destVertexNormal.c = srcVertexNormal.c.clone();\n          morphNormal.vertexNormals.push(destVertexNormal);\n        }\n      }\n\n      if (morphNormals[i].faceNormals !== void 0) {\n        morphNormal.faceNormals = [];\n\n        for (let j = 0, jl = morphNormals[i].faceNormals.length; j < jl; j++) {\n          morphNormal.faceNormals.push(morphNormals[i].faceNormals[j].clone());\n        }\n      }\n\n      this.morphNormals.push(morphNormal);\n    }\n\n    const skinWeights = source.skinWeights;\n\n    for (let i = 0, il = skinWeights.length; i < il; i++) {\n      this.skinWeights.push(skinWeights[i].clone());\n    }\n\n    const skinIndices = source.skinIndices;\n\n    for (let i = 0, il = skinIndices.length; i < il; i++) {\n      this.skinIndices.push(skinIndices[i].clone());\n    }\n\n    const lineDistances = source.lineDistances;\n\n    for (let i = 0, il = lineDistances.length; i < il; i++) {\n      this.lineDistances.push(lineDistances[i]);\n    }\n\n    const boundingBox = source.boundingBox;\n\n    if (boundingBox !== null) {\n      this.boundingBox = boundingBox.clone();\n    }\n\n    const boundingSphere = source.boundingSphere;\n\n    if (boundingSphere !== null) {\n      this.boundingSphere = boundingSphere.clone();\n    }\n\n    this.elementsNeedUpdate = source.elementsNeedUpdate;\n    this.verticesNeedUpdate = source.verticesNeedUpdate;\n    this.uvsNeedUpdate = source.uvsNeedUpdate;\n    this.normalsNeedUpdate = source.normalsNeedUpdate;\n    this.colorsNeedUpdate = source.colorsNeedUpdate;\n    this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;\n    this.groupsNeedUpdate = source.groupsNeedUpdate;\n    return this;\n  }\n\n  toBufferGeometry() {\n    const geometry = new DirectGeometry().fromGeometry(this);\n    const buffergeometry = new BufferGeometry();\n    const positions = new Float32Array(geometry.vertices.length * 3);\n    buffergeometry.setAttribute(\"position\", new BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));\n\n    if (geometry.normals.length > 0) {\n      const normals = new Float32Array(geometry.normals.length * 3);\n      buffergeometry.setAttribute(\"normal\", new BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));\n    }\n\n    if (geometry.colors.length > 0) {\n      const colors = new Float32Array(geometry.colors.length * 3);\n      buffergeometry.setAttribute(\"color\", new BufferAttribute(colors, 3).copyColorsArray(geometry.colors));\n    }\n\n    if (geometry.uvs.length > 0) {\n      const uvs = new Float32Array(geometry.uvs.length * 2);\n      buffergeometry.setAttribute(\"uv\", new BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));\n    }\n\n    if (geometry.uvs2.length > 0) {\n      const uvs2 = new Float32Array(geometry.uvs2.length * 2);\n      buffergeometry.setAttribute(\"uv2\", new BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));\n    }\n\n    buffergeometry.groups = geometry.groups;\n\n    for (let name in geometry.morphTargets) {\n      const array = [];\n      const morphTargets = geometry.morphTargets[name];\n\n      for (let i = 0, l = morphTargets.length; i < l; i++) {\n        const morphTarget = morphTargets[i];\n        const attribute = new Float32BufferAttribute(morphTarget.data.length * 3, 3);\n        attribute.name = morphTarget.name;\n        array.push(attribute.copyVector3sArray(morphTarget.data));\n      }\n\n      buffergeometry.morphAttributes[name] = array;\n    }\n\n    if (geometry.skinIndices.length > 0) {\n      const skinIndices = new Float32BufferAttribute(geometry.skinIndices.length * 4, 4);\n      buffergeometry.setAttribute(\"skinIndex\", skinIndices.copyVector4sArray(geometry.skinIndices));\n    }\n\n    if (geometry.skinWeights.length > 0) {\n      const skinWeights = new Float32BufferAttribute(geometry.skinWeights.length * 4, 4);\n      buffergeometry.setAttribute(\"skinWeight\", skinWeights.copyVector4sArray(geometry.skinWeights));\n    }\n\n    if (geometry.boundingSphere !== null) {\n      buffergeometry.boundingSphere = geometry.boundingSphere.clone();\n    }\n\n    if (geometry.boundingBox !== null) {\n      buffergeometry.boundingBox = geometry.boundingBox.clone();\n    }\n\n    return buffergeometry;\n  }\n\n  computeTangents() {\n    console.error(\"THREE.Geometry: .computeTangents() has been removed.\");\n  }\n\n  computeLineDistances() {\n    console.error(\"THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.\");\n  }\n\n  applyMatrix(matrix) {\n    console.warn(\"THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4().\");\n    return this.applyMatrix4(matrix);\n  }\n\n  dispose() {\n    this.dispatchEvent({\n      type: \"dispose\"\n    });\n  }\n\n}\n\nclass DirectGeometry {\n  constructor() {\n    this.vertices = [];\n    this.normals = [];\n    this.colors = [];\n    this.uvs = [];\n    this.uvs2 = [];\n    this.groups = [];\n    this.morphTargets = {};\n    this.skinWeights = [];\n    this.skinIndices = [];\n    this.boundingBox = null;\n    this.boundingSphere = null;\n    this.verticesNeedUpdate = false;\n    this.normalsNeedUpdate = false;\n    this.colorsNeedUpdate = false;\n    this.uvsNeedUpdate = false;\n    this.groupsNeedUpdate = false;\n  }\n\n  computeGroups(geometry) {\n    const groups = [];\n    let group, i;\n    let materialIndex = void 0;\n    const faces = geometry.faces;\n\n    for (i = 0; i < faces.length; i++) {\n      const face = faces[i];\n\n      if (face.materialIndex !== materialIndex) {\n        materialIndex = face.materialIndex;\n\n        if (group !== void 0) {\n          group.count = i * 3 - group.start;\n          groups.push(group);\n        }\n\n        group = {\n          start: i * 3,\n          materialIndex\n        };\n      }\n    }\n\n    if (group !== void 0) {\n      group.count = i * 3 - group.start;\n      groups.push(group);\n    }\n\n    this.groups = groups;\n  }\n\n  fromGeometry(geometry) {\n    const faces = geometry.faces;\n    const vertices = geometry.vertices;\n    const faceVertexUvs = geometry.faceVertexUvs;\n    const hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;\n    const hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0;\n    const morphTargets = geometry.morphTargets;\n    const morphTargetsLength = morphTargets.length;\n    let morphTargetsPosition;\n\n    if (morphTargetsLength > 0) {\n      morphTargetsPosition = [];\n\n      for (let i = 0; i < morphTargetsLength; i++) {\n        morphTargetsPosition[i] = {\n          name: morphTargets[i].name,\n          data: []\n        };\n      }\n\n      this.morphTargets.position = morphTargetsPosition;\n    }\n\n    const morphNormals = geometry.morphNormals;\n    const morphNormalsLength = morphNormals.length;\n    let morphTargetsNormal;\n\n    if (morphNormalsLength > 0) {\n      morphTargetsNormal = [];\n\n      for (let i = 0; i < morphNormalsLength; i++) {\n        morphTargetsNormal[i] = {\n          name: morphNormals[i].name,\n          data: []\n        };\n      }\n\n      this.morphTargets.normal = morphTargetsNormal;\n    }\n\n    const skinIndices = geometry.skinIndices;\n    const skinWeights = geometry.skinWeights;\n    const hasSkinIndices = skinIndices.length === vertices.length;\n    const hasSkinWeights = skinWeights.length === vertices.length;\n\n    if (vertices.length > 0 && faces.length === 0) {\n      console.error(\"THREE.DirectGeometry: Faceless geometries are not supported.\");\n    }\n\n    for (let i = 0; i < faces.length; i++) {\n      const face = faces[i];\n      this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);\n      const vertexNormals = face.vertexNormals;\n\n      if (vertexNormals.length === 3) {\n        this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);\n      } else {\n        const normal = face.normal;\n        this.normals.push(normal, normal, normal);\n      }\n\n      const vertexColors = face.vertexColors;\n\n      if (vertexColors.length === 3) {\n        this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);\n      } else {\n        const color = face.color;\n        this.colors.push(color, color, color);\n      }\n\n      if (hasFaceVertexUv === true) {\n        const vertexUvs = faceVertexUvs[0][i];\n\n        if (vertexUvs !== void 0) {\n          this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);\n        } else {\n          console.warn(\"THREE.DirectGeometry.fromGeometry(): Undefined vertexUv \", i);\n          this.uvs.push(new Vector2(), new Vector2(), new Vector2());\n        }\n      }\n\n      if (hasFaceVertexUv2 === true) {\n        const vertexUvs = faceVertexUvs[1][i];\n\n        if (vertexUvs !== void 0) {\n          this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);\n        } else {\n          console.warn(\"THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 \", i);\n          this.uvs2.push(new Vector2(), new Vector2(), new Vector2());\n        }\n      }\n\n      for (let j = 0; j < morphTargetsLength; j++) {\n        const morphTarget = morphTargets[j].vertices;\n        morphTargetsPosition[j].data.push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);\n      }\n\n      for (let j = 0; j < morphNormalsLength; j++) {\n        const morphNormal = morphNormals[j].vertexNormals[i];\n        morphTargetsNormal[j].data.push(morphNormal.a, morphNormal.b, morphNormal.c);\n      }\n\n      if (hasSkinIndices) {\n        this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);\n      }\n\n      if (hasSkinWeights) {\n        this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);\n      }\n    }\n\n    this.computeGroups(geometry);\n    this.verticesNeedUpdate = geometry.verticesNeedUpdate;\n    this.normalsNeedUpdate = geometry.normalsNeedUpdate;\n    this.colorsNeedUpdate = geometry.colorsNeedUpdate;\n    this.uvsNeedUpdate = geometry.uvsNeedUpdate;\n    this.groupsNeedUpdate = geometry.groupsNeedUpdate;\n\n    if (geometry.boundingSphere !== null) {\n      this.boundingSphere = geometry.boundingSphere.clone();\n    }\n\n    if (geometry.boundingBox !== null) {\n      this.boundingBox = geometry.boundingBox.clone();\n    }\n\n    return this;\n  }\n\n}\n\nclass Face3 {\n  constructor(a, b, c, normal, color, materialIndex = 0) {\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.normal = normal && normal.isVector3 ? normal : new Vector3();\n    this.vertexNormals = Array.isArray(normal) ? normal : [];\n    this.color = color && color.isColor ? color : new Color();\n    this.vertexColors = Array.isArray(color) ? color : [];\n    this.materialIndex = materialIndex;\n  }\n\n  clone() {\n    return new this.constructor().copy(this);\n  }\n\n  copy(source) {\n    this.a = source.a;\n    this.b = source.b;\n    this.c = source.c;\n    this.normal.copy(source.normal);\n    this.color.copy(source.color);\n    this.materialIndex = source.materialIndex;\n\n    for (let i = 0, il = source.vertexNormals.length; i < il; i++) {\n      this.vertexNormals[i] = source.vertexNormals[i].clone();\n    }\n\n    for (let i = 0, il = source.vertexColors.length; i < il; i++) {\n      this.vertexColors[i] = source.vertexColors[i].clone();\n    }\n\n    return this;\n  }\n\n}\n\nexport { Face3, Geometry };","map":{"version":3,"sources":["/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/three-stdlib/deprecated/Geometry.js"],"names":["Matrix4","Object3D","Vector3","EventDispatcher","BufferGeometry","Float32BufferAttribute","MathUtils","Matrix3","Color","Vector2","Box3","Sphere","BufferAttribute","_m1","_obj","_offset","Geometry","createBufferGeometryFromObject","object","buffergeometry","geometry","isPoints","isLine","positions","vertices","length","colors","setAttribute","copyVector3sArray","copyColorsArray","lineDistances","copyArray","boundingSphere","clone","boundingBox","isMesh","toBufferGeometry","constructor","isGeometry","uuid","generateUUID","name","type","faces","faceVertexUvs","morphTargets","morphNormals","skinWeights","skinIndices","elementsNeedUpdate","verticesNeedUpdate","uvsNeedUpdate","normalsNeedUpdate","colorsNeedUpdate","lineDistancesNeedUpdate","groupsNeedUpdate","applyMatrix4","matrix","normalMatrix","getNormalMatrix","i","il","vertex","face","normal","applyMatrix3","normalize","j","jl","vertexNormals","computeBoundingBox","computeBoundingSphere","rotateX","angle","makeRotationX","rotateY","makeRotationY","rotateZ","makeRotationZ","translate","x","y","z","makeTranslation","scale","makeScale","lookAt","vector","updateMatrix","fromBufferGeometry","scope","index","attributes","position","console","error","color","uv","uv2","count","push","fromBufferAttribute","addFace","a","b","c","materialIndex","vertexColors","Face3","groups","group","start","getX","computeFaceNormals","center","getCenter","negate","radius","s","set","cb","ab","f","fl","vA","vB","vC","subVectors","cross","copy","computeVertexNormals","areaWeighted","Array","v","vl","add","computeFlatVertexNormals","computeMorphNormals","__originalFaceNormal","__originalVertexNormals","tmpGeo","faceNormals","dstNormalsFace","dstNormalsVertex","faceNormal","setFromPoints","merge","materialIndexOffset","vertexOffset","vertices1","vertices2","faces1","faces2","colors1","colors2","vertexCopy","faceVertexNormals","faceVertexColors","faceCopy","faceVertexUvs2","uvs2","uvsCopy","k","kl","mergeMesh","mesh","matrixAutoUpdate","mergeVertices","precisionPoints","verticesMap","unique","changes","precision","Math","pow","key","round","faceIndicesToRemove","indices","n","idx","splice","diff","points","l","point","sortFacesByMaterialIndex","_id","materialIndexSort","sort","uvs1","newUvs1","newUvs2","id","toJSON","data","metadata","version","generator","parameters","normals","normalsHash","colorsHash","uvs","uvsHash","hasMaterial","hasFaceUv","hasFaceVertexUv","hasFaceNormal","hasFaceVertexNormal","hasFaceColor","r","g","hasFaceVertexColor","faceType","setBit","getUvIndex","getNormalIndex","getColorIndex","value","enabled","hash","toString","getHex","source","morphTarget","morphNormal","srcVertexNormal","destVertexNormal","DirectGeometry","fromGeometry","Float32Array","copyVector2sArray","array","attribute","morphAttributes","copyVector4sArray","computeTangents","computeLineDistances","applyMatrix","warn","dispose","dispatchEvent","computeGroups","hasFaceVertexUv2","morphTargetsLength","morphTargetsPosition","morphNormalsLength","morphTargetsNormal","hasSkinIndices","hasSkinWeights","vertexUvs","isVector3","isArray","isColor"],"mappings":"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","sourcesContent":["import { Matrix4, Object3D, Vector3, EventDispatcher, BufferGeometry, Float32BufferAttribute, MathUtils, Matrix3, Color, Vector2, Box3, Sphere, BufferAttribute } from \"three\";\nconst _m1 = /* @__PURE__ */ new Matrix4();\nconst _obj = /* @__PURE__ */ new Object3D();\nconst _offset = /* @__PURE__ */ new Vector3();\nclass Geometry extends EventDispatcher {\n  static createBufferGeometryFromObject(object) {\n    let buffergeometry = new BufferGeometry();\n    const geometry = object.geometry;\n    if (object.isPoints || object.isLine) {\n      const positions = new Float32BufferAttribute(geometry.vertices.length * 3, 3);\n      const colors = new Float32BufferAttribute(geometry.colors.length * 3, 3);\n      buffergeometry.setAttribute(\"position\", positions.copyVector3sArray(geometry.vertices));\n      buffergeometry.setAttribute(\"color\", colors.copyColorsArray(geometry.colors));\n      if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {\n        const lineDistances = new Float32BufferAttribute(geometry.lineDistances.length, 1);\n        buffergeometry.setAttribute(\"lineDistance\", lineDistances.copyArray(geometry.lineDistances));\n      }\n      if (geometry.boundingSphere !== null) {\n        buffergeometry.boundingSphere = geometry.boundingSphere.clone();\n      }\n      if (geometry.boundingBox !== null) {\n        buffergeometry.boundingBox = geometry.boundingBox.clone();\n      }\n    } else if (object.isMesh) {\n      buffergeometry = geometry.toBufferGeometry();\n    }\n    return buffergeometry;\n  }\n  constructor() {\n    super();\n    this.isGeometry = true;\n    this.uuid = MathUtils.generateUUID();\n    this.name = \"\";\n    this.type = \"Geometry\";\n    this.vertices = [];\n    this.colors = [];\n    this.faces = [];\n    this.faceVertexUvs = [[]];\n    this.morphTargets = [];\n    this.morphNormals = [];\n    this.skinWeights = [];\n    this.skinIndices = [];\n    this.lineDistances = [];\n    this.boundingBox = null;\n    this.boundingSphere = null;\n    this.elementsNeedUpdate = false;\n    this.verticesNeedUpdate = false;\n    this.uvsNeedUpdate = false;\n    this.normalsNeedUpdate = false;\n    this.colorsNeedUpdate = false;\n    this.lineDistancesNeedUpdate = false;\n    this.groupsNeedUpdate = false;\n  }\n  applyMatrix4(matrix) {\n    const normalMatrix = new Matrix3().getNormalMatrix(matrix);\n    for (let i = 0, il = this.vertices.length; i < il; i++) {\n      const vertex = this.vertices[i];\n      vertex.applyMatrix4(matrix);\n    }\n    for (let i = 0, il = this.faces.length; i < il; i++) {\n      const face = this.faces[i];\n      face.normal.applyMatrix3(normalMatrix).normalize();\n      for (let j = 0, jl = face.vertexNormals.length; j < jl; j++) {\n        face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();\n      }\n    }\n    if (this.boundingBox !== null) {\n      this.computeBoundingBox();\n    }\n    if (this.boundingSphere !== null) {\n      this.computeBoundingSphere();\n    }\n    this.verticesNeedUpdate = true;\n    this.normalsNeedUpdate = true;\n    return this;\n  }\n  rotateX(angle) {\n    _m1.makeRotationX(angle);\n    this.applyMatrix4(_m1);\n    return this;\n  }\n  rotateY(angle) {\n    _m1.makeRotationY(angle);\n    this.applyMatrix4(_m1);\n    return this;\n  }\n  rotateZ(angle) {\n    _m1.makeRotationZ(angle);\n    this.applyMatrix4(_m1);\n    return this;\n  }\n  translate(x, y, z) {\n    _m1.makeTranslation(x, y, z);\n    this.applyMatrix4(_m1);\n    return this;\n  }\n  scale(x, y, z) {\n    _m1.makeScale(x, y, z);\n    this.applyMatrix4(_m1);\n    return this;\n  }\n  lookAt(vector) {\n    _obj.lookAt(vector);\n    _obj.updateMatrix();\n    this.applyMatrix4(_obj.matrix);\n    return this;\n  }\n  fromBufferGeometry(geometry) {\n    const scope = this;\n    const index = geometry.index !== null ? geometry.index : void 0;\n    const attributes = geometry.attributes;\n    if (attributes.position === void 0) {\n      console.error(\"THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.\");\n      return this;\n    }\n    const position = attributes.position;\n    const normal = attributes.normal;\n    const color = attributes.color;\n    const uv = attributes.uv;\n    const uv2 = attributes.uv2;\n    if (uv2 !== void 0)\n      this.faceVertexUvs[1] = [];\n    for (let i = 0; i < position.count; i++) {\n      scope.vertices.push(new Vector3().fromBufferAttribute(position, i));\n      if (color !== void 0) {\n        scope.colors.push(new Color().fromBufferAttribute(color, i));\n      }\n    }\n    function addFace(a, b, c, materialIndex) {\n      const vertexColors = color === void 0 ? [] : [scope.colors[a].clone(), scope.colors[b].clone(), scope.colors[c].clone()];\n      const vertexNormals = normal === void 0 ? [] : [\n        new Vector3().fromBufferAttribute(normal, a),\n        new Vector3().fromBufferAttribute(normal, b),\n        new Vector3().fromBufferAttribute(normal, c)\n      ];\n      const face = new Face3(a, b, c, vertexNormals, vertexColors, materialIndex);\n      scope.faces.push(face);\n      if (uv !== void 0) {\n        scope.faceVertexUvs[0].push([\n          new Vector2().fromBufferAttribute(uv, a),\n          new Vector2().fromBufferAttribute(uv, b),\n          new Vector2().fromBufferAttribute(uv, c)\n        ]);\n      }\n      if (uv2 !== void 0) {\n        scope.faceVertexUvs[1].push([\n          new Vector2().fromBufferAttribute(uv2, a),\n          new Vector2().fromBufferAttribute(uv2, b),\n          new Vector2().fromBufferAttribute(uv2, c)\n        ]);\n      }\n    }\n    const groups = geometry.groups;\n    if (groups.length > 0) {\n      for (let i = 0; i < groups.length; i++) {\n        const group = groups[i];\n        const start = group.start;\n        const count = group.count;\n        for (let j = start, jl = start + count; j < jl; j += 3) {\n          if (index !== void 0) {\n            addFace(index.getX(j), index.getX(j + 1), index.getX(j + 2), group.materialIndex);\n          } else {\n            addFace(j, j + 1, j + 2, group.materialIndex);\n          }\n        }\n      }\n    } else {\n      if (index !== void 0) {\n        for (let i = 0; i < index.count; i += 3) {\n          addFace(index.getX(i), index.getX(i + 1), index.getX(i + 2));\n        }\n      } else {\n        for (let i = 0; i < position.count; i += 3) {\n          addFace(i, i + 1, i + 2);\n        }\n      }\n    }\n    this.computeFaceNormals();\n    if (geometry.boundingBox !== null) {\n      this.boundingBox = geometry.boundingBox.clone();\n    }\n    if (geometry.boundingSphere !== null) {\n      this.boundingSphere = geometry.boundingSphere.clone();\n    }\n    return this;\n  }\n  center() {\n    this.computeBoundingBox();\n    this.boundingBox.getCenter(_offset).negate();\n    this.translate(_offset.x, _offset.y, _offset.z);\n    return this;\n  }\n  normalize() {\n    this.computeBoundingSphere();\n    const center = this.boundingSphere.center;\n    const radius = this.boundingSphere.radius;\n    const s = radius === 0 ? 1 : 1 / radius;\n    const matrix = new Matrix4();\n    matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1);\n    this.applyMatrix4(matrix);\n    return this;\n  }\n  computeFaceNormals() {\n    const cb = new Vector3(), ab = new Vector3();\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n      const vA = this.vertices[face.a];\n      const vB = this.vertices[face.b];\n      const vC = this.vertices[face.c];\n      cb.subVectors(vC, vB);\n      ab.subVectors(vA, vB);\n      cb.cross(ab);\n      cb.normalize();\n      face.normal.copy(cb);\n    }\n  }\n  computeVertexNormals(areaWeighted = true) {\n    const vertices = new Array(this.vertices.length);\n    for (let v = 0, vl = this.vertices.length; v < vl; v++) {\n      vertices[v] = new Vector3();\n    }\n    if (areaWeighted) {\n      const cb = new Vector3(), ab = new Vector3();\n      for (let f = 0, fl = this.faces.length; f < fl; f++) {\n        const face = this.faces[f];\n        const vA = this.vertices[face.a];\n        const vB = this.vertices[face.b];\n        const vC = this.vertices[face.c];\n        cb.subVectors(vC, vB);\n        ab.subVectors(vA, vB);\n        cb.cross(ab);\n        vertices[face.a].add(cb);\n        vertices[face.b].add(cb);\n        vertices[face.c].add(cb);\n      }\n    } else {\n      this.computeFaceNormals();\n      for (let f = 0, fl = this.faces.length; f < fl; f++) {\n        const face = this.faces[f];\n        vertices[face.a].add(face.normal);\n        vertices[face.b].add(face.normal);\n        vertices[face.c].add(face.normal);\n      }\n    }\n    for (let v = 0, vl = this.vertices.length; v < vl; v++) {\n      vertices[v].normalize();\n    }\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n      const vertexNormals = face.vertexNormals;\n      if (vertexNormals.length === 3) {\n        vertexNormals[0].copy(vertices[face.a]);\n        vertexNormals[1].copy(vertices[face.b]);\n        vertexNormals[2].copy(vertices[face.c]);\n      } else {\n        vertexNormals[0] = vertices[face.a].clone();\n        vertexNormals[1] = vertices[face.b].clone();\n        vertexNormals[2] = vertices[face.c].clone();\n      }\n    }\n    if (this.faces.length > 0) {\n      this.normalsNeedUpdate = true;\n    }\n  }\n  computeFlatVertexNormals() {\n    this.computeFaceNormals();\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n      const vertexNormals = face.vertexNormals;\n      if (vertexNormals.length === 3) {\n        vertexNormals[0].copy(face.normal);\n        vertexNormals[1].copy(face.normal);\n        vertexNormals[2].copy(face.normal);\n      } else {\n        vertexNormals[0] = face.normal.clone();\n        vertexNormals[1] = face.normal.clone();\n        vertexNormals[2] = face.normal.clone();\n      }\n    }\n    if (this.faces.length > 0) {\n      this.normalsNeedUpdate = true;\n    }\n  }\n  computeMorphNormals() {\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n      if (!face.__originalFaceNormal) {\n        face.__originalFaceNormal = face.normal.clone();\n      } else {\n        face.__originalFaceNormal.copy(face.normal);\n      }\n      if (!face.__originalVertexNormals)\n        face.__originalVertexNormals = [];\n      for (let i = 0, il = face.vertexNormals.length; i < il; i++) {\n        if (!face.__originalVertexNormals[i]) {\n          face.__originalVertexNormals[i] = face.vertexNormals[i].clone();\n        } else {\n          face.__originalVertexNormals[i].copy(face.vertexNormals[i]);\n        }\n      }\n    }\n    const tmpGeo = new Geometry();\n    tmpGeo.faces = this.faces;\n    for (let i = 0, il = this.morphTargets.length; i < il; i++) {\n      if (!this.morphNormals[i]) {\n        this.morphNormals[i] = {};\n        this.morphNormals[i].faceNormals = [];\n        this.morphNormals[i].vertexNormals = [];\n        const dstNormalsFace = this.morphNormals[i].faceNormals;\n        const dstNormalsVertex = this.morphNormals[i].vertexNormals;\n        for (let f = 0, fl = this.faces.length; f < fl; f++) {\n          const faceNormal = new Vector3();\n          const vertexNormals = {\n            a: new Vector3(),\n            b: new Vector3(),\n            c: new Vector3()\n          };\n          dstNormalsFace.push(faceNormal);\n          dstNormalsVertex.push(vertexNormals);\n        }\n      }\n      const morphNormals = this.morphNormals[i];\n      tmpGeo.vertices = this.morphTargets[i].vertices;\n      tmpGeo.computeFaceNormals();\n      tmpGeo.computeVertexNormals();\n      for (let f = 0, fl = this.faces.length; f < fl; f++) {\n        const face = this.faces[f];\n        const faceNormal = morphNormals.faceNormals[f];\n        const vertexNormals = morphNormals.vertexNormals[f];\n        faceNormal.copy(face.normal);\n        vertexNormals.a.copy(face.vertexNormals[0]);\n        vertexNormals.b.copy(face.vertexNormals[1]);\n        vertexNormals.c.copy(face.vertexNormals[2]);\n      }\n    }\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n      face.normal = face.__originalFaceNormal;\n      face.vertexNormals = face.__originalVertexNormals;\n    }\n  }\n  computeBoundingBox() {\n    if (this.boundingBox === null) {\n      this.boundingBox = new Box3();\n    }\n    this.boundingBox.setFromPoints(this.vertices);\n  }\n  computeBoundingSphere() {\n    if (this.boundingSphere === null) {\n      this.boundingSphere = new Sphere();\n    }\n    this.boundingSphere.setFromPoints(this.vertices);\n  }\n  merge(geometry, matrix, materialIndexOffset = 0) {\n    if (!(geometry && geometry.isGeometry)) {\n      console.error(\"THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.\", geometry);\n      return;\n    }\n    let normalMatrix;\n    const vertexOffset = this.vertices.length, vertices1 = this.vertices, vertices2 = geometry.vertices, faces1 = this.faces, faces2 = geometry.faces, colors1 = this.colors, colors2 = geometry.colors;\n    if (matrix !== void 0) {\n      normalMatrix = new Matrix3().getNormalMatrix(matrix);\n    }\n    for (let i = 0, il = vertices2.length; i < il; i++) {\n      const vertex = vertices2[i];\n      const vertexCopy = vertex.clone();\n      if (matrix !== void 0)\n        vertexCopy.applyMatrix4(matrix);\n      vertices1.push(vertexCopy);\n    }\n    for (let i = 0, il = colors2.length; i < il; i++) {\n      colors1.push(colors2[i].clone());\n    }\n    for (let i = 0, il = faces2.length; i < il; i++) {\n      const face = faces2[i];\n      let normal, color;\n      const faceVertexNormals = face.vertexNormals, faceVertexColors = face.vertexColors;\n      const faceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);\n      faceCopy.normal.copy(face.normal);\n      if (normalMatrix !== void 0) {\n        faceCopy.normal.applyMatrix3(normalMatrix).normalize();\n      }\n      for (let j = 0, jl = faceVertexNormals.length; j < jl; j++) {\n        normal = faceVertexNormals[j].clone();\n        if (normalMatrix !== void 0) {\n          normal.applyMatrix3(normalMatrix).normalize();\n        }\n        faceCopy.vertexNormals.push(normal);\n      }\n      faceCopy.color.copy(face.color);\n      for (let j = 0, jl = faceVertexColors.length; j < jl; j++) {\n        color = faceVertexColors[j];\n        faceCopy.vertexColors.push(color.clone());\n      }\n      faceCopy.materialIndex = face.materialIndex + materialIndexOffset;\n      faces1.push(faceCopy);\n    }\n    for (let i = 0, il = geometry.faceVertexUvs.length; i < il; i++) {\n      const faceVertexUvs2 = geometry.faceVertexUvs[i];\n      if (this.faceVertexUvs[i] === void 0)\n        this.faceVertexUvs[i] = [];\n      for (let j = 0, jl = faceVertexUvs2.length; j < jl; j++) {\n        const uvs2 = faceVertexUvs2[j], uvsCopy = [];\n        for (let k = 0, kl = uvs2.length; k < kl; k++) {\n          uvsCopy.push(uvs2[k].clone());\n        }\n        this.faceVertexUvs[i].push(uvsCopy);\n      }\n    }\n  }\n  mergeMesh(mesh) {\n    if (!(mesh && mesh.isMesh)) {\n      console.error(\"THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.\", mesh);\n      return;\n    }\n    if (mesh.matrixAutoUpdate)\n      mesh.updateMatrix();\n    this.merge(mesh.geometry, mesh.matrix);\n  }\n  /*\n   * Checks for duplicate vertices with hashmap.\n   * Duplicated vertices are removed\n   * and faces' vertices are updated.\n   */\n  mergeVertices(precisionPoints = 4) {\n    const verticesMap = {};\n    const unique = [], changes = [];\n    const precision = Math.pow(10, precisionPoints);\n    for (let i = 0, il = this.vertices.length; i < il; i++) {\n      const v = this.vertices[i];\n      const key = `${Math.round(v.x * precision)}_${Math.round(v.y * precision)}_${Math.round(v.z * precision)}`;\n      if (verticesMap[key] === void 0) {\n        verticesMap[key] = i;\n        unique.push(this.vertices[i]);\n        changes[i] = unique.length - 1;\n      } else {\n        changes[i] = changes[verticesMap[key]];\n      }\n    }\n    const faceIndicesToRemove = [];\n    for (let i = 0, il = this.faces.length; i < il; i++) {\n      const face = this.faces[i];\n      face.a = changes[face.a];\n      face.b = changes[face.b];\n      face.c = changes[face.c];\n      const indices = [face.a, face.b, face.c];\n      for (let n = 0; n < 3; n++) {\n        if (indices[n] === indices[(n + 1) % 3]) {\n          faceIndicesToRemove.push(i);\n          break;\n        }\n      }\n    }\n    for (let i = faceIndicesToRemove.length - 1; i >= 0; i--) {\n      const idx = faceIndicesToRemove[i];\n      this.faces.splice(idx, 1);\n      for (let j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {\n        this.faceVertexUvs[j].splice(idx, 1);\n      }\n    }\n    const diff = this.vertices.length - unique.length;\n    this.vertices = unique;\n    return diff;\n  }\n  setFromPoints(points) {\n    this.vertices = [];\n    for (let i = 0, l = points.length; i < l; i++) {\n      const point = points[i];\n      this.vertices.push(new Vector3(point.x, point.y, point.z || 0));\n    }\n    return this;\n  }\n  sortFacesByMaterialIndex() {\n    const faces = this.faces;\n    const length = faces.length;\n    for (let i = 0; i < length; i++) {\n      faces[i]._id = i;\n    }\n    function materialIndexSort(a, b) {\n      return a.materialIndex - b.materialIndex;\n    }\n    faces.sort(materialIndexSort);\n    const uvs1 = this.faceVertexUvs[0];\n    const uvs2 = this.faceVertexUvs[1];\n    let newUvs1, newUvs2;\n    if (uvs1 && uvs1.length === length)\n      newUvs1 = [];\n    if (uvs2 && uvs2.length === length)\n      newUvs2 = [];\n    for (let i = 0; i < length; i++) {\n      const id = faces[i]._id;\n      if (newUvs1)\n        newUvs1.push(uvs1[id]);\n      if (newUvs2)\n        newUvs2.push(uvs2[id]);\n    }\n    if (newUvs1)\n      this.faceVertexUvs[0] = newUvs1;\n    if (newUvs2)\n      this.faceVertexUvs[1] = newUvs2;\n  }\n  toJSON() {\n    const data = {\n      metadata: {\n        version: 4.5,\n        type: \"Geometry\",\n        generator: \"Geometry.toJSON\"\n      }\n    };\n    data.uuid = this.uuid;\n    data.type = this.type;\n    if (this.name !== \"\")\n      data.name = this.name;\n    if (this.parameters !== void 0) {\n      const parameters = this.parameters;\n      for (let key in parameters) {\n        if (parameters[key] !== void 0)\n          data[key] = parameters[key];\n      }\n      return data;\n    }\n    const vertices = [];\n    for (let i = 0; i < this.vertices.length; i++) {\n      const vertex = this.vertices[i];\n      vertices.push(vertex.x, vertex.y, vertex.z);\n    }\n    const faces = [];\n    const normals = [];\n    const normalsHash = {};\n    const colors = [];\n    const colorsHash = {};\n    const uvs = [];\n    const uvsHash = {};\n    for (let i = 0; i < this.faces.length; i++) {\n      const face = this.faces[i];\n      const hasMaterial = true;\n      const hasFaceUv = false;\n      const hasFaceVertexUv = this.faceVertexUvs[0][i] !== void 0;\n      const hasFaceNormal = face.normal.length() > 0;\n      const hasFaceVertexNormal = face.vertexNormals.length > 0;\n      const hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\n      const hasFaceVertexColor = face.vertexColors.length > 0;\n      let faceType = 0;\n      faceType = setBit(faceType, 0, 0);\n      faceType = setBit(faceType, 1, hasMaterial);\n      faceType = setBit(faceType, 2, hasFaceUv);\n      faceType = setBit(faceType, 3, hasFaceVertexUv);\n      faceType = setBit(faceType, 4, hasFaceNormal);\n      faceType = setBit(faceType, 5, hasFaceVertexNormal);\n      faceType = setBit(faceType, 6, hasFaceColor);\n      faceType = setBit(faceType, 7, hasFaceVertexColor);\n      faces.push(faceType);\n      faces.push(face.a, face.b, face.c);\n      faces.push(face.materialIndex);\n      if (hasFaceVertexUv) {\n        const faceVertexUvs = this.faceVertexUvs[0][i];\n        faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));\n      }\n      if (hasFaceNormal) {\n        faces.push(getNormalIndex(face.normal));\n      }\n      if (hasFaceVertexNormal) {\n        const vertexNormals = face.vertexNormals;\n        faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));\n      }\n      if (hasFaceColor) {\n        faces.push(getColorIndex(face.color));\n      }\n      if (hasFaceVertexColor) {\n        const vertexColors = face.vertexColors;\n        faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));\n      }\n    }\n    function setBit(value, position, enabled) {\n      return enabled ? value | 1 << position : value & ~(1 << position);\n    }\n    function getNormalIndex(normal) {\n      const hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\n      if (normalsHash[hash] !== void 0) {\n        return normalsHash[hash];\n      }\n      normalsHash[hash] = normals.length / 3;\n      normals.push(normal.x, normal.y, normal.z);\n      return normalsHash[hash];\n    }\n    function getColorIndex(color) {\n      const hash = color.r.toString() + color.g.toString() + color.b.toString();\n      if (colorsHash[hash] !== void 0) {\n        return colorsHash[hash];\n      }\n      colorsHash[hash] = colors.length;\n      colors.push(color.getHex());\n      return colorsHash[hash];\n    }\n    function getUvIndex(uv) {\n      const hash = uv.x.toString() + uv.y.toString();\n      if (uvsHash[hash] !== void 0) {\n        return uvsHash[hash];\n      }\n      uvsHash[hash] = uvs.length / 2;\n      uvs.push(uv.x, uv.y);\n      return uvsHash[hash];\n    }\n    data.data = {};\n    data.data.vertices = vertices;\n    data.data.normals = normals;\n    if (colors.length > 0)\n      data.data.colors = colors;\n    if (uvs.length > 0)\n      data.data.uvs = [uvs];\n    data.data.faces = faces;\n    return data;\n  }\n  clone() {\n    return new Geometry().copy(this);\n  }\n  copy(source) {\n    this.vertices = [];\n    this.colors = [];\n    this.faces = [];\n    this.faceVertexUvs = [[]];\n    this.morphTargets = [];\n    this.morphNormals = [];\n    this.skinWeights = [];\n    this.skinIndices = [];\n    this.lineDistances = [];\n    this.boundingBox = null;\n    this.boundingSphere = null;\n    this.name = source.name;\n    const vertices = source.vertices;\n    for (let i = 0, il = vertices.length; i < il; i++) {\n      this.vertices.push(vertices[i].clone());\n    }\n    const colors = source.colors;\n    for (let i = 0, il = colors.length; i < il; i++) {\n      this.colors.push(colors[i].clone());\n    }\n    const faces = source.faces;\n    for (let i = 0, il = faces.length; i < il; i++) {\n      this.faces.push(faces[i].clone());\n    }\n    for (let i = 0, il = source.faceVertexUvs.length; i < il; i++) {\n      const faceVertexUvs = source.faceVertexUvs[i];\n      if (this.faceVertexUvs[i] === void 0) {\n        this.faceVertexUvs[i] = [];\n      }\n      for (let j = 0, jl = faceVertexUvs.length; j < jl; j++) {\n        const uvs = faceVertexUvs[j], uvsCopy = [];\n        for (let k = 0, kl = uvs.length; k < kl; k++) {\n          const uv = uvs[k];\n          uvsCopy.push(uv.clone());\n        }\n        this.faceVertexUvs[i].push(uvsCopy);\n      }\n    }\n    const morphTargets = source.morphTargets;\n    for (let i = 0, il = morphTargets.length; i < il; i++) {\n      const morphTarget = {};\n      morphTarget.name = morphTargets[i].name;\n      if (morphTargets[i].vertices !== void 0) {\n        morphTarget.vertices = [];\n        for (let j = 0, jl = morphTargets[i].vertices.length; j < jl; j++) {\n          morphTarget.vertices.push(morphTargets[i].vertices[j].clone());\n        }\n      }\n      if (morphTargets[i].normals !== void 0) {\n        morphTarget.normals = [];\n        for (let j = 0, jl = morphTargets[i].normals.length; j < jl; j++) {\n          morphTarget.normals.push(morphTargets[i].normals[j].clone());\n        }\n      }\n      this.morphTargets.push(morphTarget);\n    }\n    const morphNormals = source.morphNormals;\n    for (let i = 0, il = morphNormals.length; i < il; i++) {\n      const morphNormal = {};\n      if (morphNormals[i].vertexNormals !== void 0) {\n        morphNormal.vertexNormals = [];\n        for (let j = 0, jl = morphNormals[i].vertexNormals.length; j < jl; j++) {\n          const srcVertexNormal = morphNormals[i].vertexNormals[j];\n          const destVertexNormal = {};\n          destVertexNormal.a = srcVertexNormal.a.clone();\n          destVertexNormal.b = srcVertexNormal.b.clone();\n          destVertexNormal.c = srcVertexNormal.c.clone();\n          morphNormal.vertexNormals.push(destVertexNormal);\n        }\n      }\n      if (morphNormals[i].faceNormals !== void 0) {\n        morphNormal.faceNormals = [];\n        for (let j = 0, jl = morphNormals[i].faceNormals.length; j < jl; j++) {\n          morphNormal.faceNormals.push(morphNormals[i].faceNormals[j].clone());\n        }\n      }\n      this.morphNormals.push(morphNormal);\n    }\n    const skinWeights = source.skinWeights;\n    for (let i = 0, il = skinWeights.length; i < il; i++) {\n      this.skinWeights.push(skinWeights[i].clone());\n    }\n    const skinIndices = source.skinIndices;\n    for (let i = 0, il = skinIndices.length; i < il; i++) {\n      this.skinIndices.push(skinIndices[i].clone());\n    }\n    const lineDistances = source.lineDistances;\n    for (let i = 0, il = lineDistances.length; i < il; i++) {\n      this.lineDistances.push(lineDistances[i]);\n    }\n    const boundingBox = source.boundingBox;\n    if (boundingBox !== null) {\n      this.boundingBox = boundingBox.clone();\n    }\n    const boundingSphere = source.boundingSphere;\n    if (boundingSphere !== null) {\n      this.boundingSphere = boundingSphere.clone();\n    }\n    this.elementsNeedUpdate = source.elementsNeedUpdate;\n    this.verticesNeedUpdate = source.verticesNeedUpdate;\n    this.uvsNeedUpdate = source.uvsNeedUpdate;\n    this.normalsNeedUpdate = source.normalsNeedUpdate;\n    this.colorsNeedUpdate = source.colorsNeedUpdate;\n    this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;\n    this.groupsNeedUpdate = source.groupsNeedUpdate;\n    return this;\n  }\n  toBufferGeometry() {\n    const geometry = new DirectGeometry().fromGeometry(this);\n    const buffergeometry = new BufferGeometry();\n    const positions = new Float32Array(geometry.vertices.length * 3);\n    buffergeometry.setAttribute(\"position\", new BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));\n    if (geometry.normals.length > 0) {\n      const normals = new Float32Array(geometry.normals.length * 3);\n      buffergeometry.setAttribute(\"normal\", new BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));\n    }\n    if (geometry.colors.length > 0) {\n      const colors = new Float32Array(geometry.colors.length * 3);\n      buffergeometry.setAttribute(\"color\", new BufferAttribute(colors, 3).copyColorsArray(geometry.colors));\n    }\n    if (geometry.uvs.length > 0) {\n      const uvs = new Float32Array(geometry.uvs.length * 2);\n      buffergeometry.setAttribute(\"uv\", new BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));\n    }\n    if (geometry.uvs2.length > 0) {\n      const uvs2 = new Float32Array(geometry.uvs2.length * 2);\n      buffergeometry.setAttribute(\"uv2\", new BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));\n    }\n    buffergeometry.groups = geometry.groups;\n    for (let name in geometry.morphTargets) {\n      const array = [];\n      const morphTargets = geometry.morphTargets[name];\n      for (let i = 0, l = morphTargets.length; i < l; i++) {\n        const morphTarget = morphTargets[i];\n        const attribute = new Float32BufferAttribute(morphTarget.data.length * 3, 3);\n        attribute.name = morphTarget.name;\n        array.push(attribute.copyVector3sArray(morphTarget.data));\n      }\n      buffergeometry.morphAttributes[name] = array;\n    }\n    if (geometry.skinIndices.length > 0) {\n      const skinIndices = new Float32BufferAttribute(geometry.skinIndices.length * 4, 4);\n      buffergeometry.setAttribute(\"skinIndex\", skinIndices.copyVector4sArray(geometry.skinIndices));\n    }\n    if (geometry.skinWeights.length > 0) {\n      const skinWeights = new Float32BufferAttribute(geometry.skinWeights.length * 4, 4);\n      buffergeometry.setAttribute(\"skinWeight\", skinWeights.copyVector4sArray(geometry.skinWeights));\n    }\n    if (geometry.boundingSphere !== null) {\n      buffergeometry.boundingSphere = geometry.boundingSphere.clone();\n    }\n    if (geometry.boundingBox !== null) {\n      buffergeometry.boundingBox = geometry.boundingBox.clone();\n    }\n    return buffergeometry;\n  }\n  computeTangents() {\n    console.error(\"THREE.Geometry: .computeTangents() has been removed.\");\n  }\n  computeLineDistances() {\n    console.error(\n      \"THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.\"\n    );\n  }\n  applyMatrix(matrix) {\n    console.warn(\"THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4().\");\n    return this.applyMatrix4(matrix);\n  }\n  dispose() {\n    this.dispatchEvent({ type: \"dispose\" });\n  }\n}\nclass DirectGeometry {\n  constructor() {\n    this.vertices = [];\n    this.normals = [];\n    this.colors = [];\n    this.uvs = [];\n    this.uvs2 = [];\n    this.groups = [];\n    this.morphTargets = {};\n    this.skinWeights = [];\n    this.skinIndices = [];\n    this.boundingBox = null;\n    this.boundingSphere = null;\n    this.verticesNeedUpdate = false;\n    this.normalsNeedUpdate = false;\n    this.colorsNeedUpdate = false;\n    this.uvsNeedUpdate = false;\n    this.groupsNeedUpdate = false;\n  }\n  computeGroups(geometry) {\n    const groups = [];\n    let group, i;\n    let materialIndex = void 0;\n    const faces = geometry.faces;\n    for (i = 0; i < faces.length; i++) {\n      const face = faces[i];\n      if (face.materialIndex !== materialIndex) {\n        materialIndex = face.materialIndex;\n        if (group !== void 0) {\n          group.count = i * 3 - group.start;\n          groups.push(group);\n        }\n        group = {\n          start: i * 3,\n          materialIndex\n        };\n      }\n    }\n    if (group !== void 0) {\n      group.count = i * 3 - group.start;\n      groups.push(group);\n    }\n    this.groups = groups;\n  }\n  fromGeometry(geometry) {\n    const faces = geometry.faces;\n    const vertices = geometry.vertices;\n    const faceVertexUvs = geometry.faceVertexUvs;\n    const hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;\n    const hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0;\n    const morphTargets = geometry.morphTargets;\n    const morphTargetsLength = morphTargets.length;\n    let morphTargetsPosition;\n    if (morphTargetsLength > 0) {\n      morphTargetsPosition = [];\n      for (let i = 0; i < morphTargetsLength; i++) {\n        morphTargetsPosition[i] = {\n          name: morphTargets[i].name,\n          data: []\n        };\n      }\n      this.morphTargets.position = morphTargetsPosition;\n    }\n    const morphNormals = geometry.morphNormals;\n    const morphNormalsLength = morphNormals.length;\n    let morphTargetsNormal;\n    if (morphNormalsLength > 0) {\n      morphTargetsNormal = [];\n      for (let i = 0; i < morphNormalsLength; i++) {\n        morphTargetsNormal[i] = {\n          name: morphNormals[i].name,\n          data: []\n        };\n      }\n      this.morphTargets.normal = morphTargetsNormal;\n    }\n    const skinIndices = geometry.skinIndices;\n    const skinWeights = geometry.skinWeights;\n    const hasSkinIndices = skinIndices.length === vertices.length;\n    const hasSkinWeights = skinWeights.length === vertices.length;\n    if (vertices.length > 0 && faces.length === 0) {\n      console.error(\"THREE.DirectGeometry: Faceless geometries are not supported.\");\n    }\n    for (let i = 0; i < faces.length; i++) {\n      const face = faces[i];\n      this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);\n      const vertexNormals = face.vertexNormals;\n      if (vertexNormals.length === 3) {\n        this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);\n      } else {\n        const normal = face.normal;\n        this.normals.push(normal, normal, normal);\n      }\n      const vertexColors = face.vertexColors;\n      if (vertexColors.length === 3) {\n        this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);\n      } else {\n        const color = face.color;\n        this.colors.push(color, color, color);\n      }\n      if (hasFaceVertexUv === true) {\n        const vertexUvs = faceVertexUvs[0][i];\n        if (vertexUvs !== void 0) {\n          this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);\n        } else {\n          console.warn(\"THREE.DirectGeometry.fromGeometry(): Undefined vertexUv \", i);\n          this.uvs.push(new Vector2(), new Vector2(), new Vector2());\n        }\n      }\n      if (hasFaceVertexUv2 === true) {\n        const vertexUvs = faceVertexUvs[1][i];\n        if (vertexUvs !== void 0) {\n          this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);\n        } else {\n          console.warn(\"THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 \", i);\n          this.uvs2.push(new Vector2(), new Vector2(), new Vector2());\n        }\n      }\n      for (let j = 0; j < morphTargetsLength; j++) {\n        const morphTarget = morphTargets[j].vertices;\n        morphTargetsPosition[j].data.push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);\n      }\n      for (let j = 0; j < morphNormalsLength; j++) {\n        const morphNormal = morphNormals[j].vertexNormals[i];\n        morphTargetsNormal[j].data.push(morphNormal.a, morphNormal.b, morphNormal.c);\n      }\n      if (hasSkinIndices) {\n        this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);\n      }\n      if (hasSkinWeights) {\n        this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);\n      }\n    }\n    this.computeGroups(geometry);\n    this.verticesNeedUpdate = geometry.verticesNeedUpdate;\n    this.normalsNeedUpdate = geometry.normalsNeedUpdate;\n    this.colorsNeedUpdate = geometry.colorsNeedUpdate;\n    this.uvsNeedUpdate = geometry.uvsNeedUpdate;\n    this.groupsNeedUpdate = geometry.groupsNeedUpdate;\n    if (geometry.boundingSphere !== null) {\n      this.boundingSphere = geometry.boundingSphere.clone();\n    }\n    if (geometry.boundingBox !== null) {\n      this.boundingBox = geometry.boundingBox.clone();\n    }\n    return this;\n  }\n}\nclass Face3 {\n  constructor(a, b, c, normal, color, materialIndex = 0) {\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.normal = normal && normal.isVector3 ? normal : new Vector3();\n    this.vertexNormals = Array.isArray(normal) ? normal : [];\n    this.color = color && color.isColor ? color : new Color();\n    this.vertexColors = Array.isArray(color) ? color : [];\n    this.materialIndex = materialIndex;\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n  copy(source) {\n    this.a = source.a;\n    this.b = source.b;\n    this.c = source.c;\n    this.normal.copy(source.normal);\n    this.color.copy(source.color);\n    this.materialIndex = source.materialIndex;\n    for (let i = 0, il = source.vertexNormals.length; i < il; i++) {\n      this.vertexNormals[i] = source.vertexNormals[i].clone();\n    }\n    for (let i = 0, il = source.vertexColors.length; i < il; i++) {\n      this.vertexColors[i] = source.vertexColors[i].clone();\n    }\n    return this;\n  }\n}\nexport {\n  Face3,\n  Geometry\n};\n"]},"metadata":{},"sourceType":"module"}