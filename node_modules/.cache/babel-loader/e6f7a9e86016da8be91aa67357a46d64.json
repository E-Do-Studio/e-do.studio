{"ast":null,"code":"import { Object3D, MeshBasicMaterial, MathUtils, Mesh } from \"three\";\nimport { LightningStrike } from \"../geometries/LightningStrike.js\";\n\nclass LightningStorm extends Object3D {\n  constructor(stormParams = {}) {\n    super();\n    this.isLightningStorm = true;\n    this.stormParams = stormParams;\n    stormParams.size = stormParams.size !== void 0 ? stormParams.size : 1e3;\n    stormParams.minHeight = stormParams.minHeight !== void 0 ? stormParams.minHeight : 80;\n    stormParams.maxHeight = stormParams.maxHeight !== void 0 ? stormParams.maxHeight : 100;\n    stormParams.maxSlope = stormParams.maxSlope !== void 0 ? stormParams.maxSlope : 1.1;\n    stormParams.maxLightnings = stormParams.maxLightnings !== void 0 ? stormParams.maxLightnings : 3;\n    stormParams.lightningMinPeriod = stormParams.lightningMinPeriod !== void 0 ? stormParams.lightningMinPeriod : 3;\n    stormParams.lightningMaxPeriod = stormParams.lightningMaxPeriod !== void 0 ? stormParams.lightningMaxPeriod : 7;\n    stormParams.lightningMinDuration = stormParams.lightningMinDuration !== void 0 ? stormParams.lightningMinDuration : 1;\n    stormParams.lightningMaxDuration = stormParams.lightningMaxDuration !== void 0 ? stormParams.lightningMaxDuration : 2.5;\n    this.lightningParameters = LightningStrike.copyParameters(stormParams.lightningParameters, stormParams.lightningParameters);\n    this.lightningParameters.isEternal = false;\n    this.lightningMaterial = stormParams.lightningMaterial !== void 0 ? stormParams.lightningMaterial : new MeshBasicMaterial({\n      color: 11599871\n    });\n\n    if (stormParams.onRayPosition !== void 0) {\n      this.onRayPosition = stormParams.onRayPosition;\n    } else {\n      this.onRayPosition = function (source, dest) {\n        dest.set((Math.random() - 0.5) * stormParams.size, 0, (Math.random() - 0.5) * stormParams.size);\n        const height = MathUtils.lerp(stormParams.minHeight, stormParams.maxHeight, Math.random());\n        source.set(stormParams.maxSlope * (2 * Math.random() - 1), 1, stormParams.maxSlope * (2 * Math.random() - 1)).multiplyScalar(height).add(dest);\n      };\n    }\n\n    this.onLightningDown = stormParams.onLightningDown;\n    this.inited = false;\n    this.nextLightningTime = 0;\n    this.lightningsMeshes = [];\n    this.deadLightningsMeshes = [];\n\n    for (let i = 0; i < this.stormParams.maxLightnings; i++) {\n      const lightning = new LightningStrike(LightningStrike.copyParameters({}, this.lightningParameters));\n      const mesh = new Mesh(lightning, this.lightningMaterial);\n      this.deadLightningsMeshes.push(mesh);\n    }\n  }\n\n  update(time) {\n    if (!this.inited) {\n      this.nextLightningTime = this.getNextLightningTime(time) * Math.random();\n      this.inited = true;\n    }\n\n    if (time >= this.nextLightningTime) {\n      const lightningMesh = this.deadLightningsMeshes.pop();\n\n      if (lightningMesh) {\n        const lightningParams1 = LightningStrike.copyParameters(lightningMesh.geometry.rayParameters, this.lightningParameters);\n        lightningParams1.birthTime = time;\n        lightningParams1.deathTime = time + MathUtils.lerp(this.stormParams.lightningMinDuration, this.stormParams.lightningMaxDuration, Math.random());\n        this.onRayPosition(lightningParams1.sourceOffset, lightningParams1.destOffset);\n        lightningParams1.noiseSeed = Math.random();\n        this.add(lightningMesh);\n        this.lightningsMeshes.push(lightningMesh);\n      }\n\n      this.nextLightningTime = this.getNextLightningTime(time);\n    }\n\n    let i = 0,\n        il = this.lightningsMeshes.length;\n\n    while (i < il) {\n      const mesh = this.lightningsMeshes[i];\n      const lightning = mesh.geometry;\n      const prevState = lightning.state;\n      lightning.update(time);\n\n      if (prevState === LightningStrike.RAY_PROPAGATING && lightning.state > prevState) {\n        if (this.onLightningDown) {\n          this.onLightningDown(lightning);\n        }\n      }\n\n      if (lightning.state === LightningStrike.RAY_EXTINGUISHED) {\n        this.lightningsMeshes.splice(this.lightningsMeshes.indexOf(mesh), 1);\n        this.deadLightningsMeshes.push(mesh);\n        this.remove(mesh);\n        il--;\n      } else {\n        i++;\n      }\n    }\n  }\n\n  getNextLightningTime(currentTime) {\n    return currentTime + MathUtils.lerp(this.stormParams.lightningMinPeriod, this.stormParams.lightningMaxPeriod, Math.random()) / (this.stormParams.maxLightnings + 1);\n  }\n\n  copy(source, recursive) {\n    super.copy(source, recursive);\n    this.stormParams.size = source.stormParams.size;\n    this.stormParams.minHeight = source.stormParams.minHeight;\n    this.stormParams.maxHeight = source.stormParams.maxHeight;\n    this.stormParams.maxSlope = source.stormParams.maxSlope;\n    this.stormParams.maxLightnings = source.stormParams.maxLightnings;\n    this.stormParams.lightningMinPeriod = source.stormParams.lightningMinPeriod;\n    this.stormParams.lightningMaxPeriod = source.stormParams.lightningMaxPeriod;\n    this.stormParams.lightningMinDuration = source.stormParams.lightningMinDuration;\n    this.stormParams.lightningMaxDuration = source.stormParams.lightningMaxDuration;\n    this.lightningParameters = LightningStrike.copyParameters({}, source.lightningParameters);\n    this.lightningMaterial = source.stormParams.lightningMaterial;\n    this.onLightningDown = source.onLightningDown;\n    return this;\n  }\n\n  clone() {\n    return new this.constructor(this.stormParams).copy(this);\n  }\n\n}\n\nexport { LightningStorm };","map":{"version":3,"sources":["/Users/theodaguier/Developer/old/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/three-stdlib/objects/LightningStorm.js"],"names":["Object3D","MeshBasicMaterial","MathUtils","Mesh","LightningStrike","LightningStorm","constructor","stormParams","isLightningStorm","size","minHeight","maxHeight","maxSlope","maxLightnings","lightningMinPeriod","lightningMaxPeriod","lightningMinDuration","lightningMaxDuration","lightningParameters","copyParameters","isEternal","lightningMaterial","color","onRayPosition","source","dest","set","Math","random","height","lerp","multiplyScalar","add","onLightningDown","inited","nextLightningTime","lightningsMeshes","deadLightningsMeshes","i","lightning","mesh","push","update","time","getNextLightningTime","lightningMesh","pop","lightningParams1","geometry","rayParameters","birthTime","deathTime","sourceOffset","destOffset","noiseSeed","il","length","prevState","state","RAY_PROPAGATING","RAY_EXTINGUISHED","splice","indexOf","remove","currentTime","copy","recursive","clone"],"mappings":"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","sourcesContent":["import { Object3D, MeshBasicMaterial, MathUtils, Mesh } from \"three\";\nimport { LightningStrike } from \"../geometries/LightningStrike.js\";\nclass LightningStorm extends Object3D {\n  constructor(stormParams = {}) {\n    super();\n    this.isLightningStorm = true;\n    this.stormParams = stormParams;\n    stormParams.size = stormParams.size !== void 0 ? stormParams.size : 1e3;\n    stormParams.minHeight = stormParams.minHeight !== void 0 ? stormParams.minHeight : 80;\n    stormParams.maxHeight = stormParams.maxHeight !== void 0 ? stormParams.maxHeight : 100;\n    stormParams.maxSlope = stormParams.maxSlope !== void 0 ? stormParams.maxSlope : 1.1;\n    stormParams.maxLightnings = stormParams.maxLightnings !== void 0 ? stormParams.maxLightnings : 3;\n    stormParams.lightningMinPeriod = stormParams.lightningMinPeriod !== void 0 ? stormParams.lightningMinPeriod : 3;\n    stormParams.lightningMaxPeriod = stormParams.lightningMaxPeriod !== void 0 ? stormParams.lightningMaxPeriod : 7;\n    stormParams.lightningMinDuration = stormParams.lightningMinDuration !== void 0 ? stormParams.lightningMinDuration : 1;\n    stormParams.lightningMaxDuration = stormParams.lightningMaxDuration !== void 0 ? stormParams.lightningMaxDuration : 2.5;\n    this.lightningParameters = LightningStrike.copyParameters(\n      stormParams.lightningParameters,\n      stormParams.lightningParameters\n    );\n    this.lightningParameters.isEternal = false;\n    this.lightningMaterial = stormParams.lightningMaterial !== void 0 ? stormParams.lightningMaterial : new MeshBasicMaterial({ color: 11599871 });\n    if (stormParams.onRayPosition !== void 0) {\n      this.onRayPosition = stormParams.onRayPosition;\n    } else {\n      this.onRayPosition = function(source, dest) {\n        dest.set((Math.random() - 0.5) * stormParams.size, 0, (Math.random() - 0.5) * stormParams.size);\n        const height = MathUtils.lerp(stormParams.minHeight, stormParams.maxHeight, Math.random());\n        source.set(stormParams.maxSlope * (2 * Math.random() - 1), 1, stormParams.maxSlope * (2 * Math.random() - 1)).multiplyScalar(height).add(dest);\n      };\n    }\n    this.onLightningDown = stormParams.onLightningDown;\n    this.inited = false;\n    this.nextLightningTime = 0;\n    this.lightningsMeshes = [];\n    this.deadLightningsMeshes = [];\n    for (let i = 0; i < this.stormParams.maxLightnings; i++) {\n      const lightning = new LightningStrike(LightningStrike.copyParameters({}, this.lightningParameters));\n      const mesh = new Mesh(lightning, this.lightningMaterial);\n      this.deadLightningsMeshes.push(mesh);\n    }\n  }\n  update(time) {\n    if (!this.inited) {\n      this.nextLightningTime = this.getNextLightningTime(time) * Math.random();\n      this.inited = true;\n    }\n    if (time >= this.nextLightningTime) {\n      const lightningMesh = this.deadLightningsMeshes.pop();\n      if (lightningMesh) {\n        const lightningParams1 = LightningStrike.copyParameters(\n          lightningMesh.geometry.rayParameters,\n          this.lightningParameters\n        );\n        lightningParams1.birthTime = time;\n        lightningParams1.deathTime = time + MathUtils.lerp(this.stormParams.lightningMinDuration, this.stormParams.lightningMaxDuration, Math.random());\n        this.onRayPosition(lightningParams1.sourceOffset, lightningParams1.destOffset);\n        lightningParams1.noiseSeed = Math.random();\n        this.add(lightningMesh);\n        this.lightningsMeshes.push(lightningMesh);\n      }\n      this.nextLightningTime = this.getNextLightningTime(time);\n    }\n    let i = 0, il = this.lightningsMeshes.length;\n    while (i < il) {\n      const mesh = this.lightningsMeshes[i];\n      const lightning = mesh.geometry;\n      const prevState = lightning.state;\n      lightning.update(time);\n      if (prevState === LightningStrike.RAY_PROPAGATING && lightning.state > prevState) {\n        if (this.onLightningDown) {\n          this.onLightningDown(lightning);\n        }\n      }\n      if (lightning.state === LightningStrike.RAY_EXTINGUISHED) {\n        this.lightningsMeshes.splice(this.lightningsMeshes.indexOf(mesh), 1);\n        this.deadLightningsMeshes.push(mesh);\n        this.remove(mesh);\n        il--;\n      } else {\n        i++;\n      }\n    }\n  }\n  getNextLightningTime(currentTime) {\n    return currentTime + MathUtils.lerp(this.stormParams.lightningMinPeriod, this.stormParams.lightningMaxPeriod, Math.random()) / (this.stormParams.maxLightnings + 1);\n  }\n  copy(source, recursive) {\n    super.copy(source, recursive);\n    this.stormParams.size = source.stormParams.size;\n    this.stormParams.minHeight = source.stormParams.minHeight;\n    this.stormParams.maxHeight = source.stormParams.maxHeight;\n    this.stormParams.maxSlope = source.stormParams.maxSlope;\n    this.stormParams.maxLightnings = source.stormParams.maxLightnings;\n    this.stormParams.lightningMinPeriod = source.stormParams.lightningMinPeriod;\n    this.stormParams.lightningMaxPeriod = source.stormParams.lightningMaxPeriod;\n    this.stormParams.lightningMinDuration = source.stormParams.lightningMinDuration;\n    this.stormParams.lightningMaxDuration = source.stormParams.lightningMaxDuration;\n    this.lightningParameters = LightningStrike.copyParameters({}, source.lightningParameters);\n    this.lightningMaterial = source.stormParams.lightningMaterial;\n    this.onLightningDown = source.onLightningDown;\n    return this;\n  }\n  clone() {\n    return new this.constructor(this.stormParams).copy(this);\n  }\n}\nexport {\n  LightningStorm\n};\n"]},"metadata":{},"sourceType":"module"}