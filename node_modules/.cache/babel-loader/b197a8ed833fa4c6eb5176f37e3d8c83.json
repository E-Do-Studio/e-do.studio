{"ast":null,"code":"import _classCallCheck from \"/Users/theodaguier/_workdir/dev/pro/e-do/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/theodaguier/_workdir/dev/pro/e-do/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/theodaguier/_workdir/dev/pro/e-do/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/theodaguier/_workdir/dev/pro/e-do/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { Loader, FileLoader, ShapePath, Vector2, Path, Matrix3, Vector3, ShapeUtils, Box2, Shape, BufferGeometry, Float32BufferAttribute } from \"three\";\n\nvar SVGLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(SVGLoader, _Loader);\n\n  var _super = _createSuper(SVGLoader);\n\n  function SVGLoader(manager) {\n    var _this;\n\n    _classCallCheck(this, SVGLoader);\n\n    _this = _super.call(this, manager);\n    _this.defaultDPI = 90;\n    _this.defaultUnit = \"px\";\n    return _this;\n  }\n\n  _createClass(SVGLoader, [{\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var loader = new FileLoader(scope.manager);\n      loader.setPath(scope.path);\n      loader.setRequestHeader(scope.requestHeader);\n      loader.setWithCredentials(scope.withCredentials);\n      loader.load(url, function (text) {\n        try {\n          onLoad(scope.parse(text));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(text) {\n      var scope = this;\n\n      function parseNode(node, style) {\n        if (node.nodeType !== 1) return;\n        var transform = getNodeTransform(node);\n        var traverseChildNodes = true;\n        var path = null;\n\n        switch (node.nodeName) {\n          case \"svg\":\n            break;\n\n          case \"style\":\n            parseCSSStylesheet(node);\n            break;\n\n          case \"g\":\n            style = parseStyle(node, style);\n            break;\n\n          case \"path\":\n            style = parseStyle(node, style);\n            if (node.hasAttribute(\"d\")) path = parsePathNode(node);\n            break;\n\n          case \"rect\":\n            style = parseStyle(node, style);\n            path = parseRectNode(node);\n            break;\n\n          case \"polygon\":\n            style = parseStyle(node, style);\n            path = parsePolygonNode(node);\n            break;\n\n          case \"polyline\":\n            style = parseStyle(node, style);\n            path = parsePolylineNode(node);\n            break;\n\n          case \"circle\":\n            style = parseStyle(node, style);\n            path = parseCircleNode(node);\n            break;\n\n          case \"ellipse\":\n            style = parseStyle(node, style);\n            path = parseEllipseNode(node);\n            break;\n\n          case \"line\":\n            style = parseStyle(node, style);\n            path = parseLineNode(node);\n            break;\n\n          case \"defs\":\n            traverseChildNodes = false;\n            break;\n\n          case \"mask\":\n            traverseChildNodes = false;\n            break;\n\n          case \"use\":\n            style = parseStyle(node, style);\n            var usedNodeId = node.href.baseVal.substring(1);\n            var usedNode = node.viewportElement.getElementById(usedNodeId);\n\n            if (usedNode) {\n              parseNode(usedNode, style);\n            } else {\n              console.warn(\"SVGLoader: 'use node' references non-existent node id: \" + usedNodeId);\n            }\n\n            break;\n\n          default:\n        }\n\n        if (path) {\n          if (style.fill !== void 0 && style.fill !== \"none\") {\n            path.color.setStyle(style.fill);\n          }\n\n          transformPath(path, currentTransform);\n          paths.push(path);\n          path.userData = {\n            node: node,\n            style: style\n          };\n        }\n\n        if (traverseChildNodes) {\n          var nodes = node.childNodes;\n\n          for (var i = 0; i < nodes.length; i++) {\n            parseNode(nodes[i], style);\n          }\n        }\n\n        if (transform) {\n          transformStack.pop();\n\n          if (transformStack.length > 0) {\n            currentTransform.copy(transformStack[transformStack.length - 1]);\n          } else {\n            currentTransform.identity();\n          }\n        }\n      }\n\n      function parsePathNode(node) {\n        var path = new ShapePath();\n        var point = new Vector2();\n        var control = new Vector2();\n        var firstPoint = new Vector2();\n        var isFirstPoint = true;\n        var doSetFirstPoint = false;\n        var d = node.getAttribute(\"d\");\n        var commands = d.match(/[a-df-z][^a-df-z]*/gi);\n\n        for (var i = 0, l = commands.length; i < l; i++) {\n          var command = commands[i];\n          var type = command.charAt(0);\n          var data2 = command.substr(1).trim();\n\n          if (isFirstPoint === true) {\n            doSetFirstPoint = true;\n            isFirstPoint = false;\n          }\n\n          var numbers = void 0;\n\n          switch (type) {\n            case \"M\":\n              numbers = parseFloats(data2);\n\n              for (var j = 0, jl = numbers.length; j < jl; j += 2) {\n                point.x = numbers[j + 0];\n                point.y = numbers[j + 1];\n                control.x = point.x;\n                control.y = point.y;\n\n                if (j === 0) {\n                  path.moveTo(point.x, point.y);\n                } else {\n                  path.lineTo(point.x, point.y);\n                }\n\n                if (j === 0) firstPoint.copy(point);\n              }\n\n              break;\n\n            case \"H\":\n              numbers = parseFloats(data2);\n\n              for (var _j = 0, _jl = numbers.length; _j < _jl; _j++) {\n                point.x = numbers[_j];\n                control.x = point.x;\n                control.y = point.y;\n                path.lineTo(point.x, point.y);\n                if (_j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n\n              break;\n\n            case \"V\":\n              numbers = parseFloats(data2);\n\n              for (var _j2 = 0, _jl2 = numbers.length; _j2 < _jl2; _j2++) {\n                point.y = numbers[_j2];\n                control.x = point.x;\n                control.y = point.y;\n                path.lineTo(point.x, point.y);\n                if (_j2 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n\n              break;\n\n            case \"L\":\n              numbers = parseFloats(data2);\n\n              for (var _j3 = 0, _jl3 = numbers.length; _j3 < _jl3; _j3 += 2) {\n                point.x = numbers[_j3 + 0];\n                point.y = numbers[_j3 + 1];\n                control.x = point.x;\n                control.y = point.y;\n                path.lineTo(point.x, point.y);\n                if (_j3 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n\n              break;\n\n            case \"C\":\n              numbers = parseFloats(data2);\n\n              for (var _j4 = 0, _jl4 = numbers.length; _j4 < _jl4; _j4 += 6) {\n                path.bezierCurveTo(numbers[_j4 + 0], numbers[_j4 + 1], numbers[_j4 + 2], numbers[_j4 + 3], numbers[_j4 + 4], numbers[_j4 + 5]);\n                control.x = numbers[_j4 + 2];\n                control.y = numbers[_j4 + 3];\n                point.x = numbers[_j4 + 4];\n                point.y = numbers[_j4 + 5];\n                if (_j4 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n\n              break;\n\n            case \"S\":\n              numbers = parseFloats(data2);\n\n              for (var _j5 = 0, _jl5 = numbers.length; _j5 < _jl5; _j5 += 4) {\n                path.bezierCurveTo(getReflection(point.x, control.x), getReflection(point.y, control.y), numbers[_j5 + 0], numbers[_j5 + 1], numbers[_j5 + 2], numbers[_j5 + 3]);\n                control.x = numbers[_j5 + 0];\n                control.y = numbers[_j5 + 1];\n                point.x = numbers[_j5 + 2];\n                point.y = numbers[_j5 + 3];\n                if (_j5 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n\n              break;\n\n            case \"Q\":\n              numbers = parseFloats(data2);\n\n              for (var _j6 = 0, _jl6 = numbers.length; _j6 < _jl6; _j6 += 4) {\n                path.quadraticCurveTo(numbers[_j6 + 0], numbers[_j6 + 1], numbers[_j6 + 2], numbers[_j6 + 3]);\n                control.x = numbers[_j6 + 0];\n                control.y = numbers[_j6 + 1];\n                point.x = numbers[_j6 + 2];\n                point.y = numbers[_j6 + 3];\n                if (_j6 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n\n              break;\n\n            case \"T\":\n              numbers = parseFloats(data2);\n\n              for (var _j7 = 0, _jl7 = numbers.length; _j7 < _jl7; _j7 += 2) {\n                var rx = getReflection(point.x, control.x);\n                var ry = getReflection(point.y, control.y);\n                path.quadraticCurveTo(rx, ry, numbers[_j7 + 0], numbers[_j7 + 1]);\n                control.x = rx;\n                control.y = ry;\n                point.x = numbers[_j7 + 0];\n                point.y = numbers[_j7 + 1];\n                if (_j7 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n\n              break;\n\n            case \"A\":\n              numbers = parseFloats(data2, [3, 4], 7);\n\n              for (var _j8 = 0, _jl8 = numbers.length; _j8 < _jl8; _j8 += 7) {\n                if (numbers[_j8 + 5] == point.x && numbers[_j8 + 6] == point.y) continue;\n                var start = point.clone();\n                point.x = numbers[_j8 + 5];\n                point.y = numbers[_j8 + 6];\n                control.x = point.x;\n                control.y = point.y;\n                parseArcCommand(path, numbers[_j8], numbers[_j8 + 1], numbers[_j8 + 2], numbers[_j8 + 3], numbers[_j8 + 4], start, point);\n                if (_j8 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n\n              break;\n\n            case \"m\":\n              numbers = parseFloats(data2);\n\n              for (var _j9 = 0, _jl9 = numbers.length; _j9 < _jl9; _j9 += 2) {\n                point.x += numbers[_j9 + 0];\n                point.y += numbers[_j9 + 1];\n                control.x = point.x;\n                control.y = point.y;\n\n                if (_j9 === 0) {\n                  path.moveTo(point.x, point.y);\n                } else {\n                  path.lineTo(point.x, point.y);\n                }\n\n                if (_j9 === 0) firstPoint.copy(point);\n              }\n\n              break;\n\n            case \"h\":\n              numbers = parseFloats(data2);\n\n              for (var _j10 = 0, _jl10 = numbers.length; _j10 < _jl10; _j10++) {\n                point.x += numbers[_j10];\n                control.x = point.x;\n                control.y = point.y;\n                path.lineTo(point.x, point.y);\n                if (_j10 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n\n              break;\n\n            case \"v\":\n              numbers = parseFloats(data2);\n\n              for (var _j11 = 0, _jl11 = numbers.length; _j11 < _jl11; _j11++) {\n                point.y += numbers[_j11];\n                control.x = point.x;\n                control.y = point.y;\n                path.lineTo(point.x, point.y);\n                if (_j11 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n\n              break;\n\n            case \"l\":\n              numbers = parseFloats(data2);\n\n              for (var _j12 = 0, _jl12 = numbers.length; _j12 < _jl12; _j12 += 2) {\n                point.x += numbers[_j12 + 0];\n                point.y += numbers[_j12 + 1];\n                control.x = point.x;\n                control.y = point.y;\n                path.lineTo(point.x, point.y);\n                if (_j12 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n\n              break;\n\n            case \"c\":\n              numbers = parseFloats(data2);\n\n              for (var _j13 = 0, _jl13 = numbers.length; _j13 < _jl13; _j13 += 6) {\n                path.bezierCurveTo(point.x + numbers[_j13 + 0], point.y + numbers[_j13 + 1], point.x + numbers[_j13 + 2], point.y + numbers[_j13 + 3], point.x + numbers[_j13 + 4], point.y + numbers[_j13 + 5]);\n                control.x = point.x + numbers[_j13 + 2];\n                control.y = point.y + numbers[_j13 + 3];\n                point.x += numbers[_j13 + 4];\n                point.y += numbers[_j13 + 5];\n                if (_j13 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n\n              break;\n\n            case \"s\":\n              numbers = parseFloats(data2);\n\n              for (var _j14 = 0, _jl14 = numbers.length; _j14 < _jl14; _j14 += 4) {\n                path.bezierCurveTo(getReflection(point.x, control.x), getReflection(point.y, control.y), point.x + numbers[_j14 + 0], point.y + numbers[_j14 + 1], point.x + numbers[_j14 + 2], point.y + numbers[_j14 + 3]);\n                control.x = point.x + numbers[_j14 + 0];\n                control.y = point.y + numbers[_j14 + 1];\n                point.x += numbers[_j14 + 2];\n                point.y += numbers[_j14 + 3];\n                if (_j14 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n\n              break;\n\n            case \"q\":\n              numbers = parseFloats(data2);\n\n              for (var _j15 = 0, _jl15 = numbers.length; _j15 < _jl15; _j15 += 4) {\n                path.quadraticCurveTo(point.x + numbers[_j15 + 0], point.y + numbers[_j15 + 1], point.x + numbers[_j15 + 2], point.y + numbers[_j15 + 3]);\n                control.x = point.x + numbers[_j15 + 0];\n                control.y = point.y + numbers[_j15 + 1];\n                point.x += numbers[_j15 + 2];\n                point.y += numbers[_j15 + 3];\n                if (_j15 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n\n              break;\n\n            case \"t\":\n              numbers = parseFloats(data2);\n\n              for (var _j16 = 0, _jl16 = numbers.length; _j16 < _jl16; _j16 += 2) {\n                var _rx = getReflection(point.x, control.x);\n\n                var _ry = getReflection(point.y, control.y);\n\n                path.quadraticCurveTo(_rx, _ry, point.x + numbers[_j16 + 0], point.y + numbers[_j16 + 1]);\n                control.x = _rx;\n                control.y = _ry;\n                point.x = point.x + numbers[_j16 + 0];\n                point.y = point.y + numbers[_j16 + 1];\n                if (_j16 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n\n              break;\n\n            case \"a\":\n              numbers = parseFloats(data2, [3, 4], 7);\n\n              for (var _j17 = 0, _jl17 = numbers.length; _j17 < _jl17; _j17 += 7) {\n                if (numbers[_j17 + 5] == 0 && numbers[_j17 + 6] == 0) continue;\n\n                var _start = point.clone();\n\n                point.x += numbers[_j17 + 5];\n                point.y += numbers[_j17 + 6];\n                control.x = point.x;\n                control.y = point.y;\n                parseArcCommand(path, numbers[_j17], numbers[_j17 + 1], numbers[_j17 + 2], numbers[_j17 + 3], numbers[_j17 + 4], _start, point);\n                if (_j17 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n\n              break;\n\n            case \"Z\":\n            case \"z\":\n              path.currentPath.autoClose = true;\n\n              if (path.currentPath.curves.length > 0) {\n                point.copy(firstPoint);\n                path.currentPath.currentPoint.copy(point);\n                isFirstPoint = true;\n              }\n\n              break;\n\n            default:\n              console.warn(command);\n          }\n\n          doSetFirstPoint = false;\n        }\n\n        return path;\n      }\n\n      function parseCSSStylesheet(node) {\n        if (!node.sheet || !node.sheet.cssRules || !node.sheet.cssRules.length) return;\n\n        for (var i = 0; i < node.sheet.cssRules.length; i++) {\n          var stylesheet = node.sheet.cssRules[i];\n          if (stylesheet.type !== 1) continue;\n          var selectorList = stylesheet.selectorText.split(/,/gm).filter(Boolean).map(function (i2) {\n            return i2.trim();\n          });\n\n          for (var j = 0; j < selectorList.length; j++) {\n            stylesheets[selectorList[j]] = Object.assign(stylesheets[selectorList[j]] || {}, stylesheet.style);\n          }\n        }\n      }\n\n      function parseArcCommand(path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end) {\n        if (rx == 0 || ry == 0) {\n          path.lineTo(end.x, end.y);\n          return;\n        }\n\n        x_axis_rotation = x_axis_rotation * Math.PI / 180;\n        rx = Math.abs(rx);\n        ry = Math.abs(ry);\n        var dx2 = (start.x - end.x) / 2;\n        var dy2 = (start.y - end.y) / 2;\n        var x1p = Math.cos(x_axis_rotation) * dx2 + Math.sin(x_axis_rotation) * dy2;\n        var y1p = -Math.sin(x_axis_rotation) * dx2 + Math.cos(x_axis_rotation) * dy2;\n        var rxs = rx * rx;\n        var rys = ry * ry;\n        var x1ps = x1p * x1p;\n        var y1ps = y1p * y1p;\n        var cr = x1ps / rxs + y1ps / rys;\n\n        if (cr > 1) {\n          var s = Math.sqrt(cr);\n          rx = s * rx;\n          ry = s * ry;\n          rxs = rx * rx;\n          rys = ry * ry;\n        }\n\n        var dq = rxs * y1ps + rys * x1ps;\n        var pq = (rxs * rys - dq) / dq;\n        var q = Math.sqrt(Math.max(0, pq));\n        if (large_arc_flag === sweep_flag) q = -q;\n        var cxp = q * rx * y1p / ry;\n        var cyp = -q * ry * x1p / rx;\n        var cx = Math.cos(x_axis_rotation) * cxp - Math.sin(x_axis_rotation) * cyp + (start.x + end.x) / 2;\n        var cy = Math.sin(x_axis_rotation) * cxp + Math.cos(x_axis_rotation) * cyp + (start.y + end.y) / 2;\n        var theta = svgAngle(1, 0, (x1p - cxp) / rx, (y1p - cyp) / ry);\n        var delta = svgAngle((x1p - cxp) / rx, (y1p - cyp) / ry, (-x1p - cxp) / rx, (-y1p - cyp) / ry) % (Math.PI * 2);\n        path.currentPath.absellipse(cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation);\n      }\n\n      function svgAngle(ux, uy, vx, vy) {\n        var dot = ux * vx + uy * vy;\n        var len = Math.sqrt(ux * ux + uy * uy) * Math.sqrt(vx * vx + vy * vy);\n        var ang = Math.acos(Math.max(-1, Math.min(1, dot / len)));\n        if (ux * vy - uy * vx < 0) ang = -ang;\n        return ang;\n      }\n\n      function parseRectNode(node) {\n        var x = parseFloatWithUnits(node.getAttribute(\"x\") || 0);\n        var y = parseFloatWithUnits(node.getAttribute(\"y\") || 0);\n        var rx = parseFloatWithUnits(node.getAttribute(\"rx\") || node.getAttribute(\"ry\") || 0);\n        var ry = parseFloatWithUnits(node.getAttribute(\"ry\") || node.getAttribute(\"rx\") || 0);\n        var w = parseFloatWithUnits(node.getAttribute(\"width\"));\n        var h = parseFloatWithUnits(node.getAttribute(\"height\"));\n        var bci = 1 - 0.551915024494;\n        var path = new ShapePath();\n        path.moveTo(x + rx, y);\n        path.lineTo(x + w - rx, y);\n\n        if (rx !== 0 || ry !== 0) {\n          path.bezierCurveTo(x + w - rx * bci, y, x + w, y + ry * bci, x + w, y + ry);\n        }\n\n        path.lineTo(x + w, y + h - ry);\n\n        if (rx !== 0 || ry !== 0) {\n          path.bezierCurveTo(x + w, y + h - ry * bci, x + w - rx * bci, y + h, x + w - rx, y + h);\n        }\n\n        path.lineTo(x + rx, y + h);\n\n        if (rx !== 0 || ry !== 0) {\n          path.bezierCurveTo(x + rx * bci, y + h, x, y + h - ry * bci, x, y + h - ry);\n        }\n\n        path.lineTo(x, y + ry);\n\n        if (rx !== 0 || ry !== 0) {\n          path.bezierCurveTo(x, y + ry * bci, x + rx * bci, y, x + rx, y);\n        }\n\n        return path;\n      }\n\n      function parsePolygonNode(node) {\n        function iterator(match, a, b) {\n          var x = parseFloatWithUnits(a);\n          var y = parseFloatWithUnits(b);\n\n          if (index === 0) {\n            path.moveTo(x, y);\n          } else {\n            path.lineTo(x, y);\n          }\n\n          index++;\n        }\n\n        var regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\n        var path = new ShapePath();\n        var index = 0;\n        node.getAttribute(\"points\").replace(regex, iterator);\n        path.currentPath.autoClose = true;\n        return path;\n      }\n\n      function parsePolylineNode(node) {\n        function iterator(match, a, b) {\n          var x = parseFloatWithUnits(a);\n          var y = parseFloatWithUnits(b);\n\n          if (index === 0) {\n            path.moveTo(x, y);\n          } else {\n            path.lineTo(x, y);\n          }\n\n          index++;\n        }\n\n        var regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\n        var path = new ShapePath();\n        var index = 0;\n        node.getAttribute(\"points\").replace(regex, iterator);\n        path.currentPath.autoClose = false;\n        return path;\n      }\n\n      function parseCircleNode(node) {\n        var x = parseFloatWithUnits(node.getAttribute(\"cx\") || 0);\n        var y = parseFloatWithUnits(node.getAttribute(\"cy\") || 0);\n        var r = parseFloatWithUnits(node.getAttribute(\"r\") || 0);\n        var subpath = new Path();\n        subpath.absarc(x, y, r, 0, Math.PI * 2);\n        var path = new ShapePath();\n        path.subPaths.push(subpath);\n        return path;\n      }\n\n      function parseEllipseNode(node) {\n        var x = parseFloatWithUnits(node.getAttribute(\"cx\") || 0);\n        var y = parseFloatWithUnits(node.getAttribute(\"cy\") || 0);\n        var rx = parseFloatWithUnits(node.getAttribute(\"rx\") || 0);\n        var ry = parseFloatWithUnits(node.getAttribute(\"ry\") || 0);\n        var subpath = new Path();\n        subpath.absellipse(x, y, rx, ry, 0, Math.PI * 2);\n        var path = new ShapePath();\n        path.subPaths.push(subpath);\n        return path;\n      }\n\n      function parseLineNode(node) {\n        var x1 = parseFloatWithUnits(node.getAttribute(\"x1\") || 0);\n        var y1 = parseFloatWithUnits(node.getAttribute(\"y1\") || 0);\n        var x2 = parseFloatWithUnits(node.getAttribute(\"x2\") || 0);\n        var y2 = parseFloatWithUnits(node.getAttribute(\"y2\") || 0);\n        var path = new ShapePath();\n        path.moveTo(x1, y1);\n        path.lineTo(x2, y2);\n        path.currentPath.autoClose = false;\n        return path;\n      }\n\n      function parseStyle(node, style) {\n        style = Object.assign({}, style);\n        var stylesheetStyles = {};\n\n        if (node.hasAttribute(\"class\")) {\n          var classSelectors = node.getAttribute(\"class\").split(/\\s/).filter(Boolean).map(function (i) {\n            return i.trim();\n          });\n\n          for (var i = 0; i < classSelectors.length; i++) {\n            stylesheetStyles = Object.assign(stylesheetStyles, stylesheets[\".\" + classSelectors[i]]);\n          }\n        }\n\n        if (node.hasAttribute(\"id\")) {\n          stylesheetStyles = Object.assign(stylesheetStyles, stylesheets[\"#\" + node.getAttribute(\"id\")]);\n        }\n\n        function addStyle(svgName, jsName, adjustFunction) {\n          if (adjustFunction === void 0) {\n            adjustFunction = function copy(v) {\n              if (v.startsWith(\"url\")) console.warn(\"SVGLoader: url access in attributes is not implemented.\");\n              return v;\n            };\n          }\n\n          if (node.hasAttribute(svgName)) style[jsName] = adjustFunction(node.getAttribute(svgName));\n          if (stylesheetStyles[svgName]) style[jsName] = adjustFunction(stylesheetStyles[svgName]);\n          if (node.style && node.style[svgName] !== \"\") style[jsName] = adjustFunction(node.style[svgName]);\n        }\n\n        function clamp(v) {\n          return Math.max(0, Math.min(1, parseFloatWithUnits(v)));\n        }\n\n        function positive(v) {\n          return Math.max(0, parseFloatWithUnits(v));\n        }\n\n        addStyle(\"fill\", \"fill\");\n        addStyle(\"fill-opacity\", \"fillOpacity\", clamp);\n        addStyle(\"fill-rule\", \"fillRule\");\n        addStyle(\"opacity\", \"opacity\", clamp);\n        addStyle(\"stroke\", \"stroke\");\n        addStyle(\"stroke-opacity\", \"strokeOpacity\", clamp);\n        addStyle(\"stroke-width\", \"strokeWidth\", positive);\n        addStyle(\"stroke-linejoin\", \"strokeLineJoin\");\n        addStyle(\"stroke-linecap\", \"strokeLineCap\");\n        addStyle(\"stroke-miterlimit\", \"strokeMiterLimit\", positive);\n        addStyle(\"visibility\", \"visibility\");\n        return style;\n      }\n\n      function getReflection(a, b) {\n        return a - (b - a);\n      }\n\n      function parseFloats(input, flags, stride) {\n        if (typeof input !== \"string\") {\n          throw new TypeError(\"Invalid input: \" + typeof input);\n        }\n\n        var RE = {\n          SEPARATOR: /[ \\t\\r\\n\\,.\\-+]/,\n          WHITESPACE: /[ \\t\\r\\n]/,\n          DIGIT: /[\\d]/,\n          SIGN: /[-+]/,\n          POINT: /\\./,\n          COMMA: /,/,\n          EXP: /e/i,\n          FLAGS: /[01]/\n        };\n        var SEP = 0;\n        var INT = 1;\n        var FLOAT = 2;\n        var EXP = 3;\n        var state = SEP;\n        var seenComma = true;\n        var number = \"\",\n            exponent = \"\";\n        var result = [];\n\n        function throwSyntaxError(current2, i, partial) {\n          var error = new SyntaxError('Unexpected character \"' + current2 + '\" at index ' + i + \".\");\n          error.partial = partial;\n          throw error;\n        }\n\n        function newNumber() {\n          if (number !== \"\") {\n            if (exponent === \"\") result.push(Number(number));else result.push(Number(number) * Math.pow(10, Number(exponent)));\n          }\n\n          number = \"\";\n          exponent = \"\";\n        }\n\n        var current;\n        var length = input.length;\n\n        for (var i = 0; i < length; i++) {\n          current = input[i];\n\n          if (Array.isArray(flags) && flags.includes(result.length % stride) && RE.FLAGS.test(current)) {\n            state = INT;\n            number = current;\n            newNumber();\n            continue;\n          }\n\n          if (state === SEP) {\n            if (RE.WHITESPACE.test(current)) {\n              continue;\n            }\n\n            if (RE.DIGIT.test(current) || RE.SIGN.test(current)) {\n              state = INT;\n              number = current;\n              continue;\n            }\n\n            if (RE.POINT.test(current)) {\n              state = FLOAT;\n              number = current;\n              continue;\n            }\n\n            if (RE.COMMA.test(current)) {\n              if (seenComma) {\n                throwSyntaxError(current, i, result);\n              }\n\n              seenComma = true;\n            }\n          }\n\n          if (state === INT) {\n            if (RE.DIGIT.test(current)) {\n              number += current;\n              continue;\n            }\n\n            if (RE.POINT.test(current)) {\n              number += current;\n              state = FLOAT;\n              continue;\n            }\n\n            if (RE.EXP.test(current)) {\n              state = EXP;\n              continue;\n            }\n\n            if (RE.SIGN.test(current) && number.length === 1 && RE.SIGN.test(number[0])) {\n              throwSyntaxError(current, i, result);\n            }\n          }\n\n          if (state === FLOAT) {\n            if (RE.DIGIT.test(current)) {\n              number += current;\n              continue;\n            }\n\n            if (RE.EXP.test(current)) {\n              state = EXP;\n              continue;\n            }\n\n            if (RE.POINT.test(current) && number[number.length - 1] === \".\") {\n              throwSyntaxError(current, i, result);\n            }\n          }\n\n          if (state === EXP) {\n            if (RE.DIGIT.test(current)) {\n              exponent += current;\n              continue;\n            }\n\n            if (RE.SIGN.test(current)) {\n              if (exponent === \"\") {\n                exponent += current;\n                continue;\n              }\n\n              if (exponent.length === 1 && RE.SIGN.test(exponent)) {\n                throwSyntaxError(current, i, result);\n              }\n            }\n          }\n\n          if (RE.WHITESPACE.test(current)) {\n            newNumber();\n            state = SEP;\n            seenComma = false;\n          } else if (RE.COMMA.test(current)) {\n            newNumber();\n            state = SEP;\n            seenComma = true;\n          } else if (RE.SIGN.test(current)) {\n            newNumber();\n            state = INT;\n            number = current;\n          } else if (RE.POINT.test(current)) {\n            newNumber();\n            state = FLOAT;\n            number = current;\n          } else {\n            throwSyntaxError(current, i, result);\n          }\n        }\n\n        newNumber();\n        return result;\n      }\n\n      var units = [\"mm\", \"cm\", \"in\", \"pt\", \"pc\", \"px\"];\n      var unitConversion = {\n        mm: {\n          mm: 1,\n          cm: 0.1,\n          in: 1 / 25.4,\n          pt: 72 / 25.4,\n          pc: 6 / 25.4,\n          px: -1\n        },\n        cm: {\n          mm: 10,\n          cm: 1,\n          in: 1 / 2.54,\n          pt: 72 / 2.54,\n          pc: 6 / 2.54,\n          px: -1\n        },\n        in: {\n          mm: 25.4,\n          cm: 2.54,\n          in: 1,\n          pt: 72,\n          pc: 6,\n          px: -1\n        },\n        pt: {\n          mm: 25.4 / 72,\n          cm: 2.54 / 72,\n          in: 1 / 72,\n          pt: 1,\n          pc: 6 / 72,\n          px: -1\n        },\n        pc: {\n          mm: 25.4 / 6,\n          cm: 2.54 / 6,\n          in: 1 / 6,\n          pt: 72 / 6,\n          pc: 1,\n          px: -1\n        },\n        px: {\n          px: 1\n        }\n      };\n\n      function parseFloatWithUnits(string) {\n        var theUnit = \"px\";\n\n        if (typeof string === \"string\" || string instanceof String) {\n          for (var i = 0, n = units.length; i < n; i++) {\n            var u = units[i];\n\n            if (string.endsWith(u)) {\n              theUnit = u;\n              string = string.substring(0, string.length - u.length);\n              break;\n            }\n          }\n        }\n\n        var scale = void 0;\n\n        if (theUnit === \"px\" && scope.defaultUnit !== \"px\") {\n          scale = unitConversion[\"in\"][scope.defaultUnit] / scope.defaultDPI;\n        } else {\n          scale = unitConversion[theUnit][scope.defaultUnit];\n\n          if (scale < 0) {\n            scale = unitConversion[theUnit][\"in\"] * scope.defaultDPI;\n          }\n        }\n\n        return scale * parseFloat(string);\n      }\n\n      function getNodeTransform(node) {\n        if (!(node.hasAttribute(\"transform\") || node.nodeName === \"use\" && (node.hasAttribute(\"x\") || node.hasAttribute(\"y\")))) {\n          return null;\n        }\n\n        var transform = parseNodeTransform(node);\n\n        if (transformStack.length > 0) {\n          transform.premultiply(transformStack[transformStack.length - 1]);\n        }\n\n        currentTransform.copy(transform);\n        transformStack.push(transform);\n        return transform;\n      }\n\n      function parseNodeTransform(node) {\n        var transform = new Matrix3();\n        var currentTransform2 = tempTransform0;\n\n        if (node.nodeName === \"use\" && (node.hasAttribute(\"x\") || node.hasAttribute(\"y\"))) {\n          var tx = parseFloatWithUnits(node.getAttribute(\"x\"));\n          var ty = parseFloatWithUnits(node.getAttribute(\"y\"));\n          transform.translate(tx, ty);\n        }\n\n        if (node.hasAttribute(\"transform\")) {\n          var transformsTexts = node.getAttribute(\"transform\").split(\")\");\n\n          for (var tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex--) {\n            var transformText = transformsTexts[tIndex].trim();\n            if (transformText === \"\") continue;\n            var openParPos = transformText.indexOf(\"(\");\n            var closeParPos = transformText.length;\n\n            if (openParPos > 0 && openParPos < closeParPos) {\n              var transformType = transformText.substr(0, openParPos);\n              var array = parseFloats(transformText.substr(openParPos + 1, closeParPos - openParPos - 1));\n              currentTransform2.identity();\n\n              switch (transformType) {\n                case \"translate\":\n                  if (array.length >= 1) {\n                    var _tx = array[0];\n                    var _ty = _tx;\n\n                    if (array.length >= 2) {\n                      _ty = array[1];\n                    }\n\n                    currentTransform2.translate(_tx, _ty);\n                  }\n\n                  break;\n\n                case \"rotate\":\n                  if (array.length >= 1) {\n                    var angle = 0;\n                    var cx = 0;\n                    var cy = 0;\n                    angle = -array[0] * Math.PI / 180;\n\n                    if (array.length >= 3) {\n                      cx = array[1];\n                      cy = array[2];\n                    }\n\n                    tempTransform1.identity().translate(-cx, -cy);\n                    tempTransform2.identity().rotate(angle);\n                    tempTransform3.multiplyMatrices(tempTransform2, tempTransform1);\n                    tempTransform1.identity().translate(cx, cy);\n                    currentTransform2.multiplyMatrices(tempTransform1, tempTransform3);\n                  }\n\n                  break;\n\n                case \"scale\":\n                  if (array.length >= 1) {\n                    var scaleX = array[0];\n                    var scaleY = scaleX;\n\n                    if (array.length >= 2) {\n                      scaleY = array[1];\n                    }\n\n                    currentTransform2.scale(scaleX, scaleY);\n                  }\n\n                  break;\n\n                case \"skewX\":\n                  if (array.length === 1) {\n                    currentTransform2.set(1, Math.tan(array[0] * Math.PI / 180), 0, 0, 1, 0, 0, 0, 1);\n                  }\n\n                  break;\n\n                case \"skewY\":\n                  if (array.length === 1) {\n                    currentTransform2.set(1, 0, 0, Math.tan(array[0] * Math.PI / 180), 1, 0, 0, 0, 1);\n                  }\n\n                  break;\n\n                case \"matrix\":\n                  if (array.length === 6) {\n                    currentTransform2.set(array[0], array[2], array[4], array[1], array[3], array[5], 0, 0, 1);\n                  }\n\n                  break;\n              }\n            }\n\n            transform.premultiply(currentTransform2);\n          }\n        }\n\n        return transform;\n      }\n\n      function transformPath(path, m) {\n        function transfVec2(v2) {\n          tempV3.set(v2.x, v2.y, 1).applyMatrix3(m);\n          v2.set(tempV3.x, tempV3.y);\n        }\n\n        var isRotated = isTransformRotated(m);\n        var subPaths = path.subPaths;\n\n        for (var i = 0, n = subPaths.length; i < n; i++) {\n          var subPath = subPaths[i];\n          var curves = subPath.curves;\n\n          for (var j = 0; j < curves.length; j++) {\n            var curve = curves[j];\n\n            if (curve.isLineCurve) {\n              transfVec2(curve.v1);\n              transfVec2(curve.v2);\n            } else if (curve.isCubicBezierCurve) {\n              transfVec2(curve.v0);\n              transfVec2(curve.v1);\n              transfVec2(curve.v2);\n              transfVec2(curve.v3);\n            } else if (curve.isQuadraticBezierCurve) {\n              transfVec2(curve.v0);\n              transfVec2(curve.v1);\n              transfVec2(curve.v2);\n            } else if (curve.isEllipseCurve) {\n              if (isRotated) {\n                console.warn(\"SVGLoader: Elliptic arc or ellipse rotation or skewing is not implemented.\");\n              }\n\n              tempV2.set(curve.aX, curve.aY);\n              transfVec2(tempV2);\n              curve.aX = tempV2.x;\n              curve.aY = tempV2.y;\n              curve.xRadius *= getTransformScaleX(m);\n              curve.yRadius *= getTransformScaleY(m);\n            }\n          }\n        }\n      }\n\n      function isTransformRotated(m) {\n        return m.elements[1] !== 0 || m.elements[3] !== 0;\n      }\n\n      function getTransformScaleX(m) {\n        var te = m.elements;\n        return Math.sqrt(te[0] * te[0] + te[1] * te[1]);\n      }\n\n      function getTransformScaleY(m) {\n        var te = m.elements;\n        return Math.sqrt(te[3] * te[3] + te[4] * te[4]);\n      }\n\n      var paths = [];\n      var stylesheets = {};\n      var transformStack = [];\n      var tempTransform0 = new Matrix3();\n      var tempTransform1 = new Matrix3();\n      var tempTransform2 = new Matrix3();\n      var tempTransform3 = new Matrix3();\n      var tempV2 = new Vector2();\n      var tempV3 = new Vector3();\n      var currentTransform = new Matrix3();\n      var xml = new DOMParser().parseFromString(text, \"image/svg+xml\");\n      parseNode(xml.documentElement, {\n        fill: \"#000\",\n        fillOpacity: 1,\n        strokeOpacity: 1,\n        strokeWidth: 1,\n        strokeLineJoin: \"miter\",\n        strokeLineCap: \"butt\",\n        strokeMiterLimit: 4\n      });\n      var data = {\n        paths: paths,\n        xml: xml.documentElement\n      };\n      return data;\n    }\n  }], [{\n    key: \"createShapes\",\n    value: function createShapes(shapePath) {\n      var BIGNUMBER = 999999999;\n      var IntersectionLocationType = {\n        ORIGIN: 0,\n        DESTINATION: 1,\n        BETWEEN: 2,\n        LEFT: 3,\n        RIGHT: 4,\n        BEHIND: 5,\n        BEYOND: 6\n      };\n      var classifyResult = {\n        loc: IntersectionLocationType.ORIGIN,\n        t: 0\n      };\n\n      function findEdgeIntersection(a0, a1, b0, b1) {\n        var x1 = a0.x;\n        var x2 = a1.x;\n        var x3 = b0.x;\n        var x4 = b1.x;\n        var y1 = a0.y;\n        var y2 = a1.y;\n        var y3 = b0.y;\n        var y4 = b1.y;\n        var nom1 = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);\n        var nom2 = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);\n        var denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);\n        var t1 = nom1 / denom;\n        var t2 = nom2 / denom;\n\n        if (denom === 0 && nom1 !== 0 || t1 <= 0 || t1 >= 1 || t2 < 0 || t2 > 1) {\n          return null;\n        } else if (nom1 === 0 && denom === 0) {\n          for (var i = 0; i < 2; i++) {\n            classifyPoint(i === 0 ? b0 : b1, a0, a1);\n\n            if (classifyResult.loc == IntersectionLocationType.ORIGIN) {\n              var point = i === 0 ? b0 : b1;\n              return {\n                x: point.x,\n                y: point.y,\n                t: classifyResult.t\n              };\n            } else if (classifyResult.loc == IntersectionLocationType.BETWEEN) {\n              var x = +(x1 + classifyResult.t * (x2 - x1)).toPrecision(10);\n              var y = +(y1 + classifyResult.t * (y2 - y1)).toPrecision(10);\n              return {\n                x: x,\n                y: y,\n                t: classifyResult.t\n              };\n            }\n          }\n\n          return null;\n        } else {\n          for (var _i = 0; _i < 2; _i++) {\n            classifyPoint(_i === 0 ? b0 : b1, a0, a1);\n\n            if (classifyResult.loc == IntersectionLocationType.ORIGIN) {\n              var _point = _i === 0 ? b0 : b1;\n\n              return {\n                x: _point.x,\n                y: _point.y,\n                t: classifyResult.t\n              };\n            }\n          }\n\n          var _x = +(x1 + t1 * (x2 - x1)).toPrecision(10);\n\n          var _y = +(y1 + t1 * (y2 - y1)).toPrecision(10);\n\n          return {\n            x: _x,\n            y: _y,\n            t: t1\n          };\n        }\n      }\n\n      function classifyPoint(p, edgeStart, edgeEnd) {\n        var ax = edgeEnd.x - edgeStart.x;\n        var ay = edgeEnd.y - edgeStart.y;\n        var bx = p.x - edgeStart.x;\n        var by = p.y - edgeStart.y;\n        var sa = ax * by - bx * ay;\n\n        if (p.x === edgeStart.x && p.y === edgeStart.y) {\n          classifyResult.loc = IntersectionLocationType.ORIGIN;\n          classifyResult.t = 0;\n          return;\n        }\n\n        if (p.x === edgeEnd.x && p.y === edgeEnd.y) {\n          classifyResult.loc = IntersectionLocationType.DESTINATION;\n          classifyResult.t = 1;\n          return;\n        }\n\n        if (sa < -Number.EPSILON) {\n          classifyResult.loc = IntersectionLocationType.LEFT;\n          return;\n        }\n\n        if (sa > Number.EPSILON) {\n          classifyResult.loc = IntersectionLocationType.RIGHT;\n          return;\n        }\n\n        if (ax * bx < 0 || ay * by < 0) {\n          classifyResult.loc = IntersectionLocationType.BEHIND;\n          return;\n        }\n\n        if (Math.sqrt(ax * ax + ay * ay) < Math.sqrt(bx * bx + by * by)) {\n          classifyResult.loc = IntersectionLocationType.BEYOND;\n          return;\n        }\n\n        var t;\n\n        if (ax !== 0) {\n          t = bx / ax;\n        } else {\n          t = by / ay;\n        }\n\n        classifyResult.loc = IntersectionLocationType.BETWEEN;\n        classifyResult.t = t;\n      }\n\n      function getIntersections(path1, path2) {\n        var intersectionsRaw = [];\n        var intersections = [];\n\n        for (var index = 1; index < path1.length; index++) {\n          var path1EdgeStart = path1[index - 1];\n          var path1EdgeEnd = path1[index];\n\n          var _loop = function _loop(index2) {\n            var path2EdgeStart = path2[index2 - 1];\n            var path2EdgeEnd = path2[index2];\n            var intersection = findEdgeIntersection(path1EdgeStart, path1EdgeEnd, path2EdgeStart, path2EdgeEnd);\n\n            if (intersection !== null && intersectionsRaw.find(function (i) {\n              return i.t <= intersection.t + Number.EPSILON && i.t >= intersection.t - Number.EPSILON;\n            }) === void 0) {\n              intersectionsRaw.push(intersection);\n              intersections.push(new Vector2(intersection.x, intersection.y));\n            }\n          };\n\n          for (var index2 = 1; index2 < path2.length; index2++) {\n            _loop(index2);\n          }\n        }\n\n        return intersections;\n      }\n\n      function getScanlineIntersections(scanline, boundingBox, paths) {\n        var center = new Vector2();\n        boundingBox.getCenter(center);\n        var allIntersections = [];\n        paths.forEach(function (path) {\n          if (path.boundingBox.containsPoint(center)) {\n            var intersections = getIntersections(scanline, path.points);\n            intersections.forEach(function (p) {\n              allIntersections.push({\n                identifier: path.identifier,\n                isCW: path.isCW,\n                point: p\n              });\n            });\n          }\n        });\n        allIntersections.sort(function (i1, i2) {\n          return i1.point.x - i2.point.x;\n        });\n        return allIntersections;\n      }\n\n      function isHoleTo(simplePath, allPaths, scanlineMinX2, scanlineMaxX2, _fillRule) {\n        if (_fillRule === null || _fillRule === void 0 || _fillRule === \"\") {\n          _fillRule = \"nonzero\";\n        }\n\n        var centerBoundingBox = new Vector2();\n        simplePath.boundingBox.getCenter(centerBoundingBox);\n        var scanline = [new Vector2(scanlineMinX2, centerBoundingBox.y), new Vector2(scanlineMaxX2, centerBoundingBox.y)];\n        var scanlineIntersections = getScanlineIntersections(scanline, simplePath.boundingBox, allPaths);\n        scanlineIntersections.sort(function (i1, i2) {\n          return i1.point.x - i2.point.x;\n        });\n        var baseIntersections = [];\n        var otherIntersections = [];\n        scanlineIntersections.forEach(function (i2) {\n          if (i2.identifier === simplePath.identifier) {\n            baseIntersections.push(i2);\n          } else {\n            otherIntersections.push(i2);\n          }\n        });\n        var firstXOfPath = baseIntersections[0].point.x;\n        var stack = [];\n        var i = 0;\n\n        while (i < otherIntersections.length && otherIntersections[i].point.x < firstXOfPath) {\n          if (stack.length > 0 && stack[stack.length - 1] === otherIntersections[i].identifier) {\n            stack.pop();\n          } else {\n            stack.push(otherIntersections[i].identifier);\n          }\n\n          i++;\n        }\n\n        stack.push(simplePath.identifier);\n\n        if (_fillRule === \"evenodd\") {\n          var isHole = stack.length % 2 === 0 ? true : false;\n          var isHoleFor = stack[stack.length - 2];\n          return {\n            identifier: simplePath.identifier,\n            isHole: isHole,\n            for: isHoleFor\n          };\n        } else if (_fillRule === \"nonzero\") {\n          var _isHole = true;\n          var _isHoleFor = null;\n          var lastCWValue = null;\n\n          for (var i2 = 0; i2 < stack.length; i2++) {\n            var identifier2 = stack[i2];\n\n            if (_isHole) {\n              lastCWValue = allPaths[identifier2].isCW;\n              _isHole = false;\n              _isHoleFor = identifier2;\n            } else if (lastCWValue !== allPaths[identifier2].isCW) {\n              lastCWValue = allPaths[identifier2].isCW;\n              _isHole = true;\n            }\n          }\n\n          return {\n            identifier: simplePath.identifier,\n            isHole: _isHole,\n            for: _isHoleFor\n          };\n        } else {\n          console.warn('fill-rule: \"' + _fillRule + '\" is currently not implemented.');\n        }\n      }\n\n      var identifier = 0;\n      var scanlineMinX = BIGNUMBER;\n      var scanlineMaxX = -BIGNUMBER;\n      var simplePaths = shapePath.subPaths.map(function (p) {\n        var points = p.getPoints();\n        var maxY = -BIGNUMBER;\n        var minY = BIGNUMBER;\n        var maxX = -BIGNUMBER;\n        var minX = BIGNUMBER;\n\n        for (var i = 0; i < points.length; i++) {\n          var p2 = points[i];\n\n          if (p2.y > maxY) {\n            maxY = p2.y;\n          }\n\n          if (p2.y < minY) {\n            minY = p2.y;\n          }\n\n          if (p2.x > maxX) {\n            maxX = p2.x;\n          }\n\n          if (p2.x < minX) {\n            minX = p2.x;\n          }\n        }\n\n        if (scanlineMaxX <= maxX) {\n          scanlineMaxX = maxX + 1;\n        }\n\n        if (scanlineMinX >= minX) {\n          scanlineMinX = minX - 1;\n        }\n\n        return {\n          curves: p.curves,\n          points: points,\n          isCW: ShapeUtils.isClockWise(points),\n          identifier: identifier++,\n          boundingBox: new Box2(new Vector2(minX, minY), new Vector2(maxX, maxY))\n        };\n      });\n      simplePaths = simplePaths.filter(function (sp) {\n        return sp.points.length > 1;\n      });\n      var isAHole = simplePaths.map(function (p) {\n        return isHoleTo(p, simplePaths, scanlineMinX, scanlineMaxX, shapePath.userData.style.fillRule);\n      });\n      var shapesToReturn = [];\n      simplePaths.forEach(function (p) {\n        var amIAHole = isAHole[p.identifier];\n\n        if (!amIAHole.isHole) {\n          var shape = new Shape();\n          shape.curves = p.curves;\n          var holes = isAHole.filter(function (h) {\n            return h.isHole && h.for === p.identifier;\n          });\n          holes.forEach(function (h) {\n            var hole = simplePaths[h.identifier];\n            var path = new Path();\n            path.curves = hole.curves;\n            shape.holes.push(path);\n          });\n          shapesToReturn.push(shape);\n        }\n      });\n      return shapesToReturn;\n    }\n  }, {\n    key: \"getStrokeStyle\",\n    value: function getStrokeStyle(width, color, lineJoin, lineCap, miterLimit) {\n      width = width !== void 0 ? width : 1;\n      color = color !== void 0 ? color : \"#000\";\n      lineJoin = lineJoin !== void 0 ? lineJoin : \"miter\";\n      lineCap = lineCap !== void 0 ? lineCap : \"butt\";\n      miterLimit = miterLimit !== void 0 ? miterLimit : 4;\n      return {\n        strokeColor: color,\n        strokeWidth: width,\n        strokeLineJoin: lineJoin,\n        strokeLineCap: lineCap,\n        strokeMiterLimit: miterLimit\n      };\n    }\n  }, {\n    key: \"pointsToStroke\",\n    value: function pointsToStroke(points, style, arcDivisions, minDistance) {\n      var vertices = [];\n      var normals = [];\n      var uvs = [];\n\n      if (SVGLoader.pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs) === 0) {\n        return null;\n      }\n\n      var geometry = new BufferGeometry();\n      geometry.setAttribute(\"position\", new Float32BufferAttribute(vertices, 3));\n      geometry.setAttribute(\"normal\", new Float32BufferAttribute(normals, 3));\n      geometry.setAttribute(\"uv\", new Float32BufferAttribute(uvs, 2));\n      return geometry;\n    }\n  }, {\n    key: \"pointsToStrokeWithBuffers\",\n    value: function pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs, vertexOffset) {\n      var tempV2_1 = new Vector2();\n      var tempV2_2 = new Vector2();\n      var tempV2_3 = new Vector2();\n      var tempV2_4 = new Vector2();\n      var tempV2_5 = new Vector2();\n      var tempV2_6 = new Vector2();\n      var tempV2_7 = new Vector2();\n      var lastPointL = new Vector2();\n      var lastPointR = new Vector2();\n      var point0L = new Vector2();\n      var point0R = new Vector2();\n      var currentPointL = new Vector2();\n      var currentPointR = new Vector2();\n      var nextPointL = new Vector2();\n      var nextPointR = new Vector2();\n      var innerPoint = new Vector2();\n      var outerPoint = new Vector2();\n      arcDivisions = arcDivisions !== void 0 ? arcDivisions : 12;\n      minDistance = minDistance !== void 0 ? minDistance : 1e-3;\n      vertexOffset = vertexOffset !== void 0 ? vertexOffset : 0;\n      points = removeDuplicatedPoints(points);\n      var numPoints = points.length;\n      if (numPoints < 2) return 0;\n      var isClosed = points[0].equals(points[numPoints - 1]);\n      var currentPoint;\n      var previousPoint = points[0];\n      var nextPoint;\n      var strokeWidth2 = style.strokeWidth / 2;\n      var deltaU = 1 / (numPoints - 1);\n      var u0 = 0,\n          u1;\n      var innerSideModified;\n      var joinIsOnLeftSide;\n      var isMiter;\n      var initialJoinIsOnLeftSide = false;\n      var numVertices = 0;\n      var currentCoordinate = vertexOffset * 3;\n      var currentCoordinateUV = vertexOffset * 2;\n      getNormal(points[0], points[1], tempV2_1).multiplyScalar(strokeWidth2);\n      lastPointL.copy(points[0]).sub(tempV2_1);\n      lastPointR.copy(points[0]).add(tempV2_1);\n      point0L.copy(lastPointL);\n      point0R.copy(lastPointR);\n\n      for (var iPoint = 1; iPoint < numPoints; iPoint++) {\n        currentPoint = points[iPoint];\n\n        if (iPoint === numPoints - 1) {\n          if (isClosed) {\n            nextPoint = points[1];\n          } else {\n            nextPoint = void 0;\n          }\n        } else {\n          nextPoint = points[iPoint + 1];\n        }\n\n        var normal1 = tempV2_1;\n        getNormal(previousPoint, currentPoint, normal1);\n        tempV2_3.copy(normal1).multiplyScalar(strokeWidth2);\n        currentPointL.copy(currentPoint).sub(tempV2_3);\n        currentPointR.copy(currentPoint).add(tempV2_3);\n        u1 = u0 + deltaU;\n        innerSideModified = false;\n\n        if (nextPoint !== void 0) {\n          getNormal(currentPoint, nextPoint, tempV2_2);\n          tempV2_3.copy(tempV2_2).multiplyScalar(strokeWidth2);\n          nextPointL.copy(currentPoint).sub(tempV2_3);\n          nextPointR.copy(currentPoint).add(tempV2_3);\n          joinIsOnLeftSide = true;\n          tempV2_3.subVectors(nextPoint, previousPoint);\n\n          if (normal1.dot(tempV2_3) < 0) {\n            joinIsOnLeftSide = false;\n          }\n\n          if (iPoint === 1) initialJoinIsOnLeftSide = joinIsOnLeftSide;\n          tempV2_3.subVectors(nextPoint, currentPoint);\n          tempV2_3.normalize();\n          var dot = Math.abs(normal1.dot(tempV2_3));\n\n          if (dot !== 0) {\n            var miterSide = strokeWidth2 / dot;\n            tempV2_3.multiplyScalar(-miterSide);\n            tempV2_4.subVectors(currentPoint, previousPoint);\n            tempV2_5.copy(tempV2_4).setLength(miterSide).add(tempV2_3);\n            innerPoint.copy(tempV2_5).negate();\n            var miterLength2 = tempV2_5.length();\n            var segmentLengthPrev = tempV2_4.length();\n            tempV2_4.divideScalar(segmentLengthPrev);\n            tempV2_6.subVectors(nextPoint, currentPoint);\n            var segmentLengthNext = tempV2_6.length();\n            tempV2_6.divideScalar(segmentLengthNext);\n\n            if (tempV2_4.dot(innerPoint) < segmentLengthPrev && tempV2_6.dot(innerPoint) < segmentLengthNext) {\n              innerSideModified = true;\n            }\n\n            outerPoint.copy(tempV2_5).add(currentPoint);\n            innerPoint.add(currentPoint);\n            isMiter = false;\n\n            if (innerSideModified) {\n              if (joinIsOnLeftSide) {\n                nextPointR.copy(innerPoint);\n                currentPointR.copy(innerPoint);\n              } else {\n                nextPointL.copy(innerPoint);\n                currentPointL.copy(innerPoint);\n              }\n            } else {\n              makeSegmentTriangles();\n            }\n\n            switch (style.strokeLineJoin) {\n              case \"bevel\":\n                makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1);\n                break;\n\n              case \"round\":\n                createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified);\n\n                if (joinIsOnLeftSide) {\n                  makeCircularSector(currentPoint, currentPointL, nextPointL, u1, 0);\n                } else {\n                  makeCircularSector(currentPoint, nextPointR, currentPointR, u1, 1);\n                }\n\n                break;\n\n              case \"miter\":\n              case \"miter-clip\":\n              default:\n                var miterFraction = strokeWidth2 * style.strokeMiterLimit / miterLength2;\n\n                if (miterFraction < 1) {\n                  if (style.strokeLineJoin !== \"miter-clip\") {\n                    makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1);\n                    break;\n                  } else {\n                    createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified);\n\n                    if (joinIsOnLeftSide) {\n                      tempV2_6.subVectors(outerPoint, currentPointL).multiplyScalar(miterFraction).add(currentPointL);\n                      tempV2_7.subVectors(outerPoint, nextPointL).multiplyScalar(miterFraction).add(nextPointL);\n                      addVertex(currentPointL, u1, 0);\n                      addVertex(tempV2_6, u1, 0);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(tempV2_6, u1, 0);\n                      addVertex(tempV2_7, u1, 0);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(tempV2_7, u1, 0);\n                      addVertex(nextPointL, u1, 0);\n                    } else {\n                      tempV2_6.subVectors(outerPoint, currentPointR).multiplyScalar(miterFraction).add(currentPointR);\n                      tempV2_7.subVectors(outerPoint, nextPointR).multiplyScalar(miterFraction).add(nextPointR);\n                      addVertex(currentPointR, u1, 1);\n                      addVertex(tempV2_6, u1, 1);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(tempV2_6, u1, 1);\n                      addVertex(tempV2_7, u1, 1);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(tempV2_7, u1, 1);\n                      addVertex(nextPointR, u1, 1);\n                    }\n                  }\n                } else {\n                  if (innerSideModified) {\n                    if (joinIsOnLeftSide) {\n                      addVertex(lastPointR, u0, 1);\n                      addVertex(lastPointL, u0, 0);\n                      addVertex(outerPoint, u1, 0);\n                      addVertex(lastPointR, u0, 1);\n                      addVertex(outerPoint, u1, 0);\n                      addVertex(innerPoint, u1, 1);\n                    } else {\n                      addVertex(lastPointR, u0, 1);\n                      addVertex(lastPointL, u0, 0);\n                      addVertex(outerPoint, u1, 1);\n                      addVertex(lastPointL, u0, 0);\n                      addVertex(innerPoint, u1, 0);\n                      addVertex(outerPoint, u1, 1);\n                    }\n\n                    if (joinIsOnLeftSide) {\n                      nextPointL.copy(outerPoint);\n                    } else {\n                      nextPointR.copy(outerPoint);\n                    }\n                  } else {\n                    if (joinIsOnLeftSide) {\n                      addVertex(currentPointL, u1, 0);\n                      addVertex(outerPoint, u1, 0);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(outerPoint, u1, 0);\n                      addVertex(nextPointL, u1, 0);\n                    } else {\n                      addVertex(currentPointR, u1, 1);\n                      addVertex(outerPoint, u1, 1);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(outerPoint, u1, 1);\n                      addVertex(nextPointR, u1, 1);\n                    }\n                  }\n\n                  isMiter = true;\n                }\n\n                break;\n            }\n          } else {\n            makeSegmentTriangles();\n          }\n        } else {\n          makeSegmentTriangles();\n        }\n\n        if (!isClosed && iPoint === numPoints - 1) {\n          addCapGeometry(points[0], point0L, point0R, joinIsOnLeftSide, true, u0);\n        }\n\n        u0 = u1;\n        previousPoint = currentPoint;\n        lastPointL.copy(nextPointL);\n        lastPointR.copy(nextPointR);\n      }\n\n      if (!isClosed) {\n        addCapGeometry(currentPoint, currentPointL, currentPointR, joinIsOnLeftSide, false, u1);\n      } else if (innerSideModified && vertices) {\n        var lastOuter = outerPoint;\n        var lastInner = innerPoint;\n\n        if (initialJoinIsOnLeftSide !== joinIsOnLeftSide) {\n          lastOuter = innerPoint;\n          lastInner = outerPoint;\n        }\n\n        if (joinIsOnLeftSide) {\n          if (isMiter || initialJoinIsOnLeftSide) {\n            lastInner.toArray(vertices, 0 * 3);\n            lastInner.toArray(vertices, 3 * 3);\n\n            if (isMiter) {\n              lastOuter.toArray(vertices, 1 * 3);\n            }\n          }\n        } else {\n          if (isMiter || !initialJoinIsOnLeftSide) {\n            lastInner.toArray(vertices, 1 * 3);\n            lastInner.toArray(vertices, 3 * 3);\n\n            if (isMiter) {\n              lastOuter.toArray(vertices, 0 * 3);\n            }\n          }\n        }\n      }\n\n      return numVertices;\n\n      function getNormal(p1, p2, result) {\n        result.subVectors(p2, p1);\n        return result.set(-result.y, result.x).normalize();\n      }\n\n      function addVertex(position, u, v) {\n        if (vertices) {\n          vertices[currentCoordinate] = position.x;\n          vertices[currentCoordinate + 1] = position.y;\n          vertices[currentCoordinate + 2] = 0;\n\n          if (normals) {\n            normals[currentCoordinate] = 0;\n            normals[currentCoordinate + 1] = 0;\n            normals[currentCoordinate + 2] = 1;\n          }\n\n          currentCoordinate += 3;\n\n          if (uvs) {\n            uvs[currentCoordinateUV] = u;\n            uvs[currentCoordinateUV + 1] = v;\n            currentCoordinateUV += 2;\n          }\n        }\n\n        numVertices += 3;\n      }\n\n      function makeCircularSector(center, p1, p2, u, v) {\n        tempV2_1.copy(p1).sub(center).normalize();\n        tempV2_2.copy(p2).sub(center).normalize();\n        var angle = Math.PI;\n        var dot = tempV2_1.dot(tempV2_2);\n        if (Math.abs(dot) < 1) angle = Math.abs(Math.acos(dot));\n        angle /= arcDivisions;\n        tempV2_3.copy(p1);\n\n        for (var i = 0, il = arcDivisions - 1; i < il; i++) {\n          tempV2_4.copy(tempV2_3).rotateAround(center, angle);\n          addVertex(tempV2_3, u, v);\n          addVertex(tempV2_4, u, v);\n          addVertex(center, u, 0.5);\n          tempV2_3.copy(tempV2_4);\n        }\n\n        addVertex(tempV2_4, u, v);\n        addVertex(p2, u, v);\n        addVertex(center, u, 0.5);\n      }\n\n      function makeSegmentTriangles() {\n        addVertex(lastPointR, u0, 1);\n        addVertex(lastPointL, u0, 0);\n        addVertex(currentPointL, u1, 0);\n        addVertex(lastPointR, u0, 1);\n        addVertex(currentPointL, u1, 1);\n        addVertex(currentPointR, u1, 0);\n      }\n\n      function makeSegmentWithBevelJoin(joinIsOnLeftSide2, innerSideModified2, u) {\n        if (innerSideModified2) {\n          if (joinIsOnLeftSide2) {\n            addVertex(lastPointR, u0, 1);\n            addVertex(lastPointL, u0, 0);\n            addVertex(currentPointL, u1, 0);\n            addVertex(lastPointR, u0, 1);\n            addVertex(currentPointL, u1, 0);\n            addVertex(innerPoint, u1, 1);\n            addVertex(currentPointL, u, 0);\n            addVertex(nextPointL, u, 0);\n            addVertex(innerPoint, u, 0.5);\n          } else {\n            addVertex(lastPointR, u0, 1);\n            addVertex(lastPointL, u0, 0);\n            addVertex(currentPointR, u1, 1);\n            addVertex(lastPointL, u0, 0);\n            addVertex(innerPoint, u1, 0);\n            addVertex(currentPointR, u1, 1);\n            addVertex(currentPointR, u, 1);\n            addVertex(nextPointR, u, 0);\n            addVertex(innerPoint, u, 0.5);\n          }\n        } else {\n          if (joinIsOnLeftSide2) {\n            addVertex(currentPointL, u, 0);\n            addVertex(nextPointL, u, 0);\n            addVertex(currentPoint, u, 0.5);\n          } else {\n            addVertex(currentPointR, u, 1);\n            addVertex(nextPointR, u, 0);\n            addVertex(currentPoint, u, 0.5);\n          }\n        }\n      }\n\n      function createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide2, innerSideModified2) {\n        if (innerSideModified2) {\n          if (joinIsOnLeftSide2) {\n            addVertex(lastPointR, u0, 1);\n            addVertex(lastPointL, u0, 0);\n            addVertex(currentPointL, u1, 0);\n            addVertex(lastPointR, u0, 1);\n            addVertex(currentPointL, u1, 0);\n            addVertex(innerPoint, u1, 1);\n            addVertex(currentPointL, u0, 0);\n            addVertex(currentPoint, u1, 0.5);\n            addVertex(innerPoint, u1, 1);\n            addVertex(currentPoint, u1, 0.5);\n            addVertex(nextPointL, u0, 0);\n            addVertex(innerPoint, u1, 1);\n          } else {\n            addVertex(lastPointR, u0, 1);\n            addVertex(lastPointL, u0, 0);\n            addVertex(currentPointR, u1, 1);\n            addVertex(lastPointL, u0, 0);\n            addVertex(innerPoint, u1, 0);\n            addVertex(currentPointR, u1, 1);\n            addVertex(currentPointR, u0, 1);\n            addVertex(innerPoint, u1, 0);\n            addVertex(currentPoint, u1, 0.5);\n            addVertex(currentPoint, u1, 0.5);\n            addVertex(innerPoint, u1, 0);\n            addVertex(nextPointR, u0, 1);\n          }\n        }\n      }\n\n      function addCapGeometry(center, p1, p2, joinIsOnLeftSide2, start, u) {\n        switch (style.strokeLineCap) {\n          case \"round\":\n            if (start) {\n              makeCircularSector(center, p2, p1, u, 0.5);\n            } else {\n              makeCircularSector(center, p1, p2, u, 0.5);\n            }\n\n            break;\n\n          case \"square\":\n            if (start) {\n              tempV2_1.subVectors(p1, center);\n              tempV2_2.set(tempV2_1.y, -tempV2_1.x);\n              tempV2_3.addVectors(tempV2_1, tempV2_2).add(center);\n              tempV2_4.subVectors(tempV2_2, tempV2_1).add(center);\n\n              if (joinIsOnLeftSide2) {\n                tempV2_3.toArray(vertices, 1 * 3);\n                tempV2_4.toArray(vertices, 0 * 3);\n                tempV2_4.toArray(vertices, 3 * 3);\n              } else {\n                tempV2_3.toArray(vertices, 1 * 3);\n                tempV2_3.toArray(vertices, 3 * 3);\n                tempV2_4.toArray(vertices, 0 * 3);\n              }\n            } else {\n              tempV2_1.subVectors(p2, center);\n              tempV2_2.set(tempV2_1.y, -tempV2_1.x);\n              tempV2_3.addVectors(tempV2_1, tempV2_2).add(center);\n              tempV2_4.subVectors(tempV2_2, tempV2_1).add(center);\n              var vl = vertices.length;\n\n              if (joinIsOnLeftSide2) {\n                tempV2_3.toArray(vertices, vl - 1 * 3);\n                tempV2_4.toArray(vertices, vl - 2 * 3);\n                tempV2_4.toArray(vertices, vl - 4 * 3);\n              } else {\n                tempV2_3.toArray(vertices, vl - 2 * 3);\n                tempV2_4.toArray(vertices, vl - 1 * 3);\n                tempV2_4.toArray(vertices, vl - 4 * 3);\n              }\n            }\n\n            break;\n\n          case \"butt\":\n          default:\n            break;\n        }\n      }\n\n      function removeDuplicatedPoints(points2) {\n        var dupPoints = false;\n\n        for (var i = 1, n = points2.length - 1; i < n; i++) {\n          if (points2[i].distanceTo(points2[i + 1]) < minDistance) {\n            dupPoints = true;\n            break;\n          }\n        }\n\n        if (!dupPoints) return points2;\n        var newPoints = [];\n        newPoints.push(points2[0]);\n\n        for (var _i2 = 1, _n = points2.length - 1; _i2 < _n; _i2++) {\n          if (points2[_i2].distanceTo(points2[_i2 + 1]) >= minDistance) {\n            newPoints.push(points2[_i2]);\n          }\n        }\n\n        newPoints.push(points2[points2.length - 1]);\n        return newPoints;\n      }\n    }\n  }]);\n\n  return SVGLoader;\n}(Loader);\n\nexport { SVGLoader };","map":{"version":3,"sources":["/Users/theodaguier/_workdir/dev/pro/e-do/E-Do-Studio/node_modules/three-stdlib/loaders/SVGLoader.js"],"names":["Loader","FileLoader","ShapePath","Vector2","Path","Matrix3","Vector3","ShapeUtils","Box2","Shape","BufferGeometry","Float32BufferAttribute","SVGLoader","manager","defaultDPI","defaultUnit","url","onLoad","onProgress","onError","scope","loader","setPath","path","setRequestHeader","requestHeader","setWithCredentials","withCredentials","load","text","parse","e","console","error","itemError","parseNode","node","style","nodeType","transform","getNodeTransform","traverseChildNodes","nodeName","parseCSSStylesheet","parseStyle","hasAttribute","parsePathNode","parseRectNode","parsePolygonNode","parsePolylineNode","parseCircleNode","parseEllipseNode","parseLineNode","usedNodeId","href","baseVal","substring","usedNode","viewportElement","getElementById","warn","fill","color","setStyle","transformPath","currentTransform","paths","push","userData","nodes","childNodes","i","length","transformStack","pop","copy","identity","point","control","firstPoint","isFirstPoint","doSetFirstPoint","d","getAttribute","commands","match","l","command","type","charAt","data2","substr","trim","numbers","parseFloats","j","jl","x","y","moveTo","lineTo","bezierCurveTo","getReflection","quadraticCurveTo","rx","ry","start","clone","parseArcCommand","currentPath","autoClose","curves","currentPoint","sheet","cssRules","stylesheet","selectorList","selectorText","split","filter","Boolean","map","i2","stylesheets","Object","assign","x_axis_rotation","large_arc_flag","sweep_flag","end","Math","PI","abs","dx2","dy2","x1p","cos","sin","y1p","rxs","rys","x1ps","y1ps","cr","s","sqrt","dq","pq","q","max","cxp","cyp","cx","cy","theta","svgAngle","delta","absellipse","ux","uy","vx","vy","dot","len","ang","acos","min","parseFloatWithUnits","w","h","bci","iterator","a","b","index","regex","replace","r","subpath","absarc","subPaths","x1","y1","x2","y2","stylesheetStyles","classSelectors","addStyle","svgName","jsName","adjustFunction","v","startsWith","clamp","positive","input","flags","stride","TypeError","RE","SEPARATOR","WHITESPACE","DIGIT","SIGN","POINT","COMMA","EXP","FLAGS","SEP","INT","FLOAT","state","seenComma","number","exponent","result","throwSyntaxError","current2","partial","SyntaxError","newNumber","Number","pow","current","Array","isArray","includes","test","units","unitConversion","mm","cm","in","pt","pc","px","string","theUnit","String","n","u","endsWith","scale","parseFloat","parseNodeTransform","premultiply","currentTransform2","tempTransform0","tx","ty","translate","transformsTexts","tIndex","transformText","openParPos","indexOf","closeParPos","transformType","array","angle","tempTransform1","tempTransform2","rotate","tempTransform3","multiplyMatrices","scaleX","scaleY","set","tan","m","transfVec2","v2","tempV3","applyMatrix3","isRotated","isTransformRotated","subPath","curve","isLineCurve","v1","isCubicBezierCurve","v0","v3","isQuadraticBezierCurve","isEllipseCurve","tempV2","aX","aY","xRadius","getTransformScaleX","yRadius","getTransformScaleY","elements","te","xml","DOMParser","parseFromString","documentElement","fillOpacity","strokeOpacity","strokeWidth","strokeLineJoin","strokeLineCap","strokeMiterLimit","data","shapePath","BIGNUMBER","IntersectionLocationType","ORIGIN","DESTINATION","BETWEEN","LEFT","RIGHT","BEHIND","BEYOND","classifyResult","loc","t","findEdgeIntersection","a0","a1","b0","b1","x3","x4","y3","y4","nom1","nom2","denom","t1","t2","classifyPoint","toPrecision","p","edgeStart","edgeEnd","ax","ay","bx","by","sa","EPSILON","getIntersections","path1","path2","intersectionsRaw","intersections","path1EdgeStart","path1EdgeEnd","index2","path2EdgeStart","path2EdgeEnd","intersection","find","getScanlineIntersections","scanline","boundingBox","center","getCenter","allIntersections","forEach","containsPoint","points","identifier","isCW","sort","i1","isHoleTo","simplePath","allPaths","scanlineMinX2","scanlineMaxX2","_fillRule","centerBoundingBox","scanlineIntersections","baseIntersections","otherIntersections","firstXOfPath","stack","isHole","isHoleFor","for","lastCWValue","identifier2","scanlineMinX","scanlineMaxX","simplePaths","getPoints","maxY","minY","maxX","minX","p2","isClockWise","sp","isAHole","fillRule","shapesToReturn","amIAHole","shape","holes","hole","width","lineJoin","lineCap","miterLimit","strokeColor","arcDivisions","minDistance","vertices","normals","uvs","pointsToStrokeWithBuffers","geometry","setAttribute","vertexOffset","tempV2_1","tempV2_2","tempV2_3","tempV2_4","tempV2_5","tempV2_6","tempV2_7","lastPointL","lastPointR","point0L","point0R","currentPointL","currentPointR","nextPointL","nextPointR","innerPoint","outerPoint","removeDuplicatedPoints","numPoints","isClosed","equals","previousPoint","nextPoint","strokeWidth2","deltaU","u0","u1","innerSideModified","joinIsOnLeftSide","isMiter","initialJoinIsOnLeftSide","numVertices","currentCoordinate","currentCoordinateUV","getNormal","multiplyScalar","sub","add","iPoint","normal1","subVectors","normalize","miterSide","setLength","negate","miterLength2","segmentLengthPrev","divideScalar","segmentLengthNext","makeSegmentTriangles","makeSegmentWithBevelJoin","createSegmentTrianglesWithMiddleSection","makeCircularSector","miterFraction","addVertex","addCapGeometry","lastOuter","lastInner","toArray","p1","position","il","rotateAround","joinIsOnLeftSide2","innerSideModified2","addVectors","vl","points2","dupPoints","distanceTo","newPoints"],"mappings":"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","sourcesContent":["import { Loader, FileLoader, ShapePath, Vector2, Path, Matrix3, Vector3, ShapeUtils, Box2, Shape, BufferGeometry, Float32BufferAttribute } from \"three\";\nclass SVGLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.defaultDPI = 90;\n    this.defaultUnit = \"px\";\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(\n      url,\n      function(text) {\n        try {\n          onLoad(scope.parse(text));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n          scope.manager.itemError(url);\n        }\n      },\n      onProgress,\n      onError\n    );\n  }\n  parse(text) {\n    const scope = this;\n    function parseNode(node, style) {\n      if (node.nodeType !== 1)\n        return;\n      const transform = getNodeTransform(node);\n      let traverseChildNodes = true;\n      let path = null;\n      switch (node.nodeName) {\n        case \"svg\":\n          break;\n        case \"style\":\n          parseCSSStylesheet(node);\n          break;\n        case \"g\":\n          style = parseStyle(node, style);\n          break;\n        case \"path\":\n          style = parseStyle(node, style);\n          if (node.hasAttribute(\"d\"))\n            path = parsePathNode(node);\n          break;\n        case \"rect\":\n          style = parseStyle(node, style);\n          path = parseRectNode(node);\n          break;\n        case \"polygon\":\n          style = parseStyle(node, style);\n          path = parsePolygonNode(node);\n          break;\n        case \"polyline\":\n          style = parseStyle(node, style);\n          path = parsePolylineNode(node);\n          break;\n        case \"circle\":\n          style = parseStyle(node, style);\n          path = parseCircleNode(node);\n          break;\n        case \"ellipse\":\n          style = parseStyle(node, style);\n          path = parseEllipseNode(node);\n          break;\n        case \"line\":\n          style = parseStyle(node, style);\n          path = parseLineNode(node);\n          break;\n        case \"defs\":\n          traverseChildNodes = false;\n          break;\n        case \"mask\":\n          traverseChildNodes = false;\n          break;\n        case \"use\":\n          style = parseStyle(node, style);\n          const usedNodeId = node.href.baseVal.substring(1);\n          const usedNode = node.viewportElement.getElementById(usedNodeId);\n          if (usedNode) {\n            parseNode(usedNode, style);\n          } else {\n            console.warn(\"SVGLoader: 'use node' references non-existent node id: \" + usedNodeId);\n          }\n          break;\n        default:\n      }\n      if (path) {\n        if (style.fill !== void 0 && style.fill !== \"none\") {\n          path.color.setStyle(style.fill);\n        }\n        transformPath(path, currentTransform);\n        paths.push(path);\n        path.userData = { node, style };\n      }\n      if (traverseChildNodes) {\n        const nodes = node.childNodes;\n        for (let i = 0; i < nodes.length; i++) {\n          parseNode(nodes[i], style);\n        }\n      }\n      if (transform) {\n        transformStack.pop();\n        if (transformStack.length > 0) {\n          currentTransform.copy(transformStack[transformStack.length - 1]);\n        } else {\n          currentTransform.identity();\n        }\n      }\n    }\n    function parsePathNode(node) {\n      const path = new ShapePath();\n      const point = new Vector2();\n      const control = new Vector2();\n      const firstPoint = new Vector2();\n      let isFirstPoint = true;\n      let doSetFirstPoint = false;\n      const d = node.getAttribute(\"d\");\n      const commands = d.match(/[a-df-z][^a-df-z]*/gi);\n      for (let i = 0, l = commands.length; i < l; i++) {\n        const command = commands[i];\n        const type = command.charAt(0);\n        const data2 = command.substr(1).trim();\n        if (isFirstPoint === true) {\n          doSetFirstPoint = true;\n          isFirstPoint = false;\n        }\n        let numbers;\n        switch (type) {\n          case \"M\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              point.x = numbers[j + 0];\n              point.y = numbers[j + 1];\n              control.x = point.x;\n              control.y = point.y;\n              if (j === 0) {\n                path.moveTo(point.x, point.y);\n              } else {\n                path.lineTo(point.x, point.y);\n              }\n              if (j === 0)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"H\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j++) {\n              point.x = numbers[j];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"V\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j++) {\n              point.y = numbers[j];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"L\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              point.x = numbers[j + 0];\n              point.y = numbers[j + 1];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"C\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j += 6) {\n              path.bezierCurveTo(\n                numbers[j + 0],\n                numbers[j + 1],\n                numbers[j + 2],\n                numbers[j + 3],\n                numbers[j + 4],\n                numbers[j + 5]\n              );\n              control.x = numbers[j + 2];\n              control.y = numbers[j + 3];\n              point.x = numbers[j + 4];\n              point.y = numbers[j + 5];\n              if (j === 0 && doSetFirstPoint === true)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"S\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n              path.bezierCurveTo(\n                getReflection(point.x, control.x),\n                getReflection(point.y, control.y),\n                numbers[j + 0],\n                numbers[j + 1],\n                numbers[j + 2],\n                numbers[j + 3]\n              );\n              control.x = numbers[j + 0];\n              control.y = numbers[j + 1];\n              point.x = numbers[j + 2];\n              point.y = numbers[j + 3];\n              if (j === 0 && doSetFirstPoint === true)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"Q\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n              path.quadraticCurveTo(numbers[j + 0], numbers[j + 1], numbers[j + 2], numbers[j + 3]);\n              control.x = numbers[j + 0];\n              control.y = numbers[j + 1];\n              point.x = numbers[j + 2];\n              point.y = numbers[j + 3];\n              if (j === 0 && doSetFirstPoint === true)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"T\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              const rx = getReflection(point.x, control.x);\n              const ry = getReflection(point.y, control.y);\n              path.quadraticCurveTo(rx, ry, numbers[j + 0], numbers[j + 1]);\n              control.x = rx;\n              control.y = ry;\n              point.x = numbers[j + 0];\n              point.y = numbers[j + 1];\n              if (j === 0 && doSetFirstPoint === true)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"A\":\n            numbers = parseFloats(data2, [3, 4], 7);\n            for (let j = 0, jl = numbers.length; j < jl; j += 7) {\n              if (numbers[j + 5] == point.x && numbers[j + 6] == point.y)\n                continue;\n              const start = point.clone();\n              point.x = numbers[j + 5];\n              point.y = numbers[j + 6];\n              control.x = point.x;\n              control.y = point.y;\n              parseArcCommand(\n                path,\n                numbers[j],\n                numbers[j + 1],\n                numbers[j + 2],\n                numbers[j + 3],\n                numbers[j + 4],\n                start,\n                point\n              );\n              if (j === 0 && doSetFirstPoint === true)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"m\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              point.x += numbers[j + 0];\n              point.y += numbers[j + 1];\n              control.x = point.x;\n              control.y = point.y;\n              if (j === 0) {\n                path.moveTo(point.x, point.y);\n              } else {\n                path.lineTo(point.x, point.y);\n              }\n              if (j === 0)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"h\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j++) {\n              point.x += numbers[j];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"v\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j++) {\n              point.y += numbers[j];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"l\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              point.x += numbers[j + 0];\n              point.y += numbers[j + 1];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"c\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j += 6) {\n              path.bezierCurveTo(\n                point.x + numbers[j + 0],\n                point.y + numbers[j + 1],\n                point.x + numbers[j + 2],\n                point.y + numbers[j + 3],\n                point.x + numbers[j + 4],\n                point.y + numbers[j + 5]\n              );\n              control.x = point.x + numbers[j + 2];\n              control.y = point.y + numbers[j + 3];\n              point.x += numbers[j + 4];\n              point.y += numbers[j + 5];\n              if (j === 0 && doSetFirstPoint === true)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"s\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n              path.bezierCurveTo(\n                getReflection(point.x, control.x),\n                getReflection(point.y, control.y),\n                point.x + numbers[j + 0],\n                point.y + numbers[j + 1],\n                point.x + numbers[j + 2],\n                point.y + numbers[j + 3]\n              );\n              control.x = point.x + numbers[j + 0];\n              control.y = point.y + numbers[j + 1];\n              point.x += numbers[j + 2];\n              point.y += numbers[j + 3];\n              if (j === 0 && doSetFirstPoint === true)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"q\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n              path.quadraticCurveTo(\n                point.x + numbers[j + 0],\n                point.y + numbers[j + 1],\n                point.x + numbers[j + 2],\n                point.y + numbers[j + 3]\n              );\n              control.x = point.x + numbers[j + 0];\n              control.y = point.y + numbers[j + 1];\n              point.x += numbers[j + 2];\n              point.y += numbers[j + 3];\n              if (j === 0 && doSetFirstPoint === true)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"t\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              const rx = getReflection(point.x, control.x);\n              const ry = getReflection(point.y, control.y);\n              path.quadraticCurveTo(rx, ry, point.x + numbers[j + 0], point.y + numbers[j + 1]);\n              control.x = rx;\n              control.y = ry;\n              point.x = point.x + numbers[j + 0];\n              point.y = point.y + numbers[j + 1];\n              if (j === 0 && doSetFirstPoint === true)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"a\":\n            numbers = parseFloats(data2, [3, 4], 7);\n            for (let j = 0, jl = numbers.length; j < jl; j += 7) {\n              if (numbers[j + 5] == 0 && numbers[j + 6] == 0)\n                continue;\n              const start = point.clone();\n              point.x += numbers[j + 5];\n              point.y += numbers[j + 6];\n              control.x = point.x;\n              control.y = point.y;\n              parseArcCommand(\n                path,\n                numbers[j],\n                numbers[j + 1],\n                numbers[j + 2],\n                numbers[j + 3],\n                numbers[j + 4],\n                start,\n                point\n              );\n              if (j === 0 && doSetFirstPoint === true)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"Z\":\n          case \"z\":\n            path.currentPath.autoClose = true;\n            if (path.currentPath.curves.length > 0) {\n              point.copy(firstPoint);\n              path.currentPath.currentPoint.copy(point);\n              isFirstPoint = true;\n            }\n            break;\n          default:\n            console.warn(command);\n        }\n        doSetFirstPoint = false;\n      }\n      return path;\n    }\n    function parseCSSStylesheet(node) {\n      if (!node.sheet || !node.sheet.cssRules || !node.sheet.cssRules.length)\n        return;\n      for (let i = 0; i < node.sheet.cssRules.length; i++) {\n        const stylesheet = node.sheet.cssRules[i];\n        if (stylesheet.type !== 1)\n          continue;\n        const selectorList = stylesheet.selectorText.split(/,/gm).filter(Boolean).map((i2) => i2.trim());\n        for (let j = 0; j < selectorList.length; j++) {\n          stylesheets[selectorList[j]] = Object.assign(stylesheets[selectorList[j]] || {}, stylesheet.style);\n        }\n      }\n    }\n    function parseArcCommand(path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end) {\n      if (rx == 0 || ry == 0) {\n        path.lineTo(end.x, end.y);\n        return;\n      }\n      x_axis_rotation = x_axis_rotation * Math.PI / 180;\n      rx = Math.abs(rx);\n      ry = Math.abs(ry);\n      const dx2 = (start.x - end.x) / 2;\n      const dy2 = (start.y - end.y) / 2;\n      const x1p = Math.cos(x_axis_rotation) * dx2 + Math.sin(x_axis_rotation) * dy2;\n      const y1p = -Math.sin(x_axis_rotation) * dx2 + Math.cos(x_axis_rotation) * dy2;\n      let rxs = rx * rx;\n      let rys = ry * ry;\n      const x1ps = x1p * x1p;\n      const y1ps = y1p * y1p;\n      const cr = x1ps / rxs + y1ps / rys;\n      if (cr > 1) {\n        const s = Math.sqrt(cr);\n        rx = s * rx;\n        ry = s * ry;\n        rxs = rx * rx;\n        rys = ry * ry;\n      }\n      const dq = rxs * y1ps + rys * x1ps;\n      const pq = (rxs * rys - dq) / dq;\n      let q = Math.sqrt(Math.max(0, pq));\n      if (large_arc_flag === sweep_flag)\n        q = -q;\n      const cxp = q * rx * y1p / ry;\n      const cyp = -q * ry * x1p / rx;\n      const cx = Math.cos(x_axis_rotation) * cxp - Math.sin(x_axis_rotation) * cyp + (start.x + end.x) / 2;\n      const cy = Math.sin(x_axis_rotation) * cxp + Math.cos(x_axis_rotation) * cyp + (start.y + end.y) / 2;\n      const theta = svgAngle(1, 0, (x1p - cxp) / rx, (y1p - cyp) / ry);\n      const delta = svgAngle((x1p - cxp) / rx, (y1p - cyp) / ry, (-x1p - cxp) / rx, (-y1p - cyp) / ry) % (Math.PI * 2);\n      path.currentPath.absellipse(cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation);\n    }\n    function svgAngle(ux, uy, vx, vy) {\n      const dot = ux * vx + uy * vy;\n      const len = Math.sqrt(ux * ux + uy * uy) * Math.sqrt(vx * vx + vy * vy);\n      let ang = Math.acos(Math.max(-1, Math.min(1, dot / len)));\n      if (ux * vy - uy * vx < 0)\n        ang = -ang;\n      return ang;\n    }\n    function parseRectNode(node) {\n      const x = parseFloatWithUnits(node.getAttribute(\"x\") || 0);\n      const y = parseFloatWithUnits(node.getAttribute(\"y\") || 0);\n      const rx = parseFloatWithUnits(node.getAttribute(\"rx\") || node.getAttribute(\"ry\") || 0);\n      const ry = parseFloatWithUnits(node.getAttribute(\"ry\") || node.getAttribute(\"rx\") || 0);\n      const w = parseFloatWithUnits(node.getAttribute(\"width\"));\n      const h = parseFloatWithUnits(node.getAttribute(\"height\"));\n      const bci = 1 - 0.551915024494;\n      const path = new ShapePath();\n      path.moveTo(x + rx, y);\n      path.lineTo(x + w - rx, y);\n      if (rx !== 0 || ry !== 0) {\n        path.bezierCurveTo(x + w - rx * bci, y, x + w, y + ry * bci, x + w, y + ry);\n      }\n      path.lineTo(x + w, y + h - ry);\n      if (rx !== 0 || ry !== 0) {\n        path.bezierCurveTo(x + w, y + h - ry * bci, x + w - rx * bci, y + h, x + w - rx, y + h);\n      }\n      path.lineTo(x + rx, y + h);\n      if (rx !== 0 || ry !== 0) {\n        path.bezierCurveTo(x + rx * bci, y + h, x, y + h - ry * bci, x, y + h - ry);\n      }\n      path.lineTo(x, y + ry);\n      if (rx !== 0 || ry !== 0) {\n        path.bezierCurveTo(x, y + ry * bci, x + rx * bci, y, x + rx, y);\n      }\n      return path;\n    }\n    function parsePolygonNode(node) {\n      function iterator(match, a, b) {\n        const x = parseFloatWithUnits(a);\n        const y = parseFloatWithUnits(b);\n        if (index === 0) {\n          path.moveTo(x, y);\n        } else {\n          path.lineTo(x, y);\n        }\n        index++;\n      }\n      const regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\n      const path = new ShapePath();\n      let index = 0;\n      node.getAttribute(\"points\").replace(regex, iterator);\n      path.currentPath.autoClose = true;\n      return path;\n    }\n    function parsePolylineNode(node) {\n      function iterator(match, a, b) {\n        const x = parseFloatWithUnits(a);\n        const y = parseFloatWithUnits(b);\n        if (index === 0) {\n          path.moveTo(x, y);\n        } else {\n          path.lineTo(x, y);\n        }\n        index++;\n      }\n      const regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\n      const path = new ShapePath();\n      let index = 0;\n      node.getAttribute(\"points\").replace(regex, iterator);\n      path.currentPath.autoClose = false;\n      return path;\n    }\n    function parseCircleNode(node) {\n      const x = parseFloatWithUnits(node.getAttribute(\"cx\") || 0);\n      const y = parseFloatWithUnits(node.getAttribute(\"cy\") || 0);\n      const r = parseFloatWithUnits(node.getAttribute(\"r\") || 0);\n      const subpath = new Path();\n      subpath.absarc(x, y, r, 0, Math.PI * 2);\n      const path = new ShapePath();\n      path.subPaths.push(subpath);\n      return path;\n    }\n    function parseEllipseNode(node) {\n      const x = parseFloatWithUnits(node.getAttribute(\"cx\") || 0);\n      const y = parseFloatWithUnits(node.getAttribute(\"cy\") || 0);\n      const rx = parseFloatWithUnits(node.getAttribute(\"rx\") || 0);\n      const ry = parseFloatWithUnits(node.getAttribute(\"ry\") || 0);\n      const subpath = new Path();\n      subpath.absellipse(x, y, rx, ry, 0, Math.PI * 2);\n      const path = new ShapePath();\n      path.subPaths.push(subpath);\n      return path;\n    }\n    function parseLineNode(node) {\n      const x1 = parseFloatWithUnits(node.getAttribute(\"x1\") || 0);\n      const y1 = parseFloatWithUnits(node.getAttribute(\"y1\") || 0);\n      const x2 = parseFloatWithUnits(node.getAttribute(\"x2\") || 0);\n      const y2 = parseFloatWithUnits(node.getAttribute(\"y2\") || 0);\n      const path = new ShapePath();\n      path.moveTo(x1, y1);\n      path.lineTo(x2, y2);\n      path.currentPath.autoClose = false;\n      return path;\n    }\n    function parseStyle(node, style) {\n      style = Object.assign({}, style);\n      let stylesheetStyles = {};\n      if (node.hasAttribute(\"class\")) {\n        const classSelectors = node.getAttribute(\"class\").split(/\\s/).filter(Boolean).map((i) => i.trim());\n        for (let i = 0; i < classSelectors.length; i++) {\n          stylesheetStyles = Object.assign(stylesheetStyles, stylesheets[\".\" + classSelectors[i]]);\n        }\n      }\n      if (node.hasAttribute(\"id\")) {\n        stylesheetStyles = Object.assign(stylesheetStyles, stylesheets[\"#\" + node.getAttribute(\"id\")]);\n      }\n      function addStyle(svgName, jsName, adjustFunction) {\n        if (adjustFunction === void 0) {\n          adjustFunction = function copy(v) {\n            if (v.startsWith(\"url\"))\n              console.warn(\"SVGLoader: url access in attributes is not implemented.\");\n            return v;\n          };\n        }\n        if (node.hasAttribute(svgName))\n          style[jsName] = adjustFunction(node.getAttribute(svgName));\n        if (stylesheetStyles[svgName])\n          style[jsName] = adjustFunction(stylesheetStyles[svgName]);\n        if (node.style && node.style[svgName] !== \"\")\n          style[jsName] = adjustFunction(node.style[svgName]);\n      }\n      function clamp(v) {\n        return Math.max(0, Math.min(1, parseFloatWithUnits(v)));\n      }\n      function positive(v) {\n        return Math.max(0, parseFloatWithUnits(v));\n      }\n      addStyle(\"fill\", \"fill\");\n      addStyle(\"fill-opacity\", \"fillOpacity\", clamp);\n      addStyle(\"fill-rule\", \"fillRule\");\n      addStyle(\"opacity\", \"opacity\", clamp);\n      addStyle(\"stroke\", \"stroke\");\n      addStyle(\"stroke-opacity\", \"strokeOpacity\", clamp);\n      addStyle(\"stroke-width\", \"strokeWidth\", positive);\n      addStyle(\"stroke-linejoin\", \"strokeLineJoin\");\n      addStyle(\"stroke-linecap\", \"strokeLineCap\");\n      addStyle(\"stroke-miterlimit\", \"strokeMiterLimit\", positive);\n      addStyle(\"visibility\", \"visibility\");\n      return style;\n    }\n    function getReflection(a, b) {\n      return a - (b - a);\n    }\n    function parseFloats(input, flags, stride) {\n      if (typeof input !== \"string\") {\n        throw new TypeError(\"Invalid input: \" + typeof input);\n      }\n      const RE = {\n        SEPARATOR: /[ \\t\\r\\n\\,.\\-+]/,\n        WHITESPACE: /[ \\t\\r\\n]/,\n        DIGIT: /[\\d]/,\n        SIGN: /[-+]/,\n        POINT: /\\./,\n        COMMA: /,/,\n        EXP: /e/i,\n        FLAGS: /[01]/\n      };\n      const SEP = 0;\n      const INT = 1;\n      const FLOAT = 2;\n      const EXP = 3;\n      let state = SEP;\n      let seenComma = true;\n      let number = \"\", exponent = \"\";\n      const result = [];\n      function throwSyntaxError(current2, i, partial) {\n        const error = new SyntaxError('Unexpected character \"' + current2 + '\" at index ' + i + \".\");\n        error.partial = partial;\n        throw error;\n      }\n      function newNumber() {\n        if (number !== \"\") {\n          if (exponent === \"\")\n            result.push(Number(number));\n          else\n            result.push(Number(number) * Math.pow(10, Number(exponent)));\n        }\n        number = \"\";\n        exponent = \"\";\n      }\n      let current;\n      const length = input.length;\n      for (let i = 0; i < length; i++) {\n        current = input[i];\n        if (Array.isArray(flags) && flags.includes(result.length % stride) && RE.FLAGS.test(current)) {\n          state = INT;\n          number = current;\n          newNumber();\n          continue;\n        }\n        if (state === SEP) {\n          if (RE.WHITESPACE.test(current)) {\n            continue;\n          }\n          if (RE.DIGIT.test(current) || RE.SIGN.test(current)) {\n            state = INT;\n            number = current;\n            continue;\n          }\n          if (RE.POINT.test(current)) {\n            state = FLOAT;\n            number = current;\n            continue;\n          }\n          if (RE.COMMA.test(current)) {\n            if (seenComma) {\n              throwSyntaxError(current, i, result);\n            }\n            seenComma = true;\n          }\n        }\n        if (state === INT) {\n          if (RE.DIGIT.test(current)) {\n            number += current;\n            continue;\n          }\n          if (RE.POINT.test(current)) {\n            number += current;\n            state = FLOAT;\n            continue;\n          }\n          if (RE.EXP.test(current)) {\n            state = EXP;\n            continue;\n          }\n          if (RE.SIGN.test(current) && number.length === 1 && RE.SIGN.test(number[0])) {\n            throwSyntaxError(current, i, result);\n          }\n        }\n        if (state === FLOAT) {\n          if (RE.DIGIT.test(current)) {\n            number += current;\n            continue;\n          }\n          if (RE.EXP.test(current)) {\n            state = EXP;\n            continue;\n          }\n          if (RE.POINT.test(current) && number[number.length - 1] === \".\") {\n            throwSyntaxError(current, i, result);\n          }\n        }\n        if (state === EXP) {\n          if (RE.DIGIT.test(current)) {\n            exponent += current;\n            continue;\n          }\n          if (RE.SIGN.test(current)) {\n            if (exponent === \"\") {\n              exponent += current;\n              continue;\n            }\n            if (exponent.length === 1 && RE.SIGN.test(exponent)) {\n              throwSyntaxError(current, i, result);\n            }\n          }\n        }\n        if (RE.WHITESPACE.test(current)) {\n          newNumber();\n          state = SEP;\n          seenComma = false;\n        } else if (RE.COMMA.test(current)) {\n          newNumber();\n          state = SEP;\n          seenComma = true;\n        } else if (RE.SIGN.test(current)) {\n          newNumber();\n          state = INT;\n          number = current;\n        } else if (RE.POINT.test(current)) {\n          newNumber();\n          state = FLOAT;\n          number = current;\n        } else {\n          throwSyntaxError(current, i, result);\n        }\n      }\n      newNumber();\n      return result;\n    }\n    const units = [\"mm\", \"cm\", \"in\", \"pt\", \"pc\", \"px\"];\n    const unitConversion = {\n      mm: {\n        mm: 1,\n        cm: 0.1,\n        in: 1 / 25.4,\n        pt: 72 / 25.4,\n        pc: 6 / 25.4,\n        px: -1\n      },\n      cm: {\n        mm: 10,\n        cm: 1,\n        in: 1 / 2.54,\n        pt: 72 / 2.54,\n        pc: 6 / 2.54,\n        px: -1\n      },\n      in: {\n        mm: 25.4,\n        cm: 2.54,\n        in: 1,\n        pt: 72,\n        pc: 6,\n        px: -1\n      },\n      pt: {\n        mm: 25.4 / 72,\n        cm: 2.54 / 72,\n        in: 1 / 72,\n        pt: 1,\n        pc: 6 / 72,\n        px: -1\n      },\n      pc: {\n        mm: 25.4 / 6,\n        cm: 2.54 / 6,\n        in: 1 / 6,\n        pt: 72 / 6,\n        pc: 1,\n        px: -1\n      },\n      px: {\n        px: 1\n      }\n    };\n    function parseFloatWithUnits(string) {\n      let theUnit = \"px\";\n      if (typeof string === \"string\" || string instanceof String) {\n        for (let i = 0, n = units.length; i < n; i++) {\n          const u = units[i];\n          if (string.endsWith(u)) {\n            theUnit = u;\n            string = string.substring(0, string.length - u.length);\n            break;\n          }\n        }\n      }\n      let scale = void 0;\n      if (theUnit === \"px\" && scope.defaultUnit !== \"px\") {\n        scale = unitConversion[\"in\"][scope.defaultUnit] / scope.defaultDPI;\n      } else {\n        scale = unitConversion[theUnit][scope.defaultUnit];\n        if (scale < 0) {\n          scale = unitConversion[theUnit][\"in\"] * scope.defaultDPI;\n        }\n      }\n      return scale * parseFloat(string);\n    }\n    function getNodeTransform(node) {\n      if (!(node.hasAttribute(\"transform\") || node.nodeName === \"use\" && (node.hasAttribute(\"x\") || node.hasAttribute(\"y\")))) {\n        return null;\n      }\n      const transform = parseNodeTransform(node);\n      if (transformStack.length > 0) {\n        transform.premultiply(transformStack[transformStack.length - 1]);\n      }\n      currentTransform.copy(transform);\n      transformStack.push(transform);\n      return transform;\n    }\n    function parseNodeTransform(node) {\n      const transform = new Matrix3();\n      const currentTransform2 = tempTransform0;\n      if (node.nodeName === \"use\" && (node.hasAttribute(\"x\") || node.hasAttribute(\"y\"))) {\n        const tx = parseFloatWithUnits(node.getAttribute(\"x\"));\n        const ty = parseFloatWithUnits(node.getAttribute(\"y\"));\n        transform.translate(tx, ty);\n      }\n      if (node.hasAttribute(\"transform\")) {\n        const transformsTexts = node.getAttribute(\"transform\").split(\")\");\n        for (let tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex--) {\n          const transformText = transformsTexts[tIndex].trim();\n          if (transformText === \"\")\n            continue;\n          const openParPos = transformText.indexOf(\"(\");\n          const closeParPos = transformText.length;\n          if (openParPos > 0 && openParPos < closeParPos) {\n            const transformType = transformText.substr(0, openParPos);\n            const array = parseFloats(transformText.substr(openParPos + 1, closeParPos - openParPos - 1));\n            currentTransform2.identity();\n            switch (transformType) {\n              case \"translate\":\n                if (array.length >= 1) {\n                  const tx = array[0];\n                  let ty = tx;\n                  if (array.length >= 2) {\n                    ty = array[1];\n                  }\n                  currentTransform2.translate(tx, ty);\n                }\n                break;\n              case \"rotate\":\n                if (array.length >= 1) {\n                  let angle = 0;\n                  let cx = 0;\n                  let cy = 0;\n                  angle = -array[0] * Math.PI / 180;\n                  if (array.length >= 3) {\n                    cx = array[1];\n                    cy = array[2];\n                  }\n                  tempTransform1.identity().translate(-cx, -cy);\n                  tempTransform2.identity().rotate(angle);\n                  tempTransform3.multiplyMatrices(tempTransform2, tempTransform1);\n                  tempTransform1.identity().translate(cx, cy);\n                  currentTransform2.multiplyMatrices(tempTransform1, tempTransform3);\n                }\n                break;\n              case \"scale\":\n                if (array.length >= 1) {\n                  const scaleX = array[0];\n                  let scaleY = scaleX;\n                  if (array.length >= 2) {\n                    scaleY = array[1];\n                  }\n                  currentTransform2.scale(scaleX, scaleY);\n                }\n                break;\n              case \"skewX\":\n                if (array.length === 1) {\n                  currentTransform2.set(1, Math.tan(array[0] * Math.PI / 180), 0, 0, 1, 0, 0, 0, 1);\n                }\n                break;\n              case \"skewY\":\n                if (array.length === 1) {\n                  currentTransform2.set(1, 0, 0, Math.tan(array[0] * Math.PI / 180), 1, 0, 0, 0, 1);\n                }\n                break;\n              case \"matrix\":\n                if (array.length === 6) {\n                  currentTransform2.set(array[0], array[2], array[4], array[1], array[3], array[5], 0, 0, 1);\n                }\n                break;\n            }\n          }\n          transform.premultiply(currentTransform2);\n        }\n      }\n      return transform;\n    }\n    function transformPath(path, m) {\n      function transfVec2(v2) {\n        tempV3.set(v2.x, v2.y, 1).applyMatrix3(m);\n        v2.set(tempV3.x, tempV3.y);\n      }\n      const isRotated = isTransformRotated(m);\n      const subPaths = path.subPaths;\n      for (let i = 0, n = subPaths.length; i < n; i++) {\n        const subPath = subPaths[i];\n        const curves = subPath.curves;\n        for (let j = 0; j < curves.length; j++) {\n          const curve = curves[j];\n          if (curve.isLineCurve) {\n            transfVec2(curve.v1);\n            transfVec2(curve.v2);\n          } else if (curve.isCubicBezierCurve) {\n            transfVec2(curve.v0);\n            transfVec2(curve.v1);\n            transfVec2(curve.v2);\n            transfVec2(curve.v3);\n          } else if (curve.isQuadraticBezierCurve) {\n            transfVec2(curve.v0);\n            transfVec2(curve.v1);\n            transfVec2(curve.v2);\n          } else if (curve.isEllipseCurve) {\n            if (isRotated) {\n              console.warn(\"SVGLoader: Elliptic arc or ellipse rotation or skewing is not implemented.\");\n            }\n            tempV2.set(curve.aX, curve.aY);\n            transfVec2(tempV2);\n            curve.aX = tempV2.x;\n            curve.aY = tempV2.y;\n            curve.xRadius *= getTransformScaleX(m);\n            curve.yRadius *= getTransformScaleY(m);\n          }\n        }\n      }\n    }\n    function isTransformRotated(m) {\n      return m.elements[1] !== 0 || m.elements[3] !== 0;\n    }\n    function getTransformScaleX(m) {\n      const te = m.elements;\n      return Math.sqrt(te[0] * te[0] + te[1] * te[1]);\n    }\n    function getTransformScaleY(m) {\n      const te = m.elements;\n      return Math.sqrt(te[3] * te[3] + te[4] * te[4]);\n    }\n    const paths = [];\n    const stylesheets = {};\n    const transformStack = [];\n    const tempTransform0 = new Matrix3();\n    const tempTransform1 = new Matrix3();\n    const tempTransform2 = new Matrix3();\n    const tempTransform3 = new Matrix3();\n    const tempV2 = new Vector2();\n    const tempV3 = new Vector3();\n    const currentTransform = new Matrix3();\n    const xml = new DOMParser().parseFromString(text, \"image/svg+xml\");\n    parseNode(xml.documentElement, {\n      fill: \"#000\",\n      fillOpacity: 1,\n      strokeOpacity: 1,\n      strokeWidth: 1,\n      strokeLineJoin: \"miter\",\n      strokeLineCap: \"butt\",\n      strokeMiterLimit: 4\n    });\n    const data = { paths, xml: xml.documentElement };\n    return data;\n  }\n  static createShapes(shapePath) {\n    const BIGNUMBER = 999999999;\n    const IntersectionLocationType = {\n      ORIGIN: 0,\n      DESTINATION: 1,\n      BETWEEN: 2,\n      LEFT: 3,\n      RIGHT: 4,\n      BEHIND: 5,\n      BEYOND: 6\n    };\n    const classifyResult = {\n      loc: IntersectionLocationType.ORIGIN,\n      t: 0\n    };\n    function findEdgeIntersection(a0, a1, b0, b1) {\n      const x1 = a0.x;\n      const x2 = a1.x;\n      const x3 = b0.x;\n      const x4 = b1.x;\n      const y1 = a0.y;\n      const y2 = a1.y;\n      const y3 = b0.y;\n      const y4 = b1.y;\n      const nom1 = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);\n      const nom2 = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);\n      const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);\n      const t1 = nom1 / denom;\n      const t2 = nom2 / denom;\n      if (denom === 0 && nom1 !== 0 || t1 <= 0 || t1 >= 1 || t2 < 0 || t2 > 1) {\n        return null;\n      } else if (nom1 === 0 && denom === 0) {\n        for (let i = 0; i < 2; i++) {\n          classifyPoint(i === 0 ? b0 : b1, a0, a1);\n          if (classifyResult.loc == IntersectionLocationType.ORIGIN) {\n            const point = i === 0 ? b0 : b1;\n            return { x: point.x, y: point.y, t: classifyResult.t };\n          } else if (classifyResult.loc == IntersectionLocationType.BETWEEN) {\n            const x = +(x1 + classifyResult.t * (x2 - x1)).toPrecision(10);\n            const y = +(y1 + classifyResult.t * (y2 - y1)).toPrecision(10);\n            return { x, y, t: classifyResult.t };\n          }\n        }\n        return null;\n      } else {\n        for (let i = 0; i < 2; i++) {\n          classifyPoint(i === 0 ? b0 : b1, a0, a1);\n          if (classifyResult.loc == IntersectionLocationType.ORIGIN) {\n            const point = i === 0 ? b0 : b1;\n            return { x: point.x, y: point.y, t: classifyResult.t };\n          }\n        }\n        const x = +(x1 + t1 * (x2 - x1)).toPrecision(10);\n        const y = +(y1 + t1 * (y2 - y1)).toPrecision(10);\n        return { x, y, t: t1 };\n      }\n    }\n    function classifyPoint(p, edgeStart, edgeEnd) {\n      const ax = edgeEnd.x - edgeStart.x;\n      const ay = edgeEnd.y - edgeStart.y;\n      const bx = p.x - edgeStart.x;\n      const by = p.y - edgeStart.y;\n      const sa = ax * by - bx * ay;\n      if (p.x === edgeStart.x && p.y === edgeStart.y) {\n        classifyResult.loc = IntersectionLocationType.ORIGIN;\n        classifyResult.t = 0;\n        return;\n      }\n      if (p.x === edgeEnd.x && p.y === edgeEnd.y) {\n        classifyResult.loc = IntersectionLocationType.DESTINATION;\n        classifyResult.t = 1;\n        return;\n      }\n      if (sa < -Number.EPSILON) {\n        classifyResult.loc = IntersectionLocationType.LEFT;\n        return;\n      }\n      if (sa > Number.EPSILON) {\n        classifyResult.loc = IntersectionLocationType.RIGHT;\n        return;\n      }\n      if (ax * bx < 0 || ay * by < 0) {\n        classifyResult.loc = IntersectionLocationType.BEHIND;\n        return;\n      }\n      if (Math.sqrt(ax * ax + ay * ay) < Math.sqrt(bx * bx + by * by)) {\n        classifyResult.loc = IntersectionLocationType.BEYOND;\n        return;\n      }\n      let t;\n      if (ax !== 0) {\n        t = bx / ax;\n      } else {\n        t = by / ay;\n      }\n      classifyResult.loc = IntersectionLocationType.BETWEEN;\n      classifyResult.t = t;\n    }\n    function getIntersections(path1, path2) {\n      const intersectionsRaw = [];\n      const intersections = [];\n      for (let index = 1; index < path1.length; index++) {\n        const path1EdgeStart = path1[index - 1];\n        const path1EdgeEnd = path1[index];\n        for (let index2 = 1; index2 < path2.length; index2++) {\n          const path2EdgeStart = path2[index2 - 1];\n          const path2EdgeEnd = path2[index2];\n          const intersection = findEdgeIntersection(path1EdgeStart, path1EdgeEnd, path2EdgeStart, path2EdgeEnd);\n          if (intersection !== null && intersectionsRaw.find(\n            (i) => i.t <= intersection.t + Number.EPSILON && i.t >= intersection.t - Number.EPSILON\n          ) === void 0) {\n            intersectionsRaw.push(intersection);\n            intersections.push(new Vector2(intersection.x, intersection.y));\n          }\n        }\n      }\n      return intersections;\n    }\n    function getScanlineIntersections(scanline, boundingBox, paths) {\n      const center = new Vector2();\n      boundingBox.getCenter(center);\n      const allIntersections = [];\n      paths.forEach((path) => {\n        if (path.boundingBox.containsPoint(center)) {\n          const intersections = getIntersections(scanline, path.points);\n          intersections.forEach((p) => {\n            allIntersections.push({ identifier: path.identifier, isCW: path.isCW, point: p });\n          });\n        }\n      });\n      allIntersections.sort((i1, i2) => {\n        return i1.point.x - i2.point.x;\n      });\n      return allIntersections;\n    }\n    function isHoleTo(simplePath, allPaths, scanlineMinX2, scanlineMaxX2, _fillRule) {\n      if (_fillRule === null || _fillRule === void 0 || _fillRule === \"\") {\n        _fillRule = \"nonzero\";\n      }\n      const centerBoundingBox = new Vector2();\n      simplePath.boundingBox.getCenter(centerBoundingBox);\n      const scanline = [new Vector2(scanlineMinX2, centerBoundingBox.y), new Vector2(scanlineMaxX2, centerBoundingBox.y)];\n      const scanlineIntersections = getScanlineIntersections(scanline, simplePath.boundingBox, allPaths);\n      scanlineIntersections.sort((i1, i2) => {\n        return i1.point.x - i2.point.x;\n      });\n      const baseIntersections = [];\n      const otherIntersections = [];\n      scanlineIntersections.forEach((i2) => {\n        if (i2.identifier === simplePath.identifier) {\n          baseIntersections.push(i2);\n        } else {\n          otherIntersections.push(i2);\n        }\n      });\n      const firstXOfPath = baseIntersections[0].point.x;\n      const stack = [];\n      let i = 0;\n      while (i < otherIntersections.length && otherIntersections[i].point.x < firstXOfPath) {\n        if (stack.length > 0 && stack[stack.length - 1] === otherIntersections[i].identifier) {\n          stack.pop();\n        } else {\n          stack.push(otherIntersections[i].identifier);\n        }\n        i++;\n      }\n      stack.push(simplePath.identifier);\n      if (_fillRule === \"evenodd\") {\n        const isHole = stack.length % 2 === 0 ? true : false;\n        const isHoleFor = stack[stack.length - 2];\n        return { identifier: simplePath.identifier, isHole, for: isHoleFor };\n      } else if (_fillRule === \"nonzero\") {\n        let isHole = true;\n        let isHoleFor = null;\n        let lastCWValue = null;\n        for (let i2 = 0; i2 < stack.length; i2++) {\n          const identifier2 = stack[i2];\n          if (isHole) {\n            lastCWValue = allPaths[identifier2].isCW;\n            isHole = false;\n            isHoleFor = identifier2;\n          } else if (lastCWValue !== allPaths[identifier2].isCW) {\n            lastCWValue = allPaths[identifier2].isCW;\n            isHole = true;\n          }\n        }\n        return { identifier: simplePath.identifier, isHole, for: isHoleFor };\n      } else {\n        console.warn('fill-rule: \"' + _fillRule + '\" is currently not implemented.');\n      }\n    }\n    let identifier = 0;\n    let scanlineMinX = BIGNUMBER;\n    let scanlineMaxX = -BIGNUMBER;\n    let simplePaths = shapePath.subPaths.map((p) => {\n      const points = p.getPoints();\n      let maxY = -BIGNUMBER;\n      let minY = BIGNUMBER;\n      let maxX = -BIGNUMBER;\n      let minX = BIGNUMBER;\n      for (let i = 0; i < points.length; i++) {\n        const p2 = points[i];\n        if (p2.y > maxY) {\n          maxY = p2.y;\n        }\n        if (p2.y < minY) {\n          minY = p2.y;\n        }\n        if (p2.x > maxX) {\n          maxX = p2.x;\n        }\n        if (p2.x < minX) {\n          minX = p2.x;\n        }\n      }\n      if (scanlineMaxX <= maxX) {\n        scanlineMaxX = maxX + 1;\n      }\n      if (scanlineMinX >= minX) {\n        scanlineMinX = minX - 1;\n      }\n      return {\n        curves: p.curves,\n        points,\n        isCW: ShapeUtils.isClockWise(points),\n        identifier: identifier++,\n        boundingBox: new Box2(new Vector2(minX, minY), new Vector2(maxX, maxY))\n      };\n    });\n    simplePaths = simplePaths.filter((sp) => sp.points.length > 1);\n    const isAHole = simplePaths.map(\n      (p) => isHoleTo(p, simplePaths, scanlineMinX, scanlineMaxX, shapePath.userData.style.fillRule)\n    );\n    const shapesToReturn = [];\n    simplePaths.forEach((p) => {\n      const amIAHole = isAHole[p.identifier];\n      if (!amIAHole.isHole) {\n        const shape = new Shape();\n        shape.curves = p.curves;\n        const holes = isAHole.filter((h) => h.isHole && h.for === p.identifier);\n        holes.forEach((h) => {\n          const hole = simplePaths[h.identifier];\n          const path = new Path();\n          path.curves = hole.curves;\n          shape.holes.push(path);\n        });\n        shapesToReturn.push(shape);\n      }\n    });\n    return shapesToReturn;\n  }\n  static getStrokeStyle(width, color, lineJoin, lineCap, miterLimit) {\n    width = width !== void 0 ? width : 1;\n    color = color !== void 0 ? color : \"#000\";\n    lineJoin = lineJoin !== void 0 ? lineJoin : \"miter\";\n    lineCap = lineCap !== void 0 ? lineCap : \"butt\";\n    miterLimit = miterLimit !== void 0 ? miterLimit : 4;\n    return {\n      strokeColor: color,\n      strokeWidth: width,\n      strokeLineJoin: lineJoin,\n      strokeLineCap: lineCap,\n      strokeMiterLimit: miterLimit\n    };\n  }\n  static pointsToStroke(points, style, arcDivisions, minDistance) {\n    const vertices = [];\n    const normals = [];\n    const uvs = [];\n    if (SVGLoader.pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs) === 0) {\n      return null;\n    }\n    const geometry = new BufferGeometry();\n    geometry.setAttribute(\"position\", new Float32BufferAttribute(vertices, 3));\n    geometry.setAttribute(\"normal\", new Float32BufferAttribute(normals, 3));\n    geometry.setAttribute(\"uv\", new Float32BufferAttribute(uvs, 2));\n    return geometry;\n  }\n  static pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs, vertexOffset) {\n    const tempV2_1 = new Vector2();\n    const tempV2_2 = new Vector2();\n    const tempV2_3 = new Vector2();\n    const tempV2_4 = new Vector2();\n    const tempV2_5 = new Vector2();\n    const tempV2_6 = new Vector2();\n    const tempV2_7 = new Vector2();\n    const lastPointL = new Vector2();\n    const lastPointR = new Vector2();\n    const point0L = new Vector2();\n    const point0R = new Vector2();\n    const currentPointL = new Vector2();\n    const currentPointR = new Vector2();\n    const nextPointL = new Vector2();\n    const nextPointR = new Vector2();\n    const innerPoint = new Vector2();\n    const outerPoint = new Vector2();\n    arcDivisions = arcDivisions !== void 0 ? arcDivisions : 12;\n    minDistance = minDistance !== void 0 ? minDistance : 1e-3;\n    vertexOffset = vertexOffset !== void 0 ? vertexOffset : 0;\n    points = removeDuplicatedPoints(points);\n    const numPoints = points.length;\n    if (numPoints < 2)\n      return 0;\n    const isClosed = points[0].equals(points[numPoints - 1]);\n    let currentPoint;\n    let previousPoint = points[0];\n    let nextPoint;\n    const strokeWidth2 = style.strokeWidth / 2;\n    const deltaU = 1 / (numPoints - 1);\n    let u0 = 0, u1;\n    let innerSideModified;\n    let joinIsOnLeftSide;\n    let isMiter;\n    let initialJoinIsOnLeftSide = false;\n    let numVertices = 0;\n    let currentCoordinate = vertexOffset * 3;\n    let currentCoordinateUV = vertexOffset * 2;\n    getNormal(points[0], points[1], tempV2_1).multiplyScalar(strokeWidth2);\n    lastPointL.copy(points[0]).sub(tempV2_1);\n    lastPointR.copy(points[0]).add(tempV2_1);\n    point0L.copy(lastPointL);\n    point0R.copy(lastPointR);\n    for (let iPoint = 1; iPoint < numPoints; iPoint++) {\n      currentPoint = points[iPoint];\n      if (iPoint === numPoints - 1) {\n        if (isClosed) {\n          nextPoint = points[1];\n        } else {\n          nextPoint = void 0;\n        }\n      } else {\n        nextPoint = points[iPoint + 1];\n      }\n      const normal1 = tempV2_1;\n      getNormal(previousPoint, currentPoint, normal1);\n      tempV2_3.copy(normal1).multiplyScalar(strokeWidth2);\n      currentPointL.copy(currentPoint).sub(tempV2_3);\n      currentPointR.copy(currentPoint).add(tempV2_3);\n      u1 = u0 + deltaU;\n      innerSideModified = false;\n      if (nextPoint !== void 0) {\n        getNormal(currentPoint, nextPoint, tempV2_2);\n        tempV2_3.copy(tempV2_2).multiplyScalar(strokeWidth2);\n        nextPointL.copy(currentPoint).sub(tempV2_3);\n        nextPointR.copy(currentPoint).add(tempV2_3);\n        joinIsOnLeftSide = true;\n        tempV2_3.subVectors(nextPoint, previousPoint);\n        if (normal1.dot(tempV2_3) < 0) {\n          joinIsOnLeftSide = false;\n        }\n        if (iPoint === 1)\n          initialJoinIsOnLeftSide = joinIsOnLeftSide;\n        tempV2_3.subVectors(nextPoint, currentPoint);\n        tempV2_3.normalize();\n        const dot = Math.abs(normal1.dot(tempV2_3));\n        if (dot !== 0) {\n          const miterSide = strokeWidth2 / dot;\n          tempV2_3.multiplyScalar(-miterSide);\n          tempV2_4.subVectors(currentPoint, previousPoint);\n          tempV2_5.copy(tempV2_4).setLength(miterSide).add(tempV2_3);\n          innerPoint.copy(tempV2_5).negate();\n          const miterLength2 = tempV2_5.length();\n          const segmentLengthPrev = tempV2_4.length();\n          tempV2_4.divideScalar(segmentLengthPrev);\n          tempV2_6.subVectors(nextPoint, currentPoint);\n          const segmentLengthNext = tempV2_6.length();\n          tempV2_6.divideScalar(segmentLengthNext);\n          if (tempV2_4.dot(innerPoint) < segmentLengthPrev && tempV2_6.dot(innerPoint) < segmentLengthNext) {\n            innerSideModified = true;\n          }\n          outerPoint.copy(tempV2_5).add(currentPoint);\n          innerPoint.add(currentPoint);\n          isMiter = false;\n          if (innerSideModified) {\n            if (joinIsOnLeftSide) {\n              nextPointR.copy(innerPoint);\n              currentPointR.copy(innerPoint);\n            } else {\n              nextPointL.copy(innerPoint);\n              currentPointL.copy(innerPoint);\n            }\n          } else {\n            makeSegmentTriangles();\n          }\n          switch (style.strokeLineJoin) {\n            case \"bevel\":\n              makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1);\n              break;\n            case \"round\":\n              createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified);\n              if (joinIsOnLeftSide) {\n                makeCircularSector(currentPoint, currentPointL, nextPointL, u1, 0);\n              } else {\n                makeCircularSector(currentPoint, nextPointR, currentPointR, u1, 1);\n              }\n              break;\n            case \"miter\":\n            case \"miter-clip\":\n            default:\n              const miterFraction = strokeWidth2 * style.strokeMiterLimit / miterLength2;\n              if (miterFraction < 1) {\n                if (style.strokeLineJoin !== \"miter-clip\") {\n                  makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1);\n                  break;\n                } else {\n                  createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified);\n                  if (joinIsOnLeftSide) {\n                    tempV2_6.subVectors(outerPoint, currentPointL).multiplyScalar(miterFraction).add(currentPointL);\n                    tempV2_7.subVectors(outerPoint, nextPointL).multiplyScalar(miterFraction).add(nextPointL);\n                    addVertex(currentPointL, u1, 0);\n                    addVertex(tempV2_6, u1, 0);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(tempV2_6, u1, 0);\n                    addVertex(tempV2_7, u1, 0);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(tempV2_7, u1, 0);\n                    addVertex(nextPointL, u1, 0);\n                  } else {\n                    tempV2_6.subVectors(outerPoint, currentPointR).multiplyScalar(miterFraction).add(currentPointR);\n                    tempV2_7.subVectors(outerPoint, nextPointR).multiplyScalar(miterFraction).add(nextPointR);\n                    addVertex(currentPointR, u1, 1);\n                    addVertex(tempV2_6, u1, 1);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(tempV2_6, u1, 1);\n                    addVertex(tempV2_7, u1, 1);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(tempV2_7, u1, 1);\n                    addVertex(nextPointR, u1, 1);\n                  }\n                }\n              } else {\n                if (innerSideModified) {\n                  if (joinIsOnLeftSide) {\n                    addVertex(lastPointR, u0, 1);\n                    addVertex(lastPointL, u0, 0);\n                    addVertex(outerPoint, u1, 0);\n                    addVertex(lastPointR, u0, 1);\n                    addVertex(outerPoint, u1, 0);\n                    addVertex(innerPoint, u1, 1);\n                  } else {\n                    addVertex(lastPointR, u0, 1);\n                    addVertex(lastPointL, u0, 0);\n                    addVertex(outerPoint, u1, 1);\n                    addVertex(lastPointL, u0, 0);\n                    addVertex(innerPoint, u1, 0);\n                    addVertex(outerPoint, u1, 1);\n                  }\n                  if (joinIsOnLeftSide) {\n                    nextPointL.copy(outerPoint);\n                  } else {\n                    nextPointR.copy(outerPoint);\n                  }\n                } else {\n                  if (joinIsOnLeftSide) {\n                    addVertex(currentPointL, u1, 0);\n                    addVertex(outerPoint, u1, 0);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(outerPoint, u1, 0);\n                    addVertex(nextPointL, u1, 0);\n                  } else {\n                    addVertex(currentPointR, u1, 1);\n                    addVertex(outerPoint, u1, 1);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(outerPoint, u1, 1);\n                    addVertex(nextPointR, u1, 1);\n                  }\n                }\n                isMiter = true;\n              }\n              break;\n          }\n        } else {\n          makeSegmentTriangles();\n        }\n      } else {\n        makeSegmentTriangles();\n      }\n      if (!isClosed && iPoint === numPoints - 1) {\n        addCapGeometry(points[0], point0L, point0R, joinIsOnLeftSide, true, u0);\n      }\n      u0 = u1;\n      previousPoint = currentPoint;\n      lastPointL.copy(nextPointL);\n      lastPointR.copy(nextPointR);\n    }\n    if (!isClosed) {\n      addCapGeometry(currentPoint, currentPointL, currentPointR, joinIsOnLeftSide, false, u1);\n    } else if (innerSideModified && vertices) {\n      let lastOuter = outerPoint;\n      let lastInner = innerPoint;\n      if (initialJoinIsOnLeftSide !== joinIsOnLeftSide) {\n        lastOuter = innerPoint;\n        lastInner = outerPoint;\n      }\n      if (joinIsOnLeftSide) {\n        if (isMiter || initialJoinIsOnLeftSide) {\n          lastInner.toArray(vertices, 0 * 3);\n          lastInner.toArray(vertices, 3 * 3);\n          if (isMiter) {\n            lastOuter.toArray(vertices, 1 * 3);\n          }\n        }\n      } else {\n        if (isMiter || !initialJoinIsOnLeftSide) {\n          lastInner.toArray(vertices, 1 * 3);\n          lastInner.toArray(vertices, 3 * 3);\n          if (isMiter) {\n            lastOuter.toArray(vertices, 0 * 3);\n          }\n        }\n      }\n    }\n    return numVertices;\n    function getNormal(p1, p2, result) {\n      result.subVectors(p2, p1);\n      return result.set(-result.y, result.x).normalize();\n    }\n    function addVertex(position, u, v) {\n      if (vertices) {\n        vertices[currentCoordinate] = position.x;\n        vertices[currentCoordinate + 1] = position.y;\n        vertices[currentCoordinate + 2] = 0;\n        if (normals) {\n          normals[currentCoordinate] = 0;\n          normals[currentCoordinate + 1] = 0;\n          normals[currentCoordinate + 2] = 1;\n        }\n        currentCoordinate += 3;\n        if (uvs) {\n          uvs[currentCoordinateUV] = u;\n          uvs[currentCoordinateUV + 1] = v;\n          currentCoordinateUV += 2;\n        }\n      }\n      numVertices += 3;\n    }\n    function makeCircularSector(center, p1, p2, u, v) {\n      tempV2_1.copy(p1).sub(center).normalize();\n      tempV2_2.copy(p2).sub(center).normalize();\n      let angle = Math.PI;\n      const dot = tempV2_1.dot(tempV2_2);\n      if (Math.abs(dot) < 1)\n        angle = Math.abs(Math.acos(dot));\n      angle /= arcDivisions;\n      tempV2_3.copy(p1);\n      for (let i = 0, il = arcDivisions - 1; i < il; i++) {\n        tempV2_4.copy(tempV2_3).rotateAround(center, angle);\n        addVertex(tempV2_3, u, v);\n        addVertex(tempV2_4, u, v);\n        addVertex(center, u, 0.5);\n        tempV2_3.copy(tempV2_4);\n      }\n      addVertex(tempV2_4, u, v);\n      addVertex(p2, u, v);\n      addVertex(center, u, 0.5);\n    }\n    function makeSegmentTriangles() {\n      addVertex(lastPointR, u0, 1);\n      addVertex(lastPointL, u0, 0);\n      addVertex(currentPointL, u1, 0);\n      addVertex(lastPointR, u0, 1);\n      addVertex(currentPointL, u1, 1);\n      addVertex(currentPointR, u1, 0);\n    }\n    function makeSegmentWithBevelJoin(joinIsOnLeftSide2, innerSideModified2, u) {\n      if (innerSideModified2) {\n        if (joinIsOnLeftSide2) {\n          addVertex(lastPointR, u0, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(currentPointL, u1, 0);\n          addVertex(lastPointR, u0, 1);\n          addVertex(currentPointL, u1, 0);\n          addVertex(innerPoint, u1, 1);\n          addVertex(currentPointL, u, 0);\n          addVertex(nextPointL, u, 0);\n          addVertex(innerPoint, u, 0.5);\n        } else {\n          addVertex(lastPointR, u0, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(currentPointR, u1, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(innerPoint, u1, 0);\n          addVertex(currentPointR, u1, 1);\n          addVertex(currentPointR, u, 1);\n          addVertex(nextPointR, u, 0);\n          addVertex(innerPoint, u, 0.5);\n        }\n      } else {\n        if (joinIsOnLeftSide2) {\n          addVertex(currentPointL, u, 0);\n          addVertex(nextPointL, u, 0);\n          addVertex(currentPoint, u, 0.5);\n        } else {\n          addVertex(currentPointR, u, 1);\n          addVertex(nextPointR, u, 0);\n          addVertex(currentPoint, u, 0.5);\n        }\n      }\n    }\n    function createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide2, innerSideModified2) {\n      if (innerSideModified2) {\n        if (joinIsOnLeftSide2) {\n          addVertex(lastPointR, u0, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(currentPointL, u1, 0);\n          addVertex(lastPointR, u0, 1);\n          addVertex(currentPointL, u1, 0);\n          addVertex(innerPoint, u1, 1);\n          addVertex(currentPointL, u0, 0);\n          addVertex(currentPoint, u1, 0.5);\n          addVertex(innerPoint, u1, 1);\n          addVertex(currentPoint, u1, 0.5);\n          addVertex(nextPointL, u0, 0);\n          addVertex(innerPoint, u1, 1);\n        } else {\n          addVertex(lastPointR, u0, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(currentPointR, u1, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(innerPoint, u1, 0);\n          addVertex(currentPointR, u1, 1);\n          addVertex(currentPointR, u0, 1);\n          addVertex(innerPoint, u1, 0);\n          addVertex(currentPoint, u1, 0.5);\n          addVertex(currentPoint, u1, 0.5);\n          addVertex(innerPoint, u1, 0);\n          addVertex(nextPointR, u0, 1);\n        }\n      }\n    }\n    function addCapGeometry(center, p1, p2, joinIsOnLeftSide2, start, u) {\n      switch (style.strokeLineCap) {\n        case \"round\":\n          if (start) {\n            makeCircularSector(center, p2, p1, u, 0.5);\n          } else {\n            makeCircularSector(center, p1, p2, u, 0.5);\n          }\n          break;\n        case \"square\":\n          if (start) {\n            tempV2_1.subVectors(p1, center);\n            tempV2_2.set(tempV2_1.y, -tempV2_1.x);\n            tempV2_3.addVectors(tempV2_1, tempV2_2).add(center);\n            tempV2_4.subVectors(tempV2_2, tempV2_1).add(center);\n            if (joinIsOnLeftSide2) {\n              tempV2_3.toArray(vertices, 1 * 3);\n              tempV2_4.toArray(vertices, 0 * 3);\n              tempV2_4.toArray(vertices, 3 * 3);\n            } else {\n              tempV2_3.toArray(vertices, 1 * 3);\n              tempV2_3.toArray(vertices, 3 * 3);\n              tempV2_4.toArray(vertices, 0 * 3);\n            }\n          } else {\n            tempV2_1.subVectors(p2, center);\n            tempV2_2.set(tempV2_1.y, -tempV2_1.x);\n            tempV2_3.addVectors(tempV2_1, tempV2_2).add(center);\n            tempV2_4.subVectors(tempV2_2, tempV2_1).add(center);\n            const vl = vertices.length;\n            if (joinIsOnLeftSide2) {\n              tempV2_3.toArray(vertices, vl - 1 * 3);\n              tempV2_4.toArray(vertices, vl - 2 * 3);\n              tempV2_4.toArray(vertices, vl - 4 * 3);\n            } else {\n              tempV2_3.toArray(vertices, vl - 2 * 3);\n              tempV2_4.toArray(vertices, vl - 1 * 3);\n              tempV2_4.toArray(vertices, vl - 4 * 3);\n            }\n          }\n          break;\n        case \"butt\":\n        default:\n          break;\n      }\n    }\n    function removeDuplicatedPoints(points2) {\n      let dupPoints = false;\n      for (let i = 1, n = points2.length - 1; i < n; i++) {\n        if (points2[i].distanceTo(points2[i + 1]) < minDistance) {\n          dupPoints = true;\n          break;\n        }\n      }\n      if (!dupPoints)\n        return points2;\n      const newPoints = [];\n      newPoints.push(points2[0]);\n      for (let i = 1, n = points2.length - 1; i < n; i++) {\n        if (points2[i].distanceTo(points2[i + 1]) >= minDistance) {\n          newPoints.push(points2[i]);\n        }\n      }\n      newPoints.push(points2[points2.length - 1]);\n      return newPoints;\n    }\n  }\n}\nexport {\n  SVGLoader\n};\n"]},"metadata":{},"sourceType":"module"}