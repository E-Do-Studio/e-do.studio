{"ast":null,"code":"'use strict';\n\nconst http = require('http');\n\nconst https = require('https');\n\nconst urllib = require('url');\n\nconst zlib = require('zlib');\n\nconst PassThrough = require('stream').PassThrough;\n\nconst Cookies = require('./cookies');\n\nconst packageData = require('../../package.json');\n\nconst MAX_REDIRECTS = 5;\n\nmodule.exports = function (url, options) {\n  return fetch(url, options);\n};\n\nmodule.exports.Cookies = Cookies;\n\nfunction fetch(url, options) {\n  options = options || {};\n  options.fetchRes = options.fetchRes || new PassThrough();\n  options.cookies = options.cookies || new Cookies();\n  options.redirects = options.redirects || 0;\n  options.maxRedirects = isNaN(options.maxRedirects) ? MAX_REDIRECTS : options.maxRedirects;\n\n  if (options.cookie) {\n    [].concat(options.cookie || []).forEach(cookie => {\n      options.cookies.set(cookie, url);\n    });\n    options.cookie = false;\n  }\n\n  let fetchRes = options.fetchRes;\n  let parsed = urllib.parse(url);\n  let method = (options.method || '').toString().trim().toUpperCase() || 'GET';\n  let finished = false;\n  let cookies;\n  let body;\n  let handler = parsed.protocol === 'https:' ? https : http;\n  let headers = {\n    'accept-encoding': 'gzip,deflate',\n    'user-agent': 'nodemailer/' + packageData.version\n  };\n  Object.keys(options.headers || {}).forEach(key => {\n    headers[key.toLowerCase().trim()] = options.headers[key];\n  });\n\n  if (options.userAgent) {\n    headers['user-agent'] = options.userAgent;\n  }\n\n  if (parsed.auth) {\n    headers.Authorization = 'Basic ' + new Buffer(parsed.auth).toString('base64');\n  }\n\n  if (cookies = options.cookies.get(url)) {\n    headers.cookie = cookies;\n  }\n\n  if (options.body) {\n    if (options.contentType !== false) {\n      headers['Content-Type'] = options.contentType || 'application/x-www-form-urlencoded';\n    }\n\n    if (typeof options.body.pipe === 'function') {\n      // it's a stream\n      headers['Transfer-Encoding'] = 'chunked';\n      body = options.body;\n      body.on('error', err => {\n        if (finished) {\n          return;\n        }\n\n        finished = true;\n        err.type = 'FETCH';\n        err.sourceUrl = url;\n        fetchRes.emit('error', err);\n      });\n    } else {\n      if (options.body instanceof Buffer) {\n        body = options.body;\n      } else if (typeof options.body === 'object') {\n        body = new Buffer(Object.keys(options.body).map(key => {\n          let value = options.body[key].toString().trim();\n          return encodeURIComponent(key) + '=' + encodeURIComponent(value);\n        }).join('&'));\n      } else {\n        body = new Buffer(options.body.toString().trim());\n      }\n\n      headers['Content-Type'] = options.contentType || 'application/x-www-form-urlencoded';\n      headers['Content-Length'] = body.length;\n    } // if method is not provided, use POST instead of GET\n\n\n    method = (options.method || '').toString().trim().toUpperCase() || 'POST';\n  }\n\n  let req;\n  let reqOptions = {\n    method,\n    host: parsed.hostname,\n    path: parsed.path,\n    port: parsed.port ? parsed.port : parsed.protocol === 'https:' ? 443 : 80,\n    headers,\n    rejectUnauthorized: false,\n    agent: false\n  };\n\n  if (options.tls) {\n    Object.keys(options.tls).forEach(key => {\n      reqOptions[key] = options.tls[key];\n    });\n  }\n\n  try {\n    req = handler.request(reqOptions);\n  } catch (E) {\n    finished = true;\n    setImmediate(() => {\n      E.type = 'FETCH';\n      E.sourceUrl = url;\n      fetchRes.emit('error', E);\n    });\n    return fetchRes;\n  }\n\n  if (options.timeout) {\n    req.setTimeout(options.timeout, () => {\n      if (finished) {\n        return;\n      }\n\n      finished = true;\n      req.abort();\n      let err = new Error('Request Timeout');\n      err.type = 'FETCH';\n      err.sourceUrl = url;\n      fetchRes.emit('error', err);\n    });\n  }\n\n  req.on('error', err => {\n    if (finished) {\n      return;\n    }\n\n    finished = true;\n    err.type = 'FETCH';\n    err.sourceUrl = url;\n    fetchRes.emit('error', err);\n  });\n  req.on('response', res => {\n    let inflate;\n\n    if (finished) {\n      return;\n    }\n\n    switch (res.headers['content-encoding']) {\n      case 'gzip':\n      case 'deflate':\n        inflate = zlib.createUnzip();\n        break;\n    }\n\n    if (res.headers['set-cookie']) {\n      [].concat(res.headers['set-cookie'] || []).forEach(cookie => {\n        options.cookies.set(cookie, url);\n      });\n    }\n\n    if ([301, 302, 303, 307, 308].includes(res.statusCode) && res.headers.location) {\n      // redirect\n      options.redirects++;\n\n      if (options.redirects > options.maxRedirects) {\n        finished = true;\n        let err = new Error('Maximum redirect count exceeded');\n        err.type = 'FETCH';\n        err.sourceUrl = url;\n        fetchRes.emit('error', err);\n        req.abort();\n        return;\n      }\n\n      return fetch(urllib.resolve(url, res.headers.location), options);\n    }\n\n    fetchRes.statusCode = res.statusCode;\n\n    if (res.statusCode >= 300 && !options.allowErrorResponse) {\n      finished = true;\n      let err = new Error('Invalid status code ' + res.statusCode);\n      err.type = 'FETCH';\n      err.sourceUrl = url;\n      fetchRes.emit('error', err);\n      req.abort();\n      return;\n    }\n\n    res.on('error', err => {\n      if (finished) {\n        return;\n      }\n\n      finished = true;\n      err.type = 'FETCH';\n      err.sourceUrl = url;\n      fetchRes.emit('error', err);\n      req.abort();\n    });\n\n    if (inflate) {\n      res.pipe(inflate).pipe(fetchRes);\n      inflate.on('error', err => {\n        if (finished) {\n          return;\n        }\n\n        finished = true;\n        err.type = 'FETCH';\n        err.sourceUrl = url;\n        fetchRes.emit('error', err);\n        req.abort();\n      });\n    } else {\n      res.pipe(fetchRes);\n    }\n  });\n  setImmediate(() => {\n    if (body) {\n      try {\n        if (typeof body.pipe === 'function') {\n          return body.pipe(req);\n        } else {\n          req.write(body);\n        }\n      } catch (err) {\n        finished = true;\n        err.type = 'FETCH';\n        err.sourceUrl = url;\n        fetchRes.emit('error', err);\n        return;\n      }\n    }\n\n    req.end();\n  });\n  return fetchRes;\n}","map":{"version":3,"sources":["/Users/theodaguier/e-do/node_modules/smtp-connection/node_modules/nodemailer/lib/fetch/index.js"],"names":["http","require","https","urllib","zlib","PassThrough","Cookies","packageData","MAX_REDIRECTS","module","exports","url","options","fetch","fetchRes","cookies","redirects","maxRedirects","isNaN","cookie","concat","forEach","set","parsed","parse","method","toString","trim","toUpperCase","finished","body","handler","protocol","headers","version","Object","keys","key","toLowerCase","userAgent","auth","Authorization","Buffer","get","contentType","pipe","on","err","type","sourceUrl","emit","map","value","encodeURIComponent","join","length","req","reqOptions","host","hostname","path","port","rejectUnauthorized","agent","tls","request","E","setImmediate","timeout","setTimeout","abort","Error","res","inflate","createUnzip","includes","statusCode","location","resolve","allowErrorResponse","write","end"],"mappings":"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","sourcesContent":["'use strict';\n\nconst http = require('http');\nconst https = require('https');\nconst urllib = require('url');\nconst zlib = require('zlib');\nconst PassThrough = require('stream').PassThrough;\nconst Cookies = require('./cookies');\nconst packageData = require('../../package.json');\n\nconst MAX_REDIRECTS = 5;\n\nmodule.exports = function (url, options) {\n    return fetch(url, options);\n};\n\nmodule.exports.Cookies = Cookies;\n\nfunction fetch(url, options) {\n    options = options || {};\n\n    options.fetchRes = options.fetchRes || new PassThrough();\n    options.cookies = options.cookies || new Cookies();\n    options.redirects = options.redirects || 0;\n    options.maxRedirects = isNaN(options.maxRedirects) ? MAX_REDIRECTS : options.maxRedirects;\n\n    if (options.cookie) {\n        [].concat(options.cookie || []).forEach(cookie => {\n            options.cookies.set(cookie, url);\n        });\n        options.cookie = false;\n    }\n\n    let fetchRes = options.fetchRes;\n    let parsed = urllib.parse(url);\n    let method = (options.method || '').toString().trim().toUpperCase() || 'GET';\n    let finished = false;\n    let cookies;\n    let body;\n\n    let handler = parsed.protocol === 'https:' ? https : http;\n\n    let headers = {\n        'accept-encoding': 'gzip,deflate',\n        'user-agent': 'nodemailer/' + packageData.version\n    };\n\n    Object.keys(options.headers || {}).forEach(key => {\n        headers[key.toLowerCase().trim()] = options.headers[key];\n    });\n\n    if (options.userAgent) {\n        headers['user-agent'] = options.userAgent;\n    }\n\n    if (parsed.auth) {\n        headers.Authorization = 'Basic ' + new Buffer(parsed.auth).toString('base64');\n    }\n\n    if ((cookies = options.cookies.get(url))) {\n        headers.cookie = cookies;\n    }\n\n    if (options.body) {\n        if (options.contentType !== false) {\n            headers['Content-Type'] = options.contentType || 'application/x-www-form-urlencoded';\n        }\n\n        if (typeof options.body.pipe === 'function') {\n            // it's a stream\n            headers['Transfer-Encoding'] = 'chunked';\n            body = options.body;\n            body.on('error', err => {\n                if (finished) {\n                    return;\n                }\n                finished = true;\n                err.type = 'FETCH';\n                err.sourceUrl = url;\n                fetchRes.emit('error', err);\n            });\n        } else {\n            if (options.body instanceof Buffer) {\n                body = options.body;\n            } else if (typeof options.body === 'object') {\n                body = new Buffer(Object.keys(options.body).map(key => {\n                    let value = options.body[key].toString().trim();\n                    return encodeURIComponent(key) + '=' + encodeURIComponent(value);\n                }).join('&'));\n            } else {\n                body = new Buffer(options.body.toString().trim());\n            }\n\n            headers['Content-Type'] = options.contentType || 'application/x-www-form-urlencoded';\n            headers['Content-Length'] = body.length;\n        }\n        // if method is not provided, use POST instead of GET\n        method = (options.method || '').toString().trim().toUpperCase() || 'POST';\n    }\n\n    let req;\n    let reqOptions = {\n        method,\n        host: parsed.hostname,\n        path: parsed.path,\n        port: parsed.port ? parsed.port : (parsed.protocol === 'https:' ? 443 : 80),\n        headers,\n        rejectUnauthorized: false,\n        agent: false\n    };\n\n    if (options.tls) {\n        Object.keys(options.tls).forEach(key => {\n            reqOptions[key] = options.tls[key];\n        });\n    }\n\n    try {\n        req = handler.request(reqOptions);\n    } catch (E) {\n        finished = true;\n        setImmediate(() => {\n            E.type = 'FETCH';\n            E.sourceUrl = url;\n            fetchRes.emit('error', E);\n        });\n        return fetchRes;\n    }\n\n    if (options.timeout) {\n        req.setTimeout(options.timeout, () => {\n            if (finished) {\n                return;\n            }\n            finished = true;\n            req.abort();\n            let err = new Error('Request Timeout');\n            err.type = 'FETCH';\n            err.sourceUrl = url;\n            fetchRes.emit('error', err);\n        });\n    }\n\n    req.on('error', err => {\n        if (finished) {\n            return;\n        }\n        finished = true;\n        err.type = 'FETCH';\n        err.sourceUrl = url;\n        fetchRes.emit('error', err);\n    });\n\n    req.on('response', res => {\n        let inflate;\n\n        if (finished) {\n            return;\n        }\n\n        switch (res.headers['content-encoding']) {\n            case 'gzip':\n            case 'deflate':\n                inflate = zlib.createUnzip();\n                break;\n        }\n\n        if (res.headers['set-cookie']) {\n            [].concat(res.headers['set-cookie'] || []).forEach(cookie => {\n                options.cookies.set(cookie, url);\n            });\n        }\n\n        if ([301, 302, 303, 307, 308].includes(res.statusCode) && res.headers.location) {\n            // redirect\n            options.redirects++;\n            if (options.redirects > options.maxRedirects) {\n                finished = true;\n                let err = new Error('Maximum redirect count exceeded');\n                err.type = 'FETCH';\n                err.sourceUrl = url;\n                fetchRes.emit('error', err);\n                req.abort();\n                return;\n            }\n            return fetch(urllib.resolve(url, res.headers.location), options);\n        }\n\n        fetchRes.statusCode = res.statusCode;\n\n        if (res.statusCode >= 300 && !options.allowErrorResponse) {\n            finished = true;\n            let err = new Error('Invalid status code ' + res.statusCode);\n            err.type = 'FETCH';\n            err.sourceUrl = url;\n            fetchRes.emit('error', err);\n            req.abort();\n            return;\n        }\n\n        res.on('error', err => {\n            if (finished) {\n                return;\n            }\n            finished = true;\n            err.type = 'FETCH';\n            err.sourceUrl = url;\n            fetchRes.emit('error', err);\n            req.abort();\n        });\n\n        if (inflate) {\n            res.pipe(inflate).pipe(fetchRes);\n            inflate.on('error', err => {\n                if (finished) {\n                    return;\n                }\n                finished = true;\n                err.type = 'FETCH';\n                err.sourceUrl = url;\n                fetchRes.emit('error', err);\n                req.abort();\n            });\n        } else {\n            res.pipe(fetchRes);\n        }\n    });\n\n    setImmediate(() => {\n        if (body) {\n            try {\n                if (typeof body.pipe === 'function') {\n                    return body.pipe(req);\n                } else {\n                    req.write(body);\n                }\n            } catch (err) {\n                finished = true;\n                err.type = 'FETCH';\n                err.sourceUrl = url;\n                fetchRes.emit('error', err);\n                return;\n            }\n        }\n        req.end();\n    });\n\n    return fetchRes;\n}\n"]},"metadata":{},"sourceType":"script"}