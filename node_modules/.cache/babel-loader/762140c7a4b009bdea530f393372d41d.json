{"ast":null,"code":"'use strict';\n\nconst stream = require('stream');\n\nconst Transform = stream.Transform;\n/**\n * Escapes dots in the beginning of lines. Ends the stream with <CR><LF>.<CR><LF>\n * Also makes sure that only <CR><LF> sequences are used for linebreaks\n *\n * @param {Object} options Stream options\n */\n\nclass DataStream extends Transform {\n  constructor(options) {\n    super(options); // init Transform\n\n    this.options = options || {};\n    this._curLine = '';\n    this.inByteCount = 0;\n    this.outByteCount = 0;\n    this.lastByte = false;\n  }\n  /**\n   * Escapes dots\n   */\n\n\n  _transform(chunk, encoding, done) {\n    let chunks = [];\n    let chunklen = 0;\n    let i,\n        len,\n        lastPos = 0;\n    let buf;\n\n    if (!chunk || !chunk.length) {\n      return done();\n    }\n\n    if (typeof chunk === 'string') {\n      chunk = new Buffer(chunk);\n    }\n\n    this.inByteCount += chunk.length;\n\n    for (i = 0, len = chunk.length; i < len; i++) {\n      if (chunk[i] === 0x2E) {\n        // .\n        if (i && chunk[i - 1] === 0x0A || !i && (!this.lastByte || this.lastByte === 0x0A)) {\n          buf = chunk.slice(lastPos, i + 1);\n          chunks.push(buf);\n          chunks.push(new Buffer('.'));\n          chunklen += buf.length + 1;\n          lastPos = i + 1;\n        }\n      } else if (chunk[i] === 0x0A) {\n        // .\n        if (i && chunk[i - 1] !== 0x0D || !i && this.lastByte !== 0x0D) {\n          if (i > lastPos) {\n            buf = chunk.slice(lastPos, i);\n            chunks.push(buf);\n            chunklen += buf.length + 2;\n          } else {\n            chunklen += 2;\n          }\n\n          chunks.push(new Buffer('\\r\\n'));\n          lastPos = i + 1;\n        }\n      }\n    }\n\n    if (chunklen) {\n      // add last piece\n      if (lastPos < chunk.length) {\n        buf = chunk.slice(lastPos);\n        chunks.push(buf);\n        chunklen += buf.length;\n      }\n\n      this.outByteCount += chunklen;\n      this.push(Buffer.concat(chunks, chunklen));\n    } else {\n      this.outByteCount += chunk.length;\n      this.push(chunk);\n    }\n\n    this.lastByte = chunk[chunk.length - 1];\n    done();\n  }\n  /**\n   * Finalizes the stream with a dot on a single line\n   */\n\n\n  _flush(done) {\n    let buf;\n\n    if (this.lastByte === 0x0A) {\n      buf = new Buffer('.\\r\\n');\n    } else if (this.lastByte === 0x0D) {\n      buf = new Buffer('\\n.\\r\\n');\n    } else {\n      buf = new Buffer('\\r\\n.\\r\\n');\n    }\n\n    this.outByteCount += buf.length;\n    this.push(buf);\n    done();\n  }\n\n}\n\nmodule.exports = DataStream;","map":{"version":3,"sources":["/Users/theodaguier/e-do/node_modules/smtp-connection/node_modules/nodemailer/lib/smtp-connection/data-stream.js"],"names":["stream","require","Transform","DataStream","constructor","options","_curLine","inByteCount","outByteCount","lastByte","_transform","chunk","encoding","done","chunks","chunklen","i","len","lastPos","buf","length","Buffer","slice","push","concat","_flush","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst stream = require('stream');\nconst Transform = stream.Transform;\n\n/**\n * Escapes dots in the beginning of lines. Ends the stream with <CR><LF>.<CR><LF>\n * Also makes sure that only <CR><LF> sequences are used for linebreaks\n *\n * @param {Object} options Stream options\n */\nclass DataStream extends Transform {\n\n    constructor(options) {\n        super(options);\n        // init Transform\n        this.options = options || {};\n        this._curLine = '';\n\n        this.inByteCount = 0;\n        this.outByteCount = 0;\n        this.lastByte = false;\n\n    }\n\n    /**\n     * Escapes dots\n     */\n    _transform(chunk, encoding, done) {\n        let chunks = [];\n        let chunklen = 0;\n        let i, len, lastPos = 0;\n        let buf;\n\n        if (!chunk || !chunk.length) {\n            return done();\n        }\n\n        if (typeof chunk === 'string') {\n            chunk = new Buffer(chunk);\n        }\n\n        this.inByteCount += chunk.length;\n\n        for (i = 0, len = chunk.length; i < len; i++) {\n            if (chunk[i] === 0x2E) { // .\n                if (\n                    (i && chunk[i - 1] === 0x0A) ||\n                    (!i && (!this.lastByte || this.lastByte === 0x0A))\n                ) {\n                    buf = chunk.slice(lastPos, i + 1);\n                    chunks.push(buf);\n                    chunks.push(new Buffer('.'));\n                    chunklen += buf.length + 1;\n                    lastPos = i + 1;\n                }\n            } else if (chunk[i] === 0x0A) { // .\n                if (\n                    (i && chunk[i - 1] !== 0x0D) ||\n                    (!i && this.lastByte !== 0x0D)\n                ) {\n                    if (i > lastPos) {\n                        buf = chunk.slice(lastPos, i);\n                        chunks.push(buf);\n                        chunklen += buf.length + 2;\n                    } else {\n                        chunklen += 2;\n                    }\n                    chunks.push(new Buffer('\\r\\n'));\n                    lastPos = i + 1;\n                }\n            }\n        }\n\n        if (chunklen) {\n            // add last piece\n            if (lastPos < chunk.length) {\n                buf = chunk.slice(lastPos);\n                chunks.push(buf);\n                chunklen += buf.length;\n            }\n\n            this.outByteCount += chunklen;\n            this.push(Buffer.concat(chunks, chunklen));\n        } else {\n            this.outByteCount += chunk.length;\n            this.push(chunk);\n        }\n\n        this.lastByte = chunk[chunk.length - 1];\n        done();\n    }\n\n    /**\n     * Finalizes the stream with a dot on a single line\n     */\n    _flush(done) {\n        let buf;\n        if (this.lastByte === 0x0A) {\n            buf = new Buffer('.\\r\\n');\n        } else if (this.lastByte === 0x0D) {\n            buf = new Buffer('\\n.\\r\\n');\n        } else {\n            buf = new Buffer('\\r\\n.\\r\\n');\n        }\n        this.outByteCount += buf.length;\n        this.push(buf);\n        done();\n    }\n\n}\n\nmodule.exports = DataStream;\n"]},"metadata":{},"sourceType":"script"}