{"ast":null,"code":"var __defProp = Object.defineProperty;\n\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\n\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n\n  return value;\n};\n\nimport { Mesh, Vector4, Color, Vector2, Matrix4, Clock, ShaderMaterial, UniformsUtils, UniformsLib, RepeatWrapping } from \"three\";\nimport { Reflector } from \"./Reflector.js\";\nimport { Refractor } from \"./Refractor.js\";\n\nconst _Water2 = class extends Mesh {\n  constructor(geometry, options = {}) {\n    super(geometry);\n    this.isWater = true;\n    this.type = \"Water\";\n    const scope = this;\n    const color = options.color !== void 0 ? new Color(options.color) : new Color(16777215);\n    const textureWidth = options.textureWidth || 512;\n    const textureHeight = options.textureHeight || 512;\n    const clipBias = options.clipBias || 0;\n    const flowDirection = options.flowDirection || new Vector2(1, 0);\n    const flowSpeed = options.flowSpeed || 0.03;\n    const reflectivity = options.reflectivity || 0.02;\n    const scale = options.scale || 1;\n    const shader = options.shader || _Water2.WaterShader;\n    const encoding = options.encoding !== void 0 ? options.encoding : 3e3;\n    const flowMap = options.flowMap || void 0;\n    const normalMap0 = options.normalMap0;\n    const normalMap1 = options.normalMap1;\n    const cycle = 0.15;\n    const halfCycle = cycle * 0.5;\n    const textureMatrix = new Matrix4();\n    const clock = new Clock();\n\n    if (Reflector === void 0) {\n      console.error(\"THREE.Water: Required component Reflector not found.\");\n      return;\n    }\n\n    if (Refractor === void 0) {\n      console.error(\"THREE.Water: Required component Refractor not found.\");\n      return;\n    }\n\n    const reflector = new Reflector(geometry, {\n      textureWidth,\n      textureHeight,\n      clipBias,\n      encoding\n    });\n    const refractor = new Refractor(geometry, {\n      textureWidth,\n      textureHeight,\n      clipBias,\n      encoding\n    });\n    reflector.matrixAutoUpdate = false;\n    refractor.matrixAutoUpdate = false;\n    this.material = new ShaderMaterial({\n      uniforms: UniformsUtils.merge([UniformsLib[\"fog\"], shader.uniforms]),\n      vertexShader: shader.vertexShader,\n      fragmentShader: shader.fragmentShader,\n      transparent: true,\n      fog: true\n    });\n\n    if (flowMap !== void 0) {\n      this.material.defines.USE_FLOWMAP = \"\";\n      this.material.uniforms[\"tFlowMap\"] = {\n        type: \"t\",\n        value: flowMap\n      };\n    } else {\n      this.material.uniforms[\"flowDirection\"] = {\n        type: \"v2\",\n        value: flowDirection\n      };\n    }\n\n    normalMap0.wrapS = normalMap0.wrapT = RepeatWrapping;\n    normalMap1.wrapS = normalMap1.wrapT = RepeatWrapping;\n    this.material.uniforms[\"tReflectionMap\"].value = reflector.getRenderTarget().texture;\n    this.material.uniforms[\"tRefractionMap\"].value = refractor.getRenderTarget().texture;\n    this.material.uniforms[\"tNormalMap0\"].value = normalMap0;\n    this.material.uniforms[\"tNormalMap1\"].value = normalMap1;\n    this.material.uniforms[\"color\"].value = color;\n    this.material.uniforms[\"reflectivity\"].value = reflectivity;\n    this.material.uniforms[\"textureMatrix\"].value = textureMatrix;\n    this.material.uniforms[\"config\"].value.x = 0;\n    this.material.uniforms[\"config\"].value.y = halfCycle;\n    this.material.uniforms[\"config\"].value.z = halfCycle;\n    this.material.uniforms[\"config\"].value.w = scale;\n\n    function updateTextureMatrix(camera) {\n      textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);\n      textureMatrix.multiply(camera.projectionMatrix);\n      textureMatrix.multiply(camera.matrixWorldInverse);\n      textureMatrix.multiply(scope.matrixWorld);\n    }\n\n    function updateFlow() {\n      const delta = clock.getDelta();\n      const config = scope.material.uniforms[\"config\"];\n      config.value.x += flowSpeed * delta;\n      config.value.y = config.value.x + halfCycle;\n\n      if (config.value.x >= cycle) {\n        config.value.x = 0;\n        config.value.y = halfCycle;\n      } else if (config.value.y >= cycle) {\n        config.value.y = config.value.y - cycle;\n      }\n    }\n\n    this.onBeforeRender = function (renderer, scene, camera) {\n      updateTextureMatrix(camera);\n      updateFlow();\n      scope.visible = false;\n      reflector.matrixWorld.copy(scope.matrixWorld);\n      refractor.matrixWorld.copy(scope.matrixWorld);\n      reflector.onBeforeRender(renderer, scene, camera);\n      refractor.onBeforeRender(renderer, scene, camera);\n      scope.visible = true;\n    };\n  }\n\n};\n\nlet Water2 = _Water2;\n\n__publicField(Water2, \"WaterShader\", {\n  uniforms: {\n    color: {\n      value: null\n    },\n    reflectivity: {\n      value: 0\n    },\n    tReflectionMap: {\n      value: null\n    },\n    tRefractionMap: {\n      value: null\n    },\n    tNormalMap0: {\n      value: null\n    },\n    tNormalMap1: {\n      value: null\n    },\n    textureMatrix: {\n      value: null\n    },\n    config: {\n      value: /* @__PURE__ */new Vector4()\n    }\n  },\n  vertexShader:\n  /* glsl */\n  `\n\n\t\t#include <common>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\n\t\tuniform mat4 textureMatrix;\n\n\t\tvarying vec4 vCoord;\n\t\tvarying vec2 vUv;\n\t\tvarying vec3 vToEye;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tvCoord = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\t\t\tvToEye = cameraPosition - worldPosition.xyz;\n\n\t\t\tvec4 mvPosition =  viewMatrix * worldPosition; // used in fog_vertex\n\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}`,\n  fragmentShader:\n  /* glsl */\n  `\n\n\t\t#include <common>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\n\t\tuniform sampler2D tReflectionMap;\n\t\tuniform sampler2D tRefractionMap;\n\t\tuniform sampler2D tNormalMap0;\n\t\tuniform sampler2D tNormalMap1;\n\n\t\t#ifdef USE_FLOWMAP\n\t\t\tuniform sampler2D tFlowMap;\n\t\t#else\n\t\t\tuniform vec2 flowDirection;\n\t\t#endif\n\n\t\tuniform vec3 color;\n\t\tuniform float reflectivity;\n\t\tuniform vec4 config;\n\n\t\tvarying vec4 vCoord;\n\t\tvarying vec2 vUv;\n\t\tvarying vec3 vToEye;\n\n\t\tvoid main() {\n\n\t\t\t#include <logdepthbuf_fragment>\n\n\t\t\tfloat flowMapOffset0 = config.x;\n\t\t\tfloat flowMapOffset1 = config.y;\n\t\t\tfloat halfCycle = config.z;\n\t\t\tfloat scale = config.w;\n\n\t\t\tvec3 toEye = normalize( vToEye );\n\n\t\t\t// determine flow direction\n\t\t\tvec2 flow;\n\t\t\t#ifdef USE_FLOWMAP\n\t\t\t\tflow = texture2D( tFlowMap, vUv ).rg * 2.0 - 1.0;\n\t\t\t#else\n\t\t\t\tflow = flowDirection;\n\t\t\t#endif\n\t\t\tflow.x *= - 1.0;\n\n\t\t\t// sample normal maps (distort uvs with flowdata)\n\t\t\tvec4 normalColor0 = texture2D( tNormalMap0, ( vUv * scale ) + flow * flowMapOffset0 );\n\t\t\tvec4 normalColor1 = texture2D( tNormalMap1, ( vUv * scale ) + flow * flowMapOffset1 );\n\n\t\t\t// linear interpolate to get the final normal color\n\t\t\tfloat flowLerp = abs( halfCycle - flowMapOffset0 ) / halfCycle;\n\t\t\tvec4 normalColor = mix( normalColor0, normalColor1, flowLerp );\n\n\t\t\t// calculate normal vector\n\t\t\tvec3 normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );\n\n\t\t\t// calculate the fresnel term to blend reflection and refraction maps\n\t\t\tfloat theta = max( dot( toEye, normal ), 0.0 );\n\t\t\tfloat reflectance = reflectivity + ( 1.0 - reflectivity ) * pow( ( 1.0 - theta ), 5.0 );\n\n\t\t\t// calculate final uv coords\n\t\t\tvec3 coord = vCoord.xyz / vCoord.w;\n\t\t\tvec2 uv = coord.xy + coord.z * normal.xz * 0.05;\n\n\t\t\tvec4 reflectColor = texture2D( tReflectionMap, vec2( 1.0 - uv.x, uv.y ) );\n\t\t\tvec4 refractColor = texture2D( tRefractionMap, uv );\n\n\t\t\t// multiply water color with the mix of both textures\n\t\t\tgl_FragColor = vec4( color, 1.0 ) * mix( refractColor, reflectColor, reflectance );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\t\t\t#include <fog_fragment>\n\n\t\t}`\n});\n\nexport { Water2 };","map":{"version":3,"sources":["/Users/theodaguier/Developer/old/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/three-stdlib/objects/Water2.js"],"names":["__defProp","Object","defineProperty","__defNormalProp","obj","key","value","enumerable","configurable","writable","__publicField","Mesh","Vector4","Color","Vector2","Matrix4","Clock","ShaderMaterial","UniformsUtils","UniformsLib","RepeatWrapping","Reflector","Refractor","_Water2","constructor","geometry","options","isWater","type","scope","color","textureWidth","textureHeight","clipBias","flowDirection","flowSpeed","reflectivity","scale","shader","WaterShader","encoding","flowMap","normalMap0","normalMap1","cycle","halfCycle","textureMatrix","clock","console","error","reflector","refractor","matrixAutoUpdate","material","uniforms","merge","vertexShader","fragmentShader","transparent","fog","defines","USE_FLOWMAP","wrapS","wrapT","getRenderTarget","texture","x","y","z","w","updateTextureMatrix","camera","set","multiply","projectionMatrix","matrixWorldInverse","matrixWorld","updateFlow","delta","getDelta","config","onBeforeRender","renderer","scene","visible","copy","Water2","tReflectionMap","tRefractionMap","tNormalMap0","tNormalMap1"],"mappings":"AAAA,IAAIA,SAAS,GAAGC,MAAM,CAACC,cAAvB;;AACA,IAAIC,eAAe,GAAG,CAACC,GAAD,EAAMC,GAAN,EAAWC,KAAX,KAAqBD,GAAG,IAAID,GAAP,GAAaJ,SAAS,CAACI,GAAD,EAAMC,GAAN,EAAW;AAAEE,EAAAA,UAAU,EAAE,IAAd;AAAoBC,EAAAA,YAAY,EAAE,IAAlC;AAAwCC,EAAAA,QAAQ,EAAE,IAAlD;AAAwDH,EAAAA;AAAxD,CAAX,CAAtB,GAAoGF,GAAG,CAACC,GAAD,CAAH,GAAWC,KAA1J;;AACA,IAAII,aAAa,GAAG,CAACN,GAAD,EAAMC,GAAN,EAAWC,KAAX,KAAqB;AACvCH,EAAAA,eAAe,CAACC,GAAD,EAAM,OAAOC,GAAP,KAAe,QAAf,GAA0BA,GAAG,GAAG,EAAhC,GAAqCA,GAA3C,EAAgDC,KAAhD,CAAf;;AACA,SAAOA,KAAP;AACD,CAHD;;AAIA,SAASK,IAAT,EAAeC,OAAf,EAAwBC,KAAxB,EAA+BC,OAA/B,EAAwCC,OAAxC,EAAiDC,KAAjD,EAAwDC,cAAxD,EAAwEC,aAAxE,EAAuFC,WAAvF,EAAoGC,cAApG,QAA0H,OAA1H;AACA,SAASC,SAAT,QAA0B,gBAA1B;AACA,SAASC,SAAT,QAA0B,gBAA1B;;AACA,MAAMC,OAAO,GAAG,cAAcZ,IAAd,CAAmB;AACjCa,EAAAA,WAAW,CAACC,QAAD,EAAWC,OAAO,GAAG,EAArB,EAAyB;AAClC,UAAMD,QAAN;AACA,SAAKE,OAAL,GAAe,IAAf;AACA,SAAKC,IAAL,GAAY,OAAZ;AACA,UAAMC,KAAK,GAAG,IAAd;AACA,UAAMC,KAAK,GAAGJ,OAAO,CAACI,KAAR,KAAkB,KAAK,CAAvB,GAA2B,IAAIjB,KAAJ,CAAUa,OAAO,CAACI,KAAlB,CAA3B,GAAsD,IAAIjB,KAAJ,CAAU,QAAV,CAApE;AACA,UAAMkB,YAAY,GAAGL,OAAO,CAACK,YAAR,IAAwB,GAA7C;AACA,UAAMC,aAAa,GAAGN,OAAO,CAACM,aAAR,IAAyB,GAA/C;AACA,UAAMC,QAAQ,GAAGP,OAAO,CAACO,QAAR,IAAoB,CAArC;AACA,UAAMC,aAAa,GAAGR,OAAO,CAACQ,aAAR,IAAyB,IAAIpB,OAAJ,CAAY,CAAZ,EAAe,CAAf,CAA/C;AACA,UAAMqB,SAAS,GAAGT,OAAO,CAACS,SAAR,IAAqB,IAAvC;AACA,UAAMC,YAAY,GAAGV,OAAO,CAACU,YAAR,IAAwB,IAA7C;AACA,UAAMC,KAAK,GAAGX,OAAO,CAACW,KAAR,IAAiB,CAA/B;AACA,UAAMC,MAAM,GAAGZ,OAAO,CAACY,MAAR,IAAkBf,OAAO,CAACgB,WAAzC;AACA,UAAMC,QAAQ,GAAGd,OAAO,CAACc,QAAR,KAAqB,KAAK,CAA1B,GAA8Bd,OAAO,CAACc,QAAtC,GAAiD,GAAlE;AACA,UAAMC,OAAO,GAAGf,OAAO,CAACe,OAAR,IAAmB,KAAK,CAAxC;AACA,UAAMC,UAAU,GAAGhB,OAAO,CAACgB,UAA3B;AACA,UAAMC,UAAU,GAAGjB,OAAO,CAACiB,UAA3B;AACA,UAAMC,KAAK,GAAG,IAAd;AACA,UAAMC,SAAS,GAAGD,KAAK,GAAG,GAA1B;AACA,UAAME,aAAa,GAAG,IAAI/B,OAAJ,EAAtB;AACA,UAAMgC,KAAK,GAAG,IAAI/B,KAAJ,EAAd;;AACA,QAAIK,SAAS,KAAK,KAAK,CAAvB,EAA0B;AACxB2B,MAAAA,OAAO,CAACC,KAAR,CAAc,sDAAd;AACA;AACD;;AACD,QAAI3B,SAAS,KAAK,KAAK,CAAvB,EAA0B;AACxB0B,MAAAA,OAAO,CAACC,KAAR,CAAc,sDAAd;AACA;AACD;;AACD,UAAMC,SAAS,GAAG,IAAI7B,SAAJ,CAAcI,QAAd,EAAwB;AACxCM,MAAAA,YADwC;AAExCC,MAAAA,aAFwC;AAGxCC,MAAAA,QAHwC;AAIxCO,MAAAA;AAJwC,KAAxB,CAAlB;AAMA,UAAMW,SAAS,GAAG,IAAI7B,SAAJ,CAAcG,QAAd,EAAwB;AACxCM,MAAAA,YADwC;AAExCC,MAAAA,aAFwC;AAGxCC,MAAAA,QAHwC;AAIxCO,MAAAA;AAJwC,KAAxB,CAAlB;AAMAU,IAAAA,SAAS,CAACE,gBAAV,GAA6B,KAA7B;AACAD,IAAAA,SAAS,CAACC,gBAAV,GAA6B,KAA7B;AACA,SAAKC,QAAL,GAAgB,IAAIpC,cAAJ,CAAmB;AACjCqC,MAAAA,QAAQ,EAAEpC,aAAa,CAACqC,KAAd,CAAoB,CAACpC,WAAW,CAAC,KAAD,CAAZ,EAAqBmB,MAAM,CAACgB,QAA5B,CAApB,CADuB;AAEjCE,MAAAA,YAAY,EAAElB,MAAM,CAACkB,YAFY;AAGjCC,MAAAA,cAAc,EAAEnB,MAAM,CAACmB,cAHU;AAIjCC,MAAAA,WAAW,EAAE,IAJoB;AAKjCC,MAAAA,GAAG,EAAE;AAL4B,KAAnB,CAAhB;;AAOA,QAAIlB,OAAO,KAAK,KAAK,CAArB,EAAwB;AACtB,WAAKY,QAAL,CAAcO,OAAd,CAAsBC,WAAtB,GAAoC,EAApC;AACA,WAAKR,QAAL,CAAcC,QAAd,CAAuB,UAAvB,IAAqC;AACnC1B,QAAAA,IAAI,EAAE,GAD6B;AAEnCtB,QAAAA,KAAK,EAAEmC;AAF4B,OAArC;AAID,KAND,MAMO;AACL,WAAKY,QAAL,CAAcC,QAAd,CAAuB,eAAvB,IAA0C;AACxC1B,QAAAA,IAAI,EAAE,IADkC;AAExCtB,QAAAA,KAAK,EAAE4B;AAFiC,OAA1C;AAID;;AACDQ,IAAAA,UAAU,CAACoB,KAAX,GAAmBpB,UAAU,CAACqB,KAAX,GAAmB3C,cAAtC;AACAuB,IAAAA,UAAU,CAACmB,KAAX,GAAmBnB,UAAU,CAACoB,KAAX,GAAmB3C,cAAtC;AACA,SAAKiC,QAAL,CAAcC,QAAd,CAAuB,gBAAvB,EAAyChD,KAAzC,GAAiD4C,SAAS,CAACc,eAAV,GAA4BC,OAA7E;AACA,SAAKZ,QAAL,CAAcC,QAAd,CAAuB,gBAAvB,EAAyChD,KAAzC,GAAiD6C,SAAS,CAACa,eAAV,GAA4BC,OAA7E;AACA,SAAKZ,QAAL,CAAcC,QAAd,CAAuB,aAAvB,EAAsChD,KAAtC,GAA8CoC,UAA9C;AACA,SAAKW,QAAL,CAAcC,QAAd,CAAuB,aAAvB,EAAsChD,KAAtC,GAA8CqC,UAA9C;AACA,SAAKU,QAAL,CAAcC,QAAd,CAAuB,OAAvB,EAAgChD,KAAhC,GAAwCwB,KAAxC;AACA,SAAKuB,QAAL,CAAcC,QAAd,CAAuB,cAAvB,EAAuChD,KAAvC,GAA+C8B,YAA/C;AACA,SAAKiB,QAAL,CAAcC,QAAd,CAAuB,eAAvB,EAAwChD,KAAxC,GAAgDwC,aAAhD;AACA,SAAKO,QAAL,CAAcC,QAAd,CAAuB,QAAvB,EAAiChD,KAAjC,CAAuC4D,CAAvC,GAA2C,CAA3C;AACA,SAAKb,QAAL,CAAcC,QAAd,CAAuB,QAAvB,EAAiChD,KAAjC,CAAuC6D,CAAvC,GAA2CtB,SAA3C;AACA,SAAKQ,QAAL,CAAcC,QAAd,CAAuB,QAAvB,EAAiChD,KAAjC,CAAuC8D,CAAvC,GAA2CvB,SAA3C;AACA,SAAKQ,QAAL,CAAcC,QAAd,CAAuB,QAAvB,EAAiChD,KAAjC,CAAuC+D,CAAvC,GAA2ChC,KAA3C;;AACA,aAASiC,mBAAT,CAA6BC,MAA7B,EAAqC;AACnCzB,MAAAA,aAAa,CAAC0B,GAAd,CAAkB,GAAlB,EAAuB,CAAvB,EAA0B,CAA1B,EAA6B,GAA7B,EAAkC,CAAlC,EAAqC,GAArC,EAA0C,CAA1C,EAA6C,GAA7C,EAAkD,CAAlD,EAAqD,CAArD,EAAwD,GAAxD,EAA6D,GAA7D,EAAkE,CAAlE,EAAqE,CAArE,EAAwE,CAAxE,EAA2E,CAA3E;AACA1B,MAAAA,aAAa,CAAC2B,QAAd,CAAuBF,MAAM,CAACG,gBAA9B;AACA5B,MAAAA,aAAa,CAAC2B,QAAd,CAAuBF,MAAM,CAACI,kBAA9B;AACA7B,MAAAA,aAAa,CAAC2B,QAAd,CAAuB5C,KAAK,CAAC+C,WAA7B;AACD;;AACD,aAASC,UAAT,GAAsB;AACpB,YAAMC,KAAK,GAAG/B,KAAK,CAACgC,QAAN,EAAd;AACA,YAAMC,MAAM,GAAGnD,KAAK,CAACwB,QAAN,CAAeC,QAAf,CAAwB,QAAxB,CAAf;AACA0B,MAAAA,MAAM,CAAC1E,KAAP,CAAa4D,CAAb,IAAkB/B,SAAS,GAAG2C,KAA9B;AACAE,MAAAA,MAAM,CAAC1E,KAAP,CAAa6D,CAAb,GAAiBa,MAAM,CAAC1E,KAAP,CAAa4D,CAAb,GAAiBrB,SAAlC;;AACA,UAAImC,MAAM,CAAC1E,KAAP,CAAa4D,CAAb,IAAkBtB,KAAtB,EAA6B;AAC3BoC,QAAAA,MAAM,CAAC1E,KAAP,CAAa4D,CAAb,GAAiB,CAAjB;AACAc,QAAAA,MAAM,CAAC1E,KAAP,CAAa6D,CAAb,GAAiBtB,SAAjB;AACD,OAHD,MAGO,IAAImC,MAAM,CAAC1E,KAAP,CAAa6D,CAAb,IAAkBvB,KAAtB,EAA6B;AAClCoC,QAAAA,MAAM,CAAC1E,KAAP,CAAa6D,CAAb,GAAiBa,MAAM,CAAC1E,KAAP,CAAa6D,CAAb,GAAiBvB,KAAlC;AACD;AACF;;AACD,SAAKqC,cAAL,GAAsB,UAASC,QAAT,EAAmBC,KAAnB,EAA0BZ,MAA1B,EAAkC;AACtDD,MAAAA,mBAAmB,CAACC,MAAD,CAAnB;AACAM,MAAAA,UAAU;AACVhD,MAAAA,KAAK,CAACuD,OAAN,GAAgB,KAAhB;AACAlC,MAAAA,SAAS,CAAC0B,WAAV,CAAsBS,IAAtB,CAA2BxD,KAAK,CAAC+C,WAAjC;AACAzB,MAAAA,SAAS,CAACyB,WAAV,CAAsBS,IAAtB,CAA2BxD,KAAK,CAAC+C,WAAjC;AACA1B,MAAAA,SAAS,CAAC+B,cAAV,CAAyBC,QAAzB,EAAmCC,KAAnC,EAA0CZ,MAA1C;AACApB,MAAAA,SAAS,CAAC8B,cAAV,CAAyBC,QAAzB,EAAmCC,KAAnC,EAA0CZ,MAA1C;AACA1C,MAAAA,KAAK,CAACuD,OAAN,GAAgB,IAAhB;AACD,KATD;AAUD;;AAzGgC,CAAnC;;AA2GA,IAAIE,MAAM,GAAG/D,OAAb;;AACAb,aAAa,CAAC4E,MAAD,EAAS,aAAT,EAAwB;AACnChC,EAAAA,QAAQ,EAAE;AACRxB,IAAAA,KAAK,EAAE;AACLxB,MAAAA,KAAK,EAAE;AADF,KADC;AAIR8B,IAAAA,YAAY,EAAE;AACZ9B,MAAAA,KAAK,EAAE;AADK,KAJN;AAORiF,IAAAA,cAAc,EAAE;AACdjF,MAAAA,KAAK,EAAE;AADO,KAPR;AAURkF,IAAAA,cAAc,EAAE;AACdlF,MAAAA,KAAK,EAAE;AADO,KAVR;AAaRmF,IAAAA,WAAW,EAAE;AACXnF,MAAAA,KAAK,EAAE;AADI,KAbL;AAgBRoF,IAAAA,WAAW,EAAE;AACXpF,MAAAA,KAAK,EAAE;AADI,KAhBL;AAmBRwC,IAAAA,aAAa,EAAE;AACbxC,MAAAA,KAAK,EAAE;AADM,KAnBP;AAsBR0E,IAAAA,MAAM,EAAE;AACN1E,MAAAA,KAAK,EAAE,eAAgB,IAAIM,OAAJ;AADjB;AAtBA,GADyB;AA2BnC4C,EAAAA,YAAY;AACV;AACC;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAvDqC;AAyDnCC,EAAAA,cAAc;AACZ;AACC;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AArIqC,CAAxB,CAAb;;AAwIA,SACE6B,MADF","sourcesContent":["var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Mesh, Vector4, Color, Vector2, Matrix4, Clock, ShaderMaterial, UniformsUtils, UniformsLib, RepeatWrapping } from \"three\";\nimport { Reflector } from \"./Reflector.js\";\nimport { Refractor } from \"./Refractor.js\";\nconst _Water2 = class extends Mesh {\n  constructor(geometry, options = {}) {\n    super(geometry);\n    this.isWater = true;\n    this.type = \"Water\";\n    const scope = this;\n    const color = options.color !== void 0 ? new Color(options.color) : new Color(16777215);\n    const textureWidth = options.textureWidth || 512;\n    const textureHeight = options.textureHeight || 512;\n    const clipBias = options.clipBias || 0;\n    const flowDirection = options.flowDirection || new Vector2(1, 0);\n    const flowSpeed = options.flowSpeed || 0.03;\n    const reflectivity = options.reflectivity || 0.02;\n    const scale = options.scale || 1;\n    const shader = options.shader || _Water2.WaterShader;\n    const encoding = options.encoding !== void 0 ? options.encoding : 3e3;\n    const flowMap = options.flowMap || void 0;\n    const normalMap0 = options.normalMap0;\n    const normalMap1 = options.normalMap1;\n    const cycle = 0.15;\n    const halfCycle = cycle * 0.5;\n    const textureMatrix = new Matrix4();\n    const clock = new Clock();\n    if (Reflector === void 0) {\n      console.error(\"THREE.Water: Required component Reflector not found.\");\n      return;\n    }\n    if (Refractor === void 0) {\n      console.error(\"THREE.Water: Required component Refractor not found.\");\n      return;\n    }\n    const reflector = new Reflector(geometry, {\n      textureWidth,\n      textureHeight,\n      clipBias,\n      encoding\n    });\n    const refractor = new Refractor(geometry, {\n      textureWidth,\n      textureHeight,\n      clipBias,\n      encoding\n    });\n    reflector.matrixAutoUpdate = false;\n    refractor.matrixAutoUpdate = false;\n    this.material = new ShaderMaterial({\n      uniforms: UniformsUtils.merge([UniformsLib[\"fog\"], shader.uniforms]),\n      vertexShader: shader.vertexShader,\n      fragmentShader: shader.fragmentShader,\n      transparent: true,\n      fog: true\n    });\n    if (flowMap !== void 0) {\n      this.material.defines.USE_FLOWMAP = \"\";\n      this.material.uniforms[\"tFlowMap\"] = {\n        type: \"t\",\n        value: flowMap\n      };\n    } else {\n      this.material.uniforms[\"flowDirection\"] = {\n        type: \"v2\",\n        value: flowDirection\n      };\n    }\n    normalMap0.wrapS = normalMap0.wrapT = RepeatWrapping;\n    normalMap1.wrapS = normalMap1.wrapT = RepeatWrapping;\n    this.material.uniforms[\"tReflectionMap\"].value = reflector.getRenderTarget().texture;\n    this.material.uniforms[\"tRefractionMap\"].value = refractor.getRenderTarget().texture;\n    this.material.uniforms[\"tNormalMap0\"].value = normalMap0;\n    this.material.uniforms[\"tNormalMap1\"].value = normalMap1;\n    this.material.uniforms[\"color\"].value = color;\n    this.material.uniforms[\"reflectivity\"].value = reflectivity;\n    this.material.uniforms[\"textureMatrix\"].value = textureMatrix;\n    this.material.uniforms[\"config\"].value.x = 0;\n    this.material.uniforms[\"config\"].value.y = halfCycle;\n    this.material.uniforms[\"config\"].value.z = halfCycle;\n    this.material.uniforms[\"config\"].value.w = scale;\n    function updateTextureMatrix(camera) {\n      textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);\n      textureMatrix.multiply(camera.projectionMatrix);\n      textureMatrix.multiply(camera.matrixWorldInverse);\n      textureMatrix.multiply(scope.matrixWorld);\n    }\n    function updateFlow() {\n      const delta = clock.getDelta();\n      const config = scope.material.uniforms[\"config\"];\n      config.value.x += flowSpeed * delta;\n      config.value.y = config.value.x + halfCycle;\n      if (config.value.x >= cycle) {\n        config.value.x = 0;\n        config.value.y = halfCycle;\n      } else if (config.value.y >= cycle) {\n        config.value.y = config.value.y - cycle;\n      }\n    }\n    this.onBeforeRender = function(renderer, scene, camera) {\n      updateTextureMatrix(camera);\n      updateFlow();\n      scope.visible = false;\n      reflector.matrixWorld.copy(scope.matrixWorld);\n      refractor.matrixWorld.copy(scope.matrixWorld);\n      reflector.onBeforeRender(renderer, scene, camera);\n      refractor.onBeforeRender(renderer, scene, camera);\n      scope.visible = true;\n    };\n  }\n};\nlet Water2 = _Water2;\n__publicField(Water2, \"WaterShader\", {\n  uniforms: {\n    color: {\n      value: null\n    },\n    reflectivity: {\n      value: 0\n    },\n    tReflectionMap: {\n      value: null\n    },\n    tRefractionMap: {\n      value: null\n    },\n    tNormalMap0: {\n      value: null\n    },\n    tNormalMap1: {\n      value: null\n    },\n    textureMatrix: {\n      value: null\n    },\n    config: {\n      value: /* @__PURE__ */ new Vector4()\n    }\n  },\n  vertexShader: (\n    /* glsl */\n    `\n\n\t\t#include <common>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\n\t\tuniform mat4 textureMatrix;\n\n\t\tvarying vec4 vCoord;\n\t\tvarying vec2 vUv;\n\t\tvarying vec3 vToEye;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tvCoord = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\t\t\tvToEye = cameraPosition - worldPosition.xyz;\n\n\t\t\tvec4 mvPosition =  viewMatrix * worldPosition; // used in fog_vertex\n\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}`\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n\n\t\t#include <common>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\n\t\tuniform sampler2D tReflectionMap;\n\t\tuniform sampler2D tRefractionMap;\n\t\tuniform sampler2D tNormalMap0;\n\t\tuniform sampler2D tNormalMap1;\n\n\t\t#ifdef USE_FLOWMAP\n\t\t\tuniform sampler2D tFlowMap;\n\t\t#else\n\t\t\tuniform vec2 flowDirection;\n\t\t#endif\n\n\t\tuniform vec3 color;\n\t\tuniform float reflectivity;\n\t\tuniform vec4 config;\n\n\t\tvarying vec4 vCoord;\n\t\tvarying vec2 vUv;\n\t\tvarying vec3 vToEye;\n\n\t\tvoid main() {\n\n\t\t\t#include <logdepthbuf_fragment>\n\n\t\t\tfloat flowMapOffset0 = config.x;\n\t\t\tfloat flowMapOffset1 = config.y;\n\t\t\tfloat halfCycle = config.z;\n\t\t\tfloat scale = config.w;\n\n\t\t\tvec3 toEye = normalize( vToEye );\n\n\t\t\t// determine flow direction\n\t\t\tvec2 flow;\n\t\t\t#ifdef USE_FLOWMAP\n\t\t\t\tflow = texture2D( tFlowMap, vUv ).rg * 2.0 - 1.0;\n\t\t\t#else\n\t\t\t\tflow = flowDirection;\n\t\t\t#endif\n\t\t\tflow.x *= - 1.0;\n\n\t\t\t// sample normal maps (distort uvs with flowdata)\n\t\t\tvec4 normalColor0 = texture2D( tNormalMap0, ( vUv * scale ) + flow * flowMapOffset0 );\n\t\t\tvec4 normalColor1 = texture2D( tNormalMap1, ( vUv * scale ) + flow * flowMapOffset1 );\n\n\t\t\t// linear interpolate to get the final normal color\n\t\t\tfloat flowLerp = abs( halfCycle - flowMapOffset0 ) / halfCycle;\n\t\t\tvec4 normalColor = mix( normalColor0, normalColor1, flowLerp );\n\n\t\t\t// calculate normal vector\n\t\t\tvec3 normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );\n\n\t\t\t// calculate the fresnel term to blend reflection and refraction maps\n\t\t\tfloat theta = max( dot( toEye, normal ), 0.0 );\n\t\t\tfloat reflectance = reflectivity + ( 1.0 - reflectivity ) * pow( ( 1.0 - theta ), 5.0 );\n\n\t\t\t// calculate final uv coords\n\t\t\tvec3 coord = vCoord.xyz / vCoord.w;\n\t\t\tvec2 uv = coord.xy + coord.z * normal.xz * 0.05;\n\n\t\t\tvec4 reflectColor = texture2D( tReflectionMap, vec2( 1.0 - uv.x, uv.y ) );\n\t\t\tvec4 refractColor = texture2D( tRefractionMap, uv );\n\n\t\t\t// multiply water color with the mix of both textures\n\t\t\tgl_FragColor = vec4( color, 1.0 ) * mix( refractColor, reflectColor, reflectance );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\t\t\t#include <fog_fragment>\n\n\t\t}`\n  )\n});\nexport {\n  Water2\n};\n"]},"metadata":{},"sourceType":"module"}