{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/theodaguier/Repositories/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"/Users/theodaguier/Repositories/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nvar __defProp = Object.defineProperty;\n\nvar __defNormalProp = function __defNormalProp(obj, key, value) {\n  return key in obj ? __defProp(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\n\nvar __publicField = function __publicField(obj, key, value) {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n\n  return value;\n};\n\nimport { Vector3, BufferAttribute, BufferGeometry } from \"three\";\nimport * as BufferGeometryUtils from \"../utils/BufferGeometryUtils.js\";\nimport { mergeVertices } from \"../utils/BufferGeometryUtils.js\";\n\nvar EdgeSplitModifier = function EdgeSplitModifier() {\n  var _this = this;\n\n  _classCallCheck(this, EdgeSplitModifier);\n\n  __publicField(this, \"A\", new Vector3());\n\n  __publicField(this, \"B\", new Vector3());\n\n  __publicField(this, \"C\", new Vector3());\n\n  __publicField(this, \"positions\", []);\n\n  __publicField(this, \"normals\", new Float32Array());\n\n  __publicField(this, \"indexes\", []);\n\n  __publicField(this, \"pointToIndexMap\", []);\n\n  __publicField(this, \"splitIndexes\", []);\n\n  __publicField(this, \"oldNormals\", []);\n\n  __publicField(this, \"computeNormals\", function () {\n    _this.normals = new Float32Array(_this.indexes.length * 3);\n\n    for (var i = 0; i < _this.indexes.length; i += 3) {\n      var index = _this.indexes[i];\n\n      _this.A.set(_this.positions[3 * index], _this.positions[3 * index + 1], _this.positions[3 * index + 2]);\n\n      index = _this.indexes[i + 1];\n\n      _this.B.set(_this.positions[3 * index], _this.positions[3 * index + 1], _this.positions[3 * index + 2]);\n\n      index = _this.indexes[i + 2];\n\n      _this.C.set(_this.positions[3 * index], _this.positions[3 * index + 1], _this.positions[3 * index + 2]);\n\n      _this.C.sub(_this.B);\n\n      _this.A.sub(_this.B);\n\n      var normal = _this.C.cross(_this.A).normalize();\n\n      for (var j = 0; j < 3; j++) {\n        _this.normals[3 * (i + j)] = normal.x;\n        _this.normals[3 * (i + j) + 1] = normal.y;\n        _this.normals[3 * (i + j) + 2] = normal.z;\n      }\n    }\n  });\n\n  __publicField(this, \"mapPositionsToIndexes\", function () {\n    _this.pointToIndexMap = Array(_this.positions.length / 3);\n\n    for (var i = 0; i < _this.indexes.length; i++) {\n      var index = _this.indexes[i];\n\n      if (_this.pointToIndexMap[index] == null) {\n        _this.pointToIndexMap[index] = [];\n      }\n\n      _this.pointToIndexMap[index].push(i);\n    }\n  });\n\n  __publicField(this, \"edgeSplitToGroups\", function (indexes, cutOff, firstIndex) {\n    _this.A.set(_this.normals[3 * firstIndex], _this.normals[3 * firstIndex + 1], _this.normals[3 * firstIndex + 2]).normalize();\n\n    var result = {\n      splitGroup: [],\n      currentGroup: [firstIndex]\n    };\n\n    var _iterator = _createForOfIteratorHelper(indexes),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var j = _step.value;\n\n        if (j !== firstIndex) {\n          _this.B.set(_this.normals[3 * j], _this.normals[3 * j + 1], _this.normals[3 * j + 2]).normalize();\n\n          if (_this.B.dot(_this.A) < cutOff) {\n            result.splitGroup.push(j);\n          } else {\n            result.currentGroup.push(j);\n          }\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return result;\n  });\n\n  __publicField(this, \"edgeSplit\", function (indexes, cutOff) {\n    var original = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    if (indexes.length === 0) return;\n    var groupResults = [];\n\n    var _iterator2 = _createForOfIteratorHelper(indexes),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var index = _step2.value;\n        groupResults.push(_this.edgeSplitToGroups(indexes, cutOff, index));\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    var result = groupResults[0];\n\n    for (var _i = 0, _groupResults = groupResults; _i < _groupResults.length; _i++) {\n      var groupResult = _groupResults[_i];\n\n      if (groupResult.currentGroup.length > result.currentGroup.length) {\n        result = groupResult;\n      }\n    }\n\n    if (original != null) {\n      _this.splitIndexes.push({\n        original: original,\n        indexes: result.currentGroup\n      });\n    }\n\n    if (result.splitGroup.length) {\n      _this.edgeSplit(result.splitGroup, cutOff, original || result.currentGroup[0]);\n    }\n  });\n\n  __publicField(this, \"modify\", function (geometry, cutOffAngle) {\n    var tryKeepNormals = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    var hadNormals = false;\n\n    if (geometry.attributes.normal) {\n      hadNormals = true;\n      geometry = geometry.clone();\n\n      if (tryKeepNormals === true && geometry.index !== null) {\n        _this.oldNormals = geometry.attributes.normal.array;\n      }\n\n      geometry.deleteAttribute(\"normal\");\n    }\n\n    if (geometry.index == null) {\n      if (BufferGeometryUtils === void 0) {\n        throw \"THREE.EdgeSplitModifier relies on BufferGeometryUtils\";\n      }\n\n      geometry = mergeVertices(geometry);\n    }\n\n    _this.indexes = geometry.index.array;\n    _this.positions = geometry.getAttribute(\"position\").array;\n\n    _this.computeNormals();\n\n    _this.mapPositionsToIndexes();\n\n    _this.splitIndexes = [];\n\n    var _iterator3 = _createForOfIteratorHelper(_this.pointToIndexMap),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var vertexIndexes = _step3.value;\n\n        _this.edgeSplit(vertexIndexes, Math.cos(cutOffAngle) - 1e-3);\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n\n    var newAttributes = {};\n\n    for (var _i2 = 0, _Object$keys = Object.keys(geometry.attributes); _i2 < _Object$keys.length; _i2++) {\n      var name = _Object$keys[_i2];\n      var oldAttribute = geometry.attributes[name];\n      var newArray = new oldAttribute.array.constructor((_this.indexes.length + _this.splitIndexes.length) * oldAttribute.itemSize);\n      newArray.set(oldAttribute.array);\n      newAttributes[name] = new BufferAttribute(newArray, oldAttribute.itemSize, oldAttribute.normalized);\n    }\n\n    var newIndexes = new Uint32Array(_this.indexes.length);\n    newIndexes.set(_this.indexes);\n\n    for (var i = 0; i < _this.splitIndexes.length; i++) {\n      var split = _this.splitIndexes[i];\n      var index = _this.indexes[split.original];\n\n      for (var _i3 = 0, _Object$values = Object.values(newAttributes); _i3 < _Object$values.length; _i3++) {\n        var attribute = _Object$values[_i3];\n\n        for (var j = 0; j < attribute.itemSize; j++) {\n          attribute.array[(_this.indexes.length + i) * attribute.itemSize + j] = attribute.array[index * attribute.itemSize + j];\n        }\n      }\n\n      var _iterator4 = _createForOfIteratorHelper(split.indexes),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var _j = _step4.value;\n          newIndexes[_j] = _this.indexes.length + i;\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n    }\n\n    geometry = new BufferGeometry();\n    geometry.setIndex(new BufferAttribute(newIndexes, 1));\n\n    for (var _i4 = 0, _Object$keys2 = Object.keys(newAttributes); _i4 < _Object$keys2.length; _i4++) {\n      var _name = _Object$keys2[_i4];\n      geometry.setAttribute(_name, newAttributes[_name]);\n    }\n\n    if (hadNormals) {\n      geometry.computeVertexNormals();\n\n      if (_this.oldNormals !== null) {\n        var changedNormals = new Array(_this.oldNormals.length / 3).fill(false);\n\n        var _iterator5 = _createForOfIteratorHelper(_this.splitIndexes),\n            _step5;\n\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var splitData = _step5.value;\n            changedNormals[splitData.original] = true;\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n\n        for (var _i5 = 0; _i5 < changedNormals.length; _i5++) {\n          if (changedNormals[_i5] === false) {\n            for (var _j2 = 0; _j2 < 3; _j2++) {\n              geometry.attributes.normal.array[3 * _i5 + _j2] = _this.oldNormals[3 * _i5 + _j2];\n            }\n          }\n        }\n      }\n    }\n\n    return geometry;\n  });\n};\n\nexport { EdgeSplitModifier };","map":{"version":3,"sources":["/Users/theodaguier/Repositories/E-Do-Studio/node_modules/three-stdlib/modifiers/EdgeSplitModifier.js"],"names":["__defProp","Object","defineProperty","__defNormalProp","obj","key","value","enumerable","configurable","writable","__publicField","Vector3","BufferAttribute","BufferGeometry","BufferGeometryUtils","mergeVertices","EdgeSplitModifier","Float32Array","normals","indexes","length","i","index","A","set","positions","B","C","sub","normal","cross","normalize","j","x","y","z","pointToIndexMap","Array","push","cutOff","firstIndex","result","splitGroup","currentGroup","dot","original","groupResults","edgeSplitToGroups","groupResult","splitIndexes","edgeSplit","geometry","cutOffAngle","tryKeepNormals","hadNormals","attributes","clone","oldNormals","array","deleteAttribute","getAttribute","computeNormals","mapPositionsToIndexes","vertexIndexes","Math","cos","newAttributes","keys","name","oldAttribute","newArray","constructor","itemSize","normalized","newIndexes","Uint32Array","split","values","attribute","setIndex","setAttribute","computeVertexNormals","changedNormals","fill","splitData"],"mappings":"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","sourcesContent":["var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Vector3, BufferAttribute, BufferGeometry } from \"three\";\nimport * as BufferGeometryUtils from \"../utils/BufferGeometryUtils.js\";\nimport { mergeVertices } from \"../utils/BufferGeometryUtils.js\";\nclass EdgeSplitModifier {\n  constructor() {\n    __publicField(this, \"A\", new Vector3());\n    __publicField(this, \"B\", new Vector3());\n    __publicField(this, \"C\", new Vector3());\n    __publicField(this, \"positions\", []);\n    __publicField(this, \"normals\", new Float32Array());\n    __publicField(this, \"indexes\", []);\n    __publicField(this, \"pointToIndexMap\", []);\n    __publicField(this, \"splitIndexes\", []);\n    __publicField(this, \"oldNormals\", []);\n    __publicField(this, \"computeNormals\", () => {\n      this.normals = new Float32Array(this.indexes.length * 3);\n      for (let i = 0; i < this.indexes.length; i += 3) {\n        let index = this.indexes[i];\n        this.A.set(this.positions[3 * index], this.positions[3 * index + 1], this.positions[3 * index + 2]);\n        index = this.indexes[i + 1];\n        this.B.set(this.positions[3 * index], this.positions[3 * index + 1], this.positions[3 * index + 2]);\n        index = this.indexes[i + 2];\n        this.C.set(this.positions[3 * index], this.positions[3 * index + 1], this.positions[3 * index + 2]);\n        this.C.sub(this.B);\n        this.A.sub(this.B);\n        const normal = this.C.cross(this.A).normalize();\n        for (let j = 0; j < 3; j++) {\n          this.normals[3 * (i + j)] = normal.x;\n          this.normals[3 * (i + j) + 1] = normal.y;\n          this.normals[3 * (i + j) + 2] = normal.z;\n        }\n      }\n    });\n    __publicField(this, \"mapPositionsToIndexes\", () => {\n      this.pointToIndexMap = Array(this.positions.length / 3);\n      for (let i = 0; i < this.indexes.length; i++) {\n        const index = this.indexes[i];\n        if (this.pointToIndexMap[index] == null) {\n          this.pointToIndexMap[index] = [];\n        }\n        this.pointToIndexMap[index].push(i);\n      }\n    });\n    __publicField(this, \"edgeSplitToGroups\", (indexes, cutOff, firstIndex) => {\n      this.A.set(\n        this.normals[3 * firstIndex],\n        this.normals[3 * firstIndex + 1],\n        this.normals[3 * firstIndex + 2]\n      ).normalize();\n      const result = {\n        splitGroup: [],\n        currentGroup: [firstIndex]\n      };\n      for (let j of indexes) {\n        if (j !== firstIndex) {\n          this.B.set(this.normals[3 * j], this.normals[3 * j + 1], this.normals[3 * j + 2]).normalize();\n          if (this.B.dot(this.A) < cutOff) {\n            result.splitGroup.push(j);\n          } else {\n            result.currentGroup.push(j);\n          }\n        }\n      }\n      return result;\n    });\n    __publicField(this, \"edgeSplit\", (indexes, cutOff, original = null) => {\n      if (indexes.length === 0)\n        return;\n      const groupResults = [];\n      for (let index of indexes) {\n        groupResults.push(this.edgeSplitToGroups(indexes, cutOff, index));\n      }\n      let result = groupResults[0];\n      for (let groupResult of groupResults) {\n        if (groupResult.currentGroup.length > result.currentGroup.length) {\n          result = groupResult;\n        }\n      }\n      if (original != null) {\n        this.splitIndexes.push({\n          original,\n          indexes: result.currentGroup\n        });\n      }\n      if (result.splitGroup.length) {\n        this.edgeSplit(result.splitGroup, cutOff, original || result.currentGroup[0]);\n      }\n    });\n    __publicField(this, \"modify\", (geometry, cutOffAngle, tryKeepNormals = true) => {\n      let hadNormals = false;\n      if (geometry.attributes.normal) {\n        hadNormals = true;\n        geometry = geometry.clone();\n        if (tryKeepNormals === true && geometry.index !== null) {\n          this.oldNormals = geometry.attributes.normal.array;\n        }\n        geometry.deleteAttribute(\"normal\");\n      }\n      if (geometry.index == null) {\n        if (BufferGeometryUtils === void 0) {\n          throw \"THREE.EdgeSplitModifier relies on BufferGeometryUtils\";\n        }\n        geometry = mergeVertices(geometry);\n      }\n      this.indexes = geometry.index.array;\n      this.positions = geometry.getAttribute(\"position\").array;\n      this.computeNormals();\n      this.mapPositionsToIndexes();\n      this.splitIndexes = [];\n      for (let vertexIndexes of this.pointToIndexMap) {\n        this.edgeSplit(vertexIndexes, Math.cos(cutOffAngle) - 1e-3);\n      }\n      const newAttributes = {};\n      for (let name of Object.keys(geometry.attributes)) {\n        const oldAttribute = geometry.attributes[name];\n        const newArray = new oldAttribute.array.constructor(\n          (this.indexes.length + this.splitIndexes.length) * oldAttribute.itemSize\n        );\n        newArray.set(oldAttribute.array);\n        newAttributes[name] = new BufferAttribute(newArray, oldAttribute.itemSize, oldAttribute.normalized);\n      }\n      const newIndexes = new Uint32Array(this.indexes.length);\n      newIndexes.set(this.indexes);\n      for (let i = 0; i < this.splitIndexes.length; i++) {\n        const split = this.splitIndexes[i];\n        const index = this.indexes[split.original];\n        for (let attribute of Object.values(newAttributes)) {\n          for (let j = 0; j < attribute.itemSize; j++) {\n            attribute.array[(this.indexes.length + i) * attribute.itemSize + j] = attribute.array[index * attribute.itemSize + j];\n          }\n        }\n        for (let j of split.indexes) {\n          newIndexes[j] = this.indexes.length + i;\n        }\n      }\n      geometry = new BufferGeometry();\n      geometry.setIndex(new BufferAttribute(newIndexes, 1));\n      for (let name of Object.keys(newAttributes)) {\n        geometry.setAttribute(name, newAttributes[name]);\n      }\n      if (hadNormals) {\n        geometry.computeVertexNormals();\n        if (this.oldNormals !== null) {\n          const changedNormals = new Array(this.oldNormals.length / 3).fill(false);\n          for (let splitData of this.splitIndexes)\n            changedNormals[splitData.original] = true;\n          for (let i = 0; i < changedNormals.length; i++) {\n            if (changedNormals[i] === false) {\n              for (let j = 0; j < 3; j++) {\n                geometry.attributes.normal.array[3 * i + j] = this.oldNormals[3 * i + j];\n              }\n            }\n          }\n        }\n      }\n      return geometry;\n    });\n  }\n}\nexport {\n  EdgeSplitModifier\n};\n"]},"metadata":{},"sourceType":"module"}