{"ast":null,"code":"import { LWO2Parser } from \"./LWO2Parser.js\";\nimport { LWO3Parser } from \"./LWO3Parser.js\";\n\nclass IFFParser {\n  constructor() {\n    this.debugger = new Debugger();\n  }\n\n  parse(buffer) {\n    this.reader = new DataViewReader(buffer);\n    this.tree = {\n      materials: {},\n      layers: [],\n      tags: [],\n      textures: []\n    };\n    this.currentLayer = this.tree;\n    this.currentForm = this.tree;\n    this.parseTopForm();\n    if (this.tree.format === void 0) return;\n\n    if (this.tree.format === \"LWO2\") {\n      this.parser = new LWO2Parser(this);\n\n      while (!this.reader.endOfFile()) this.parser.parseBlock();\n    } else if (this.tree.format === \"LWO3\") {\n      this.parser = new LWO3Parser(this);\n\n      while (!this.reader.endOfFile()) this.parser.parseBlock();\n    }\n\n    this.debugger.offset = this.reader.offset;\n    this.debugger.closeForms();\n    return this.tree;\n  }\n\n  parseTopForm() {\n    this.debugger.offset = this.reader.offset;\n    var topForm = this.reader.getIDTag();\n\n    if (topForm !== \"FORM\") {\n      console.warn(\"LWOLoader: Top-level FORM missing.\");\n      return;\n    }\n\n    var length = this.reader.getUint32();\n    this.debugger.dataOffset = this.reader.offset;\n    this.debugger.length = length;\n    var type = this.reader.getIDTag();\n\n    if (type === \"LWO2\") {\n      this.tree.format = type;\n    } else if (type === \"LWO3\") {\n      this.tree.format = type;\n    }\n\n    this.debugger.node = 0;\n    this.debugger.nodeID = type;\n    this.debugger.log();\n    return;\n  } ///\n  // FORM PARSING METHODS\n  ///\n  // Forms are organisational and can contain any number of sub chunks and sub forms\n  // FORM ::= 'FORM'[ID4], length[U4], type[ID4], ( chunk[CHUNK] | form[FORM] ) * }\n\n\n  parseForm(length) {\n    var type = this.reader.getIDTag();\n\n    switch (type) {\n      case \"ISEQ\":\n      case \"ANIM\":\n      case \"STCC\":\n      case \"VPVL\":\n      case \"VPRM\":\n      case \"NROT\":\n      case \"WRPW\":\n      case \"WRPH\":\n      case \"FUNC\":\n      case \"FALL\":\n      case \"OPAC\":\n      case \"GRAD\":\n      case \"ENVS\":\n      case \"VMOP\":\n      case \"VMBG\":\n      case \"OMAX\":\n      case \"STEX\":\n      case \"CKBG\":\n      case \"CKEY\":\n      case \"VMLA\":\n      case \"VMLB\":\n        this.debugger.skipped = true;\n        this.skipForm(length);\n        break;\n\n      case \"META\":\n      case \"NNDS\":\n      case \"NODS\":\n      case \"NDTA\":\n      case \"ADAT\":\n      case \"AOVS\":\n      case \"BLOK\":\n      case \"IBGC\":\n      case \"IOPC\":\n      case \"IIMG\":\n      case \"TXTR\":\n        this.debugger.length = 4;\n        this.debugger.skipped = true;\n        break;\n\n      case \"IFAL\":\n      case \"ISCL\":\n      case \"IPOS\":\n      case \"IROT\":\n      case \"IBMP\":\n      case \"IUTD\":\n      case \"IVTD\":\n        this.parseTextureNodeAttribute(type);\n        break;\n\n      case \"ENVL\":\n        this.parseEnvelope(length);\n        break;\n\n      case \"CLIP\":\n        if (this.tree.format === \"LWO2\") {\n          this.parseForm(length);\n        } else {\n          this.parseClip(length);\n        }\n\n        break;\n\n      case \"STIL\":\n        this.parseImage();\n        break;\n\n      case \"XREF\":\n        this.reader.skip(8);\n        this.currentForm.referenceTexture = {\n          index: this.reader.getUint32(),\n          refName: this.reader.getString() // internal unique ref\n\n        };\n        break;\n\n      case \"IMST\":\n        this.parseImageStateForm(length);\n        break;\n\n      case \"SURF\":\n        this.parseSurfaceForm(length);\n        break;\n\n      case \"VALU\":\n        this.parseValueForm(length);\n        break;\n\n      case \"NTAG\":\n        this.parseSubNode(length);\n        break;\n\n      case \"ATTR\":\n      case \"SATR\":\n        this.setupForm(\"attributes\", length);\n        break;\n\n      case \"NCON\":\n        this.parseConnections(length);\n        break;\n\n      case \"SSHA\":\n        this.parentForm = this.currentForm;\n        this.currentForm = this.currentSurface;\n        this.setupForm(\"surfaceShader\", length);\n        break;\n\n      case \"SSHD\":\n        this.setupForm(\"surfaceShaderData\", length);\n        break;\n\n      case \"ENTR\":\n        this.parseEntryForm(length);\n        break;\n\n      case \"IMAP\":\n        this.parseImageMap(length);\n        break;\n\n      case \"TAMP\":\n        this.parseXVAL(\"amplitude\", length);\n        break;\n\n      case \"TMAP\":\n        this.setupForm(\"textureMap\", length);\n        break;\n\n      case \"CNTR\":\n        this.parseXVAL3(\"center\", length);\n        break;\n\n      case \"SIZE\":\n        this.parseXVAL3(\"scale\", length);\n        break;\n\n      case \"ROTA\":\n        this.parseXVAL3(\"rotation\", length);\n        break;\n\n      default:\n        this.parseUnknownForm(type, length);\n    }\n\n    this.debugger.node = 0;\n    this.debugger.nodeID = type;\n    this.debugger.log();\n  }\n\n  setupForm(type, length) {\n    if (!this.currentForm) this.currentForm = this.currentNode;\n    this.currentFormEnd = this.reader.offset + length;\n    this.parentForm = this.currentForm;\n\n    if (!this.currentForm[type]) {\n      this.currentForm[type] = {};\n      this.currentForm = this.currentForm[type];\n    } else {\n      console.warn(\"LWOLoader: form already exists on parent: \", type, this.currentForm);\n      this.currentForm = this.currentForm[type];\n    }\n  }\n\n  skipForm(length) {\n    this.reader.skip(length - 4);\n  }\n\n  parseUnknownForm(type, length) {\n    console.warn(\"LWOLoader: unknown FORM encountered: \" + type, length);\n    printBuffer(this.reader.dv.buffer, this.reader.offset, length - 4);\n    this.reader.skip(length - 4);\n  }\n\n  parseSurfaceForm(length) {\n    this.reader.skip(8);\n    var name = this.reader.getString();\n    var surface = {\n      attributes: {},\n      // LWO2 style non-node attributes will go here\n      connections: {},\n      name,\n      inputName: name,\n      nodes: {},\n      source: this.reader.getString()\n    };\n    this.tree.materials[name] = surface;\n    this.currentSurface = surface;\n    this.parentForm = this.tree.materials;\n    this.currentForm = surface;\n    this.currentFormEnd = this.reader.offset + length;\n  }\n\n  parseSurfaceLwo2(length) {\n    var name = this.reader.getString();\n    var surface = {\n      attributes: {},\n      // LWO2 style non-node attributes will go here\n      connections: {},\n      name,\n      nodes: {},\n      source: this.reader.getString()\n    };\n    this.tree.materials[name] = surface;\n    this.currentSurface = surface;\n    this.parentForm = this.tree.materials;\n    this.currentForm = surface;\n    this.currentFormEnd = this.reader.offset + length;\n  }\n\n  parseSubNode(length) {\n    this.reader.skip(8);\n    var name = this.reader.getString();\n    var node = {\n      name\n    };\n    this.currentForm = node;\n    this.currentNode = node;\n    this.currentFormEnd = this.reader.offset + length;\n  } // collect attributes from all nodes at the top level of a surface\n\n\n  parseConnections(length) {\n    this.currentFormEnd = this.reader.offset + length;\n    this.parentForm = this.currentForm;\n    this.currentForm = this.currentSurface.connections;\n  } // surface node attribute data, e.g. specular, roughness etc\n\n\n  parseEntryForm(length) {\n    this.reader.skip(8);\n    var name = this.reader.getString();\n    this.currentForm = this.currentNode.attributes;\n    this.setupForm(name, length);\n  } // parse values from material - doesn't match up to other LWO3 data types\n  // sub form of entry form\n\n\n  parseValueForm() {\n    this.reader.skip(8);\n    var valueType = this.reader.getString();\n\n    if (valueType === \"double\") {\n      this.currentForm.value = this.reader.getUint64();\n    } else if (valueType === \"int\") {\n      this.currentForm.value = this.reader.getUint32();\n    } else if (valueType === \"vparam\") {\n      this.reader.skip(24);\n      this.currentForm.value = this.reader.getFloat64();\n    } else if (valueType === \"vparam3\") {\n      this.reader.skip(24);\n      this.currentForm.value = this.reader.getFloat64Array(3);\n    }\n  } // holds various data about texture node image state\n  // Data other thanmipMapLevel unknown\n\n\n  parseImageStateForm() {\n    this.reader.skip(8);\n    this.currentForm.mipMapLevel = this.reader.getFloat32();\n  } // LWO2 style image data node OR LWO3 textures defined at top level in editor (not as SURF node)\n\n\n  parseImageMap(length) {\n    this.currentFormEnd = this.reader.offset + length;\n    this.parentForm = this.currentForm;\n    if (!this.currentForm.maps) this.currentForm.maps = [];\n    var map = {};\n    this.currentForm.maps.push(map);\n    this.currentForm = map;\n    this.reader.skip(10);\n  }\n\n  parseTextureNodeAttribute(type) {\n    this.reader.skip(28);\n    this.reader.skip(20);\n\n    switch (type) {\n      case \"ISCL\":\n        this.currentNode.scale = this.reader.getFloat32Array(3);\n        break;\n\n      case \"IPOS\":\n        this.currentNode.position = this.reader.getFloat32Array(3);\n        break;\n\n      case \"IROT\":\n        this.currentNode.rotation = this.reader.getFloat32Array(3);\n        break;\n\n      case \"IFAL\":\n        this.currentNode.falloff = this.reader.getFloat32Array(3);\n        break;\n\n      case \"IBMP\":\n        this.currentNode.amplitude = this.reader.getFloat32();\n        break;\n\n      case \"IUTD\":\n        this.currentNode.uTiles = this.reader.getFloat32();\n        break;\n\n      case \"IVTD\":\n        this.currentNode.vTiles = this.reader.getFloat32();\n        break;\n    }\n\n    this.reader.skip(2);\n  } // ENVL forms are currently ignored\n\n\n  parseEnvelope(length) {\n    this.reader.skip(length - 4);\n  } ///\n  // CHUNK PARSING METHODS\n  ///\n  // clips can either be defined inside a surface node, or at the top\n  // level and they have a different format in each case\n\n\n  parseClip(length) {\n    var tag = this.reader.getIDTag();\n\n    if (tag === \"FORM\") {\n      this.reader.skip(16);\n      this.currentNode.fileName = this.reader.getString();\n      return;\n    }\n\n    this.reader.setOffset(this.reader.offset - 4);\n    this.currentFormEnd = this.reader.offset + length;\n    this.parentForm = this.currentForm;\n    this.reader.skip(8);\n    var texture = {\n      index: this.reader.getUint32()\n    };\n    this.tree.textures.push(texture);\n    this.currentForm = texture;\n  }\n\n  parseClipLwo2(length) {\n    var texture = {\n      index: this.reader.getUint32(),\n      fileName: \"\"\n    };\n\n    while (true) {\n      var tag = this.reader.getIDTag();\n      var n_length = this.reader.getUint16();\n\n      if (tag === \"STIL\") {\n        texture.fileName = this.reader.getString();\n        break;\n      }\n\n      if (n_length >= length) {\n        break;\n      }\n    }\n\n    this.tree.textures.push(texture);\n    this.currentForm = texture;\n  }\n\n  parseImage() {\n    this.reader.skip(8);\n    this.currentForm.fileName = this.reader.getString();\n  }\n\n  parseXVAL(type, length) {\n    var endOffset = this.reader.offset + length - 4;\n    this.reader.skip(8);\n    this.currentForm[type] = this.reader.getFloat32();\n    this.reader.setOffset(endOffset);\n  }\n\n  parseXVAL3(type, length) {\n    var endOffset = this.reader.offset + length - 4;\n    this.reader.skip(8);\n    this.currentForm[type] = {\n      x: this.reader.getFloat32(),\n      y: this.reader.getFloat32(),\n      z: this.reader.getFloat32()\n    };\n    this.reader.setOffset(endOffset);\n  } // Tags associated with an object\n  // OTAG { type[ID4], tag-string[S0] }\n\n\n  parseObjectTag() {\n    if (!this.tree.objectTags) this.tree.objectTags = {};\n    this.tree.objectTags[this.reader.getIDTag()] = {\n      tagString: this.reader.getString()\n    };\n  } // Signals the start of a new layer. All the data chunks which follow will be included in this layer until another layer chunk is encountered.\n  // LAYR: number[U2], flags[U2], pivot[VEC12], name[S0], parent[U2]\n\n\n  parseLayer(length) {\n    var layer = {\n      number: this.reader.getUint16(),\n      flags: this.reader.getUint16(),\n      // If the least significant bit of flags is set, the layer is hidden.\n      pivot: this.reader.getFloat32Array(3),\n      // Note: this seems to be superflous, as the geometry is translated when pivot is present\n      name: this.reader.getString()\n    };\n    this.tree.layers.push(layer);\n    this.currentLayer = layer;\n    var parsedLength = 16 + stringOffset(this.currentLayer.name);\n    this.currentLayer.parent = parsedLength < length ? this.reader.getUint16() : -1;\n  } // VEC12 * ( F4 + F4 + F4 ) array of x,y,z vectors\n  // Converting from left to right handed coordinate system:\n  // x -> -x and switch material FrontSide -> BackSide\n\n\n  parsePoints(length) {\n    this.currentPoints = [];\n\n    for (var i = 0; i < length / 4; i += 3) {\n      this.currentPoints.push(this.reader.getFloat32(), this.reader.getFloat32(), -this.reader.getFloat32());\n    }\n  } // parse VMAP or VMAD\n  // Associates a set of floating-point vectors with a set of points.\n  // VMAP: { type[ID4], dimension[U2], name[S0], ( vert[VX], value[F4] # dimension ) * }\n  // VMAD Associates a set of floating-point vectors with the vertices of specific polygons.\n  // Similar to VMAP UVs, but associates with polygon vertices rather than points\n  // to solve to problem of UV seams:  VMAD chunks are paired with VMAPs of the same name,\n  // if they exist. The vector values in the VMAD will then replace those in the\n  // corresponding VMAP, but only for calculations involving the specified polygons.\n  // VMAD { type[ID4], dimension[U2], name[S0], ( vert[VX], poly[VX], value[F4] # dimension ) * }\n\n\n  parseVertexMapping(length, discontinuous) {\n    var finalOffset = this.reader.offset + length;\n    var channelName = this.reader.getString();\n\n    if (this.reader.offset === finalOffset) {\n      this.currentForm.UVChannel = channelName;\n      return;\n    }\n\n    this.reader.setOffset(this.reader.offset - stringOffset(channelName));\n    var type = this.reader.getIDTag();\n    this.reader.getUint16();\n    var name = this.reader.getString();\n    var remainingLength = length - 6 - stringOffset(name);\n\n    switch (type) {\n      case \"TXUV\":\n        this.parseUVMapping(name, finalOffset, discontinuous);\n        break;\n\n      case \"MORF\":\n      case \"SPOT\":\n        this.parseMorphTargets(name, finalOffset, type);\n        break;\n\n      case \"APSL\":\n      case \"NORM\":\n      case \"WGHT\":\n      case \"MNVW\":\n      case \"PICK\":\n      case \"RGB \":\n      case \"RGBA\":\n        this.reader.skip(remainingLength);\n        break;\n\n      default:\n        console.warn(\"LWOLoader: unknown vertex map type: \" + type);\n        this.reader.skip(remainingLength);\n    }\n  }\n\n  parseUVMapping(name, finalOffset, discontinuous) {\n    var uvIndices = [];\n    var polyIndices = [];\n    var uvs = [];\n\n    while (this.reader.offset < finalOffset) {\n      uvIndices.push(this.reader.getVariableLengthIndex());\n      if (discontinuous) polyIndices.push(this.reader.getVariableLengthIndex());\n      uvs.push(this.reader.getFloat32(), this.reader.getFloat32());\n    }\n\n    if (discontinuous) {\n      if (!this.currentLayer.discontinuousUVs) this.currentLayer.discontinuousUVs = {};\n      this.currentLayer.discontinuousUVs[name] = {\n        uvIndices,\n        polyIndices,\n        uvs\n      };\n    } else {\n      if (!this.currentLayer.uvs) this.currentLayer.uvs = {};\n      this.currentLayer.uvs[name] = {\n        uvIndices,\n        uvs\n      };\n    }\n  }\n\n  parseMorphTargets(name, finalOffset, type) {\n    var indices = [];\n    var points = [];\n    type = type === \"MORF\" ? \"relative\" : \"absolute\";\n\n    while (this.reader.offset < finalOffset) {\n      indices.push(this.reader.getVariableLengthIndex());\n      points.push(this.reader.getFloat32(), this.reader.getFloat32(), -this.reader.getFloat32());\n    }\n\n    if (!this.currentLayer.morphTargets) this.currentLayer.morphTargets = {};\n    this.currentLayer.morphTargets[name] = {\n      indices,\n      points,\n      type\n    };\n  } // A list of polygons for the current layer.\n  // POLS { type[ID4], ( numvert+flags[U2], vert[VX] # numvert ) * }\n\n\n  parsePolygonList(length) {\n    var finalOffset = this.reader.offset + length;\n    var type = this.reader.getIDTag();\n    var indices = [];\n    var polygonDimensions = [];\n\n    while (this.reader.offset < finalOffset) {\n      var numverts = this.reader.getUint16();\n      numverts = numverts & 1023;\n      polygonDimensions.push(numverts);\n\n      for (var j = 0; j < numverts; j++) indices.push(this.reader.getVariableLengthIndex());\n    }\n\n    var geometryData = {\n      type,\n      vertexIndices: indices,\n      polygonDimensions,\n      points: this.currentPoints\n    };\n    if (polygonDimensions[0] === 1) geometryData.type = \"points\";else if (polygonDimensions[0] === 2) geometryData.type = \"lines\";\n    this.currentLayer.geometry = geometryData;\n  } // Lists the tag strings that can be associated with polygons by the PTAG chunk.\n  // TAGS { tag-string[S0] * }\n\n\n  parseTagStrings(length) {\n    this.tree.tags = this.reader.getStringArray(length);\n  } // Associates tags of a given type with polygons in the most recent POLS chunk.\n  // PTAG { type[ID4], ( poly[VX], tag[U2] ) * }\n\n\n  parsePolygonTagMapping(length) {\n    var finalOffset = this.reader.offset + length;\n    var type = this.reader.getIDTag();\n    if (type === \"SURF\") this.parseMaterialIndices(finalOffset);else {\n      this.reader.skip(length - 4);\n    }\n  }\n\n  parseMaterialIndices(finalOffset) {\n    this.currentLayer.geometry.materialIndices = [];\n\n    while (this.reader.offset < finalOffset) {\n      var polygonIndex = this.reader.getVariableLengthIndex();\n      var materialIndex = this.reader.getUint16();\n      this.currentLayer.geometry.materialIndices.push(polygonIndex, materialIndex);\n    }\n  }\n\n  parseUnknownCHUNK(blockID, length) {\n    console.warn(\"LWOLoader: unknown chunk type: \" + blockID + \" length: \" + length);\n    var data = this.reader.getString(length);\n    this.currentForm[blockID] = data;\n  }\n\n}\n\nclass DataViewReader {\n  constructor(buffer) {\n    this.dv = new DataView(buffer);\n    this.offset = 0;\n    this._textDecoder = new TextDecoder();\n    this._bytes = new Uint8Array(buffer);\n  }\n\n  size() {\n    return this.dv.buffer.byteLength;\n  }\n\n  setOffset(offset) {\n    if (offset > 0 && offset < this.dv.buffer.byteLength) {\n      this.offset = offset;\n    } else {\n      console.error(\"LWOLoader: invalid buffer offset\");\n    }\n  }\n\n  endOfFile() {\n    if (this.offset >= this.size()) return true;\n    return false;\n  }\n\n  skip(length) {\n    this.offset += length;\n  }\n\n  getUint8() {\n    var value = this.dv.getUint8(this.offset);\n    this.offset += 1;\n    return value;\n  }\n\n  getUint16() {\n    var value = this.dv.getUint16(this.offset);\n    this.offset += 2;\n    return value;\n  }\n\n  getInt32() {\n    var value = this.dv.getInt32(this.offset, false);\n    this.offset += 4;\n    return value;\n  }\n\n  getUint32() {\n    var value = this.dv.getUint32(this.offset, false);\n    this.offset += 4;\n    return value;\n  }\n\n  getUint64() {\n    var low, high;\n    high = this.getUint32();\n    low = this.getUint32();\n    return high * 4294967296 + low;\n  }\n\n  getFloat32() {\n    var value = this.dv.getFloat32(this.offset, false);\n    this.offset += 4;\n    return value;\n  }\n\n  getFloat32Array(size) {\n    var a = [];\n\n    for (var i = 0; i < size; i++) {\n      a.push(this.getFloat32());\n    }\n\n    return a;\n  }\n\n  getFloat64() {\n    var value = this.dv.getFloat64(this.offset, this.littleEndian);\n    this.offset += 8;\n    return value;\n  }\n\n  getFloat64Array(size) {\n    var a = [];\n\n    for (var i = 0; i < size; i++) {\n      a.push(this.getFloat64());\n    }\n\n    return a;\n  } // get variable-length index data type\n  // VX ::= index[U2] | (index + 0xFF000000)[U4]\n  // If the index value is less than 65,280 (0xFF00),then VX === U2\n  // otherwise VX === U4 with bits 24-31 set\n  // When reading an index, if the first byte encountered is 255 (0xFF), then\n  // the four-byte form is being used and the first byte should be discarded or masked out.\n\n\n  getVariableLengthIndex() {\n    var firstByte = this.getUint8();\n\n    if (firstByte === 255) {\n      return this.getUint8() * 65536 + this.getUint8() * 256 + this.getUint8();\n    }\n\n    return firstByte * 256 + this.getUint8();\n  } // An ID tag is a sequence of 4 bytes containing 7-bit ASCII values\n\n\n  getIDTag() {\n    return this.getString(4);\n  }\n\n  getString(size) {\n    if (size === 0) return;\n    const start = this.offset;\n    let result;\n    let length;\n\n    if (size) {\n      length = size;\n      result = this._textDecoder.decode(new Uint8Array(this.dv.buffer, start, size));\n    } else {\n      length = this._bytes.indexOf(0, start) - start;\n      result = this._textDecoder.decode(new Uint8Array(this.dv.buffer, start, length));\n      length++;\n      length += length % 2;\n    }\n\n    this.skip(length);\n    return result;\n  }\n\n  getStringArray(size) {\n    var a = this.getString(size);\n    a = a.split(\"\\0\");\n    return a.filter(Boolean);\n  }\n\n}\n\nclass Debugger {\n  constructor() {\n    this.active = false;\n    this.depth = 0;\n    this.formList = [];\n  }\n\n  enable() {\n    this.active = true;\n  }\n\n  log() {\n    if (!this.active) return;\n    var nodeType;\n\n    switch (this.node) {\n      case 0:\n        nodeType = \"FORM\";\n        break;\n\n      case 1:\n        nodeType = \"CHK\";\n        break;\n\n      case 2:\n        nodeType = \"S-CHK\";\n        break;\n    }\n\n    console.log(\"| \".repeat(this.depth) + nodeType, this.nodeID, `( ${this.offset} ) -> ( ${this.dataOffset + this.length} )`, this.node == 0 ? \" {\" : \"\", this.skipped ? \"SKIPPED\" : \"\", this.node == 0 && this.skipped ? \"}\" : \"\");\n\n    if (this.node == 0 && !this.skipped) {\n      this.depth += 1;\n      this.formList.push(this.dataOffset + this.length);\n    }\n\n    this.skipped = false;\n  }\n\n  closeForms() {\n    if (!this.active) return;\n\n    for (var i = this.formList.length - 1; i >= 0; i--) {\n      if (this.offset >= this.formList[i]) {\n        this.depth -= 1;\n        console.log(\"| \".repeat(this.depth) + \"}\");\n        this.formList.splice(-1, 1);\n      }\n    }\n  }\n\n}\n\nfunction isEven(num) {\n  return num % 2;\n}\n\nfunction stringOffset(string) {\n  return string.length + 1 + (isEven(string.length + 1) ? 1 : 0);\n}\n\nfunction printBuffer(buffer, from, to) {\n  console.log(new TextDecoder().decode(new Uint8Array(buffer, from, to)));\n}\n\nexport { IFFParser };","map":{"version":3,"sources":["/Users/theodaguier/Repositories/E-Do-Studio/node_modules/three-stdlib/loaders/lwo/IFFParser.js"],"names":["LWO2Parser","LWO3Parser","IFFParser","constructor","debugger","Debugger","parse","buffer","reader","DataViewReader","tree","materials","layers","tags","textures","currentLayer","currentForm","parseTopForm","format","parser","endOfFile","parseBlock","offset","closeForms","topForm","getIDTag","console","warn","length","getUint32","dataOffset","type","node","nodeID","log","parseForm","skipped","skipForm","parseTextureNodeAttribute","parseEnvelope","parseClip","parseImage","skip","referenceTexture","index","refName","getString","parseImageStateForm","parseSurfaceForm","parseValueForm","parseSubNode","setupForm","parseConnections","parentForm","currentSurface","parseEntryForm","parseImageMap","parseXVAL","parseXVAL3","parseUnknownForm","currentNode","currentFormEnd","printBuffer","dv","name","surface","attributes","connections","inputName","nodes","source","parseSurfaceLwo2","valueType","value","getUint64","getFloat64","getFloat64Array","mipMapLevel","getFloat32","maps","map","push","scale","getFloat32Array","position","rotation","falloff","amplitude","uTiles","vTiles","tag","fileName","setOffset","texture","parseClipLwo2","n_length","getUint16","endOffset","x","y","z","parseObjectTag","objectTags","tagString","parseLayer","layer","number","flags","pivot","parsedLength","stringOffset","parent","parsePoints","currentPoints","i","parseVertexMapping","discontinuous","finalOffset","channelName","UVChannel","remainingLength","parseUVMapping","parseMorphTargets","uvIndices","polyIndices","uvs","getVariableLengthIndex","discontinuousUVs","indices","points","morphTargets","parsePolygonList","polygonDimensions","numverts","j","geometryData","vertexIndices","geometry","parseTagStrings","getStringArray","parsePolygonTagMapping","parseMaterialIndices","materialIndices","polygonIndex","materialIndex","parseUnknownCHUNK","blockID","data","DataView","_textDecoder","TextDecoder","_bytes","Uint8Array","size","byteLength","error","getUint8","getInt32","low","high","a","littleEndian","firstByte","start","result","decode","indexOf","split","filter","Boolean","active","depth","formList","enable","nodeType","repeat","splice","isEven","num","string","from","to"],"mappings":"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","sourcesContent":["import { LWO2Parser } from \"./LWO2Parser.js\";\nimport { LWO3Parser } from \"./LWO3Parser.js\";\nclass IFFParser {\n  constructor() {\n    this.debugger = new Debugger();\n  }\n  parse(buffer) {\n    this.reader = new DataViewReader(buffer);\n    this.tree = {\n      materials: {},\n      layers: [],\n      tags: [],\n      textures: []\n    };\n    this.currentLayer = this.tree;\n    this.currentForm = this.tree;\n    this.parseTopForm();\n    if (this.tree.format === void 0)\n      return;\n    if (this.tree.format === \"LWO2\") {\n      this.parser = new LWO2Parser(this);\n      while (!this.reader.endOfFile())\n        this.parser.parseBlock();\n    } else if (this.tree.format === \"LWO3\") {\n      this.parser = new LWO3Parser(this);\n      while (!this.reader.endOfFile())\n        this.parser.parseBlock();\n    }\n    this.debugger.offset = this.reader.offset;\n    this.debugger.closeForms();\n    return this.tree;\n  }\n  parseTopForm() {\n    this.debugger.offset = this.reader.offset;\n    var topForm = this.reader.getIDTag();\n    if (topForm !== \"FORM\") {\n      console.warn(\"LWOLoader: Top-level FORM missing.\");\n      return;\n    }\n    var length = this.reader.getUint32();\n    this.debugger.dataOffset = this.reader.offset;\n    this.debugger.length = length;\n    var type = this.reader.getIDTag();\n    if (type === \"LWO2\") {\n      this.tree.format = type;\n    } else if (type === \"LWO3\") {\n      this.tree.format = type;\n    }\n    this.debugger.node = 0;\n    this.debugger.nodeID = type;\n    this.debugger.log();\n    return;\n  }\n  ///\n  // FORM PARSING METHODS\n  ///\n  // Forms are organisational and can contain any number of sub chunks and sub forms\n  // FORM ::= 'FORM'[ID4], length[U4], type[ID4], ( chunk[CHUNK] | form[FORM] ) * }\n  parseForm(length) {\n    var type = this.reader.getIDTag();\n    switch (type) {\n      case \"ISEQ\":\n      case \"ANIM\":\n      case \"STCC\":\n      case \"VPVL\":\n      case \"VPRM\":\n      case \"NROT\":\n      case \"WRPW\":\n      case \"WRPH\":\n      case \"FUNC\":\n      case \"FALL\":\n      case \"OPAC\":\n      case \"GRAD\":\n      case \"ENVS\":\n      case \"VMOP\":\n      case \"VMBG\":\n      case \"OMAX\":\n      case \"STEX\":\n      case \"CKBG\":\n      case \"CKEY\":\n      case \"VMLA\":\n      case \"VMLB\":\n        this.debugger.skipped = true;\n        this.skipForm(length);\n        break;\n      case \"META\":\n      case \"NNDS\":\n      case \"NODS\":\n      case \"NDTA\":\n      case \"ADAT\":\n      case \"AOVS\":\n      case \"BLOK\":\n      case \"IBGC\":\n      case \"IOPC\":\n      case \"IIMG\":\n      case \"TXTR\":\n        this.debugger.length = 4;\n        this.debugger.skipped = true;\n        break;\n      case \"IFAL\":\n      case \"ISCL\":\n      case \"IPOS\":\n      case \"IROT\":\n      case \"IBMP\":\n      case \"IUTD\":\n      case \"IVTD\":\n        this.parseTextureNodeAttribute(type);\n        break;\n      case \"ENVL\":\n        this.parseEnvelope(length);\n        break;\n      case \"CLIP\":\n        if (this.tree.format === \"LWO2\") {\n          this.parseForm(length);\n        } else {\n          this.parseClip(length);\n        }\n        break;\n      case \"STIL\":\n        this.parseImage();\n        break;\n      case \"XREF\":\n        this.reader.skip(8);\n        this.currentForm.referenceTexture = {\n          index: this.reader.getUint32(),\n          refName: this.reader.getString()\n          // internal unique ref\n        };\n        break;\n      case \"IMST\":\n        this.parseImageStateForm(length);\n        break;\n      case \"SURF\":\n        this.parseSurfaceForm(length);\n        break;\n      case \"VALU\":\n        this.parseValueForm(length);\n        break;\n      case \"NTAG\":\n        this.parseSubNode(length);\n        break;\n      case \"ATTR\":\n      case \"SATR\":\n        this.setupForm(\"attributes\", length);\n        break;\n      case \"NCON\":\n        this.parseConnections(length);\n        break;\n      case \"SSHA\":\n        this.parentForm = this.currentForm;\n        this.currentForm = this.currentSurface;\n        this.setupForm(\"surfaceShader\", length);\n        break;\n      case \"SSHD\":\n        this.setupForm(\"surfaceShaderData\", length);\n        break;\n      case \"ENTR\":\n        this.parseEntryForm(length);\n        break;\n      case \"IMAP\":\n        this.parseImageMap(length);\n        break;\n      case \"TAMP\":\n        this.parseXVAL(\"amplitude\", length);\n        break;\n      case \"TMAP\":\n        this.setupForm(\"textureMap\", length);\n        break;\n      case \"CNTR\":\n        this.parseXVAL3(\"center\", length);\n        break;\n      case \"SIZE\":\n        this.parseXVAL3(\"scale\", length);\n        break;\n      case \"ROTA\":\n        this.parseXVAL3(\"rotation\", length);\n        break;\n      default:\n        this.parseUnknownForm(type, length);\n    }\n    this.debugger.node = 0;\n    this.debugger.nodeID = type;\n    this.debugger.log();\n  }\n  setupForm(type, length) {\n    if (!this.currentForm)\n      this.currentForm = this.currentNode;\n    this.currentFormEnd = this.reader.offset + length;\n    this.parentForm = this.currentForm;\n    if (!this.currentForm[type]) {\n      this.currentForm[type] = {};\n      this.currentForm = this.currentForm[type];\n    } else {\n      console.warn(\"LWOLoader: form already exists on parent: \", type, this.currentForm);\n      this.currentForm = this.currentForm[type];\n    }\n  }\n  skipForm(length) {\n    this.reader.skip(length - 4);\n  }\n  parseUnknownForm(type, length) {\n    console.warn(\"LWOLoader: unknown FORM encountered: \" + type, length);\n    printBuffer(this.reader.dv.buffer, this.reader.offset, length - 4);\n    this.reader.skip(length - 4);\n  }\n  parseSurfaceForm(length) {\n    this.reader.skip(8);\n    var name = this.reader.getString();\n    var surface = {\n      attributes: {},\n      // LWO2 style non-node attributes will go here\n      connections: {},\n      name,\n      inputName: name,\n      nodes: {},\n      source: this.reader.getString()\n    };\n    this.tree.materials[name] = surface;\n    this.currentSurface = surface;\n    this.parentForm = this.tree.materials;\n    this.currentForm = surface;\n    this.currentFormEnd = this.reader.offset + length;\n  }\n  parseSurfaceLwo2(length) {\n    var name = this.reader.getString();\n    var surface = {\n      attributes: {},\n      // LWO2 style non-node attributes will go here\n      connections: {},\n      name,\n      nodes: {},\n      source: this.reader.getString()\n    };\n    this.tree.materials[name] = surface;\n    this.currentSurface = surface;\n    this.parentForm = this.tree.materials;\n    this.currentForm = surface;\n    this.currentFormEnd = this.reader.offset + length;\n  }\n  parseSubNode(length) {\n    this.reader.skip(8);\n    var name = this.reader.getString();\n    var node = {\n      name\n    };\n    this.currentForm = node;\n    this.currentNode = node;\n    this.currentFormEnd = this.reader.offset + length;\n  }\n  // collect attributes from all nodes at the top level of a surface\n  parseConnections(length) {\n    this.currentFormEnd = this.reader.offset + length;\n    this.parentForm = this.currentForm;\n    this.currentForm = this.currentSurface.connections;\n  }\n  // surface node attribute data, e.g. specular, roughness etc\n  parseEntryForm(length) {\n    this.reader.skip(8);\n    var name = this.reader.getString();\n    this.currentForm = this.currentNode.attributes;\n    this.setupForm(name, length);\n  }\n  // parse values from material - doesn't match up to other LWO3 data types\n  // sub form of entry form\n  parseValueForm() {\n    this.reader.skip(8);\n    var valueType = this.reader.getString();\n    if (valueType === \"double\") {\n      this.currentForm.value = this.reader.getUint64();\n    } else if (valueType === \"int\") {\n      this.currentForm.value = this.reader.getUint32();\n    } else if (valueType === \"vparam\") {\n      this.reader.skip(24);\n      this.currentForm.value = this.reader.getFloat64();\n    } else if (valueType === \"vparam3\") {\n      this.reader.skip(24);\n      this.currentForm.value = this.reader.getFloat64Array(3);\n    }\n  }\n  // holds various data about texture node image state\n  // Data other thanmipMapLevel unknown\n  parseImageStateForm() {\n    this.reader.skip(8);\n    this.currentForm.mipMapLevel = this.reader.getFloat32();\n  }\n  // LWO2 style image data node OR LWO3 textures defined at top level in editor (not as SURF node)\n  parseImageMap(length) {\n    this.currentFormEnd = this.reader.offset + length;\n    this.parentForm = this.currentForm;\n    if (!this.currentForm.maps)\n      this.currentForm.maps = [];\n    var map = {};\n    this.currentForm.maps.push(map);\n    this.currentForm = map;\n    this.reader.skip(10);\n  }\n  parseTextureNodeAttribute(type) {\n    this.reader.skip(28);\n    this.reader.skip(20);\n    switch (type) {\n      case \"ISCL\":\n        this.currentNode.scale = this.reader.getFloat32Array(3);\n        break;\n      case \"IPOS\":\n        this.currentNode.position = this.reader.getFloat32Array(3);\n        break;\n      case \"IROT\":\n        this.currentNode.rotation = this.reader.getFloat32Array(3);\n        break;\n      case \"IFAL\":\n        this.currentNode.falloff = this.reader.getFloat32Array(3);\n        break;\n      case \"IBMP\":\n        this.currentNode.amplitude = this.reader.getFloat32();\n        break;\n      case \"IUTD\":\n        this.currentNode.uTiles = this.reader.getFloat32();\n        break;\n      case \"IVTD\":\n        this.currentNode.vTiles = this.reader.getFloat32();\n        break;\n    }\n    this.reader.skip(2);\n  }\n  // ENVL forms are currently ignored\n  parseEnvelope(length) {\n    this.reader.skip(length - 4);\n  }\n  ///\n  // CHUNK PARSING METHODS\n  ///\n  // clips can either be defined inside a surface node, or at the top\n  // level and they have a different format in each case\n  parseClip(length) {\n    var tag = this.reader.getIDTag();\n    if (tag === \"FORM\") {\n      this.reader.skip(16);\n      this.currentNode.fileName = this.reader.getString();\n      return;\n    }\n    this.reader.setOffset(this.reader.offset - 4);\n    this.currentFormEnd = this.reader.offset + length;\n    this.parentForm = this.currentForm;\n    this.reader.skip(8);\n    var texture = {\n      index: this.reader.getUint32()\n    };\n    this.tree.textures.push(texture);\n    this.currentForm = texture;\n  }\n  parseClipLwo2(length) {\n    var texture = {\n      index: this.reader.getUint32(),\n      fileName: \"\"\n    };\n    while (true) {\n      var tag = this.reader.getIDTag();\n      var n_length = this.reader.getUint16();\n      if (tag === \"STIL\") {\n        texture.fileName = this.reader.getString();\n        break;\n      }\n      if (n_length >= length) {\n        break;\n      }\n    }\n    this.tree.textures.push(texture);\n    this.currentForm = texture;\n  }\n  parseImage() {\n    this.reader.skip(8);\n    this.currentForm.fileName = this.reader.getString();\n  }\n  parseXVAL(type, length) {\n    var endOffset = this.reader.offset + length - 4;\n    this.reader.skip(8);\n    this.currentForm[type] = this.reader.getFloat32();\n    this.reader.setOffset(endOffset);\n  }\n  parseXVAL3(type, length) {\n    var endOffset = this.reader.offset + length - 4;\n    this.reader.skip(8);\n    this.currentForm[type] = {\n      x: this.reader.getFloat32(),\n      y: this.reader.getFloat32(),\n      z: this.reader.getFloat32()\n    };\n    this.reader.setOffset(endOffset);\n  }\n  // Tags associated with an object\n  // OTAG { type[ID4], tag-string[S0] }\n  parseObjectTag() {\n    if (!this.tree.objectTags)\n      this.tree.objectTags = {};\n    this.tree.objectTags[this.reader.getIDTag()] = {\n      tagString: this.reader.getString()\n    };\n  }\n  // Signals the start of a new layer. All the data chunks which follow will be included in this layer until another layer chunk is encountered.\n  // LAYR: number[U2], flags[U2], pivot[VEC12], name[S0], parent[U2]\n  parseLayer(length) {\n    var layer = {\n      number: this.reader.getUint16(),\n      flags: this.reader.getUint16(),\n      // If the least significant bit of flags is set, the layer is hidden.\n      pivot: this.reader.getFloat32Array(3),\n      // Note: this seems to be superflous, as the geometry is translated when pivot is present\n      name: this.reader.getString()\n    };\n    this.tree.layers.push(layer);\n    this.currentLayer = layer;\n    var parsedLength = 16 + stringOffset(this.currentLayer.name);\n    this.currentLayer.parent = parsedLength < length ? this.reader.getUint16() : -1;\n  }\n  // VEC12 * ( F4 + F4 + F4 ) array of x,y,z vectors\n  // Converting from left to right handed coordinate system:\n  // x -> -x and switch material FrontSide -> BackSide\n  parsePoints(length) {\n    this.currentPoints = [];\n    for (var i = 0; i < length / 4; i += 3) {\n      this.currentPoints.push(this.reader.getFloat32(), this.reader.getFloat32(), -this.reader.getFloat32());\n    }\n  }\n  // parse VMAP or VMAD\n  // Associates a set of floating-point vectors with a set of points.\n  // VMAP: { type[ID4], dimension[U2], name[S0], ( vert[VX], value[F4] # dimension ) * }\n  // VMAD Associates a set of floating-point vectors with the vertices of specific polygons.\n  // Similar to VMAP UVs, but associates with polygon vertices rather than points\n  // to solve to problem of UV seams:  VMAD chunks are paired with VMAPs of the same name,\n  // if they exist. The vector values in the VMAD will then replace those in the\n  // corresponding VMAP, but only for calculations involving the specified polygons.\n  // VMAD { type[ID4], dimension[U2], name[S0], ( vert[VX], poly[VX], value[F4] # dimension ) * }\n  parseVertexMapping(length, discontinuous) {\n    var finalOffset = this.reader.offset + length;\n    var channelName = this.reader.getString();\n    if (this.reader.offset === finalOffset) {\n      this.currentForm.UVChannel = channelName;\n      return;\n    }\n    this.reader.setOffset(this.reader.offset - stringOffset(channelName));\n    var type = this.reader.getIDTag();\n    this.reader.getUint16();\n    var name = this.reader.getString();\n    var remainingLength = length - 6 - stringOffset(name);\n    switch (type) {\n      case \"TXUV\":\n        this.parseUVMapping(name, finalOffset, discontinuous);\n        break;\n      case \"MORF\":\n      case \"SPOT\":\n        this.parseMorphTargets(name, finalOffset, type);\n        break;\n      case \"APSL\":\n      case \"NORM\":\n      case \"WGHT\":\n      case \"MNVW\":\n      case \"PICK\":\n      case \"RGB \":\n      case \"RGBA\":\n        this.reader.skip(remainingLength);\n        break;\n      default:\n        console.warn(\"LWOLoader: unknown vertex map type: \" + type);\n        this.reader.skip(remainingLength);\n    }\n  }\n  parseUVMapping(name, finalOffset, discontinuous) {\n    var uvIndices = [];\n    var polyIndices = [];\n    var uvs = [];\n    while (this.reader.offset < finalOffset) {\n      uvIndices.push(this.reader.getVariableLengthIndex());\n      if (discontinuous)\n        polyIndices.push(this.reader.getVariableLengthIndex());\n      uvs.push(this.reader.getFloat32(), this.reader.getFloat32());\n    }\n    if (discontinuous) {\n      if (!this.currentLayer.discontinuousUVs)\n        this.currentLayer.discontinuousUVs = {};\n      this.currentLayer.discontinuousUVs[name] = {\n        uvIndices,\n        polyIndices,\n        uvs\n      };\n    } else {\n      if (!this.currentLayer.uvs)\n        this.currentLayer.uvs = {};\n      this.currentLayer.uvs[name] = {\n        uvIndices,\n        uvs\n      };\n    }\n  }\n  parseMorphTargets(name, finalOffset, type) {\n    var indices = [];\n    var points = [];\n    type = type === \"MORF\" ? \"relative\" : \"absolute\";\n    while (this.reader.offset < finalOffset) {\n      indices.push(this.reader.getVariableLengthIndex());\n      points.push(this.reader.getFloat32(), this.reader.getFloat32(), -this.reader.getFloat32());\n    }\n    if (!this.currentLayer.morphTargets)\n      this.currentLayer.morphTargets = {};\n    this.currentLayer.morphTargets[name] = {\n      indices,\n      points,\n      type\n    };\n  }\n  // A list of polygons for the current layer.\n  // POLS { type[ID4], ( numvert+flags[U2], vert[VX] # numvert ) * }\n  parsePolygonList(length) {\n    var finalOffset = this.reader.offset + length;\n    var type = this.reader.getIDTag();\n    var indices = [];\n    var polygonDimensions = [];\n    while (this.reader.offset < finalOffset) {\n      var numverts = this.reader.getUint16();\n      numverts = numverts & 1023;\n      polygonDimensions.push(numverts);\n      for (var j = 0; j < numverts; j++)\n        indices.push(this.reader.getVariableLengthIndex());\n    }\n    var geometryData = {\n      type,\n      vertexIndices: indices,\n      polygonDimensions,\n      points: this.currentPoints\n    };\n    if (polygonDimensions[0] === 1)\n      geometryData.type = \"points\";\n    else if (polygonDimensions[0] === 2)\n      geometryData.type = \"lines\";\n    this.currentLayer.geometry = geometryData;\n  }\n  // Lists the tag strings that can be associated with polygons by the PTAG chunk.\n  // TAGS { tag-string[S0] * }\n  parseTagStrings(length) {\n    this.tree.tags = this.reader.getStringArray(length);\n  }\n  // Associates tags of a given type with polygons in the most recent POLS chunk.\n  // PTAG { type[ID4], ( poly[VX], tag[U2] ) * }\n  parsePolygonTagMapping(length) {\n    var finalOffset = this.reader.offset + length;\n    var type = this.reader.getIDTag();\n    if (type === \"SURF\")\n      this.parseMaterialIndices(finalOffset);\n    else {\n      this.reader.skip(length - 4);\n    }\n  }\n  parseMaterialIndices(finalOffset) {\n    this.currentLayer.geometry.materialIndices = [];\n    while (this.reader.offset < finalOffset) {\n      var polygonIndex = this.reader.getVariableLengthIndex();\n      var materialIndex = this.reader.getUint16();\n      this.currentLayer.geometry.materialIndices.push(polygonIndex, materialIndex);\n    }\n  }\n  parseUnknownCHUNK(blockID, length) {\n    console.warn(\"LWOLoader: unknown chunk type: \" + blockID + \" length: \" + length);\n    var data = this.reader.getString(length);\n    this.currentForm[blockID] = data;\n  }\n}\nclass DataViewReader {\n  constructor(buffer) {\n    this.dv = new DataView(buffer);\n    this.offset = 0;\n    this._textDecoder = new TextDecoder();\n    this._bytes = new Uint8Array(buffer);\n  }\n  size() {\n    return this.dv.buffer.byteLength;\n  }\n  setOffset(offset) {\n    if (offset > 0 && offset < this.dv.buffer.byteLength) {\n      this.offset = offset;\n    } else {\n      console.error(\"LWOLoader: invalid buffer offset\");\n    }\n  }\n  endOfFile() {\n    if (this.offset >= this.size())\n      return true;\n    return false;\n  }\n  skip(length) {\n    this.offset += length;\n  }\n  getUint8() {\n    var value = this.dv.getUint8(this.offset);\n    this.offset += 1;\n    return value;\n  }\n  getUint16() {\n    var value = this.dv.getUint16(this.offset);\n    this.offset += 2;\n    return value;\n  }\n  getInt32() {\n    var value = this.dv.getInt32(this.offset, false);\n    this.offset += 4;\n    return value;\n  }\n  getUint32() {\n    var value = this.dv.getUint32(this.offset, false);\n    this.offset += 4;\n    return value;\n  }\n  getUint64() {\n    var low, high;\n    high = this.getUint32();\n    low = this.getUint32();\n    return high * 4294967296 + low;\n  }\n  getFloat32() {\n    var value = this.dv.getFloat32(this.offset, false);\n    this.offset += 4;\n    return value;\n  }\n  getFloat32Array(size) {\n    var a = [];\n    for (var i = 0; i < size; i++) {\n      a.push(this.getFloat32());\n    }\n    return a;\n  }\n  getFloat64() {\n    var value = this.dv.getFloat64(this.offset, this.littleEndian);\n    this.offset += 8;\n    return value;\n  }\n  getFloat64Array(size) {\n    var a = [];\n    for (var i = 0; i < size; i++) {\n      a.push(this.getFloat64());\n    }\n    return a;\n  }\n  // get variable-length index data type\n  // VX ::= index[U2] | (index + 0xFF000000)[U4]\n  // If the index value is less than 65,280 (0xFF00),then VX === U2\n  // otherwise VX === U4 with bits 24-31 set\n  // When reading an index, if the first byte encountered is 255 (0xFF), then\n  // the four-byte form is being used and the first byte should be discarded or masked out.\n  getVariableLengthIndex() {\n    var firstByte = this.getUint8();\n    if (firstByte === 255) {\n      return this.getUint8() * 65536 + this.getUint8() * 256 + this.getUint8();\n    }\n    return firstByte * 256 + this.getUint8();\n  }\n  // An ID tag is a sequence of 4 bytes containing 7-bit ASCII values\n  getIDTag() {\n    return this.getString(4);\n  }\n  getString(size) {\n    if (size === 0)\n      return;\n    const start = this.offset;\n    let result;\n    let length;\n    if (size) {\n      length = size;\n      result = this._textDecoder.decode(new Uint8Array(this.dv.buffer, start, size));\n    } else {\n      length = this._bytes.indexOf(0, start) - start;\n      result = this._textDecoder.decode(new Uint8Array(this.dv.buffer, start, length));\n      length++;\n      length += length % 2;\n    }\n    this.skip(length);\n    return result;\n  }\n  getStringArray(size) {\n    var a = this.getString(size);\n    a = a.split(\"\\0\");\n    return a.filter(Boolean);\n  }\n}\nclass Debugger {\n  constructor() {\n    this.active = false;\n    this.depth = 0;\n    this.formList = [];\n  }\n  enable() {\n    this.active = true;\n  }\n  log() {\n    if (!this.active)\n      return;\n    var nodeType;\n    switch (this.node) {\n      case 0:\n        nodeType = \"FORM\";\n        break;\n      case 1:\n        nodeType = \"CHK\";\n        break;\n      case 2:\n        nodeType = \"S-CHK\";\n        break;\n    }\n    console.log(\n      \"| \".repeat(this.depth) + nodeType,\n      this.nodeID,\n      `( ${this.offset} ) -> ( ${this.dataOffset + this.length} )`,\n      this.node == 0 ? \" {\" : \"\",\n      this.skipped ? \"SKIPPED\" : \"\",\n      this.node == 0 && this.skipped ? \"}\" : \"\"\n    );\n    if (this.node == 0 && !this.skipped) {\n      this.depth += 1;\n      this.formList.push(this.dataOffset + this.length);\n    }\n    this.skipped = false;\n  }\n  closeForms() {\n    if (!this.active)\n      return;\n    for (var i = this.formList.length - 1; i >= 0; i--) {\n      if (this.offset >= this.formList[i]) {\n        this.depth -= 1;\n        console.log(\"| \".repeat(this.depth) + \"}\");\n        this.formList.splice(-1, 1);\n      }\n    }\n  }\n}\nfunction isEven(num) {\n  return num % 2;\n}\nfunction stringOffset(string) {\n  return string.length + 1 + (isEven(string.length + 1) ? 1 : 0);\n}\nfunction printBuffer(buffer, from, to) {\n  console.log(new TextDecoder().decode(new Uint8Array(buffer, from, to)));\n}\nexport {\n  IFFParser\n};\n"]},"metadata":{},"sourceType":"module"}