{"ast":null,"code":"import { BufferGeometry, Vector3, Matrix4, Float32BufferAttribute } from \"three\";\n\nclass DecalGeometry extends BufferGeometry {\n  constructor(mesh, position, orientation, size) {\n    super();\n    const vertices = [];\n    const normals = [];\n    const uvs = [];\n    const plane = new Vector3();\n    const projectorMatrix = new Matrix4();\n    projectorMatrix.makeRotationFromEuler(orientation);\n    projectorMatrix.setPosition(position);\n    const projectorMatrixInverse = new Matrix4();\n    projectorMatrixInverse.copy(projectorMatrix).invert();\n    generate();\n    this.setAttribute(\"position\", new Float32BufferAttribute(vertices, 3));\n    this.setAttribute(\"normal\", new Float32BufferAttribute(normals, 3));\n    this.setAttribute(\"uv\", new Float32BufferAttribute(uvs, 2));\n\n    function generate() {\n      let i;\n      let decalVertices = [];\n      const vertex = new Vector3();\n      const normal = new Vector3();\n\n      if (mesh.geometry.isGeometry === true) {\n        console.error(\"THREE.DecalGeometry no longer supports THREE.Geometry. Use BufferGeometry instead.\");\n        return;\n      }\n\n      const geometry = mesh.geometry;\n      const positionAttribute = geometry.attributes.position;\n      const normalAttribute = geometry.attributes.normal;\n\n      if (geometry.index !== null) {\n        const index = geometry.index;\n\n        for (i = 0; i < index.count; i++) {\n          vertex.fromBufferAttribute(positionAttribute, index.getX(i));\n          normal.fromBufferAttribute(normalAttribute, index.getX(i));\n          pushDecalVertex(decalVertices, vertex, normal);\n        }\n      } else {\n        for (i = 0; i < positionAttribute.count; i++) {\n          vertex.fromBufferAttribute(positionAttribute, i);\n          normal.fromBufferAttribute(normalAttribute, i);\n          pushDecalVertex(decalVertices, vertex, normal);\n        }\n      }\n\n      decalVertices = clipGeometry(decalVertices, plane.set(1, 0, 0));\n      decalVertices = clipGeometry(decalVertices, plane.set(-1, 0, 0));\n      decalVertices = clipGeometry(decalVertices, plane.set(0, 1, 0));\n      decalVertices = clipGeometry(decalVertices, plane.set(0, -1, 0));\n      decalVertices = clipGeometry(decalVertices, plane.set(0, 0, 1));\n      decalVertices = clipGeometry(decalVertices, plane.set(0, 0, -1));\n\n      for (i = 0; i < decalVertices.length; i++) {\n        const decalVertex = decalVertices[i];\n        uvs.push(0.5 + decalVertex.position.x / size.x, 0.5 + decalVertex.position.y / size.y);\n        decalVertex.position.applyMatrix4(projectorMatrix);\n        vertices.push(decalVertex.position.x, decalVertex.position.y, decalVertex.position.z);\n        normals.push(decalVertex.normal.x, decalVertex.normal.y, decalVertex.normal.z);\n      }\n    }\n\n    function pushDecalVertex(decalVertices, vertex, normal) {\n      vertex.applyMatrix4(mesh.matrixWorld);\n      vertex.applyMatrix4(projectorMatrixInverse);\n      normal.transformDirection(mesh.matrixWorld);\n      decalVertices.push(new DecalVertex(vertex.clone(), normal.clone()));\n    }\n\n    function clipGeometry(inVertices, plane2) {\n      const outVertices = [];\n      const s = 0.5 * Math.abs(size.dot(plane2));\n\n      for (let i = 0; i < inVertices.length; i += 3) {\n        let v1Out,\n            v2Out,\n            v3Out,\n            total = 0;\n        let nV1, nV2, nV3, nV4;\n        const d1 = inVertices[i + 0].position.dot(plane2) - s;\n        const d2 = inVertices[i + 1].position.dot(plane2) - s;\n        const d3 = inVertices[i + 2].position.dot(plane2) - s;\n        v1Out = d1 > 0;\n        v2Out = d2 > 0;\n        v3Out = d3 > 0;\n        total = (v1Out ? 1 : 0) + (v2Out ? 1 : 0) + (v3Out ? 1 : 0);\n\n        switch (total) {\n          case 0:\n            {\n              outVertices.push(inVertices[i]);\n              outVertices.push(inVertices[i + 1]);\n              outVertices.push(inVertices[i + 2]);\n              break;\n            }\n\n          case 1:\n            {\n              if (v1Out) {\n                nV1 = inVertices[i + 1];\n                nV2 = inVertices[i + 2];\n                nV3 = clip(inVertices[i], nV1, plane2, s);\n                nV4 = clip(inVertices[i], nV2, plane2, s);\n              }\n\n              if (v2Out) {\n                nV1 = inVertices[i];\n                nV2 = inVertices[i + 2];\n                nV3 = clip(inVertices[i + 1], nV1, plane2, s);\n                nV4 = clip(inVertices[i + 1], nV2, plane2, s);\n                outVertices.push(nV3);\n                outVertices.push(nV2.clone());\n                outVertices.push(nV1.clone());\n                outVertices.push(nV2.clone());\n                outVertices.push(nV3.clone());\n                outVertices.push(nV4);\n                break;\n              }\n\n              if (v3Out) {\n                nV1 = inVertices[i];\n                nV2 = inVertices[i + 1];\n                nV3 = clip(inVertices[i + 2], nV1, plane2, s);\n                nV4 = clip(inVertices[i + 2], nV2, plane2, s);\n              }\n\n              outVertices.push(nV1.clone());\n              outVertices.push(nV2.clone());\n              outVertices.push(nV3);\n              outVertices.push(nV4);\n              outVertices.push(nV3.clone());\n              outVertices.push(nV2.clone());\n              break;\n            }\n\n          case 2:\n            {\n              if (!v1Out) {\n                nV1 = inVertices[i].clone();\n                nV2 = clip(nV1, inVertices[i + 1], plane2, s);\n                nV3 = clip(nV1, inVertices[i + 2], plane2, s);\n                outVertices.push(nV1);\n                outVertices.push(nV2);\n                outVertices.push(nV3);\n              }\n\n              if (!v2Out) {\n                nV1 = inVertices[i + 1].clone();\n                nV2 = clip(nV1, inVertices[i + 2], plane2, s);\n                nV3 = clip(nV1, inVertices[i], plane2, s);\n                outVertices.push(nV1);\n                outVertices.push(nV2);\n                outVertices.push(nV3);\n              }\n\n              if (!v3Out) {\n                nV1 = inVertices[i + 2].clone();\n                nV2 = clip(nV1, inVertices[i], plane2, s);\n                nV3 = clip(nV1, inVertices[i + 1], plane2, s);\n                outVertices.push(nV1);\n                outVertices.push(nV2);\n                outVertices.push(nV3);\n              }\n\n              break;\n            }\n\n          case 3:\n            {\n              break;\n            }\n        }\n      }\n\n      return outVertices;\n    }\n\n    function clip(v0, v1, p, s) {\n      const d0 = v0.position.dot(p) - s;\n      const d1 = v1.position.dot(p) - s;\n      const s0 = d0 / (d0 - d1);\n      const v = new DecalVertex(new Vector3(v0.position.x + s0 * (v1.position.x - v0.position.x), v0.position.y + s0 * (v1.position.y - v0.position.y), v0.position.z + s0 * (v1.position.z - v0.position.z)), new Vector3(v0.normal.x + s0 * (v1.normal.x - v0.normal.x), v0.normal.y + s0 * (v1.normal.y - v0.normal.y), v0.normal.z + s0 * (v1.normal.z - v0.normal.z)));\n      return v;\n    }\n  }\n\n}\n\nclass DecalVertex {\n  constructor(position, normal) {\n    this.position = position;\n    this.normal = normal;\n  }\n\n  clone() {\n    return new this.constructor(this.position.clone(), this.normal.clone());\n  }\n\n}\n\nexport { DecalGeometry, DecalVertex };","map":{"version":3,"sources":["/Users/theodaguier/Developer/old/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/three-stdlib/geometries/DecalGeometry.js"],"names":["BufferGeometry","Vector3","Matrix4","Float32BufferAttribute","DecalGeometry","constructor","mesh","position","orientation","size","vertices","normals","uvs","plane","projectorMatrix","makeRotationFromEuler","setPosition","projectorMatrixInverse","copy","invert","generate","setAttribute","i","decalVertices","vertex","normal","geometry","isGeometry","console","error","positionAttribute","attributes","normalAttribute","index","count","fromBufferAttribute","getX","pushDecalVertex","clipGeometry","set","length","decalVertex","push","x","y","applyMatrix4","z","matrixWorld","transformDirection","DecalVertex","clone","inVertices","plane2","outVertices","s","Math","abs","dot","v1Out","v2Out","v3Out","total","nV1","nV2","nV3","nV4","d1","d2","d3","clip","v0","v1","p","d0","s0","v"],"mappings":"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","sourcesContent":["import { BufferGeometry, Vector3, Matrix4, Float32BufferAttribute } from \"three\";\nclass DecalGeometry extends BufferGeometry {\n  constructor(mesh, position, orientation, size) {\n    super();\n    const vertices = [];\n    const normals = [];\n    const uvs = [];\n    const plane = new Vector3();\n    const projectorMatrix = new Matrix4();\n    projectorMatrix.makeRotationFromEuler(orientation);\n    projectorMatrix.setPosition(position);\n    const projectorMatrixInverse = new Matrix4();\n    projectorMatrixInverse.copy(projectorMatrix).invert();\n    generate();\n    this.setAttribute(\"position\", new Float32BufferAttribute(vertices, 3));\n    this.setAttribute(\"normal\", new Float32BufferAttribute(normals, 3));\n    this.setAttribute(\"uv\", new Float32BufferAttribute(uvs, 2));\n    function generate() {\n      let i;\n      let decalVertices = [];\n      const vertex = new Vector3();\n      const normal = new Vector3();\n      if (mesh.geometry.isGeometry === true) {\n        console.error(\"THREE.DecalGeometry no longer supports THREE.Geometry. Use BufferGeometry instead.\");\n        return;\n      }\n      const geometry = mesh.geometry;\n      const positionAttribute = geometry.attributes.position;\n      const normalAttribute = geometry.attributes.normal;\n      if (geometry.index !== null) {\n        const index = geometry.index;\n        for (i = 0; i < index.count; i++) {\n          vertex.fromBufferAttribute(positionAttribute, index.getX(i));\n          normal.fromBufferAttribute(normalAttribute, index.getX(i));\n          pushDecalVertex(decalVertices, vertex, normal);\n        }\n      } else {\n        for (i = 0; i < positionAttribute.count; i++) {\n          vertex.fromBufferAttribute(positionAttribute, i);\n          normal.fromBufferAttribute(normalAttribute, i);\n          pushDecalVertex(decalVertices, vertex, normal);\n        }\n      }\n      decalVertices = clipGeometry(decalVertices, plane.set(1, 0, 0));\n      decalVertices = clipGeometry(decalVertices, plane.set(-1, 0, 0));\n      decalVertices = clipGeometry(decalVertices, plane.set(0, 1, 0));\n      decalVertices = clipGeometry(decalVertices, plane.set(0, -1, 0));\n      decalVertices = clipGeometry(decalVertices, plane.set(0, 0, 1));\n      decalVertices = clipGeometry(decalVertices, plane.set(0, 0, -1));\n      for (i = 0; i < decalVertices.length; i++) {\n        const decalVertex = decalVertices[i];\n        uvs.push(0.5 + decalVertex.position.x / size.x, 0.5 + decalVertex.position.y / size.y);\n        decalVertex.position.applyMatrix4(projectorMatrix);\n        vertices.push(decalVertex.position.x, decalVertex.position.y, decalVertex.position.z);\n        normals.push(decalVertex.normal.x, decalVertex.normal.y, decalVertex.normal.z);\n      }\n    }\n    function pushDecalVertex(decalVertices, vertex, normal) {\n      vertex.applyMatrix4(mesh.matrixWorld);\n      vertex.applyMatrix4(projectorMatrixInverse);\n      normal.transformDirection(mesh.matrixWorld);\n      decalVertices.push(new DecalVertex(vertex.clone(), normal.clone()));\n    }\n    function clipGeometry(inVertices, plane2) {\n      const outVertices = [];\n      const s = 0.5 * Math.abs(size.dot(plane2));\n      for (let i = 0; i < inVertices.length; i += 3) {\n        let v1Out, v2Out, v3Out, total = 0;\n        let nV1, nV2, nV3, nV4;\n        const d1 = inVertices[i + 0].position.dot(plane2) - s;\n        const d2 = inVertices[i + 1].position.dot(plane2) - s;\n        const d3 = inVertices[i + 2].position.dot(plane2) - s;\n        v1Out = d1 > 0;\n        v2Out = d2 > 0;\n        v3Out = d3 > 0;\n        total = (v1Out ? 1 : 0) + (v2Out ? 1 : 0) + (v3Out ? 1 : 0);\n        switch (total) {\n          case 0: {\n            outVertices.push(inVertices[i]);\n            outVertices.push(inVertices[i + 1]);\n            outVertices.push(inVertices[i + 2]);\n            break;\n          }\n          case 1: {\n            if (v1Out) {\n              nV1 = inVertices[i + 1];\n              nV2 = inVertices[i + 2];\n              nV3 = clip(inVertices[i], nV1, plane2, s);\n              nV4 = clip(inVertices[i], nV2, plane2, s);\n            }\n            if (v2Out) {\n              nV1 = inVertices[i];\n              nV2 = inVertices[i + 2];\n              nV3 = clip(inVertices[i + 1], nV1, plane2, s);\n              nV4 = clip(inVertices[i + 1], nV2, plane2, s);\n              outVertices.push(nV3);\n              outVertices.push(nV2.clone());\n              outVertices.push(nV1.clone());\n              outVertices.push(nV2.clone());\n              outVertices.push(nV3.clone());\n              outVertices.push(nV4);\n              break;\n            }\n            if (v3Out) {\n              nV1 = inVertices[i];\n              nV2 = inVertices[i + 1];\n              nV3 = clip(inVertices[i + 2], nV1, plane2, s);\n              nV4 = clip(inVertices[i + 2], nV2, plane2, s);\n            }\n            outVertices.push(nV1.clone());\n            outVertices.push(nV2.clone());\n            outVertices.push(nV3);\n            outVertices.push(nV4);\n            outVertices.push(nV3.clone());\n            outVertices.push(nV2.clone());\n            break;\n          }\n          case 2: {\n            if (!v1Out) {\n              nV1 = inVertices[i].clone();\n              nV2 = clip(nV1, inVertices[i + 1], plane2, s);\n              nV3 = clip(nV1, inVertices[i + 2], plane2, s);\n              outVertices.push(nV1);\n              outVertices.push(nV2);\n              outVertices.push(nV3);\n            }\n            if (!v2Out) {\n              nV1 = inVertices[i + 1].clone();\n              nV2 = clip(nV1, inVertices[i + 2], plane2, s);\n              nV3 = clip(nV1, inVertices[i], plane2, s);\n              outVertices.push(nV1);\n              outVertices.push(nV2);\n              outVertices.push(nV3);\n            }\n            if (!v3Out) {\n              nV1 = inVertices[i + 2].clone();\n              nV2 = clip(nV1, inVertices[i], plane2, s);\n              nV3 = clip(nV1, inVertices[i + 1], plane2, s);\n              outVertices.push(nV1);\n              outVertices.push(nV2);\n              outVertices.push(nV3);\n            }\n            break;\n          }\n          case 3: {\n            break;\n          }\n        }\n      }\n      return outVertices;\n    }\n    function clip(v0, v1, p, s) {\n      const d0 = v0.position.dot(p) - s;\n      const d1 = v1.position.dot(p) - s;\n      const s0 = d0 / (d0 - d1);\n      const v = new DecalVertex(\n        new Vector3(\n          v0.position.x + s0 * (v1.position.x - v0.position.x),\n          v0.position.y + s0 * (v1.position.y - v0.position.y),\n          v0.position.z + s0 * (v1.position.z - v0.position.z)\n        ),\n        new Vector3(\n          v0.normal.x + s0 * (v1.normal.x - v0.normal.x),\n          v0.normal.y + s0 * (v1.normal.y - v0.normal.y),\n          v0.normal.z + s0 * (v1.normal.z - v0.normal.z)\n        )\n      );\n      return v;\n    }\n  }\n}\nclass DecalVertex {\n  constructor(position, normal) {\n    this.position = position;\n    this.normal = normal;\n  }\n  clone() {\n    return new this.constructor(this.position.clone(), this.normal.clone());\n  }\n}\nexport {\n  DecalGeometry,\n  DecalVertex\n};\n"]},"metadata":{},"sourceType":"module"}