{"ast":null,"code":"import { BufferAttribute, DynamicDrawUsage, BufferGeometry, MeshStandardMaterial, Mesh, Vector3, Color, Matrix4 } from \"three\";\n\nfunction TubePainter() {\n  const BUFFER_SIZE = 1e6 * 3;\n  const positions = new BufferAttribute(new Float32Array(BUFFER_SIZE), 3);\n  positions.usage = DynamicDrawUsage;\n  const normals = new BufferAttribute(new Float32Array(BUFFER_SIZE), 3);\n  normals.usage = DynamicDrawUsage;\n  const colors = new BufferAttribute(new Float32Array(BUFFER_SIZE), 3);\n  colors.usage = DynamicDrawUsage;\n  const geometry = new BufferGeometry();\n  geometry.setAttribute(\"position\", positions);\n  geometry.setAttribute(\"normal\", normals);\n  geometry.setAttribute(\"color\", colors);\n  geometry.drawRange.count = 0;\n  const material = new MeshStandardMaterial({\n    vertexColors: true\n  });\n  const mesh = new Mesh(geometry, material);\n  mesh.frustumCulled = false;\n\n  function getPoints(size2) {\n    const PI2 = Math.PI * 2;\n    const sides = 10;\n    const array = [];\n    const radius = 0.01 * size2;\n\n    for (let i = 0; i < sides; i++) {\n      const angle = i / sides * PI2;\n      array.push(new Vector3(Math.sin(angle) * radius, Math.cos(angle) * radius, 0));\n    }\n\n    return array;\n  }\n\n  const vector1 = new Vector3();\n  const vector2 = new Vector3();\n  const vector3 = new Vector3();\n  const vector4 = new Vector3();\n  const color = new Color(16777215);\n  let size = 1;\n\n  function stroke(position1, position2, matrix12, matrix22) {\n    if (position1.distanceToSquared(position2) === 0) return;\n    let count2 = geometry.drawRange.count;\n    const points = getPoints(size);\n\n    for (let i = 0, il = points.length; i < il; i++) {\n      const vertex1 = points[i];\n      const vertex2 = points[(i + 1) % il];\n      vector1.copy(vertex1).applyMatrix4(matrix22).add(position2);\n      vector2.copy(vertex2).applyMatrix4(matrix22).add(position2);\n      vector3.copy(vertex2).applyMatrix4(matrix12).add(position1);\n      vector4.copy(vertex1).applyMatrix4(matrix12).add(position1);\n      vector1.toArray(positions.array, (count2 + 0) * 3);\n      vector2.toArray(positions.array, (count2 + 1) * 3);\n      vector4.toArray(positions.array, (count2 + 2) * 3);\n      vector2.toArray(positions.array, (count2 + 3) * 3);\n      vector3.toArray(positions.array, (count2 + 4) * 3);\n      vector4.toArray(positions.array, (count2 + 5) * 3);\n      vector1.copy(vertex1).applyMatrix4(matrix22).normalize();\n      vector2.copy(vertex2).applyMatrix4(matrix22).normalize();\n      vector3.copy(vertex2).applyMatrix4(matrix12).normalize();\n      vector4.copy(vertex1).applyMatrix4(matrix12).normalize();\n      vector1.toArray(normals.array, (count2 + 0) * 3);\n      vector2.toArray(normals.array, (count2 + 1) * 3);\n      vector4.toArray(normals.array, (count2 + 2) * 3);\n      vector2.toArray(normals.array, (count2 + 3) * 3);\n      vector3.toArray(normals.array, (count2 + 4) * 3);\n      vector4.toArray(normals.array, (count2 + 5) * 3);\n      color.toArray(colors.array, (count2 + 0) * 3);\n      color.toArray(colors.array, (count2 + 1) * 3);\n      color.toArray(colors.array, (count2 + 2) * 3);\n      color.toArray(colors.array, (count2 + 3) * 3);\n      color.toArray(colors.array, (count2 + 4) * 3);\n      color.toArray(colors.array, (count2 + 5) * 3);\n      count2 += 6;\n    }\n\n    geometry.drawRange.count = count2;\n  }\n\n  const up = new Vector3(0, 1, 0);\n  const point1 = new Vector3();\n  const point2 = new Vector3();\n  const matrix1 = new Matrix4();\n  const matrix2 = new Matrix4();\n\n  function moveTo(position) {\n    point1.copy(position);\n    matrix1.lookAt(point2, point1, up);\n    point2.copy(position);\n    matrix2.copy(matrix1);\n  }\n\n  function lineTo(position) {\n    point1.copy(position);\n    matrix1.lookAt(point2, point1, up);\n    stroke(point1, point2, matrix1, matrix2);\n    point2.copy(point1);\n    matrix2.copy(matrix1);\n  }\n\n  function setSize(value) {\n    size = value;\n  }\n\n  let count = 0;\n\n  function update() {\n    const start = count;\n    const end = geometry.drawRange.count;\n    if (start === end) return;\n    positions.updateRange.offset = start * 3;\n    positions.updateRange.count = (end - start) * 3;\n    positions.needsUpdate = true;\n    normals.updateRange.offset = start * 3;\n    normals.updateRange.count = (end - start) * 3;\n    normals.needsUpdate = true;\n    colors.updateRange.offset = start * 3;\n    colors.updateRange.count = (end - start) * 3;\n    colors.needsUpdate = true;\n    count = geometry.drawRange.count;\n  }\n\n  return {\n    mesh,\n    moveTo,\n    lineTo,\n    setSize,\n    update\n  };\n}\n\nexport { TubePainter };","map":{"version":3,"sources":["/Users/theodaguier/_workdir/dev/pro/e-do/E-Do-Studio/node_modules/three-stdlib/misc/TubePainter.js"],"names":["BufferAttribute","DynamicDrawUsage","BufferGeometry","MeshStandardMaterial","Mesh","Vector3","Color","Matrix4","TubePainter","BUFFER_SIZE","positions","Float32Array","usage","normals","colors","geometry","setAttribute","drawRange","count","material","vertexColors","mesh","frustumCulled","getPoints","size2","PI2","Math","PI","sides","array","radius","i","angle","push","sin","cos","vector1","vector2","vector3","vector4","color","size","stroke","position1","position2","matrix12","matrix22","distanceToSquared","count2","points","il","length","vertex1","vertex2","copy","applyMatrix4","add","toArray","normalize","up","point1","point2","matrix1","matrix2","moveTo","position","lookAt","lineTo","setSize","value","update","start","end","updateRange","offset","needsUpdate"],"mappings":"AAAA,SAASA,eAAT,EAA0BC,gBAA1B,EAA4CC,cAA5C,EAA4DC,oBAA5D,EAAkFC,IAAlF,EAAwFC,OAAxF,EAAiGC,KAAjG,EAAwGC,OAAxG,QAAuH,OAAvH;;AACA,SAASC,WAAT,GAAuB;AACrB,QAAMC,WAAW,GAAG,MAAM,CAA1B;AACA,QAAMC,SAAS,GAAG,IAAIV,eAAJ,CAAoB,IAAIW,YAAJ,CAAiBF,WAAjB,CAApB,EAAmD,CAAnD,CAAlB;AACAC,EAAAA,SAAS,CAACE,KAAV,GAAkBX,gBAAlB;AACA,QAAMY,OAAO,GAAG,IAAIb,eAAJ,CAAoB,IAAIW,YAAJ,CAAiBF,WAAjB,CAApB,EAAmD,CAAnD,CAAhB;AACAI,EAAAA,OAAO,CAACD,KAAR,GAAgBX,gBAAhB;AACA,QAAMa,MAAM,GAAG,IAAId,eAAJ,CAAoB,IAAIW,YAAJ,CAAiBF,WAAjB,CAApB,EAAmD,CAAnD,CAAf;AACAK,EAAAA,MAAM,CAACF,KAAP,GAAeX,gBAAf;AACA,QAAMc,QAAQ,GAAG,IAAIb,cAAJ,EAAjB;AACAa,EAAAA,QAAQ,CAACC,YAAT,CAAsB,UAAtB,EAAkCN,SAAlC;AACAK,EAAAA,QAAQ,CAACC,YAAT,CAAsB,QAAtB,EAAgCH,OAAhC;AACAE,EAAAA,QAAQ,CAACC,YAAT,CAAsB,OAAtB,EAA+BF,MAA/B;AACAC,EAAAA,QAAQ,CAACE,SAAT,CAAmBC,KAAnB,GAA2B,CAA3B;AACA,QAAMC,QAAQ,GAAG,IAAIhB,oBAAJ,CAAyB;AACxCiB,IAAAA,YAAY,EAAE;AAD0B,GAAzB,CAAjB;AAGA,QAAMC,IAAI,GAAG,IAAIjB,IAAJ,CAASW,QAAT,EAAmBI,QAAnB,CAAb;AACAE,EAAAA,IAAI,CAACC,aAAL,GAAqB,KAArB;;AACA,WAASC,SAAT,CAAmBC,KAAnB,EAA0B;AACxB,UAAMC,GAAG,GAAGC,IAAI,CAACC,EAAL,GAAU,CAAtB;AACA,UAAMC,KAAK,GAAG,EAAd;AACA,UAAMC,KAAK,GAAG,EAAd;AACA,UAAMC,MAAM,GAAG,OAAON,KAAtB;;AACA,SAAK,IAAIO,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,KAApB,EAA2BG,CAAC,EAA5B,EAAgC;AAC9B,YAAMC,KAAK,GAAGD,CAAC,GAAGH,KAAJ,GAAYH,GAA1B;AACAI,MAAAA,KAAK,CAACI,IAAN,CAAW,IAAI5B,OAAJ,CAAYqB,IAAI,CAACQ,GAAL,CAASF,KAAT,IAAkBF,MAA9B,EAAsCJ,IAAI,CAACS,GAAL,CAASH,KAAT,IAAkBF,MAAxD,EAAgE,CAAhE,CAAX;AACD;;AACD,WAAOD,KAAP;AACD;;AACD,QAAMO,OAAO,GAAG,IAAI/B,OAAJ,EAAhB;AACA,QAAMgC,OAAO,GAAG,IAAIhC,OAAJ,EAAhB;AACA,QAAMiC,OAAO,GAAG,IAAIjC,OAAJ,EAAhB;AACA,QAAMkC,OAAO,GAAG,IAAIlC,OAAJ,EAAhB;AACA,QAAMmC,KAAK,GAAG,IAAIlC,KAAJ,CAAU,QAAV,CAAd;AACA,MAAImC,IAAI,GAAG,CAAX;;AACA,WAASC,MAAT,CAAgBC,SAAhB,EAA2BC,SAA3B,EAAsCC,QAAtC,EAAgDC,QAAhD,EAA0D;AACxD,QAAIH,SAAS,CAACI,iBAAV,CAA4BH,SAA5B,MAA2C,CAA/C,EACE;AACF,QAAII,MAAM,GAAGjC,QAAQ,CAACE,SAAT,CAAmBC,KAAhC;AACA,UAAM+B,MAAM,GAAG1B,SAAS,CAACkB,IAAD,CAAxB;;AACA,SAAK,IAAIV,CAAC,GAAG,CAAR,EAAWmB,EAAE,GAAGD,MAAM,CAACE,MAA5B,EAAoCpB,CAAC,GAAGmB,EAAxC,EAA4CnB,CAAC,EAA7C,EAAiD;AAC/C,YAAMqB,OAAO,GAAGH,MAAM,CAAClB,CAAD,CAAtB;AACA,YAAMsB,OAAO,GAAGJ,MAAM,CAAC,CAAClB,CAAC,GAAG,CAAL,IAAUmB,EAAX,CAAtB;AACAd,MAAAA,OAAO,CAACkB,IAAR,CAAaF,OAAb,EAAsBG,YAAtB,CAAmCT,QAAnC,EAA6CU,GAA7C,CAAiDZ,SAAjD;AACAP,MAAAA,OAAO,CAACiB,IAAR,CAAaD,OAAb,EAAsBE,YAAtB,CAAmCT,QAAnC,EAA6CU,GAA7C,CAAiDZ,SAAjD;AACAN,MAAAA,OAAO,CAACgB,IAAR,CAAaD,OAAb,EAAsBE,YAAtB,CAAmCV,QAAnC,EAA6CW,GAA7C,CAAiDb,SAAjD;AACAJ,MAAAA,OAAO,CAACe,IAAR,CAAaF,OAAb,EAAsBG,YAAtB,CAAmCV,QAAnC,EAA6CW,GAA7C,CAAiDb,SAAjD;AACAP,MAAAA,OAAO,CAACqB,OAAR,CAAgB/C,SAAS,CAACmB,KAA1B,EAAiC,CAACmB,MAAM,GAAG,CAAV,IAAe,CAAhD;AACAX,MAAAA,OAAO,CAACoB,OAAR,CAAgB/C,SAAS,CAACmB,KAA1B,EAAiC,CAACmB,MAAM,GAAG,CAAV,IAAe,CAAhD;AACAT,MAAAA,OAAO,CAACkB,OAAR,CAAgB/C,SAAS,CAACmB,KAA1B,EAAiC,CAACmB,MAAM,GAAG,CAAV,IAAe,CAAhD;AACAX,MAAAA,OAAO,CAACoB,OAAR,CAAgB/C,SAAS,CAACmB,KAA1B,EAAiC,CAACmB,MAAM,GAAG,CAAV,IAAe,CAAhD;AACAV,MAAAA,OAAO,CAACmB,OAAR,CAAgB/C,SAAS,CAACmB,KAA1B,EAAiC,CAACmB,MAAM,GAAG,CAAV,IAAe,CAAhD;AACAT,MAAAA,OAAO,CAACkB,OAAR,CAAgB/C,SAAS,CAACmB,KAA1B,EAAiC,CAACmB,MAAM,GAAG,CAAV,IAAe,CAAhD;AACAZ,MAAAA,OAAO,CAACkB,IAAR,CAAaF,OAAb,EAAsBG,YAAtB,CAAmCT,QAAnC,EAA6CY,SAA7C;AACArB,MAAAA,OAAO,CAACiB,IAAR,CAAaD,OAAb,EAAsBE,YAAtB,CAAmCT,QAAnC,EAA6CY,SAA7C;AACApB,MAAAA,OAAO,CAACgB,IAAR,CAAaD,OAAb,EAAsBE,YAAtB,CAAmCV,QAAnC,EAA6Ca,SAA7C;AACAnB,MAAAA,OAAO,CAACe,IAAR,CAAaF,OAAb,EAAsBG,YAAtB,CAAmCV,QAAnC,EAA6Ca,SAA7C;AACAtB,MAAAA,OAAO,CAACqB,OAAR,CAAgB5C,OAAO,CAACgB,KAAxB,EAA+B,CAACmB,MAAM,GAAG,CAAV,IAAe,CAA9C;AACAX,MAAAA,OAAO,CAACoB,OAAR,CAAgB5C,OAAO,CAACgB,KAAxB,EAA+B,CAACmB,MAAM,GAAG,CAAV,IAAe,CAA9C;AACAT,MAAAA,OAAO,CAACkB,OAAR,CAAgB5C,OAAO,CAACgB,KAAxB,EAA+B,CAACmB,MAAM,GAAG,CAAV,IAAe,CAA9C;AACAX,MAAAA,OAAO,CAACoB,OAAR,CAAgB5C,OAAO,CAACgB,KAAxB,EAA+B,CAACmB,MAAM,GAAG,CAAV,IAAe,CAA9C;AACAV,MAAAA,OAAO,CAACmB,OAAR,CAAgB5C,OAAO,CAACgB,KAAxB,EAA+B,CAACmB,MAAM,GAAG,CAAV,IAAe,CAA9C;AACAT,MAAAA,OAAO,CAACkB,OAAR,CAAgB5C,OAAO,CAACgB,KAAxB,EAA+B,CAACmB,MAAM,GAAG,CAAV,IAAe,CAA9C;AACAR,MAAAA,KAAK,CAACiB,OAAN,CAAc3C,MAAM,CAACe,KAArB,EAA4B,CAACmB,MAAM,GAAG,CAAV,IAAe,CAA3C;AACAR,MAAAA,KAAK,CAACiB,OAAN,CAAc3C,MAAM,CAACe,KAArB,EAA4B,CAACmB,MAAM,GAAG,CAAV,IAAe,CAA3C;AACAR,MAAAA,KAAK,CAACiB,OAAN,CAAc3C,MAAM,CAACe,KAArB,EAA4B,CAACmB,MAAM,GAAG,CAAV,IAAe,CAA3C;AACAR,MAAAA,KAAK,CAACiB,OAAN,CAAc3C,MAAM,CAACe,KAArB,EAA4B,CAACmB,MAAM,GAAG,CAAV,IAAe,CAA3C;AACAR,MAAAA,KAAK,CAACiB,OAAN,CAAc3C,MAAM,CAACe,KAArB,EAA4B,CAACmB,MAAM,GAAG,CAAV,IAAe,CAA3C;AACAR,MAAAA,KAAK,CAACiB,OAAN,CAAc3C,MAAM,CAACe,KAArB,EAA4B,CAACmB,MAAM,GAAG,CAAV,IAAe,CAA3C;AACAA,MAAAA,MAAM,IAAI,CAAV;AACD;;AACDjC,IAAAA,QAAQ,CAACE,SAAT,CAAmBC,KAAnB,GAA2B8B,MAA3B;AACD;;AACD,QAAMW,EAAE,GAAG,IAAItD,OAAJ,CAAY,CAAZ,EAAe,CAAf,EAAkB,CAAlB,CAAX;AACA,QAAMuD,MAAM,GAAG,IAAIvD,OAAJ,EAAf;AACA,QAAMwD,MAAM,GAAG,IAAIxD,OAAJ,EAAf;AACA,QAAMyD,OAAO,GAAG,IAAIvD,OAAJ,EAAhB;AACA,QAAMwD,OAAO,GAAG,IAAIxD,OAAJ,EAAhB;;AACA,WAASyD,MAAT,CAAgBC,QAAhB,EAA0B;AACxBL,IAAAA,MAAM,CAACN,IAAP,CAAYW,QAAZ;AACAH,IAAAA,OAAO,CAACI,MAAR,CAAeL,MAAf,EAAuBD,MAAvB,EAA+BD,EAA/B;AACAE,IAAAA,MAAM,CAACP,IAAP,CAAYW,QAAZ;AACAF,IAAAA,OAAO,CAACT,IAAR,CAAaQ,OAAb;AACD;;AACD,WAASK,MAAT,CAAgBF,QAAhB,EAA0B;AACxBL,IAAAA,MAAM,CAACN,IAAP,CAAYW,QAAZ;AACAH,IAAAA,OAAO,CAACI,MAAR,CAAeL,MAAf,EAAuBD,MAAvB,EAA+BD,EAA/B;AACAjB,IAAAA,MAAM,CAACkB,MAAD,EAASC,MAAT,EAAiBC,OAAjB,EAA0BC,OAA1B,CAAN;AACAF,IAAAA,MAAM,CAACP,IAAP,CAAYM,MAAZ;AACAG,IAAAA,OAAO,CAACT,IAAR,CAAaQ,OAAb;AACD;;AACD,WAASM,OAAT,CAAiBC,KAAjB,EAAwB;AACtB5B,IAAAA,IAAI,GAAG4B,KAAP;AACD;;AACD,MAAInD,KAAK,GAAG,CAAZ;;AACA,WAASoD,MAAT,GAAkB;AAChB,UAAMC,KAAK,GAAGrD,KAAd;AACA,UAAMsD,GAAG,GAAGzD,QAAQ,CAACE,SAAT,CAAmBC,KAA/B;AACA,QAAIqD,KAAK,KAAKC,GAAd,EACE;AACF9D,IAAAA,SAAS,CAAC+D,WAAV,CAAsBC,MAAtB,GAA+BH,KAAK,GAAG,CAAvC;AACA7D,IAAAA,SAAS,CAAC+D,WAAV,CAAsBvD,KAAtB,GAA8B,CAACsD,GAAG,GAAGD,KAAP,IAAgB,CAA9C;AACA7D,IAAAA,SAAS,CAACiE,WAAV,GAAwB,IAAxB;AACA9D,IAAAA,OAAO,CAAC4D,WAAR,CAAoBC,MAApB,GAA6BH,KAAK,GAAG,CAArC;AACA1D,IAAAA,OAAO,CAAC4D,WAAR,CAAoBvD,KAApB,GAA4B,CAACsD,GAAG,GAAGD,KAAP,IAAgB,CAA5C;AACA1D,IAAAA,OAAO,CAAC8D,WAAR,GAAsB,IAAtB;AACA7D,IAAAA,MAAM,CAAC2D,WAAP,CAAmBC,MAAnB,GAA4BH,KAAK,GAAG,CAApC;AACAzD,IAAAA,MAAM,CAAC2D,WAAP,CAAmBvD,KAAnB,GAA2B,CAACsD,GAAG,GAAGD,KAAP,IAAgB,CAA3C;AACAzD,IAAAA,MAAM,CAAC6D,WAAP,GAAqB,IAArB;AACAzD,IAAAA,KAAK,GAAGH,QAAQ,CAACE,SAAT,CAAmBC,KAA3B;AACD;;AACD,SAAO;AACLG,IAAAA,IADK;AAEL2C,IAAAA,MAFK;AAGLG,IAAAA,MAHK;AAILC,IAAAA,OAJK;AAKLE,IAAAA;AALK,GAAP;AAOD;;AACD,SACE9D,WADF","sourcesContent":["import { BufferAttribute, DynamicDrawUsage, BufferGeometry, MeshStandardMaterial, Mesh, Vector3, Color, Matrix4 } from \"three\";\nfunction TubePainter() {\n  const BUFFER_SIZE = 1e6 * 3;\n  const positions = new BufferAttribute(new Float32Array(BUFFER_SIZE), 3);\n  positions.usage = DynamicDrawUsage;\n  const normals = new BufferAttribute(new Float32Array(BUFFER_SIZE), 3);\n  normals.usage = DynamicDrawUsage;\n  const colors = new BufferAttribute(new Float32Array(BUFFER_SIZE), 3);\n  colors.usage = DynamicDrawUsage;\n  const geometry = new BufferGeometry();\n  geometry.setAttribute(\"position\", positions);\n  geometry.setAttribute(\"normal\", normals);\n  geometry.setAttribute(\"color\", colors);\n  geometry.drawRange.count = 0;\n  const material = new MeshStandardMaterial({\n    vertexColors: true\n  });\n  const mesh = new Mesh(geometry, material);\n  mesh.frustumCulled = false;\n  function getPoints(size2) {\n    const PI2 = Math.PI * 2;\n    const sides = 10;\n    const array = [];\n    const radius = 0.01 * size2;\n    for (let i = 0; i < sides; i++) {\n      const angle = i / sides * PI2;\n      array.push(new Vector3(Math.sin(angle) * radius, Math.cos(angle) * radius, 0));\n    }\n    return array;\n  }\n  const vector1 = new Vector3();\n  const vector2 = new Vector3();\n  const vector3 = new Vector3();\n  const vector4 = new Vector3();\n  const color = new Color(16777215);\n  let size = 1;\n  function stroke(position1, position2, matrix12, matrix22) {\n    if (position1.distanceToSquared(position2) === 0)\n      return;\n    let count2 = geometry.drawRange.count;\n    const points = getPoints(size);\n    for (let i = 0, il = points.length; i < il; i++) {\n      const vertex1 = points[i];\n      const vertex2 = points[(i + 1) % il];\n      vector1.copy(vertex1).applyMatrix4(matrix22).add(position2);\n      vector2.copy(vertex2).applyMatrix4(matrix22).add(position2);\n      vector3.copy(vertex2).applyMatrix4(matrix12).add(position1);\n      vector4.copy(vertex1).applyMatrix4(matrix12).add(position1);\n      vector1.toArray(positions.array, (count2 + 0) * 3);\n      vector2.toArray(positions.array, (count2 + 1) * 3);\n      vector4.toArray(positions.array, (count2 + 2) * 3);\n      vector2.toArray(positions.array, (count2 + 3) * 3);\n      vector3.toArray(positions.array, (count2 + 4) * 3);\n      vector4.toArray(positions.array, (count2 + 5) * 3);\n      vector1.copy(vertex1).applyMatrix4(matrix22).normalize();\n      vector2.copy(vertex2).applyMatrix4(matrix22).normalize();\n      vector3.copy(vertex2).applyMatrix4(matrix12).normalize();\n      vector4.copy(vertex1).applyMatrix4(matrix12).normalize();\n      vector1.toArray(normals.array, (count2 + 0) * 3);\n      vector2.toArray(normals.array, (count2 + 1) * 3);\n      vector4.toArray(normals.array, (count2 + 2) * 3);\n      vector2.toArray(normals.array, (count2 + 3) * 3);\n      vector3.toArray(normals.array, (count2 + 4) * 3);\n      vector4.toArray(normals.array, (count2 + 5) * 3);\n      color.toArray(colors.array, (count2 + 0) * 3);\n      color.toArray(colors.array, (count2 + 1) * 3);\n      color.toArray(colors.array, (count2 + 2) * 3);\n      color.toArray(colors.array, (count2 + 3) * 3);\n      color.toArray(colors.array, (count2 + 4) * 3);\n      color.toArray(colors.array, (count2 + 5) * 3);\n      count2 += 6;\n    }\n    geometry.drawRange.count = count2;\n  }\n  const up = new Vector3(0, 1, 0);\n  const point1 = new Vector3();\n  const point2 = new Vector3();\n  const matrix1 = new Matrix4();\n  const matrix2 = new Matrix4();\n  function moveTo(position) {\n    point1.copy(position);\n    matrix1.lookAt(point2, point1, up);\n    point2.copy(position);\n    matrix2.copy(matrix1);\n  }\n  function lineTo(position) {\n    point1.copy(position);\n    matrix1.lookAt(point2, point1, up);\n    stroke(point1, point2, matrix1, matrix2);\n    point2.copy(point1);\n    matrix2.copy(matrix1);\n  }\n  function setSize(value) {\n    size = value;\n  }\n  let count = 0;\n  function update() {\n    const start = count;\n    const end = geometry.drawRange.count;\n    if (start === end)\n      return;\n    positions.updateRange.offset = start * 3;\n    positions.updateRange.count = (end - start) * 3;\n    positions.needsUpdate = true;\n    normals.updateRange.offset = start * 3;\n    normals.updateRange.count = (end - start) * 3;\n    normals.needsUpdate = true;\n    colors.updateRange.offset = start * 3;\n    colors.updateRange.count = (end - start) * 3;\n    colors.needsUpdate = true;\n    count = geometry.drawRange.count;\n  }\n  return {\n    mesh,\n    moveTo,\n    lineTo,\n    setSize,\n    update\n  };\n}\nexport {\n  TubePainter\n};\n"]},"metadata":{},"sourceType":"module"}