{"ast":null,"code":"import { Vector2 } from \"three\";\nconst DepthLimitedBlurShader = {\n  defines: {\n    KERNEL_RADIUS: 4,\n    DEPTH_PACKING: 1,\n    PERSPECTIVE_CAMERA: 1\n  },\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    size: {\n      value: /* @__PURE__ */new Vector2(512, 512)\n    },\n    sampleUvOffsets: {\n      value: [/* @__PURE__ */new Vector2(0, 0)]\n    },\n    sampleWeights: {\n      value: [1]\n    },\n    tDepth: {\n      value: null\n    },\n    cameraNear: {\n      value: 10\n    },\n    cameraFar: {\n      value: 1e3\n    },\n    depthCutoff: {\n      value: 10\n    }\n  },\n  vertexShader: [\"#include <common>\", \"uniform vec2 size;\", \"varying vec2 vUv;\", \"varying vec2 vInvSize;\", \"void main() {\", \"\tvUv = uv;\", \"\tvInvSize = 1.0 / size;\", \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n  fragmentShader: [\"#include <common>\", \"#include <packing>\", \"uniform sampler2D tDiffuse;\", \"uniform sampler2D tDepth;\", \"uniform float cameraNear;\", \"uniform float cameraFar;\", \"uniform float depthCutoff;\", \"uniform vec2 sampleUvOffsets[ KERNEL_RADIUS + 1 ];\", \"uniform float sampleWeights[ KERNEL_RADIUS + 1 ];\", \"varying vec2 vUv;\", \"varying vec2 vInvSize;\", \"float getDepth( const in vec2 screenPosition ) {\", \"\t#if DEPTH_PACKING == 1\", \"\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );\", \"\t#else\", \"\treturn texture2D( tDepth, screenPosition ).x;\", \"\t#endif\", \"}\", \"float getViewZ( const in float depth ) {\", \"\t#if PERSPECTIVE_CAMERA == 1\", \"\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\", \"\t#else\", \"\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\", \"\t#endif\", \"}\", \"void main() {\", \"\tfloat depth = getDepth( vUv );\", \"\tif( depth >= ( 1.0 - EPSILON ) ) {\", \"\t\tdiscard;\", \"\t}\", \"\tfloat centerViewZ = -getViewZ( depth );\", \"\tbool rBreak = false, lBreak = false;\", \"\tfloat weightSum = sampleWeights[0];\", \"\tvec4 diffuseSum = texture2D( tDiffuse, vUv ) * weightSum;\", \"\tfor( int i = 1; i <= KERNEL_RADIUS; i ++ ) {\", \"\t\tfloat sampleWeight = sampleWeights[i];\", \"\t\tvec2 sampleUvOffset = sampleUvOffsets[i] * vInvSize;\", \"\t\tvec2 sampleUv = vUv + sampleUvOffset;\", \"\t\tfloat viewZ = -getViewZ( getDepth( sampleUv ) );\", \"\t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) rBreak = true;\", \"\t\tif( ! rBreak ) {\", \"\t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;\", \"\t\t\tweightSum += sampleWeight;\", \"\t\t}\", \"\t\tsampleUv = vUv - sampleUvOffset;\", \"\t\tviewZ = -getViewZ( getDepth( sampleUv ) );\", \"\t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) lBreak = true;\", \"\t\tif( ! lBreak ) {\", \"\t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;\", \"\t\t\tweightSum += sampleWeight;\", \"\t\t}\", \"\t}\", \"\tgl_FragColor = diffuseSum / weightSum;\", \"}\"].join(\"\\n\")\n};\nconst BlurShaderUtils = {\n  createSampleWeights: (kernelRadius, stdDev) => {\n    const gaussian = (x, stdDev2) => {\n      return Math.exp(-(x * x) / (2 * (stdDev2 * stdDev2))) / (Math.sqrt(2 * Math.PI) * stdDev2);\n    };\n\n    const weights = [];\n\n    for (let i = 0; i <= kernelRadius; i++) {\n      weights.push(gaussian(i, stdDev));\n    }\n\n    return weights;\n  },\n  createSampleOffsets: (kernelRadius, uvIncrement) => {\n    const offsets = [];\n\n    for (let i = 0; i <= kernelRadius; i++) {\n      offsets.push(uvIncrement.clone().multiplyScalar(i));\n    }\n\n    return offsets;\n  },\n  configure: (shader, kernelRadius, stdDev, uvIncrement) => {\n    shader.defines[\"KERNEL_RADIUS\"] = kernelRadius;\n    shader.uniforms[\"sampleUvOffsets\"].value = BlurShaderUtils.createSampleOffsets(kernelRadius, uvIncrement);\n    shader.uniforms[\"sampleWeights\"].value = BlurShaderUtils.createSampleWeights(kernelRadius, stdDev);\n    shader.needsUpdate = true;\n  }\n};\nexport { BlurShaderUtils, DepthLimitedBlurShader };","map":{"version":3,"sources":["/Users/theodaguier/Repositories/E-Do-Studio/node_modules/three-stdlib/shaders/DepthLimitedBlurShader.js"],"names":["Vector2","DepthLimitedBlurShader","defines","KERNEL_RADIUS","DEPTH_PACKING","PERSPECTIVE_CAMERA","uniforms","tDiffuse","value","size","sampleUvOffsets","sampleWeights","tDepth","cameraNear","cameraFar","depthCutoff","vertexShader","join","fragmentShader","BlurShaderUtils","createSampleWeights","kernelRadius","stdDev","gaussian","x","stdDev2","Math","exp","sqrt","PI","weights","i","push","createSampleOffsets","uvIncrement","offsets","clone","multiplyScalar","configure","shader","needsUpdate"],"mappings":"AAAA,SAASA,OAAT,QAAwB,OAAxB;AACA,MAAMC,sBAAsB,GAAG;AAC7BC,EAAAA,OAAO,EAAE;AACPC,IAAAA,aAAa,EAAE,CADR;AAEPC,IAAAA,aAAa,EAAE,CAFR;AAGPC,IAAAA,kBAAkB,EAAE;AAHb,GADoB;AAM7BC,EAAAA,QAAQ,EAAE;AACRC,IAAAA,QAAQ,EAAE;AAAEC,MAAAA,KAAK,EAAE;AAAT,KADF;AAERC,IAAAA,IAAI,EAAE;AAAED,MAAAA,KAAK,EAAE,eAAgB,IAAIR,OAAJ,CAAY,GAAZ,EAAiB,GAAjB;AAAzB,KAFE;AAGRU,IAAAA,eAAe,EAAE;AAAEF,MAAAA,KAAK,EAAE,CAAC,eAAgB,IAAIR,OAAJ,CAAY,CAAZ,EAAe,CAAf,CAAjB;AAAT,KAHT;AAIRW,IAAAA,aAAa,EAAE;AAAEH,MAAAA,KAAK,EAAE,CAAC,CAAD;AAAT,KAJP;AAKRI,IAAAA,MAAM,EAAE;AAAEJ,MAAAA,KAAK,EAAE;AAAT,KALA;AAMRK,IAAAA,UAAU,EAAE;AAAEL,MAAAA,KAAK,EAAE;AAAT,KANJ;AAORM,IAAAA,SAAS,EAAE;AAAEN,MAAAA,KAAK,EAAE;AAAT,KAPH;AAQRO,IAAAA,WAAW,EAAE;AAAEP,MAAAA,KAAK,EAAE;AAAT;AARL,GANmB;AAgB7BQ,EAAAA,YAAY,EAAE,CACZ,mBADY,EAEZ,oBAFY,EAGZ,mBAHY,EAIZ,wBAJY,EAKZ,eALY,EAMZ,YANY,EAOZ,yBAPY,EAQZ,4EARY,EASZ,GATY,EAUZC,IAVY,CAUP,IAVO,CAhBe;AA2B7BC,EAAAA,cAAc,EAAE,CACd,mBADc,EAEd,oBAFc,EAGd,6BAHc,EAId,2BAJc,EAKd,2BALc,EAMd,0BANc,EAOd,4BAPc,EAQd,oDARc,EASd,mDATc,EAUd,mBAVc,EAWd,wBAXc,EAYd,kDAZc,EAad,yBAbc,EAcd,mEAdc,EAed,QAfc,EAgBd,gDAhBc,EAiBd,SAjBc,EAkBd,GAlBc,EAmBd,0CAnBc,EAoBd,8BApBc,EAqBd,kEArBc,EAsBd,QAtBc,EAuBd,mEAvBc,EAwBd,SAxBc,EAyBd,GAzBc,EA0Bd,eA1Bc,EA2Bd,iCA3Bc,EA4Bd,qCA5Bc,EA6Bd,YA7Bc,EA8Bd,IA9Bc,EA+Bd,0CA/Bc,EAgCd,uCAhCc,EAiCd,sCAjCc,EAkCd,4DAlCc,EAmCd,+CAnCc,EAoCd,0CApCc,EAqCd,wDArCc,EAsCd,yCAtCc,EAuCd,oDAvCc,EAwCd,iEAxCc,EAyCd,oBAzCc,EA0Cd,kEA1Cc,EA2Cd,+BA3Cc,EA4Cd,KA5Cc,EA6Cd,oCA7Cc,EA8Cd,8CA9Cc,EA+Cd,iEA/Cc,EAgDd,oBAhDc,EAiDd,kEAjDc,EAkDd,+BAlDc,EAmDd,KAnDc,EAoDd,IApDc,EAqDd,yCArDc,EAsDd,GAtDc,EAuDdD,IAvDc,CAuDT,IAvDS;AA3Ba,CAA/B;AAoFA,MAAME,eAAe,GAAG;AACtBC,EAAAA,mBAAmB,EAAE,CAACC,YAAD,EAAeC,MAAf,KAA0B;AAC7C,UAAMC,QAAQ,GAAG,CAACC,CAAD,EAAIC,OAAJ,KAAgB;AAC/B,aAAOC,IAAI,CAACC,GAAL,CAAS,EAAEH,CAAC,GAAGA,CAAN,KAAY,KAAKC,OAAO,GAAGA,OAAf,CAAZ,CAAT,KAAkDC,IAAI,CAACE,IAAL,CAAU,IAAIF,IAAI,CAACG,EAAnB,IAAyBJ,OAA3E,CAAP;AACD,KAFD;;AAGA,UAAMK,OAAO,GAAG,EAAhB;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAIV,YAArB,EAAmCU,CAAC,EAApC,EAAwC;AACtCD,MAAAA,OAAO,CAACE,IAAR,CAAaT,QAAQ,CAACQ,CAAD,EAAIT,MAAJ,CAArB;AACD;;AACD,WAAOQ,OAAP;AACD,GAVqB;AAWtBG,EAAAA,mBAAmB,EAAE,CAACZ,YAAD,EAAea,WAAf,KAA+B;AAClD,UAAMC,OAAO,GAAG,EAAhB;;AACA,SAAK,IAAIJ,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAIV,YAArB,EAAmCU,CAAC,EAApC,EAAwC;AACtCI,MAAAA,OAAO,CAACH,IAAR,CAAaE,WAAW,CAACE,KAAZ,GAAoBC,cAApB,CAAmCN,CAAnC,CAAb;AACD;;AACD,WAAOI,OAAP;AACD,GAjBqB;AAkBtBG,EAAAA,SAAS,EAAE,CAACC,MAAD,EAASlB,YAAT,EAAuBC,MAAvB,EAA+BY,WAA/B,KAA+C;AACxDK,IAAAA,MAAM,CAACrC,OAAP,CAAe,eAAf,IAAkCmB,YAAlC;AACAkB,IAAAA,MAAM,CAACjC,QAAP,CAAgB,iBAAhB,EAAmCE,KAAnC,GAA2CW,eAAe,CAACc,mBAAhB,CAAoCZ,YAApC,EAAkDa,WAAlD,CAA3C;AACAK,IAAAA,MAAM,CAACjC,QAAP,CAAgB,eAAhB,EAAiCE,KAAjC,GAAyCW,eAAe,CAACC,mBAAhB,CAAoCC,YAApC,EAAkDC,MAAlD,CAAzC;AACAiB,IAAAA,MAAM,CAACC,WAAP,GAAqB,IAArB;AACD;AAvBqB,CAAxB;AAyBA,SACErB,eADF,EAEElB,sBAFF","sourcesContent":["import { Vector2 } from \"three\";\nconst DepthLimitedBlurShader = {\n  defines: {\n    KERNEL_RADIUS: 4,\n    DEPTH_PACKING: 1,\n    PERSPECTIVE_CAMERA: 1\n  },\n  uniforms: {\n    tDiffuse: { value: null },\n    size: { value: /* @__PURE__ */ new Vector2(512, 512) },\n    sampleUvOffsets: { value: [/* @__PURE__ */ new Vector2(0, 0)] },\n    sampleWeights: { value: [1] },\n    tDepth: { value: null },\n    cameraNear: { value: 10 },\n    cameraFar: { value: 1e3 },\n    depthCutoff: { value: 10 }\n  },\n  vertexShader: [\n    \"#include <common>\",\n    \"uniform vec2 size;\",\n    \"varying vec2 vUv;\",\n    \"varying vec2 vInvSize;\",\n    \"void main() {\",\n    \"\tvUv = uv;\",\n    \"\tvInvSize = 1.0 / size;\",\n    \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n    \"}\"\n  ].join(\"\\n\"),\n  fragmentShader: [\n    \"#include <common>\",\n    \"#include <packing>\",\n    \"uniform sampler2D tDiffuse;\",\n    \"uniform sampler2D tDepth;\",\n    \"uniform float cameraNear;\",\n    \"uniform float cameraFar;\",\n    \"uniform float depthCutoff;\",\n    \"uniform vec2 sampleUvOffsets[ KERNEL_RADIUS + 1 ];\",\n    \"uniform float sampleWeights[ KERNEL_RADIUS + 1 ];\",\n    \"varying vec2 vUv;\",\n    \"varying vec2 vInvSize;\",\n    \"float getDepth( const in vec2 screenPosition ) {\",\n    \"\t#if DEPTH_PACKING == 1\",\n    \"\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );\",\n    \"\t#else\",\n    \"\treturn texture2D( tDepth, screenPosition ).x;\",\n    \"\t#endif\",\n    \"}\",\n    \"float getViewZ( const in float depth ) {\",\n    \"\t#if PERSPECTIVE_CAMERA == 1\",\n    \"\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\",\n    \"\t#else\",\n    \"\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\",\n    \"\t#endif\",\n    \"}\",\n    \"void main() {\",\n    \"\tfloat depth = getDepth( vUv );\",\n    \"\tif( depth >= ( 1.0 - EPSILON ) ) {\",\n    \"\t\tdiscard;\",\n    \"\t}\",\n    \"\tfloat centerViewZ = -getViewZ( depth );\",\n    \"\tbool rBreak = false, lBreak = false;\",\n    \"\tfloat weightSum = sampleWeights[0];\",\n    \"\tvec4 diffuseSum = texture2D( tDiffuse, vUv ) * weightSum;\",\n    \"\tfor( int i = 1; i <= KERNEL_RADIUS; i ++ ) {\",\n    \"\t\tfloat sampleWeight = sampleWeights[i];\",\n    \"\t\tvec2 sampleUvOffset = sampleUvOffsets[i] * vInvSize;\",\n    \"\t\tvec2 sampleUv = vUv + sampleUvOffset;\",\n    \"\t\tfloat viewZ = -getViewZ( getDepth( sampleUv ) );\",\n    \"\t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) rBreak = true;\",\n    \"\t\tif( ! rBreak ) {\",\n    \"\t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;\",\n    \"\t\t\tweightSum += sampleWeight;\",\n    \"\t\t}\",\n    \"\t\tsampleUv = vUv - sampleUvOffset;\",\n    \"\t\tviewZ = -getViewZ( getDepth( sampleUv ) );\",\n    \"\t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) lBreak = true;\",\n    \"\t\tif( ! lBreak ) {\",\n    \"\t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;\",\n    \"\t\t\tweightSum += sampleWeight;\",\n    \"\t\t}\",\n    \"\t}\",\n    \"\tgl_FragColor = diffuseSum / weightSum;\",\n    \"}\"\n  ].join(\"\\n\")\n};\nconst BlurShaderUtils = {\n  createSampleWeights: (kernelRadius, stdDev) => {\n    const gaussian = (x, stdDev2) => {\n      return Math.exp(-(x * x) / (2 * (stdDev2 * stdDev2))) / (Math.sqrt(2 * Math.PI) * stdDev2);\n    };\n    const weights = [];\n    for (let i = 0; i <= kernelRadius; i++) {\n      weights.push(gaussian(i, stdDev));\n    }\n    return weights;\n  },\n  createSampleOffsets: (kernelRadius, uvIncrement) => {\n    const offsets = [];\n    for (let i = 0; i <= kernelRadius; i++) {\n      offsets.push(uvIncrement.clone().multiplyScalar(i));\n    }\n    return offsets;\n  },\n  configure: (shader, kernelRadius, stdDev, uvIncrement) => {\n    shader.defines[\"KERNEL_RADIUS\"] = kernelRadius;\n    shader.uniforms[\"sampleUvOffsets\"].value = BlurShaderUtils.createSampleOffsets(kernelRadius, uvIncrement);\n    shader.uniforms[\"sampleWeights\"].value = BlurShaderUtils.createSampleWeights(kernelRadius, stdDev);\n    shader.needsUpdate = true;\n  }\n};\nexport {\n  BlurShaderUtils,\n  DepthLimitedBlurShader\n};\n"]},"metadata":{},"sourceType":"module"}