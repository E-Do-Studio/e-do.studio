{"ast":null,"code":"import { Texture, DataTextureLoader, HalfFloatType, DataUtils, FloatType, RGBAFormat, RedFormat, LinearFilter } from \"three\";\nimport { unzlibSync } from \"fflate\";\nconst hasColorSpace = (\"colorSpace\" in /* @__PURE__ */new Texture());\n\nclass EXRLoader extends DataTextureLoader {\n  constructor(manager) {\n    super(manager);\n    this.type = HalfFloatType;\n  }\n\n  parse(buffer) {\n    const USHORT_RANGE = 1 << 16;\n    const BITMAP_SIZE = USHORT_RANGE >> 3;\n    const HUF_ENCBITS = 16;\n    const HUF_DECBITS = 14;\n    const HUF_ENCSIZE = (1 << HUF_ENCBITS) + 1;\n    const HUF_DECSIZE = 1 << HUF_DECBITS;\n    const HUF_DECMASK = HUF_DECSIZE - 1;\n    const NBITS = 16;\n    const A_OFFSET = 1 << NBITS - 1;\n    const MOD_MASK = (1 << NBITS) - 1;\n    const SHORT_ZEROCODE_RUN = 59;\n    const LONG_ZEROCODE_RUN = 63;\n    const SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;\n    const ULONG_SIZE = 8;\n    const FLOAT32_SIZE = 4;\n    const INT32_SIZE = 4;\n    const INT16_SIZE = 2;\n    const INT8_SIZE = 1;\n    const STATIC_HUFFMAN = 0;\n    const DEFLATE = 1;\n    const UNKNOWN = 0;\n    const LOSSY_DCT = 1;\n    const RLE = 2;\n    const logBase = Math.pow(2.7182818, 2.2);\n\n    function reverseLutFromBitmap(bitmap, lut) {\n      var k = 0;\n\n      for (var i = 0; i < USHORT_RANGE; ++i) {\n        if (i == 0 || bitmap[i >> 3] & 1 << (i & 7)) {\n          lut[k++] = i;\n        }\n      }\n\n      var n = k - 1;\n\n      while (k < USHORT_RANGE) lut[k++] = 0;\n\n      return n;\n    }\n\n    function hufClearDecTable(hdec) {\n      for (var i = 0; i < HUF_DECSIZE; i++) {\n        hdec[i] = {};\n        hdec[i].len = 0;\n        hdec[i].lit = 0;\n        hdec[i].p = null;\n      }\n    }\n\n    const getBitsReturn = {\n      l: 0,\n      c: 0,\n      lc: 0\n    };\n\n    function getBits(nBits, c, lc, uInt8Array2, inOffset) {\n      while (lc < nBits) {\n        c = c << 8 | parseUint8Array(uInt8Array2, inOffset);\n        lc += 8;\n      }\n\n      lc -= nBits;\n      getBitsReturn.l = c >> lc & (1 << nBits) - 1;\n      getBitsReturn.c = c;\n      getBitsReturn.lc = lc;\n    }\n\n    const hufTableBuffer = new Array(59);\n\n    function hufCanonicalCodeTable(hcode) {\n      for (var i = 0; i <= 58; ++i) hufTableBuffer[i] = 0;\n\n      for (var i = 0; i < HUF_ENCSIZE; ++i) hufTableBuffer[hcode[i]] += 1;\n\n      var c = 0;\n\n      for (var i = 58; i > 0; --i) {\n        var nc = c + hufTableBuffer[i] >> 1;\n        hufTableBuffer[i] = c;\n        c = nc;\n      }\n\n      for (var i = 0; i < HUF_ENCSIZE; ++i) {\n        var l = hcode[i];\n        if (l > 0) hcode[i] = l | hufTableBuffer[l]++ << 6;\n      }\n    }\n\n    function hufUnpackEncTable(uInt8Array2, inDataView, inOffset, ni, im, iM, hcode) {\n      var p = inOffset;\n      var c = 0;\n      var lc = 0;\n\n      for (; im <= iM; im++) {\n        if (p.value - inOffset.value > ni) return false;\n        getBits(6, c, lc, uInt8Array2, p);\n        var l = getBitsReturn.l;\n        c = getBitsReturn.c;\n        lc = getBitsReturn.lc;\n        hcode[im] = l;\n\n        if (l == LONG_ZEROCODE_RUN) {\n          if (p.value - inOffset.value > ni) {\n            throw \"Something wrong with hufUnpackEncTable\";\n          }\n\n          getBits(8, c, lc, uInt8Array2, p);\n          var zerun = getBitsReturn.l + SHORTEST_LONG_RUN;\n          c = getBitsReturn.c;\n          lc = getBitsReturn.lc;\n\n          if (im + zerun > iM + 1) {\n            throw \"Something wrong with hufUnpackEncTable\";\n          }\n\n          while (zerun--) hcode[im++] = 0;\n\n          im--;\n        } else if (l >= SHORT_ZEROCODE_RUN) {\n          var zerun = l - SHORT_ZEROCODE_RUN + 2;\n\n          if (im + zerun > iM + 1) {\n            throw \"Something wrong with hufUnpackEncTable\";\n          }\n\n          while (zerun--) hcode[im++] = 0;\n\n          im--;\n        }\n      }\n\n      hufCanonicalCodeTable(hcode);\n    }\n\n    function hufLength(code) {\n      return code & 63;\n    }\n\n    function hufCode(code) {\n      return code >> 6;\n    }\n\n    function hufBuildDecTable(hcode, im, iM, hdecod) {\n      for (; im <= iM; im++) {\n        var c = hufCode(hcode[im]);\n        var l = hufLength(hcode[im]);\n\n        if (c >> l) {\n          throw \"Invalid table entry\";\n        }\n\n        if (l > HUF_DECBITS) {\n          var pl = hdecod[c >> l - HUF_DECBITS];\n\n          if (pl.len) {\n            throw \"Invalid table entry\";\n          }\n\n          pl.lit++;\n\n          if (pl.p) {\n            var p = pl.p;\n            pl.p = new Array(pl.lit);\n\n            for (var i = 0; i < pl.lit - 1; ++i) {\n              pl.p[i] = p[i];\n            }\n          } else {\n            pl.p = new Array(1);\n          }\n\n          pl.p[pl.lit - 1] = im;\n        } else if (l) {\n          var plOffset = 0;\n\n          for (var i = 1 << HUF_DECBITS - l; i > 0; i--) {\n            var pl = hdecod[(c << HUF_DECBITS - l) + plOffset];\n\n            if (pl.len || pl.p) {\n              throw \"Invalid table entry\";\n            }\n\n            pl.len = l;\n            pl.lit = im;\n            plOffset++;\n          }\n        }\n      }\n\n      return true;\n    }\n\n    const getCharReturn = {\n      c: 0,\n      lc: 0\n    };\n\n    function getChar(c, lc, uInt8Array2, inOffset) {\n      c = c << 8 | parseUint8Array(uInt8Array2, inOffset);\n      lc += 8;\n      getCharReturn.c = c;\n      getCharReturn.lc = lc;\n    }\n\n    const getCodeReturn = {\n      c: 0,\n      lc: 0\n    };\n\n    function getCode(po, rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outBufferOffset, outBufferEndOffset) {\n      if (po == rlc) {\n        if (lc < 8) {\n          getChar(c, lc, uInt8Array2, inOffset);\n          c = getCharReturn.c;\n          lc = getCharReturn.lc;\n        }\n\n        lc -= 8;\n        var cs = c >> lc;\n        var cs = new Uint8Array([cs])[0];\n\n        if (outBufferOffset.value + cs > outBufferEndOffset) {\n          return false;\n        }\n\n        var s = outBuffer[outBufferOffset.value - 1];\n\n        while (cs-- > 0) {\n          outBuffer[outBufferOffset.value++] = s;\n        }\n      } else if (outBufferOffset.value < outBufferEndOffset) {\n        outBuffer[outBufferOffset.value++] = po;\n      } else {\n        return false;\n      }\n\n      getCodeReturn.c = c;\n      getCodeReturn.lc = lc;\n    }\n\n    function UInt16(value) {\n      return value & 65535;\n    }\n\n    function Int16(value) {\n      var ref = UInt16(value);\n      return ref > 32767 ? ref - 65536 : ref;\n    }\n\n    const wdec14Return = {\n      a: 0,\n      b: 0\n    };\n\n    function wdec14(l, h) {\n      var ls = Int16(l);\n      var hs = Int16(h);\n      var hi = hs;\n      var ai = ls + (hi & 1) + (hi >> 1);\n      var as = ai;\n      var bs = ai - hi;\n      wdec14Return.a = as;\n      wdec14Return.b = bs;\n    }\n\n    function wdec16(l, h) {\n      var m = UInt16(l);\n      var d = UInt16(h);\n      var bb = m - (d >> 1) & MOD_MASK;\n      var aa = d + bb - A_OFFSET & MOD_MASK;\n      wdec14Return.a = aa;\n      wdec14Return.b = bb;\n    }\n\n    function wav2Decode(buffer2, j, nx, ox, ny, oy, mx) {\n      var w14 = mx < 1 << 14;\n      var n = nx > ny ? ny : nx;\n      var p = 1;\n      var p2;\n\n      while (p <= n) p <<= 1;\n\n      p >>= 1;\n      p2 = p;\n      p >>= 1;\n\n      while (p >= 1) {\n        var py = 0;\n        var ey = py + oy * (ny - p2);\n        var oy1 = oy * p;\n        var oy2 = oy * p2;\n        var ox1 = ox * p;\n        var ox2 = ox * p2;\n        var i00, i01, i10, i11;\n\n        for (; py <= ey; py += oy2) {\n          var px = py;\n          var ex = py + ox * (nx - p2);\n\n          for (; px <= ex; px += ox2) {\n            var p01 = px + ox1;\n            var p10 = px + oy1;\n            var p11 = p10 + ox1;\n\n            if (w14) {\n              wdec14(buffer2[px + j], buffer2[p10 + j]);\n              i00 = wdec14Return.a;\n              i10 = wdec14Return.b;\n              wdec14(buffer2[p01 + j], buffer2[p11 + j]);\n              i01 = wdec14Return.a;\n              i11 = wdec14Return.b;\n              wdec14(i00, i01);\n              buffer2[px + j] = wdec14Return.a;\n              buffer2[p01 + j] = wdec14Return.b;\n              wdec14(i10, i11);\n              buffer2[p10 + j] = wdec14Return.a;\n              buffer2[p11 + j] = wdec14Return.b;\n            } else {\n              wdec16(buffer2[px + j], buffer2[p10 + j]);\n              i00 = wdec14Return.a;\n              i10 = wdec14Return.b;\n              wdec16(buffer2[p01 + j], buffer2[p11 + j]);\n              i01 = wdec14Return.a;\n              i11 = wdec14Return.b;\n              wdec16(i00, i01);\n              buffer2[px + j] = wdec14Return.a;\n              buffer2[p01 + j] = wdec14Return.b;\n              wdec16(i10, i11);\n              buffer2[p10 + j] = wdec14Return.a;\n              buffer2[p11 + j] = wdec14Return.b;\n            }\n          }\n\n          if (nx & p) {\n            var p10 = px + oy1;\n            if (w14) wdec14(buffer2[px + j], buffer2[p10 + j]);else wdec16(buffer2[px + j], buffer2[p10 + j]);\n            i00 = wdec14Return.a;\n            buffer2[p10 + j] = wdec14Return.b;\n            buffer2[px + j] = i00;\n          }\n        }\n\n        if (ny & p) {\n          var px = py;\n          var ex = py + ox * (nx - p2);\n\n          for (; px <= ex; px += ox2) {\n            var p01 = px + ox1;\n            if (w14) wdec14(buffer2[px + j], buffer2[p01 + j]);else wdec16(buffer2[px + j], buffer2[p01 + j]);\n            i00 = wdec14Return.a;\n            buffer2[p01 + j] = wdec14Return.b;\n            buffer2[px + j] = i00;\n          }\n        }\n\n        p2 = p;\n        p >>= 1;\n      }\n\n      return py;\n    }\n\n    function hufDecode(encodingTable, decodingTable, uInt8Array2, inDataView, inOffset, ni, rlc, no, outBuffer, outOffset) {\n      var c = 0;\n      var lc = 0;\n      var outBufferEndOffset = no;\n      var inOffsetEnd = Math.trunc(inOffset.value + (ni + 7) / 8);\n\n      while (inOffset.value < inOffsetEnd) {\n        getChar(c, lc, uInt8Array2, inOffset);\n        c = getCharReturn.c;\n        lc = getCharReturn.lc;\n\n        while (lc >= HUF_DECBITS) {\n          var index = c >> lc - HUF_DECBITS & HUF_DECMASK;\n          var pl = decodingTable[index];\n\n          if (pl.len) {\n            lc -= pl.len;\n            getCode(pl.lit, rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n            c = getCodeReturn.c;\n            lc = getCodeReturn.lc;\n          } else {\n            if (!pl.p) {\n              throw \"hufDecode issues\";\n            }\n\n            var j;\n\n            for (j = 0; j < pl.lit; j++) {\n              var l = hufLength(encodingTable[pl.p[j]]);\n\n              while (lc < l && inOffset.value < inOffsetEnd) {\n                getChar(c, lc, uInt8Array2, inOffset);\n                c = getCharReturn.c;\n                lc = getCharReturn.lc;\n              }\n\n              if (lc >= l) {\n                if (hufCode(encodingTable[pl.p[j]]) == (c >> lc - l & (1 << l) - 1)) {\n                  lc -= l;\n                  getCode(pl.p[j], rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n                  c = getCodeReturn.c;\n                  lc = getCodeReturn.lc;\n                  break;\n                }\n              }\n            }\n\n            if (j == pl.lit) {\n              throw \"hufDecode issues\";\n            }\n          }\n        }\n      }\n\n      var i = 8 - ni & 7;\n      c >>= i;\n      lc -= i;\n\n      while (lc > 0) {\n        var pl = decodingTable[c << HUF_DECBITS - lc & HUF_DECMASK];\n\n        if (pl.len) {\n          lc -= pl.len;\n          getCode(pl.lit, rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n          c = getCodeReturn.c;\n          lc = getCodeReturn.lc;\n        } else {\n          throw \"hufDecode issues\";\n        }\n      }\n\n      return true;\n    }\n\n    function hufUncompress(uInt8Array2, inDataView, inOffset, nCompressed, outBuffer, nRaw) {\n      var outOffset = {\n        value: 0\n      };\n      var initialInOffset = inOffset.value;\n      var im = parseUint32(inDataView, inOffset);\n      var iM = parseUint32(inDataView, inOffset);\n      inOffset.value += 4;\n      var nBits = parseUint32(inDataView, inOffset);\n      inOffset.value += 4;\n\n      if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE) {\n        throw \"Something wrong with HUF_ENCSIZE\";\n      }\n\n      var freq = new Array(HUF_ENCSIZE);\n      var hdec = new Array(HUF_DECSIZE);\n      hufClearDecTable(hdec);\n      var ni = nCompressed - (inOffset.value - initialInOffset);\n      hufUnpackEncTable(uInt8Array2, inDataView, inOffset, ni, im, iM, freq);\n\n      if (nBits > 8 * (nCompressed - (inOffset.value - initialInOffset))) {\n        throw \"Something wrong with hufUncompress\";\n      }\n\n      hufBuildDecTable(freq, im, iM, hdec);\n      hufDecode(freq, hdec, uInt8Array2, inDataView, inOffset, nBits, iM, nRaw, outBuffer, outOffset);\n    }\n\n    function applyLut(lut, data, nData) {\n      for (var i = 0; i < nData; ++i) {\n        data[i] = lut[data[i]];\n      }\n    }\n\n    function predictor(source) {\n      for (var t = 1; t < source.length; t++) {\n        var d = source[t - 1] + source[t] - 128;\n        source[t] = d;\n      }\n    }\n\n    function interleaveScalar(source, out) {\n      var t1 = 0;\n      var t2 = Math.floor((source.length + 1) / 2);\n      var s = 0;\n      var stop = source.length - 1;\n\n      while (true) {\n        if (s > stop) break;\n        out[s++] = source[t1++];\n        if (s > stop) break;\n        out[s++] = source[t2++];\n      }\n    }\n\n    function decodeRunLength(source) {\n      var size = source.byteLength;\n      var out = new Array();\n      var p = 0;\n      var reader = new DataView(source);\n\n      while (size > 0) {\n        var l = reader.getInt8(p++);\n\n        if (l < 0) {\n          var count = -l;\n          size -= count + 1;\n\n          for (var i = 0; i < count; i++) {\n            out.push(reader.getUint8(p++));\n          }\n        } else {\n          var count = l;\n          size -= 2;\n          var value = reader.getUint8(p++);\n\n          for (var i = 0; i < count + 1; i++) {\n            out.push(value);\n          }\n        }\n      }\n\n      return out;\n    }\n\n    function lossyDctDecode(cscSet, rowPtrs, channelData, acBuffer, dcBuffer, outBuffer) {\n      var dataView = new DataView(outBuffer.buffer);\n      var width = channelData[cscSet.idx[0]].width;\n      var height = channelData[cscSet.idx[0]].height;\n      var numComp = 3;\n      var numFullBlocksX = Math.floor(width / 8);\n      var numBlocksX = Math.ceil(width / 8);\n      var numBlocksY = Math.ceil(height / 8);\n      var leftoverX = width - (numBlocksX - 1) * 8;\n      var leftoverY = height - (numBlocksY - 1) * 8;\n      var currAcComp = {\n        value: 0\n      };\n      var currDcComp = new Array(numComp);\n      var dctData = new Array(numComp);\n      var halfZigBlock = new Array(numComp);\n      var rowBlock = new Array(numComp);\n      var rowOffsets = new Array(numComp);\n\n      for (let comp2 = 0; comp2 < numComp; ++comp2) {\n        rowOffsets[comp2] = rowPtrs[cscSet.idx[comp2]];\n        currDcComp[comp2] = comp2 < 1 ? 0 : currDcComp[comp2 - 1] + numBlocksX * numBlocksY;\n        dctData[comp2] = new Float32Array(64);\n        halfZigBlock[comp2] = new Uint16Array(64);\n        rowBlock[comp2] = new Uint16Array(numBlocksX * 64);\n      }\n\n      for (let blocky = 0; blocky < numBlocksY; ++blocky) {\n        var maxY = 8;\n        if (blocky == numBlocksY - 1) maxY = leftoverY;\n        var maxX = 8;\n\n        for (let blockx = 0; blockx < numBlocksX; ++blockx) {\n          if (blockx == numBlocksX - 1) maxX = leftoverX;\n\n          for (let comp2 = 0; comp2 < numComp; ++comp2) {\n            halfZigBlock[comp2].fill(0);\n            halfZigBlock[comp2][0] = dcBuffer[currDcComp[comp2]++];\n            unRleAC(currAcComp, acBuffer, halfZigBlock[comp2]);\n            unZigZag(halfZigBlock[comp2], dctData[comp2]);\n            dctInverse(dctData[comp2]);\n          }\n\n          if (numComp == 3) {\n            csc709Inverse(dctData);\n          }\n\n          for (let comp2 = 0; comp2 < numComp; ++comp2) {\n            convertToHalf(dctData[comp2], rowBlock[comp2], blockx * 64);\n          }\n        }\n\n        let offset2 = 0;\n\n        for (let comp2 = 0; comp2 < numComp; ++comp2) {\n          const type2 = channelData[cscSet.idx[comp2]].type;\n\n          for (let y2 = 8 * blocky; y2 < 8 * blocky + maxY; ++y2) {\n            offset2 = rowOffsets[comp2][y2];\n\n            for (let blockx = 0; blockx < numFullBlocksX; ++blockx) {\n              const src = blockx * 64 + (y2 & 7) * 8;\n              dataView.setUint16(offset2 + 0 * INT16_SIZE * type2, rowBlock[comp2][src + 0], true);\n              dataView.setUint16(offset2 + 1 * INT16_SIZE * type2, rowBlock[comp2][src + 1], true);\n              dataView.setUint16(offset2 + 2 * INT16_SIZE * type2, rowBlock[comp2][src + 2], true);\n              dataView.setUint16(offset2 + 3 * INT16_SIZE * type2, rowBlock[comp2][src + 3], true);\n              dataView.setUint16(offset2 + 4 * INT16_SIZE * type2, rowBlock[comp2][src + 4], true);\n              dataView.setUint16(offset2 + 5 * INT16_SIZE * type2, rowBlock[comp2][src + 5], true);\n              dataView.setUint16(offset2 + 6 * INT16_SIZE * type2, rowBlock[comp2][src + 6], true);\n              dataView.setUint16(offset2 + 7 * INT16_SIZE * type2, rowBlock[comp2][src + 7], true);\n              offset2 += 8 * INT16_SIZE * type2;\n            }\n          }\n\n          if (numFullBlocksX != numBlocksX) {\n            for (let y2 = 8 * blocky; y2 < 8 * blocky + maxY; ++y2) {\n              const offset3 = rowOffsets[comp2][y2] + 8 * numFullBlocksX * INT16_SIZE * type2;\n              const src = numFullBlocksX * 64 + (y2 & 7) * 8;\n\n              for (let x2 = 0; x2 < maxX; ++x2) {\n                dataView.setUint16(offset3 + x2 * INT16_SIZE * type2, rowBlock[comp2][src + x2], true);\n              }\n            }\n          }\n        }\n      }\n\n      var halfRow = new Uint16Array(width);\n      var dataView = new DataView(outBuffer.buffer);\n\n      for (var comp = 0; comp < numComp; ++comp) {\n        channelData[cscSet.idx[comp]].decoded = true;\n        var type = channelData[cscSet.idx[comp]].type;\n        if (channelData[comp].type != 2) continue;\n\n        for (var y = 0; y < height; ++y) {\n          const offset2 = rowOffsets[comp][y];\n\n          for (var x = 0; x < width; ++x) {\n            halfRow[x] = dataView.getUint16(offset2 + x * INT16_SIZE * type, true);\n          }\n\n          for (var x = 0; x < width; ++x) {\n            dataView.setFloat32(offset2 + x * INT16_SIZE * type, decodeFloat16(halfRow[x]), true);\n          }\n        }\n      }\n    }\n\n    function unRleAC(currAcComp, acBuffer, halfZigBlock) {\n      var acValue;\n      var dctComp = 1;\n\n      while (dctComp < 64) {\n        acValue = acBuffer[currAcComp.value];\n\n        if (acValue == 65280) {\n          dctComp = 64;\n        } else if (acValue >> 8 == 255) {\n          dctComp += acValue & 255;\n        } else {\n          halfZigBlock[dctComp] = acValue;\n          dctComp++;\n        }\n\n        currAcComp.value++;\n      }\n    }\n\n    function unZigZag(src, dst) {\n      dst[0] = decodeFloat16(src[0]);\n      dst[1] = decodeFloat16(src[1]);\n      dst[2] = decodeFloat16(src[5]);\n      dst[3] = decodeFloat16(src[6]);\n      dst[4] = decodeFloat16(src[14]);\n      dst[5] = decodeFloat16(src[15]);\n      dst[6] = decodeFloat16(src[27]);\n      dst[7] = decodeFloat16(src[28]);\n      dst[8] = decodeFloat16(src[2]);\n      dst[9] = decodeFloat16(src[4]);\n      dst[10] = decodeFloat16(src[7]);\n      dst[11] = decodeFloat16(src[13]);\n      dst[12] = decodeFloat16(src[16]);\n      dst[13] = decodeFloat16(src[26]);\n      dst[14] = decodeFloat16(src[29]);\n      dst[15] = decodeFloat16(src[42]);\n      dst[16] = decodeFloat16(src[3]);\n      dst[17] = decodeFloat16(src[8]);\n      dst[18] = decodeFloat16(src[12]);\n      dst[19] = decodeFloat16(src[17]);\n      dst[20] = decodeFloat16(src[25]);\n      dst[21] = decodeFloat16(src[30]);\n      dst[22] = decodeFloat16(src[41]);\n      dst[23] = decodeFloat16(src[43]);\n      dst[24] = decodeFloat16(src[9]);\n      dst[25] = decodeFloat16(src[11]);\n      dst[26] = decodeFloat16(src[18]);\n      dst[27] = decodeFloat16(src[24]);\n      dst[28] = decodeFloat16(src[31]);\n      dst[29] = decodeFloat16(src[40]);\n      dst[30] = decodeFloat16(src[44]);\n      dst[31] = decodeFloat16(src[53]);\n      dst[32] = decodeFloat16(src[10]);\n      dst[33] = decodeFloat16(src[19]);\n      dst[34] = decodeFloat16(src[23]);\n      dst[35] = decodeFloat16(src[32]);\n      dst[36] = decodeFloat16(src[39]);\n      dst[37] = decodeFloat16(src[45]);\n      dst[38] = decodeFloat16(src[52]);\n      dst[39] = decodeFloat16(src[54]);\n      dst[40] = decodeFloat16(src[20]);\n      dst[41] = decodeFloat16(src[22]);\n      dst[42] = decodeFloat16(src[33]);\n      dst[43] = decodeFloat16(src[38]);\n      dst[44] = decodeFloat16(src[46]);\n      dst[45] = decodeFloat16(src[51]);\n      dst[46] = decodeFloat16(src[55]);\n      dst[47] = decodeFloat16(src[60]);\n      dst[48] = decodeFloat16(src[21]);\n      dst[49] = decodeFloat16(src[34]);\n      dst[50] = decodeFloat16(src[37]);\n      dst[51] = decodeFloat16(src[47]);\n      dst[52] = decodeFloat16(src[50]);\n      dst[53] = decodeFloat16(src[56]);\n      dst[54] = decodeFloat16(src[59]);\n      dst[55] = decodeFloat16(src[61]);\n      dst[56] = decodeFloat16(src[35]);\n      dst[57] = decodeFloat16(src[36]);\n      dst[58] = decodeFloat16(src[48]);\n      dst[59] = decodeFloat16(src[49]);\n      dst[60] = decodeFloat16(src[57]);\n      dst[61] = decodeFloat16(src[58]);\n      dst[62] = decodeFloat16(src[62]);\n      dst[63] = decodeFloat16(src[63]);\n    }\n\n    function dctInverse(data) {\n      const a = 0.5 * Math.cos(3.14159 / 4);\n      const b = 0.5 * Math.cos(3.14159 / 16);\n      const c = 0.5 * Math.cos(3.14159 / 8);\n      const d = 0.5 * Math.cos(3 * 3.14159 / 16);\n      const e = 0.5 * Math.cos(5 * 3.14159 / 16);\n      const f = 0.5 * Math.cos(3 * 3.14159 / 8);\n      const g = 0.5 * Math.cos(7 * 3.14159 / 16);\n      var alpha = new Array(4);\n      var beta = new Array(4);\n      var theta = new Array(4);\n      var gamma = new Array(4);\n\n      for (var row = 0; row < 8; ++row) {\n        var rowPtr = row * 8;\n        alpha[0] = c * data[rowPtr + 2];\n        alpha[1] = f * data[rowPtr + 2];\n        alpha[2] = c * data[rowPtr + 6];\n        alpha[3] = f * data[rowPtr + 6];\n        beta[0] = b * data[rowPtr + 1] + d * data[rowPtr + 3] + e * data[rowPtr + 5] + g * data[rowPtr + 7];\n        beta[1] = d * data[rowPtr + 1] - g * data[rowPtr + 3] - b * data[rowPtr + 5] - e * data[rowPtr + 7];\n        beta[2] = e * data[rowPtr + 1] - b * data[rowPtr + 3] + g * data[rowPtr + 5] + d * data[rowPtr + 7];\n        beta[3] = g * data[rowPtr + 1] - e * data[rowPtr + 3] + d * data[rowPtr + 5] - b * data[rowPtr + 7];\n        theta[0] = a * (data[rowPtr + 0] + data[rowPtr + 4]);\n        theta[3] = a * (data[rowPtr + 0] - data[rowPtr + 4]);\n        theta[1] = alpha[0] + alpha[3];\n        theta[2] = alpha[1] - alpha[2];\n        gamma[0] = theta[0] + theta[1];\n        gamma[1] = theta[3] + theta[2];\n        gamma[2] = theta[3] - theta[2];\n        gamma[3] = theta[0] - theta[1];\n        data[rowPtr + 0] = gamma[0] + beta[0];\n        data[rowPtr + 1] = gamma[1] + beta[1];\n        data[rowPtr + 2] = gamma[2] + beta[2];\n        data[rowPtr + 3] = gamma[3] + beta[3];\n        data[rowPtr + 4] = gamma[3] - beta[3];\n        data[rowPtr + 5] = gamma[2] - beta[2];\n        data[rowPtr + 6] = gamma[1] - beta[1];\n        data[rowPtr + 7] = gamma[0] - beta[0];\n      }\n\n      for (var column = 0; column < 8; ++column) {\n        alpha[0] = c * data[16 + column];\n        alpha[1] = f * data[16 + column];\n        alpha[2] = c * data[48 + column];\n        alpha[3] = f * data[48 + column];\n        beta[0] = b * data[8 + column] + d * data[24 + column] + e * data[40 + column] + g * data[56 + column];\n        beta[1] = d * data[8 + column] - g * data[24 + column] - b * data[40 + column] - e * data[56 + column];\n        beta[2] = e * data[8 + column] - b * data[24 + column] + g * data[40 + column] + d * data[56 + column];\n        beta[3] = g * data[8 + column] - e * data[24 + column] + d * data[40 + column] - b * data[56 + column];\n        theta[0] = a * (data[column] + data[32 + column]);\n        theta[3] = a * (data[column] - data[32 + column]);\n        theta[1] = alpha[0] + alpha[3];\n        theta[2] = alpha[1] - alpha[2];\n        gamma[0] = theta[0] + theta[1];\n        gamma[1] = theta[3] + theta[2];\n        gamma[2] = theta[3] - theta[2];\n        gamma[3] = theta[0] - theta[1];\n        data[0 + column] = gamma[0] + beta[0];\n        data[8 + column] = gamma[1] + beta[1];\n        data[16 + column] = gamma[2] + beta[2];\n        data[24 + column] = gamma[3] + beta[3];\n        data[32 + column] = gamma[3] - beta[3];\n        data[40 + column] = gamma[2] - beta[2];\n        data[48 + column] = gamma[1] - beta[1];\n        data[56 + column] = gamma[0] - beta[0];\n      }\n    }\n\n    function csc709Inverse(data) {\n      for (var i = 0; i < 64; ++i) {\n        var y = data[0][i];\n        var cb = data[1][i];\n        var cr = data[2][i];\n        data[0][i] = y + 1.5747 * cr;\n        data[1][i] = y - 0.1873 * cb - 0.4682 * cr;\n        data[2][i] = y + 1.8556 * cb;\n      }\n    }\n\n    function convertToHalf(src, dst, idx) {\n      for (var i = 0; i < 64; ++i) {\n        dst[idx + i] = DataUtils.toHalfFloat(toLinear(src[i]));\n      }\n    }\n\n    function toLinear(float) {\n      if (float <= 1) {\n        return Math.sign(float) * Math.pow(Math.abs(float), 2.2);\n      } else {\n        return Math.sign(float) * Math.pow(logBase, Math.abs(float) - 1);\n      }\n    }\n\n    function uncompressRAW(info) {\n      return new DataView(info.array.buffer, info.offset.value, info.size);\n    }\n\n    function uncompressRLE(info) {\n      var compressed = info.viewer.buffer.slice(info.offset.value, info.offset.value + info.size);\n      var rawBuffer = new Uint8Array(decodeRunLength(compressed));\n      var tmpBuffer = new Uint8Array(rawBuffer.length);\n      predictor(rawBuffer);\n      interleaveScalar(rawBuffer, tmpBuffer);\n      return new DataView(tmpBuffer.buffer);\n    }\n\n    function uncompressZIP(info) {\n      var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);\n      var rawBuffer = unzlibSync(compressed);\n      var tmpBuffer = new Uint8Array(rawBuffer.length);\n      predictor(rawBuffer);\n      interleaveScalar(rawBuffer, tmpBuffer);\n      return new DataView(tmpBuffer.buffer);\n    }\n\n    function uncompressPIZ(info) {\n      var inDataView = info.viewer;\n      var inOffset = {\n        value: info.offset.value\n      };\n      var outBuffer = new Uint16Array(info.width * info.scanlineBlockSize * (info.channels * info.type));\n      var bitmap = new Uint8Array(BITMAP_SIZE);\n      var outBufferEnd = 0;\n      var pizChannelData = new Array(info.channels);\n\n      for (var i = 0; i < info.channels; i++) {\n        pizChannelData[i] = {};\n        pizChannelData[i][\"start\"] = outBufferEnd;\n        pizChannelData[i][\"end\"] = pizChannelData[i][\"start\"];\n        pizChannelData[i][\"nx\"] = info.width;\n        pizChannelData[i][\"ny\"] = info.lines;\n        pizChannelData[i][\"size\"] = info.type;\n        outBufferEnd += pizChannelData[i].nx * pizChannelData[i].ny * pizChannelData[i].size;\n      }\n\n      var minNonZero = parseUint16(inDataView, inOffset);\n      var maxNonZero = parseUint16(inDataView, inOffset);\n\n      if (maxNonZero >= BITMAP_SIZE) {\n        throw \"Something is wrong with PIZ_COMPRESSION BITMAP_SIZE\";\n      }\n\n      if (minNonZero <= maxNonZero) {\n        for (var i = 0; i < maxNonZero - minNonZero + 1; i++) {\n          bitmap[i + minNonZero] = parseUint8(inDataView, inOffset);\n        }\n      }\n\n      var lut = new Uint16Array(USHORT_RANGE);\n      var maxValue = reverseLutFromBitmap(bitmap, lut);\n      var length = parseUint32(inDataView, inOffset);\n      hufUncompress(info.array, inDataView, inOffset, length, outBuffer, outBufferEnd);\n\n      for (var i = 0; i < info.channels; ++i) {\n        var cd = pizChannelData[i];\n\n        for (var j = 0; j < pizChannelData[i].size; ++j) {\n          wav2Decode(outBuffer, cd.start + j, cd.nx, cd.size, cd.ny, cd.nx * cd.size, maxValue);\n        }\n      }\n\n      applyLut(lut, outBuffer, outBufferEnd);\n      var tmpOffset2 = 0;\n      var tmpBuffer = new Uint8Array(outBuffer.buffer.byteLength);\n\n      for (var y = 0; y < info.lines; y++) {\n        for (var c = 0; c < info.channels; c++) {\n          var cd = pizChannelData[c];\n          var n = cd.nx * cd.size;\n          var cp = new Uint8Array(outBuffer.buffer, cd.end * INT16_SIZE, n * INT16_SIZE);\n          tmpBuffer.set(cp, tmpOffset2);\n          tmpOffset2 += n * INT16_SIZE;\n          cd.end += n;\n        }\n      }\n\n      return new DataView(tmpBuffer.buffer);\n    }\n\n    function uncompressPXR(info) {\n      var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);\n      var rawBuffer = unzlibSync(compressed);\n      const sz = info.lines * info.channels * info.width;\n      const tmpBuffer = info.type == 1 ? new Uint16Array(sz) : new Uint32Array(sz);\n      let tmpBufferEnd = 0;\n      let writePtr = 0;\n      const ptr = new Array(4);\n\n      for (let y = 0; y < info.lines; y++) {\n        for (let c = 0; c < info.channels; c++) {\n          let pixel = 0;\n\n          switch (info.type) {\n            case 1:\n              ptr[0] = tmpBufferEnd;\n              ptr[1] = ptr[0] + info.width;\n              tmpBufferEnd = ptr[1] + info.width;\n\n              for (let j = 0; j < info.width; ++j) {\n                const diff = rawBuffer[ptr[0]++] << 8 | rawBuffer[ptr[1]++];\n                pixel += diff;\n                tmpBuffer[writePtr] = pixel;\n                writePtr++;\n              }\n\n              break;\n\n            case 2:\n              ptr[0] = tmpBufferEnd;\n              ptr[1] = ptr[0] + info.width;\n              ptr[2] = ptr[1] + info.width;\n              tmpBufferEnd = ptr[2] + info.width;\n\n              for (let j = 0; j < info.width; ++j) {\n                const diff = rawBuffer[ptr[0]++] << 24 | rawBuffer[ptr[1]++] << 16 | rawBuffer[ptr[2]++] << 8;\n                pixel += diff;\n                tmpBuffer[writePtr] = pixel;\n                writePtr++;\n              }\n\n              break;\n          }\n        }\n      }\n\n      return new DataView(tmpBuffer.buffer);\n    }\n\n    function uncompressDWA(info) {\n      var inDataView = info.viewer;\n      var inOffset = {\n        value: info.offset.value\n      };\n      var outBuffer = new Uint8Array(info.width * info.lines * (info.channels * info.type * INT16_SIZE));\n      var dwaHeader = {\n        version: parseInt64(inDataView, inOffset),\n        unknownUncompressedSize: parseInt64(inDataView, inOffset),\n        unknownCompressedSize: parseInt64(inDataView, inOffset),\n        acCompressedSize: parseInt64(inDataView, inOffset),\n        dcCompressedSize: parseInt64(inDataView, inOffset),\n        rleCompressedSize: parseInt64(inDataView, inOffset),\n        rleUncompressedSize: parseInt64(inDataView, inOffset),\n        rleRawSize: parseInt64(inDataView, inOffset),\n        totalAcUncompressedCount: parseInt64(inDataView, inOffset),\n        totalDcUncompressedCount: parseInt64(inDataView, inOffset),\n        acCompression: parseInt64(inDataView, inOffset)\n      };\n\n      if (dwaHeader.version < 2) {\n        throw \"EXRLoader.parse: \" + EXRHeader.compression + \" version \" + dwaHeader.version + \" is unsupported\";\n      }\n\n      var channelRules = new Array();\n      var ruleSize = parseUint16(inDataView, inOffset) - INT16_SIZE;\n\n      while (ruleSize > 0) {\n        var name = parseNullTerminatedString(inDataView.buffer, inOffset);\n        var value = parseUint8(inDataView, inOffset);\n        var compression = value >> 2 & 3;\n        var csc = (value >> 4) - 1;\n        var index = new Int8Array([csc])[0];\n        var type = parseUint8(inDataView, inOffset);\n        channelRules.push({\n          name,\n          index,\n          type,\n          compression\n        });\n        ruleSize -= name.length + 3;\n      }\n\n      var channels = EXRHeader.channels;\n      var channelData = new Array(info.channels);\n\n      for (var i = 0; i < info.channels; ++i) {\n        var cd = channelData[i] = {};\n        var channel = channels[i];\n        cd.name = channel.name;\n        cd.compression = UNKNOWN;\n        cd.decoded = false;\n        cd.type = channel.pixelType;\n        cd.pLinear = channel.pLinear;\n        cd.width = info.width;\n        cd.height = info.lines;\n      }\n\n      var cscSet = {\n        idx: new Array(3)\n      };\n\n      for (var offset2 = 0; offset2 < info.channels; ++offset2) {\n        var cd = channelData[offset2];\n\n        for (var i = 0; i < channelRules.length; ++i) {\n          var rule = channelRules[i];\n\n          if (cd.name == rule.name) {\n            cd.compression = rule.compression;\n\n            if (rule.index >= 0) {\n              cscSet.idx[rule.index] = offset2;\n            }\n\n            cd.offset = offset2;\n          }\n        }\n      }\n\n      if (dwaHeader.acCompressedSize > 0) {\n        switch (dwaHeader.acCompression) {\n          case STATIC_HUFFMAN:\n            var acBuffer = new Uint16Array(dwaHeader.totalAcUncompressedCount);\n            hufUncompress(info.array, inDataView, inOffset, dwaHeader.acCompressedSize, acBuffer, dwaHeader.totalAcUncompressedCount);\n            break;\n\n          case DEFLATE:\n            var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.totalAcUncompressedCount);\n            var data = unzlibSync(compressed);\n            var acBuffer = new Uint16Array(data.buffer);\n            inOffset.value += dwaHeader.totalAcUncompressedCount;\n            break;\n        }\n      }\n\n      if (dwaHeader.dcCompressedSize > 0) {\n        var zlibInfo = {\n          array: info.array,\n          offset: inOffset,\n          size: dwaHeader.dcCompressedSize\n        };\n        var dcBuffer = new Uint16Array(uncompressZIP(zlibInfo).buffer);\n        inOffset.value += dwaHeader.dcCompressedSize;\n      }\n\n      if (dwaHeader.rleRawSize > 0) {\n        var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.rleCompressedSize);\n        var data = unzlibSync(compressed);\n        var rleBuffer = decodeRunLength(data.buffer);\n        inOffset.value += dwaHeader.rleCompressedSize;\n      }\n\n      var outBufferEnd = 0;\n      var rowOffsets = new Array(channelData.length);\n\n      for (var i = 0; i < rowOffsets.length; ++i) {\n        rowOffsets[i] = new Array();\n      }\n\n      for (var y = 0; y < info.lines; ++y) {\n        for (var chan = 0; chan < channelData.length; ++chan) {\n          rowOffsets[chan].push(outBufferEnd);\n          outBufferEnd += channelData[chan].width * info.type * INT16_SIZE;\n        }\n      }\n\n      lossyDctDecode(cscSet, rowOffsets, channelData, acBuffer, dcBuffer, outBuffer);\n\n      for (var i = 0; i < channelData.length; ++i) {\n        var cd = channelData[i];\n        if (cd.decoded) continue;\n\n        switch (cd.compression) {\n          case RLE:\n            var row = 0;\n            var rleOffset = 0;\n\n            for (var y = 0; y < info.lines; ++y) {\n              var rowOffsetBytes = rowOffsets[i][row];\n\n              for (var x = 0; x < cd.width; ++x) {\n                for (var byte = 0; byte < INT16_SIZE * cd.type; ++byte) {\n                  outBuffer[rowOffsetBytes++] = rleBuffer[rleOffset + byte * cd.width * cd.height];\n                }\n\n                rleOffset++;\n              }\n\n              row++;\n            }\n\n            break;\n\n          case LOSSY_DCT:\n          default:\n            throw \"EXRLoader.parse: unsupported channel compression\";\n        }\n      }\n\n      return new DataView(outBuffer.buffer);\n    }\n\n    function parseNullTerminatedString(buffer2, offset2) {\n      var uintBuffer = new Uint8Array(buffer2);\n      var endOffset = 0;\n\n      while (uintBuffer[offset2.value + endOffset] != 0) {\n        endOffset += 1;\n      }\n\n      var stringValue = new TextDecoder().decode(uintBuffer.slice(offset2.value, offset2.value + endOffset));\n      offset2.value = offset2.value + endOffset + 1;\n      return stringValue;\n    }\n\n    function parseFixedLengthString(buffer2, offset2, size) {\n      var stringValue = new TextDecoder().decode(new Uint8Array(buffer2).slice(offset2.value, offset2.value + size));\n      offset2.value = offset2.value + size;\n      return stringValue;\n    }\n\n    function parseRational(dataView, offset2) {\n      var x = parseInt32(dataView, offset2);\n      var y = parseUint32(dataView, offset2);\n      return [x, y];\n    }\n\n    function parseTimecode(dataView, offset2) {\n      var x = parseUint32(dataView, offset2);\n      var y = parseUint32(dataView, offset2);\n      return [x, y];\n    }\n\n    function parseInt32(dataView, offset2) {\n      var Int32 = dataView.getInt32(offset2.value, true);\n      offset2.value = offset2.value + INT32_SIZE;\n      return Int32;\n    }\n\n    function parseUint32(dataView, offset2) {\n      var Uint32 = dataView.getUint32(offset2.value, true);\n      offset2.value = offset2.value + INT32_SIZE;\n      return Uint32;\n    }\n\n    function parseUint8Array(uInt8Array2, offset2) {\n      var Uint8 = uInt8Array2[offset2.value];\n      offset2.value = offset2.value + INT8_SIZE;\n      return Uint8;\n    }\n\n    function parseUint8(dataView, offset2) {\n      var Uint8 = dataView.getUint8(offset2.value);\n      offset2.value = offset2.value + INT8_SIZE;\n      return Uint8;\n    }\n\n    const parseInt64 = function (dataView, offset2) {\n      let int;\n\n      if (\"getBigInt64\" in DataView.prototype) {\n        int = Number(dataView.getBigInt64(offset2.value, true));\n      } else {\n        int = dataView.getUint32(offset2.value + 4, true) + Number(dataView.getUint32(offset2.value, true) << 32);\n      }\n\n      offset2.value += ULONG_SIZE;\n      return int;\n    };\n\n    function parseFloat32(dataView, offset2) {\n      var float = dataView.getFloat32(offset2.value, true);\n      offset2.value += FLOAT32_SIZE;\n      return float;\n    }\n\n    function decodeFloat32(dataView, offset2) {\n      return DataUtils.toHalfFloat(parseFloat32(dataView, offset2));\n    }\n\n    function decodeFloat16(binary) {\n      var exponent = (binary & 31744) >> 10,\n          fraction = binary & 1023;\n      return (binary >> 15 ? -1 : 1) * (exponent ? exponent === 31 ? fraction ? NaN : Infinity : Math.pow(2, exponent - 15) * (1 + fraction / 1024) : 6103515625e-14 * (fraction / 1024));\n    }\n\n    function parseUint16(dataView, offset2) {\n      var Uint16 = dataView.getUint16(offset2.value, true);\n      offset2.value += INT16_SIZE;\n      return Uint16;\n    }\n\n    function parseFloat16(buffer2, offset2) {\n      return decodeFloat16(parseUint16(buffer2, offset2));\n    }\n\n    function parseChlist(dataView, buffer2, offset2, size) {\n      var startOffset = offset2.value;\n      var channels = [];\n\n      while (offset2.value < startOffset + size - 1) {\n        var name = parseNullTerminatedString(buffer2, offset2);\n        var pixelType = parseInt32(dataView, offset2);\n        var pLinear = parseUint8(dataView, offset2);\n        offset2.value += 3;\n        var xSampling = parseInt32(dataView, offset2);\n        var ySampling = parseInt32(dataView, offset2);\n        channels.push({\n          name,\n          pixelType,\n          pLinear,\n          xSampling,\n          ySampling\n        });\n      }\n\n      offset2.value += 1;\n      return channels;\n    }\n\n    function parseChromaticities(dataView, offset2) {\n      var redX = parseFloat32(dataView, offset2);\n      var redY = parseFloat32(dataView, offset2);\n      var greenX = parseFloat32(dataView, offset2);\n      var greenY = parseFloat32(dataView, offset2);\n      var blueX = parseFloat32(dataView, offset2);\n      var blueY = parseFloat32(dataView, offset2);\n      var whiteX = parseFloat32(dataView, offset2);\n      var whiteY = parseFloat32(dataView, offset2);\n      return {\n        redX,\n        redY,\n        greenX,\n        greenY,\n        blueX,\n        blueY,\n        whiteX,\n        whiteY\n      };\n    }\n\n    function parseCompression(dataView, offset2) {\n      var compressionCodes = [\"NO_COMPRESSION\", \"RLE_COMPRESSION\", \"ZIPS_COMPRESSION\", \"ZIP_COMPRESSION\", \"PIZ_COMPRESSION\", \"PXR24_COMPRESSION\", \"B44_COMPRESSION\", \"B44A_COMPRESSION\", \"DWAA_COMPRESSION\", \"DWAB_COMPRESSION\"];\n      var compression = parseUint8(dataView, offset2);\n      return compressionCodes[compression];\n    }\n\n    function parseBox2i(dataView, offset2) {\n      var xMin = parseUint32(dataView, offset2);\n      var yMin = parseUint32(dataView, offset2);\n      var xMax = parseUint32(dataView, offset2);\n      var yMax = parseUint32(dataView, offset2);\n      return {\n        xMin,\n        yMin,\n        xMax,\n        yMax\n      };\n    }\n\n    function parseLineOrder(dataView, offset2) {\n      var lineOrders = [\"INCREASING_Y\"];\n      var lineOrder = parseUint8(dataView, offset2);\n      return lineOrders[lineOrder];\n    }\n\n    function parseV2f(dataView, offset2) {\n      var x = parseFloat32(dataView, offset2);\n      var y = parseFloat32(dataView, offset2);\n      return [x, y];\n    }\n\n    function parseV3f(dataView, offset2) {\n      var x = parseFloat32(dataView, offset2);\n      var y = parseFloat32(dataView, offset2);\n      var z = parseFloat32(dataView, offset2);\n      return [x, y, z];\n    }\n\n    function parseValue(dataView, buffer2, offset2, type, size) {\n      if (type === \"string\" || type === \"stringvector\" || type === \"iccProfile\") {\n        return parseFixedLengthString(buffer2, offset2, size);\n      } else if (type === \"chlist\") {\n        return parseChlist(dataView, buffer2, offset2, size);\n      } else if (type === \"chromaticities\") {\n        return parseChromaticities(dataView, offset2);\n      } else if (type === \"compression\") {\n        return parseCompression(dataView, offset2);\n      } else if (type === \"box2i\") {\n        return parseBox2i(dataView, offset2);\n      } else if (type === \"lineOrder\") {\n        return parseLineOrder(dataView, offset2);\n      } else if (type === \"float\") {\n        return parseFloat32(dataView, offset2);\n      } else if (type === \"v2f\") {\n        return parseV2f(dataView, offset2);\n      } else if (type === \"v3f\") {\n        return parseV3f(dataView, offset2);\n      } else if (type === \"int\") {\n        return parseInt32(dataView, offset2);\n      } else if (type === \"rational\") {\n        return parseRational(dataView, offset2);\n      } else if (type === \"timecode\") {\n        return parseTimecode(dataView, offset2);\n      } else if (type === \"preview\") {\n        offset2.value += size;\n        return \"skipped\";\n      } else {\n        offset2.value += size;\n        return void 0;\n      }\n    }\n\n    function parseHeader(dataView, buffer2, offset2) {\n      const EXRHeader2 = {};\n\n      if (dataView.getUint32(0, true) != 20000630) {\n        throw \"THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.\";\n      }\n\n      EXRHeader2.version = dataView.getUint8(4);\n      const spec = dataView.getUint8(5);\n      EXRHeader2.spec = {\n        singleTile: !!(spec & 2),\n        longName: !!(spec & 4),\n        deepFormat: !!(spec & 8),\n        multiPart: !!(spec & 16)\n      };\n      offset2.value = 8;\n      var keepReading = true;\n\n      while (keepReading) {\n        var attributeName = parseNullTerminatedString(buffer2, offset2);\n\n        if (attributeName == 0) {\n          keepReading = false;\n        } else {\n          var attributeType = parseNullTerminatedString(buffer2, offset2);\n          var attributeSize = parseUint32(dataView, offset2);\n          var attributeValue = parseValue(dataView, buffer2, offset2, attributeType, attributeSize);\n\n          if (attributeValue === void 0) {\n            console.warn(`EXRLoader.parse: skipped unknown header attribute type '${attributeType}'.`);\n          } else {\n            EXRHeader2[attributeName] = attributeValue;\n          }\n        }\n      }\n\n      if (spec != 0) {\n        console.error(\"EXRHeader:\", EXRHeader2);\n        throw \"THREE.EXRLoader: provided file is currently unsupported.\";\n      }\n\n      return EXRHeader2;\n    }\n\n    function setupDecoder(EXRHeader2, dataView, uInt8Array2, offset2, outputType) {\n      const EXRDecoder2 = {\n        size: 0,\n        viewer: dataView,\n        array: uInt8Array2,\n        offset: offset2,\n        width: EXRHeader2.dataWindow.xMax - EXRHeader2.dataWindow.xMin + 1,\n        height: EXRHeader2.dataWindow.yMax - EXRHeader2.dataWindow.yMin + 1,\n        channels: EXRHeader2.channels.length,\n        bytesPerLine: null,\n        lines: null,\n        inputSize: null,\n        type: EXRHeader2.channels[0].pixelType,\n        uncompress: null,\n        getter: null,\n        format: null,\n        [hasColorSpace ? \"colorSpace\" : \"encoding\"]: null\n      };\n\n      switch (EXRHeader2.compression) {\n        case \"NO_COMPRESSION\":\n          EXRDecoder2.lines = 1;\n          EXRDecoder2.uncompress = uncompressRAW;\n          break;\n\n        case \"RLE_COMPRESSION\":\n          EXRDecoder2.lines = 1;\n          EXRDecoder2.uncompress = uncompressRLE;\n          break;\n\n        case \"ZIPS_COMPRESSION\":\n          EXRDecoder2.lines = 1;\n          EXRDecoder2.uncompress = uncompressZIP;\n          break;\n\n        case \"ZIP_COMPRESSION\":\n          EXRDecoder2.lines = 16;\n          EXRDecoder2.uncompress = uncompressZIP;\n          break;\n\n        case \"PIZ_COMPRESSION\":\n          EXRDecoder2.lines = 32;\n          EXRDecoder2.uncompress = uncompressPIZ;\n          break;\n\n        case \"PXR24_COMPRESSION\":\n          EXRDecoder2.lines = 16;\n          EXRDecoder2.uncompress = uncompressPXR;\n          break;\n\n        case \"DWAA_COMPRESSION\":\n          EXRDecoder2.lines = 32;\n          EXRDecoder2.uncompress = uncompressDWA;\n          break;\n\n        case \"DWAB_COMPRESSION\":\n          EXRDecoder2.lines = 256;\n          EXRDecoder2.uncompress = uncompressDWA;\n          break;\n\n        default:\n          throw \"EXRLoader.parse: \" + EXRHeader2.compression + \" is unsupported\";\n      }\n\n      EXRDecoder2.scanlineBlockSize = EXRDecoder2.lines;\n\n      if (EXRDecoder2.type == 1) {\n        switch (outputType) {\n          case FloatType:\n            EXRDecoder2.getter = parseFloat16;\n            EXRDecoder2.inputSize = INT16_SIZE;\n            break;\n\n          case HalfFloatType:\n            EXRDecoder2.getter = parseUint16;\n            EXRDecoder2.inputSize = INT16_SIZE;\n            break;\n        }\n      } else if (EXRDecoder2.type == 2) {\n        switch (outputType) {\n          case FloatType:\n            EXRDecoder2.getter = parseFloat32;\n            EXRDecoder2.inputSize = FLOAT32_SIZE;\n            break;\n\n          case HalfFloatType:\n            EXRDecoder2.getter = decodeFloat32;\n            EXRDecoder2.inputSize = FLOAT32_SIZE;\n        }\n      } else {\n        throw \"EXRLoader.parse: unsupported pixelType \" + EXRDecoder2.type + \" for \" + EXRHeader2.compression + \".\";\n      }\n\n      EXRDecoder2.blockCount = (EXRHeader2.dataWindow.yMax + 1) / EXRDecoder2.scanlineBlockSize;\n\n      for (var i = 0; i < EXRDecoder2.blockCount; i++) parseInt64(dataView, offset2);\n\n      EXRDecoder2.outputChannels = EXRDecoder2.channels == 3 ? 4 : EXRDecoder2.channels;\n      const size = EXRDecoder2.width * EXRDecoder2.height * EXRDecoder2.outputChannels;\n\n      switch (outputType) {\n        case FloatType:\n          EXRDecoder2.byteArray = new Float32Array(size);\n          if (EXRDecoder2.channels < EXRDecoder2.outputChannels) EXRDecoder2.byteArray.fill(1, 0, size);\n          break;\n\n        case HalfFloatType:\n          EXRDecoder2.byteArray = new Uint16Array(size);\n          if (EXRDecoder2.channels < EXRDecoder2.outputChannels) EXRDecoder2.byteArray.fill(15360, 0, size);\n          break;\n\n        default:\n          console.error(\"THREE.EXRLoader: unsupported type: \", outputType);\n          break;\n      }\n\n      EXRDecoder2.bytesPerLine = EXRDecoder2.width * EXRDecoder2.inputSize * EXRDecoder2.channels;\n      if (EXRDecoder2.outputChannels == 4) EXRDecoder2.format = RGBAFormat;else EXRDecoder2.format = RedFormat;\n      if (hasColorSpace) EXRDecoder2.colorSpace = \"srgb-linear\";else EXRDecoder2.encoding = 3e3;\n      return EXRDecoder2;\n    }\n\n    const bufferDataView = new DataView(buffer);\n    const uInt8Array = new Uint8Array(buffer);\n    const offset = {\n      value: 0\n    };\n    const EXRHeader = parseHeader(bufferDataView, buffer, offset);\n    const EXRDecoder = setupDecoder(EXRHeader, bufferDataView, uInt8Array, offset, this.type);\n    const tmpOffset = {\n      value: 0\n    };\n    const channelOffsets = {\n      R: 0,\n      G: 1,\n      B: 2,\n      A: 3,\n      Y: 0\n    };\n\n    for (let scanlineBlockIdx = 0; scanlineBlockIdx < EXRDecoder.height / EXRDecoder.scanlineBlockSize; scanlineBlockIdx++) {\n      const line = parseUint32(bufferDataView, offset);\n      EXRDecoder.size = parseUint32(bufferDataView, offset);\n      EXRDecoder.lines = line + EXRDecoder.scanlineBlockSize > EXRDecoder.height ? EXRDecoder.height - line : EXRDecoder.scanlineBlockSize;\n      const isCompressed = EXRDecoder.size < EXRDecoder.lines * EXRDecoder.bytesPerLine;\n      const viewer = isCompressed ? EXRDecoder.uncompress(EXRDecoder) : uncompressRAW(EXRDecoder);\n      offset.value += EXRDecoder.size;\n\n      for (let line_y = 0; line_y < EXRDecoder.scanlineBlockSize; line_y++) {\n        const true_y = line_y + scanlineBlockIdx * EXRDecoder.scanlineBlockSize;\n        if (true_y >= EXRDecoder.height) break;\n\n        for (let channelID = 0; channelID < EXRDecoder.channels; channelID++) {\n          const cOff = channelOffsets[EXRHeader.channels[channelID].name];\n\n          for (let x = 0; x < EXRDecoder.width; x++) {\n            tmpOffset.value = (line_y * (EXRDecoder.channels * EXRDecoder.width) + channelID * EXRDecoder.width + x) * EXRDecoder.inputSize;\n            const outIndex = (EXRDecoder.height - 1 - true_y) * (EXRDecoder.width * EXRDecoder.outputChannels) + x * EXRDecoder.outputChannels + cOff;\n            EXRDecoder.byteArray[outIndex] = EXRDecoder.getter(viewer, tmpOffset);\n          }\n        }\n      }\n    }\n\n    return {\n      header: EXRHeader,\n      width: EXRDecoder.width,\n      height: EXRDecoder.height,\n      data: EXRDecoder.byteArray,\n      format: EXRDecoder.format,\n      [hasColorSpace ? \"colorSpace\" : \"encoding\"]: EXRDecoder[hasColorSpace ? \"colorSpace\" : \"encoding\"],\n      type: this.type\n    };\n  }\n\n  setDataType(value) {\n    this.type = value;\n    return this;\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    function onLoadCallback(texture, texData) {\n      if (hasColorSpace) texture.colorSpace = texData.colorSpace;else texture.encoding = texData.encoding;\n      texture.minFilter = LinearFilter;\n      texture.magFilter = LinearFilter;\n      texture.generateMipmaps = false;\n      texture.flipY = false;\n      if (onLoad) onLoad(texture, texData);\n    }\n\n    return super.load(url, onLoadCallback, onProgress, onError);\n  }\n\n}\n\nexport { EXRLoader };","map":{"version":3,"sources":["/Users/theodaguier/Repositories/E-Do-Studio/node_modules/three-stdlib/loaders/EXRLoader.js"],"names":["Texture","DataTextureLoader","HalfFloatType","DataUtils","FloatType","RGBAFormat","RedFormat","LinearFilter","unzlibSync","hasColorSpace","EXRLoader","constructor","manager","type","parse","buffer","USHORT_RANGE","BITMAP_SIZE","HUF_ENCBITS","HUF_DECBITS","HUF_ENCSIZE","HUF_DECSIZE","HUF_DECMASK","NBITS","A_OFFSET","MOD_MASK","SHORT_ZEROCODE_RUN","LONG_ZEROCODE_RUN","SHORTEST_LONG_RUN","ULONG_SIZE","FLOAT32_SIZE","INT32_SIZE","INT16_SIZE","INT8_SIZE","STATIC_HUFFMAN","DEFLATE","UNKNOWN","LOSSY_DCT","RLE","logBase","Math","pow","reverseLutFromBitmap","bitmap","lut","k","i","n","hufClearDecTable","hdec","len","lit","p","getBitsReturn","l","c","lc","getBits","nBits","uInt8Array2","inOffset","parseUint8Array","hufTableBuffer","Array","hufCanonicalCodeTable","hcode","nc","hufUnpackEncTable","inDataView","ni","im","iM","value","zerun","hufLength","code","hufCode","hufBuildDecTable","hdecod","pl","plOffset","getCharReturn","getChar","getCodeReturn","getCode","po","rlc","outBuffer","outBufferOffset","outBufferEndOffset","cs","Uint8Array","s","UInt16","Int16","ref","wdec14Return","a","b","wdec14","h","ls","hs","hi","ai","as","bs","wdec16","m","d","bb","aa","wav2Decode","buffer2","j","nx","ox","ny","oy","mx","w14","p2","py","ey","oy1","oy2","ox1","ox2","i00","i01","i10","i11","px","ex","p01","p10","p11","hufDecode","encodingTable","decodingTable","no","outOffset","inOffsetEnd","trunc","index","hufUncompress","nCompressed","nRaw","initialInOffset","parseUint32","freq","applyLut","data","nData","predictor","source","t","length","interleaveScalar","out","t1","t2","floor","stop","decodeRunLength","size","byteLength","reader","DataView","getInt8","count","push","getUint8","lossyDctDecode","cscSet","rowPtrs","channelData","acBuffer","dcBuffer","dataView","width","idx","height","numComp","numFullBlocksX","numBlocksX","ceil","numBlocksY","leftoverX","leftoverY","currAcComp","currDcComp","dctData","halfZigBlock","rowBlock","rowOffsets","comp2","Float32Array","Uint16Array","blocky","maxY","maxX","blockx","fill","unRleAC","unZigZag","dctInverse","csc709Inverse","convertToHalf","offset2","type2","y2","src","setUint16","offset3","x2","halfRow","comp","decoded","y","x","getUint16","setFloat32","decodeFloat16","acValue","dctComp","dst","cos","e","f","g","alpha","beta","theta","gamma","row","rowPtr","column","cb","cr","toHalfFloat","toLinear","float","sign","abs","uncompressRAW","info","array","offset","uncompressRLE","compressed","viewer","slice","rawBuffer","tmpBuffer","uncompressZIP","uncompressPIZ","scanlineBlockSize","channels","outBufferEnd","pizChannelData","lines","minNonZero","parseUint16","maxNonZero","parseUint8","maxValue","cd","start","tmpOffset2","cp","end","set","uncompressPXR","sz","Uint32Array","tmpBufferEnd","writePtr","ptr","pixel","diff","uncompressDWA","dwaHeader","version","parseInt64","unknownUncompressedSize","unknownCompressedSize","acCompressedSize","dcCompressedSize","rleCompressedSize","rleUncompressedSize","rleRawSize","totalAcUncompressedCount","totalDcUncompressedCount","acCompression","EXRHeader","compression","channelRules","ruleSize","name","parseNullTerminatedString","csc","Int8Array","channel","pixelType","pLinear","rule","zlibInfo","rleBuffer","chan","rleOffset","rowOffsetBytes","byte","uintBuffer","endOffset","stringValue","TextDecoder","decode","parseFixedLengthString","parseRational","parseInt32","parseTimecode","Int32","getInt32","Uint32","getUint32","Uint8","int","prototype","Number","getBigInt64","parseFloat32","getFloat32","decodeFloat32","binary","exponent","fraction","NaN","Infinity","Uint16","parseFloat16","parseChlist","startOffset","xSampling","ySampling","parseChromaticities","redX","redY","greenX","greenY","blueX","blueY","whiteX","whiteY","parseCompression","compressionCodes","parseBox2i","xMin","yMin","xMax","yMax","parseLineOrder","lineOrders","lineOrder","parseV2f","parseV3f","z","parseValue","parseHeader","EXRHeader2","spec","singleTile","longName","deepFormat","multiPart","keepReading","attributeName","attributeType","attributeSize","attributeValue","console","warn","error","setupDecoder","outputType","EXRDecoder2","dataWindow","bytesPerLine","inputSize","uncompress","getter","format","blockCount","outputChannels","byteArray","colorSpace","encoding","bufferDataView","uInt8Array","EXRDecoder","tmpOffset","channelOffsets","R","G","B","A","Y","scanlineBlockIdx","line","isCompressed","line_y","true_y","channelID","cOff","outIndex","header","setDataType","load","url","onLoad","onProgress","onError","onLoadCallback","texture","texData","minFilter","magFilter","generateMipmaps","flipY"],"mappings":"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","sourcesContent":["import { Texture, DataTextureLoader, HalfFloatType, DataUtils, FloatType, RGBAFormat, RedFormat, LinearFilter } from \"three\";\nimport { unzlibSync } from \"fflate\";\nconst hasColorSpace = \"colorSpace\" in /* @__PURE__ */ new Texture();\nclass EXRLoader extends DataTextureLoader {\n  constructor(manager) {\n    super(manager);\n    this.type = HalfFloatType;\n  }\n  parse(buffer) {\n    const USHORT_RANGE = 1 << 16;\n    const BITMAP_SIZE = USHORT_RANGE >> 3;\n    const HUF_ENCBITS = 16;\n    const HUF_DECBITS = 14;\n    const HUF_ENCSIZE = (1 << HUF_ENCBITS) + 1;\n    const HUF_DECSIZE = 1 << HUF_DECBITS;\n    const HUF_DECMASK = HUF_DECSIZE - 1;\n    const NBITS = 16;\n    const A_OFFSET = 1 << NBITS - 1;\n    const MOD_MASK = (1 << NBITS) - 1;\n    const SHORT_ZEROCODE_RUN = 59;\n    const LONG_ZEROCODE_RUN = 63;\n    const SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;\n    const ULONG_SIZE = 8;\n    const FLOAT32_SIZE = 4;\n    const INT32_SIZE = 4;\n    const INT16_SIZE = 2;\n    const INT8_SIZE = 1;\n    const STATIC_HUFFMAN = 0;\n    const DEFLATE = 1;\n    const UNKNOWN = 0;\n    const LOSSY_DCT = 1;\n    const RLE = 2;\n    const logBase = Math.pow(2.7182818, 2.2);\n    function reverseLutFromBitmap(bitmap, lut) {\n      var k = 0;\n      for (var i = 0; i < USHORT_RANGE; ++i) {\n        if (i == 0 || bitmap[i >> 3] & 1 << (i & 7)) {\n          lut[k++] = i;\n        }\n      }\n      var n = k - 1;\n      while (k < USHORT_RANGE)\n        lut[k++] = 0;\n      return n;\n    }\n    function hufClearDecTable(hdec) {\n      for (var i = 0; i < HUF_DECSIZE; i++) {\n        hdec[i] = {};\n        hdec[i].len = 0;\n        hdec[i].lit = 0;\n        hdec[i].p = null;\n      }\n    }\n    const getBitsReturn = { l: 0, c: 0, lc: 0 };\n    function getBits(nBits, c, lc, uInt8Array2, inOffset) {\n      while (lc < nBits) {\n        c = c << 8 | parseUint8Array(uInt8Array2, inOffset);\n        lc += 8;\n      }\n      lc -= nBits;\n      getBitsReturn.l = c >> lc & (1 << nBits) - 1;\n      getBitsReturn.c = c;\n      getBitsReturn.lc = lc;\n    }\n    const hufTableBuffer = new Array(59);\n    function hufCanonicalCodeTable(hcode) {\n      for (var i = 0; i <= 58; ++i)\n        hufTableBuffer[i] = 0;\n      for (var i = 0; i < HUF_ENCSIZE; ++i)\n        hufTableBuffer[hcode[i]] += 1;\n      var c = 0;\n      for (var i = 58; i > 0; --i) {\n        var nc = c + hufTableBuffer[i] >> 1;\n        hufTableBuffer[i] = c;\n        c = nc;\n      }\n      for (var i = 0; i < HUF_ENCSIZE; ++i) {\n        var l = hcode[i];\n        if (l > 0)\n          hcode[i] = l | hufTableBuffer[l]++ << 6;\n      }\n    }\n    function hufUnpackEncTable(uInt8Array2, inDataView, inOffset, ni, im, iM, hcode) {\n      var p = inOffset;\n      var c = 0;\n      var lc = 0;\n      for (; im <= iM; im++) {\n        if (p.value - inOffset.value > ni)\n          return false;\n        getBits(6, c, lc, uInt8Array2, p);\n        var l = getBitsReturn.l;\n        c = getBitsReturn.c;\n        lc = getBitsReturn.lc;\n        hcode[im] = l;\n        if (l == LONG_ZEROCODE_RUN) {\n          if (p.value - inOffset.value > ni) {\n            throw \"Something wrong with hufUnpackEncTable\";\n          }\n          getBits(8, c, lc, uInt8Array2, p);\n          var zerun = getBitsReturn.l + SHORTEST_LONG_RUN;\n          c = getBitsReturn.c;\n          lc = getBitsReturn.lc;\n          if (im + zerun > iM + 1) {\n            throw \"Something wrong with hufUnpackEncTable\";\n          }\n          while (zerun--)\n            hcode[im++] = 0;\n          im--;\n        } else if (l >= SHORT_ZEROCODE_RUN) {\n          var zerun = l - SHORT_ZEROCODE_RUN + 2;\n          if (im + zerun > iM + 1) {\n            throw \"Something wrong with hufUnpackEncTable\";\n          }\n          while (zerun--)\n            hcode[im++] = 0;\n          im--;\n        }\n      }\n      hufCanonicalCodeTable(hcode);\n    }\n    function hufLength(code) {\n      return code & 63;\n    }\n    function hufCode(code) {\n      return code >> 6;\n    }\n    function hufBuildDecTable(hcode, im, iM, hdecod) {\n      for (; im <= iM; im++) {\n        var c = hufCode(hcode[im]);\n        var l = hufLength(hcode[im]);\n        if (c >> l) {\n          throw \"Invalid table entry\";\n        }\n        if (l > HUF_DECBITS) {\n          var pl = hdecod[c >> l - HUF_DECBITS];\n          if (pl.len) {\n            throw \"Invalid table entry\";\n          }\n          pl.lit++;\n          if (pl.p) {\n            var p = pl.p;\n            pl.p = new Array(pl.lit);\n            for (var i = 0; i < pl.lit - 1; ++i) {\n              pl.p[i] = p[i];\n            }\n          } else {\n            pl.p = new Array(1);\n          }\n          pl.p[pl.lit - 1] = im;\n        } else if (l) {\n          var plOffset = 0;\n          for (var i = 1 << HUF_DECBITS - l; i > 0; i--) {\n            var pl = hdecod[(c << HUF_DECBITS - l) + plOffset];\n            if (pl.len || pl.p) {\n              throw \"Invalid table entry\";\n            }\n            pl.len = l;\n            pl.lit = im;\n            plOffset++;\n          }\n        }\n      }\n      return true;\n    }\n    const getCharReturn = { c: 0, lc: 0 };\n    function getChar(c, lc, uInt8Array2, inOffset) {\n      c = c << 8 | parseUint8Array(uInt8Array2, inOffset);\n      lc += 8;\n      getCharReturn.c = c;\n      getCharReturn.lc = lc;\n    }\n    const getCodeReturn = { c: 0, lc: 0 };\n    function getCode(po, rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outBufferOffset, outBufferEndOffset) {\n      if (po == rlc) {\n        if (lc < 8) {\n          getChar(c, lc, uInt8Array2, inOffset);\n          c = getCharReturn.c;\n          lc = getCharReturn.lc;\n        }\n        lc -= 8;\n        var cs = c >> lc;\n        var cs = new Uint8Array([cs])[0];\n        if (outBufferOffset.value + cs > outBufferEndOffset) {\n          return false;\n        }\n        var s = outBuffer[outBufferOffset.value - 1];\n        while (cs-- > 0) {\n          outBuffer[outBufferOffset.value++] = s;\n        }\n      } else if (outBufferOffset.value < outBufferEndOffset) {\n        outBuffer[outBufferOffset.value++] = po;\n      } else {\n        return false;\n      }\n      getCodeReturn.c = c;\n      getCodeReturn.lc = lc;\n    }\n    function UInt16(value) {\n      return value & 65535;\n    }\n    function Int16(value) {\n      var ref = UInt16(value);\n      return ref > 32767 ? ref - 65536 : ref;\n    }\n    const wdec14Return = { a: 0, b: 0 };\n    function wdec14(l, h) {\n      var ls = Int16(l);\n      var hs = Int16(h);\n      var hi = hs;\n      var ai = ls + (hi & 1) + (hi >> 1);\n      var as = ai;\n      var bs = ai - hi;\n      wdec14Return.a = as;\n      wdec14Return.b = bs;\n    }\n    function wdec16(l, h) {\n      var m = UInt16(l);\n      var d = UInt16(h);\n      var bb = m - (d >> 1) & MOD_MASK;\n      var aa = d + bb - A_OFFSET & MOD_MASK;\n      wdec14Return.a = aa;\n      wdec14Return.b = bb;\n    }\n    function wav2Decode(buffer2, j, nx, ox, ny, oy, mx) {\n      var w14 = mx < 1 << 14;\n      var n = nx > ny ? ny : nx;\n      var p = 1;\n      var p2;\n      while (p <= n)\n        p <<= 1;\n      p >>= 1;\n      p2 = p;\n      p >>= 1;\n      while (p >= 1) {\n        var py = 0;\n        var ey = py + oy * (ny - p2);\n        var oy1 = oy * p;\n        var oy2 = oy * p2;\n        var ox1 = ox * p;\n        var ox2 = ox * p2;\n        var i00, i01, i10, i11;\n        for (; py <= ey; py += oy2) {\n          var px = py;\n          var ex = py + ox * (nx - p2);\n          for (; px <= ex; px += ox2) {\n            var p01 = px + ox1;\n            var p10 = px + oy1;\n            var p11 = p10 + ox1;\n            if (w14) {\n              wdec14(buffer2[px + j], buffer2[p10 + j]);\n              i00 = wdec14Return.a;\n              i10 = wdec14Return.b;\n              wdec14(buffer2[p01 + j], buffer2[p11 + j]);\n              i01 = wdec14Return.a;\n              i11 = wdec14Return.b;\n              wdec14(i00, i01);\n              buffer2[px + j] = wdec14Return.a;\n              buffer2[p01 + j] = wdec14Return.b;\n              wdec14(i10, i11);\n              buffer2[p10 + j] = wdec14Return.a;\n              buffer2[p11 + j] = wdec14Return.b;\n            } else {\n              wdec16(buffer2[px + j], buffer2[p10 + j]);\n              i00 = wdec14Return.a;\n              i10 = wdec14Return.b;\n              wdec16(buffer2[p01 + j], buffer2[p11 + j]);\n              i01 = wdec14Return.a;\n              i11 = wdec14Return.b;\n              wdec16(i00, i01);\n              buffer2[px + j] = wdec14Return.a;\n              buffer2[p01 + j] = wdec14Return.b;\n              wdec16(i10, i11);\n              buffer2[p10 + j] = wdec14Return.a;\n              buffer2[p11 + j] = wdec14Return.b;\n            }\n          }\n          if (nx & p) {\n            var p10 = px + oy1;\n            if (w14)\n              wdec14(buffer2[px + j], buffer2[p10 + j]);\n            else\n              wdec16(buffer2[px + j], buffer2[p10 + j]);\n            i00 = wdec14Return.a;\n            buffer2[p10 + j] = wdec14Return.b;\n            buffer2[px + j] = i00;\n          }\n        }\n        if (ny & p) {\n          var px = py;\n          var ex = py + ox * (nx - p2);\n          for (; px <= ex; px += ox2) {\n            var p01 = px + ox1;\n            if (w14)\n              wdec14(buffer2[px + j], buffer2[p01 + j]);\n            else\n              wdec16(buffer2[px + j], buffer2[p01 + j]);\n            i00 = wdec14Return.a;\n            buffer2[p01 + j] = wdec14Return.b;\n            buffer2[px + j] = i00;\n          }\n        }\n        p2 = p;\n        p >>= 1;\n      }\n      return py;\n    }\n    function hufDecode(encodingTable, decodingTable, uInt8Array2, inDataView, inOffset, ni, rlc, no, outBuffer, outOffset) {\n      var c = 0;\n      var lc = 0;\n      var outBufferEndOffset = no;\n      var inOffsetEnd = Math.trunc(inOffset.value + (ni + 7) / 8);\n      while (inOffset.value < inOffsetEnd) {\n        getChar(c, lc, uInt8Array2, inOffset);\n        c = getCharReturn.c;\n        lc = getCharReturn.lc;\n        while (lc >= HUF_DECBITS) {\n          var index = c >> lc - HUF_DECBITS & HUF_DECMASK;\n          var pl = decodingTable[index];\n          if (pl.len) {\n            lc -= pl.len;\n            getCode(pl.lit, rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n            c = getCodeReturn.c;\n            lc = getCodeReturn.lc;\n          } else {\n            if (!pl.p) {\n              throw \"hufDecode issues\";\n            }\n            var j;\n            for (j = 0; j < pl.lit; j++) {\n              var l = hufLength(encodingTable[pl.p[j]]);\n              while (lc < l && inOffset.value < inOffsetEnd) {\n                getChar(c, lc, uInt8Array2, inOffset);\n                c = getCharReturn.c;\n                lc = getCharReturn.lc;\n              }\n              if (lc >= l) {\n                if (hufCode(encodingTable[pl.p[j]]) == (c >> lc - l & (1 << l) - 1)) {\n                  lc -= l;\n                  getCode(\n                    pl.p[j],\n                    rlc,\n                    c,\n                    lc,\n                    uInt8Array2,\n                    inDataView,\n                    inOffset,\n                    outBuffer,\n                    outOffset,\n                    outBufferEndOffset\n                  );\n                  c = getCodeReturn.c;\n                  lc = getCodeReturn.lc;\n                  break;\n                }\n              }\n            }\n            if (j == pl.lit) {\n              throw \"hufDecode issues\";\n            }\n          }\n        }\n      }\n      var i = 8 - ni & 7;\n      c >>= i;\n      lc -= i;\n      while (lc > 0) {\n        var pl = decodingTable[c << HUF_DECBITS - lc & HUF_DECMASK];\n        if (pl.len) {\n          lc -= pl.len;\n          getCode(pl.lit, rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n          c = getCodeReturn.c;\n          lc = getCodeReturn.lc;\n        } else {\n          throw \"hufDecode issues\";\n        }\n      }\n      return true;\n    }\n    function hufUncompress(uInt8Array2, inDataView, inOffset, nCompressed, outBuffer, nRaw) {\n      var outOffset = { value: 0 };\n      var initialInOffset = inOffset.value;\n      var im = parseUint32(inDataView, inOffset);\n      var iM = parseUint32(inDataView, inOffset);\n      inOffset.value += 4;\n      var nBits = parseUint32(inDataView, inOffset);\n      inOffset.value += 4;\n      if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE) {\n        throw \"Something wrong with HUF_ENCSIZE\";\n      }\n      var freq = new Array(HUF_ENCSIZE);\n      var hdec = new Array(HUF_DECSIZE);\n      hufClearDecTable(hdec);\n      var ni = nCompressed - (inOffset.value - initialInOffset);\n      hufUnpackEncTable(uInt8Array2, inDataView, inOffset, ni, im, iM, freq);\n      if (nBits > 8 * (nCompressed - (inOffset.value - initialInOffset))) {\n        throw \"Something wrong with hufUncompress\";\n      }\n      hufBuildDecTable(freq, im, iM, hdec);\n      hufDecode(freq, hdec, uInt8Array2, inDataView, inOffset, nBits, iM, nRaw, outBuffer, outOffset);\n    }\n    function applyLut(lut, data, nData) {\n      for (var i = 0; i < nData; ++i) {\n        data[i] = lut[data[i]];\n      }\n    }\n    function predictor(source) {\n      for (var t = 1; t < source.length; t++) {\n        var d = source[t - 1] + source[t] - 128;\n        source[t] = d;\n      }\n    }\n    function interleaveScalar(source, out) {\n      var t1 = 0;\n      var t2 = Math.floor((source.length + 1) / 2);\n      var s = 0;\n      var stop = source.length - 1;\n      while (true) {\n        if (s > stop)\n          break;\n        out[s++] = source[t1++];\n        if (s > stop)\n          break;\n        out[s++] = source[t2++];\n      }\n    }\n    function decodeRunLength(source) {\n      var size = source.byteLength;\n      var out = new Array();\n      var p = 0;\n      var reader = new DataView(source);\n      while (size > 0) {\n        var l = reader.getInt8(p++);\n        if (l < 0) {\n          var count = -l;\n          size -= count + 1;\n          for (var i = 0; i < count; i++) {\n            out.push(reader.getUint8(p++));\n          }\n        } else {\n          var count = l;\n          size -= 2;\n          var value = reader.getUint8(p++);\n          for (var i = 0; i < count + 1; i++) {\n            out.push(value);\n          }\n        }\n      }\n      return out;\n    }\n    function lossyDctDecode(cscSet, rowPtrs, channelData, acBuffer, dcBuffer, outBuffer) {\n      var dataView = new DataView(outBuffer.buffer);\n      var width = channelData[cscSet.idx[0]].width;\n      var height = channelData[cscSet.idx[0]].height;\n      var numComp = 3;\n      var numFullBlocksX = Math.floor(width / 8);\n      var numBlocksX = Math.ceil(width / 8);\n      var numBlocksY = Math.ceil(height / 8);\n      var leftoverX = width - (numBlocksX - 1) * 8;\n      var leftoverY = height - (numBlocksY - 1) * 8;\n      var currAcComp = { value: 0 };\n      var currDcComp = new Array(numComp);\n      var dctData = new Array(numComp);\n      var halfZigBlock = new Array(numComp);\n      var rowBlock = new Array(numComp);\n      var rowOffsets = new Array(numComp);\n      for (let comp2 = 0; comp2 < numComp; ++comp2) {\n        rowOffsets[comp2] = rowPtrs[cscSet.idx[comp2]];\n        currDcComp[comp2] = comp2 < 1 ? 0 : currDcComp[comp2 - 1] + numBlocksX * numBlocksY;\n        dctData[comp2] = new Float32Array(64);\n        halfZigBlock[comp2] = new Uint16Array(64);\n        rowBlock[comp2] = new Uint16Array(numBlocksX * 64);\n      }\n      for (let blocky = 0; blocky < numBlocksY; ++blocky) {\n        var maxY = 8;\n        if (blocky == numBlocksY - 1)\n          maxY = leftoverY;\n        var maxX = 8;\n        for (let blockx = 0; blockx < numBlocksX; ++blockx) {\n          if (blockx == numBlocksX - 1)\n            maxX = leftoverX;\n          for (let comp2 = 0; comp2 < numComp; ++comp2) {\n            halfZigBlock[comp2].fill(0);\n            halfZigBlock[comp2][0] = dcBuffer[currDcComp[comp2]++];\n            unRleAC(currAcComp, acBuffer, halfZigBlock[comp2]);\n            unZigZag(halfZigBlock[comp2], dctData[comp2]);\n            dctInverse(dctData[comp2]);\n          }\n          if (numComp == 3) {\n            csc709Inverse(dctData);\n          }\n          for (let comp2 = 0; comp2 < numComp; ++comp2) {\n            convertToHalf(dctData[comp2], rowBlock[comp2], blockx * 64);\n          }\n        }\n        let offset2 = 0;\n        for (let comp2 = 0; comp2 < numComp; ++comp2) {\n          const type2 = channelData[cscSet.idx[comp2]].type;\n          for (let y2 = 8 * blocky; y2 < 8 * blocky + maxY; ++y2) {\n            offset2 = rowOffsets[comp2][y2];\n            for (let blockx = 0; blockx < numFullBlocksX; ++blockx) {\n              const src = blockx * 64 + (y2 & 7) * 8;\n              dataView.setUint16(offset2 + 0 * INT16_SIZE * type2, rowBlock[comp2][src + 0], true);\n              dataView.setUint16(offset2 + 1 * INT16_SIZE * type2, rowBlock[comp2][src + 1], true);\n              dataView.setUint16(offset2 + 2 * INT16_SIZE * type2, rowBlock[comp2][src + 2], true);\n              dataView.setUint16(offset2 + 3 * INT16_SIZE * type2, rowBlock[comp2][src + 3], true);\n              dataView.setUint16(offset2 + 4 * INT16_SIZE * type2, rowBlock[comp2][src + 4], true);\n              dataView.setUint16(offset2 + 5 * INT16_SIZE * type2, rowBlock[comp2][src + 5], true);\n              dataView.setUint16(offset2 + 6 * INT16_SIZE * type2, rowBlock[comp2][src + 6], true);\n              dataView.setUint16(offset2 + 7 * INT16_SIZE * type2, rowBlock[comp2][src + 7], true);\n              offset2 += 8 * INT16_SIZE * type2;\n            }\n          }\n          if (numFullBlocksX != numBlocksX) {\n            for (let y2 = 8 * blocky; y2 < 8 * blocky + maxY; ++y2) {\n              const offset3 = rowOffsets[comp2][y2] + 8 * numFullBlocksX * INT16_SIZE * type2;\n              const src = numFullBlocksX * 64 + (y2 & 7) * 8;\n              for (let x2 = 0; x2 < maxX; ++x2) {\n                dataView.setUint16(offset3 + x2 * INT16_SIZE * type2, rowBlock[comp2][src + x2], true);\n              }\n            }\n          }\n        }\n      }\n      var halfRow = new Uint16Array(width);\n      var dataView = new DataView(outBuffer.buffer);\n      for (var comp = 0; comp < numComp; ++comp) {\n        channelData[cscSet.idx[comp]].decoded = true;\n        var type = channelData[cscSet.idx[comp]].type;\n        if (channelData[comp].type != 2)\n          continue;\n        for (var y = 0; y < height; ++y) {\n          const offset2 = rowOffsets[comp][y];\n          for (var x = 0; x < width; ++x) {\n            halfRow[x] = dataView.getUint16(offset2 + x * INT16_SIZE * type, true);\n          }\n          for (var x = 0; x < width; ++x) {\n            dataView.setFloat32(offset2 + x * INT16_SIZE * type, decodeFloat16(halfRow[x]), true);\n          }\n        }\n      }\n    }\n    function unRleAC(currAcComp, acBuffer, halfZigBlock) {\n      var acValue;\n      var dctComp = 1;\n      while (dctComp < 64) {\n        acValue = acBuffer[currAcComp.value];\n        if (acValue == 65280) {\n          dctComp = 64;\n        } else if (acValue >> 8 == 255) {\n          dctComp += acValue & 255;\n        } else {\n          halfZigBlock[dctComp] = acValue;\n          dctComp++;\n        }\n        currAcComp.value++;\n      }\n    }\n    function unZigZag(src, dst) {\n      dst[0] = decodeFloat16(src[0]);\n      dst[1] = decodeFloat16(src[1]);\n      dst[2] = decodeFloat16(src[5]);\n      dst[3] = decodeFloat16(src[6]);\n      dst[4] = decodeFloat16(src[14]);\n      dst[5] = decodeFloat16(src[15]);\n      dst[6] = decodeFloat16(src[27]);\n      dst[7] = decodeFloat16(src[28]);\n      dst[8] = decodeFloat16(src[2]);\n      dst[9] = decodeFloat16(src[4]);\n      dst[10] = decodeFloat16(src[7]);\n      dst[11] = decodeFloat16(src[13]);\n      dst[12] = decodeFloat16(src[16]);\n      dst[13] = decodeFloat16(src[26]);\n      dst[14] = decodeFloat16(src[29]);\n      dst[15] = decodeFloat16(src[42]);\n      dst[16] = decodeFloat16(src[3]);\n      dst[17] = decodeFloat16(src[8]);\n      dst[18] = decodeFloat16(src[12]);\n      dst[19] = decodeFloat16(src[17]);\n      dst[20] = decodeFloat16(src[25]);\n      dst[21] = decodeFloat16(src[30]);\n      dst[22] = decodeFloat16(src[41]);\n      dst[23] = decodeFloat16(src[43]);\n      dst[24] = decodeFloat16(src[9]);\n      dst[25] = decodeFloat16(src[11]);\n      dst[26] = decodeFloat16(src[18]);\n      dst[27] = decodeFloat16(src[24]);\n      dst[28] = decodeFloat16(src[31]);\n      dst[29] = decodeFloat16(src[40]);\n      dst[30] = decodeFloat16(src[44]);\n      dst[31] = decodeFloat16(src[53]);\n      dst[32] = decodeFloat16(src[10]);\n      dst[33] = decodeFloat16(src[19]);\n      dst[34] = decodeFloat16(src[23]);\n      dst[35] = decodeFloat16(src[32]);\n      dst[36] = decodeFloat16(src[39]);\n      dst[37] = decodeFloat16(src[45]);\n      dst[38] = decodeFloat16(src[52]);\n      dst[39] = decodeFloat16(src[54]);\n      dst[40] = decodeFloat16(src[20]);\n      dst[41] = decodeFloat16(src[22]);\n      dst[42] = decodeFloat16(src[33]);\n      dst[43] = decodeFloat16(src[38]);\n      dst[44] = decodeFloat16(src[46]);\n      dst[45] = decodeFloat16(src[51]);\n      dst[46] = decodeFloat16(src[55]);\n      dst[47] = decodeFloat16(src[60]);\n      dst[48] = decodeFloat16(src[21]);\n      dst[49] = decodeFloat16(src[34]);\n      dst[50] = decodeFloat16(src[37]);\n      dst[51] = decodeFloat16(src[47]);\n      dst[52] = decodeFloat16(src[50]);\n      dst[53] = decodeFloat16(src[56]);\n      dst[54] = decodeFloat16(src[59]);\n      dst[55] = decodeFloat16(src[61]);\n      dst[56] = decodeFloat16(src[35]);\n      dst[57] = decodeFloat16(src[36]);\n      dst[58] = decodeFloat16(src[48]);\n      dst[59] = decodeFloat16(src[49]);\n      dst[60] = decodeFloat16(src[57]);\n      dst[61] = decodeFloat16(src[58]);\n      dst[62] = decodeFloat16(src[62]);\n      dst[63] = decodeFloat16(src[63]);\n    }\n    function dctInverse(data) {\n      const a = 0.5 * Math.cos(3.14159 / 4);\n      const b = 0.5 * Math.cos(3.14159 / 16);\n      const c = 0.5 * Math.cos(3.14159 / 8);\n      const d = 0.5 * Math.cos(3 * 3.14159 / 16);\n      const e = 0.5 * Math.cos(5 * 3.14159 / 16);\n      const f = 0.5 * Math.cos(3 * 3.14159 / 8);\n      const g = 0.5 * Math.cos(7 * 3.14159 / 16);\n      var alpha = new Array(4);\n      var beta = new Array(4);\n      var theta = new Array(4);\n      var gamma = new Array(4);\n      for (var row = 0; row < 8; ++row) {\n        var rowPtr = row * 8;\n        alpha[0] = c * data[rowPtr + 2];\n        alpha[1] = f * data[rowPtr + 2];\n        alpha[2] = c * data[rowPtr + 6];\n        alpha[3] = f * data[rowPtr + 6];\n        beta[0] = b * data[rowPtr + 1] + d * data[rowPtr + 3] + e * data[rowPtr + 5] + g * data[rowPtr + 7];\n        beta[1] = d * data[rowPtr + 1] - g * data[rowPtr + 3] - b * data[rowPtr + 5] - e * data[rowPtr + 7];\n        beta[2] = e * data[rowPtr + 1] - b * data[rowPtr + 3] + g * data[rowPtr + 5] + d * data[rowPtr + 7];\n        beta[3] = g * data[rowPtr + 1] - e * data[rowPtr + 3] + d * data[rowPtr + 5] - b * data[rowPtr + 7];\n        theta[0] = a * (data[rowPtr + 0] + data[rowPtr + 4]);\n        theta[3] = a * (data[rowPtr + 0] - data[rowPtr + 4]);\n        theta[1] = alpha[0] + alpha[3];\n        theta[2] = alpha[1] - alpha[2];\n        gamma[0] = theta[0] + theta[1];\n        gamma[1] = theta[3] + theta[2];\n        gamma[2] = theta[3] - theta[2];\n        gamma[3] = theta[0] - theta[1];\n        data[rowPtr + 0] = gamma[0] + beta[0];\n        data[rowPtr + 1] = gamma[1] + beta[1];\n        data[rowPtr + 2] = gamma[2] + beta[2];\n        data[rowPtr + 3] = gamma[3] + beta[3];\n        data[rowPtr + 4] = gamma[3] - beta[3];\n        data[rowPtr + 5] = gamma[2] - beta[2];\n        data[rowPtr + 6] = gamma[1] - beta[1];\n        data[rowPtr + 7] = gamma[0] - beta[0];\n      }\n      for (var column = 0; column < 8; ++column) {\n        alpha[0] = c * data[16 + column];\n        alpha[1] = f * data[16 + column];\n        alpha[2] = c * data[48 + column];\n        alpha[3] = f * data[48 + column];\n        beta[0] = b * data[8 + column] + d * data[24 + column] + e * data[40 + column] + g * data[56 + column];\n        beta[1] = d * data[8 + column] - g * data[24 + column] - b * data[40 + column] - e * data[56 + column];\n        beta[2] = e * data[8 + column] - b * data[24 + column] + g * data[40 + column] + d * data[56 + column];\n        beta[3] = g * data[8 + column] - e * data[24 + column] + d * data[40 + column] - b * data[56 + column];\n        theta[0] = a * (data[column] + data[32 + column]);\n        theta[3] = a * (data[column] - data[32 + column]);\n        theta[1] = alpha[0] + alpha[3];\n        theta[2] = alpha[1] - alpha[2];\n        gamma[0] = theta[0] + theta[1];\n        gamma[1] = theta[3] + theta[2];\n        gamma[2] = theta[3] - theta[2];\n        gamma[3] = theta[0] - theta[1];\n        data[0 + column] = gamma[0] + beta[0];\n        data[8 + column] = gamma[1] + beta[1];\n        data[16 + column] = gamma[2] + beta[2];\n        data[24 + column] = gamma[3] + beta[3];\n        data[32 + column] = gamma[3] - beta[3];\n        data[40 + column] = gamma[2] - beta[2];\n        data[48 + column] = gamma[1] - beta[1];\n        data[56 + column] = gamma[0] - beta[0];\n      }\n    }\n    function csc709Inverse(data) {\n      for (var i = 0; i < 64; ++i) {\n        var y = data[0][i];\n        var cb = data[1][i];\n        var cr = data[2][i];\n        data[0][i] = y + 1.5747 * cr;\n        data[1][i] = y - 0.1873 * cb - 0.4682 * cr;\n        data[2][i] = y + 1.8556 * cb;\n      }\n    }\n    function convertToHalf(src, dst, idx) {\n      for (var i = 0; i < 64; ++i) {\n        dst[idx + i] = DataUtils.toHalfFloat(toLinear(src[i]));\n      }\n    }\n    function toLinear(float) {\n      if (float <= 1) {\n        return Math.sign(float) * Math.pow(Math.abs(float), 2.2);\n      } else {\n        return Math.sign(float) * Math.pow(logBase, Math.abs(float) - 1);\n      }\n    }\n    function uncompressRAW(info) {\n      return new DataView(info.array.buffer, info.offset.value, info.size);\n    }\n    function uncompressRLE(info) {\n      var compressed = info.viewer.buffer.slice(info.offset.value, info.offset.value + info.size);\n      var rawBuffer = new Uint8Array(decodeRunLength(compressed));\n      var tmpBuffer = new Uint8Array(rawBuffer.length);\n      predictor(rawBuffer);\n      interleaveScalar(rawBuffer, tmpBuffer);\n      return new DataView(tmpBuffer.buffer);\n    }\n    function uncompressZIP(info) {\n      var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);\n      var rawBuffer = unzlibSync(compressed);\n      var tmpBuffer = new Uint8Array(rawBuffer.length);\n      predictor(rawBuffer);\n      interleaveScalar(rawBuffer, tmpBuffer);\n      return new DataView(tmpBuffer.buffer);\n    }\n    function uncompressPIZ(info) {\n      var inDataView = info.viewer;\n      var inOffset = { value: info.offset.value };\n      var outBuffer = new Uint16Array(info.width * info.scanlineBlockSize * (info.channels * info.type));\n      var bitmap = new Uint8Array(BITMAP_SIZE);\n      var outBufferEnd = 0;\n      var pizChannelData = new Array(info.channels);\n      for (var i = 0; i < info.channels; i++) {\n        pizChannelData[i] = {};\n        pizChannelData[i][\"start\"] = outBufferEnd;\n        pizChannelData[i][\"end\"] = pizChannelData[i][\"start\"];\n        pizChannelData[i][\"nx\"] = info.width;\n        pizChannelData[i][\"ny\"] = info.lines;\n        pizChannelData[i][\"size\"] = info.type;\n        outBufferEnd += pizChannelData[i].nx * pizChannelData[i].ny * pizChannelData[i].size;\n      }\n      var minNonZero = parseUint16(inDataView, inOffset);\n      var maxNonZero = parseUint16(inDataView, inOffset);\n      if (maxNonZero >= BITMAP_SIZE) {\n        throw \"Something is wrong with PIZ_COMPRESSION BITMAP_SIZE\";\n      }\n      if (minNonZero <= maxNonZero) {\n        for (var i = 0; i < maxNonZero - minNonZero + 1; i++) {\n          bitmap[i + minNonZero] = parseUint8(inDataView, inOffset);\n        }\n      }\n      var lut = new Uint16Array(USHORT_RANGE);\n      var maxValue = reverseLutFromBitmap(bitmap, lut);\n      var length = parseUint32(inDataView, inOffset);\n      hufUncompress(info.array, inDataView, inOffset, length, outBuffer, outBufferEnd);\n      for (var i = 0; i < info.channels; ++i) {\n        var cd = pizChannelData[i];\n        for (var j = 0; j < pizChannelData[i].size; ++j) {\n          wav2Decode(outBuffer, cd.start + j, cd.nx, cd.size, cd.ny, cd.nx * cd.size, maxValue);\n        }\n      }\n      applyLut(lut, outBuffer, outBufferEnd);\n      var tmpOffset2 = 0;\n      var tmpBuffer = new Uint8Array(outBuffer.buffer.byteLength);\n      for (var y = 0; y < info.lines; y++) {\n        for (var c = 0; c < info.channels; c++) {\n          var cd = pizChannelData[c];\n          var n = cd.nx * cd.size;\n          var cp = new Uint8Array(outBuffer.buffer, cd.end * INT16_SIZE, n * INT16_SIZE);\n          tmpBuffer.set(cp, tmpOffset2);\n          tmpOffset2 += n * INT16_SIZE;\n          cd.end += n;\n        }\n      }\n      return new DataView(tmpBuffer.buffer);\n    }\n    function uncompressPXR(info) {\n      var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);\n      var rawBuffer = unzlibSync(compressed);\n      const sz = info.lines * info.channels * info.width;\n      const tmpBuffer = info.type == 1 ? new Uint16Array(sz) : new Uint32Array(sz);\n      let tmpBufferEnd = 0;\n      let writePtr = 0;\n      const ptr = new Array(4);\n      for (let y = 0; y < info.lines; y++) {\n        for (let c = 0; c < info.channels; c++) {\n          let pixel = 0;\n          switch (info.type) {\n            case 1:\n              ptr[0] = tmpBufferEnd;\n              ptr[1] = ptr[0] + info.width;\n              tmpBufferEnd = ptr[1] + info.width;\n              for (let j = 0; j < info.width; ++j) {\n                const diff = rawBuffer[ptr[0]++] << 8 | rawBuffer[ptr[1]++];\n                pixel += diff;\n                tmpBuffer[writePtr] = pixel;\n                writePtr++;\n              }\n              break;\n            case 2:\n              ptr[0] = tmpBufferEnd;\n              ptr[1] = ptr[0] + info.width;\n              ptr[2] = ptr[1] + info.width;\n              tmpBufferEnd = ptr[2] + info.width;\n              for (let j = 0; j < info.width; ++j) {\n                const diff = rawBuffer[ptr[0]++] << 24 | rawBuffer[ptr[1]++] << 16 | rawBuffer[ptr[2]++] << 8;\n                pixel += diff;\n                tmpBuffer[writePtr] = pixel;\n                writePtr++;\n              }\n              break;\n          }\n        }\n      }\n      return new DataView(tmpBuffer.buffer);\n    }\n    function uncompressDWA(info) {\n      var inDataView = info.viewer;\n      var inOffset = { value: info.offset.value };\n      var outBuffer = new Uint8Array(info.width * info.lines * (info.channels * info.type * INT16_SIZE));\n      var dwaHeader = {\n        version: parseInt64(inDataView, inOffset),\n        unknownUncompressedSize: parseInt64(inDataView, inOffset),\n        unknownCompressedSize: parseInt64(inDataView, inOffset),\n        acCompressedSize: parseInt64(inDataView, inOffset),\n        dcCompressedSize: parseInt64(inDataView, inOffset),\n        rleCompressedSize: parseInt64(inDataView, inOffset),\n        rleUncompressedSize: parseInt64(inDataView, inOffset),\n        rleRawSize: parseInt64(inDataView, inOffset),\n        totalAcUncompressedCount: parseInt64(inDataView, inOffset),\n        totalDcUncompressedCount: parseInt64(inDataView, inOffset),\n        acCompression: parseInt64(inDataView, inOffset)\n      };\n      if (dwaHeader.version < 2) {\n        throw \"EXRLoader.parse: \" + EXRHeader.compression + \" version \" + dwaHeader.version + \" is unsupported\";\n      }\n      var channelRules = new Array();\n      var ruleSize = parseUint16(inDataView, inOffset) - INT16_SIZE;\n      while (ruleSize > 0) {\n        var name = parseNullTerminatedString(inDataView.buffer, inOffset);\n        var value = parseUint8(inDataView, inOffset);\n        var compression = value >> 2 & 3;\n        var csc = (value >> 4) - 1;\n        var index = new Int8Array([csc])[0];\n        var type = parseUint8(inDataView, inOffset);\n        channelRules.push({\n          name,\n          index,\n          type,\n          compression\n        });\n        ruleSize -= name.length + 3;\n      }\n      var channels = EXRHeader.channels;\n      var channelData = new Array(info.channels);\n      for (var i = 0; i < info.channels; ++i) {\n        var cd = channelData[i] = {};\n        var channel = channels[i];\n        cd.name = channel.name;\n        cd.compression = UNKNOWN;\n        cd.decoded = false;\n        cd.type = channel.pixelType;\n        cd.pLinear = channel.pLinear;\n        cd.width = info.width;\n        cd.height = info.lines;\n      }\n      var cscSet = {\n        idx: new Array(3)\n      };\n      for (var offset2 = 0; offset2 < info.channels; ++offset2) {\n        var cd = channelData[offset2];\n        for (var i = 0; i < channelRules.length; ++i) {\n          var rule = channelRules[i];\n          if (cd.name == rule.name) {\n            cd.compression = rule.compression;\n            if (rule.index >= 0) {\n              cscSet.idx[rule.index] = offset2;\n            }\n            cd.offset = offset2;\n          }\n        }\n      }\n      if (dwaHeader.acCompressedSize > 0) {\n        switch (dwaHeader.acCompression) {\n          case STATIC_HUFFMAN:\n            var acBuffer = new Uint16Array(dwaHeader.totalAcUncompressedCount);\n            hufUncompress(\n              info.array,\n              inDataView,\n              inOffset,\n              dwaHeader.acCompressedSize,\n              acBuffer,\n              dwaHeader.totalAcUncompressedCount\n            );\n            break;\n          case DEFLATE:\n            var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.totalAcUncompressedCount);\n            var data = unzlibSync(compressed);\n            var acBuffer = new Uint16Array(data.buffer);\n            inOffset.value += dwaHeader.totalAcUncompressedCount;\n            break;\n        }\n      }\n      if (dwaHeader.dcCompressedSize > 0) {\n        var zlibInfo = {\n          array: info.array,\n          offset: inOffset,\n          size: dwaHeader.dcCompressedSize\n        };\n        var dcBuffer = new Uint16Array(uncompressZIP(zlibInfo).buffer);\n        inOffset.value += dwaHeader.dcCompressedSize;\n      }\n      if (dwaHeader.rleRawSize > 0) {\n        var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.rleCompressedSize);\n        var data = unzlibSync(compressed);\n        var rleBuffer = decodeRunLength(data.buffer);\n        inOffset.value += dwaHeader.rleCompressedSize;\n      }\n      var outBufferEnd = 0;\n      var rowOffsets = new Array(channelData.length);\n      for (var i = 0; i < rowOffsets.length; ++i) {\n        rowOffsets[i] = new Array();\n      }\n      for (var y = 0; y < info.lines; ++y) {\n        for (var chan = 0; chan < channelData.length; ++chan) {\n          rowOffsets[chan].push(outBufferEnd);\n          outBufferEnd += channelData[chan].width * info.type * INT16_SIZE;\n        }\n      }\n      lossyDctDecode(cscSet, rowOffsets, channelData, acBuffer, dcBuffer, outBuffer);\n      for (var i = 0; i < channelData.length; ++i) {\n        var cd = channelData[i];\n        if (cd.decoded)\n          continue;\n        switch (cd.compression) {\n          case RLE:\n            var row = 0;\n            var rleOffset = 0;\n            for (var y = 0; y < info.lines; ++y) {\n              var rowOffsetBytes = rowOffsets[i][row];\n              for (var x = 0; x < cd.width; ++x) {\n                for (var byte = 0; byte < INT16_SIZE * cd.type; ++byte) {\n                  outBuffer[rowOffsetBytes++] = rleBuffer[rleOffset + byte * cd.width * cd.height];\n                }\n                rleOffset++;\n              }\n              row++;\n            }\n            break;\n          case LOSSY_DCT:\n          default:\n            throw \"EXRLoader.parse: unsupported channel compression\";\n        }\n      }\n      return new DataView(outBuffer.buffer);\n    }\n    function parseNullTerminatedString(buffer2, offset2) {\n      var uintBuffer = new Uint8Array(buffer2);\n      var endOffset = 0;\n      while (uintBuffer[offset2.value + endOffset] != 0) {\n        endOffset += 1;\n      }\n      var stringValue = new TextDecoder().decode(uintBuffer.slice(offset2.value, offset2.value + endOffset));\n      offset2.value = offset2.value + endOffset + 1;\n      return stringValue;\n    }\n    function parseFixedLengthString(buffer2, offset2, size) {\n      var stringValue = new TextDecoder().decode(new Uint8Array(buffer2).slice(offset2.value, offset2.value + size));\n      offset2.value = offset2.value + size;\n      return stringValue;\n    }\n    function parseRational(dataView, offset2) {\n      var x = parseInt32(dataView, offset2);\n      var y = parseUint32(dataView, offset2);\n      return [x, y];\n    }\n    function parseTimecode(dataView, offset2) {\n      var x = parseUint32(dataView, offset2);\n      var y = parseUint32(dataView, offset2);\n      return [x, y];\n    }\n    function parseInt32(dataView, offset2) {\n      var Int32 = dataView.getInt32(offset2.value, true);\n      offset2.value = offset2.value + INT32_SIZE;\n      return Int32;\n    }\n    function parseUint32(dataView, offset2) {\n      var Uint32 = dataView.getUint32(offset2.value, true);\n      offset2.value = offset2.value + INT32_SIZE;\n      return Uint32;\n    }\n    function parseUint8Array(uInt8Array2, offset2) {\n      var Uint8 = uInt8Array2[offset2.value];\n      offset2.value = offset2.value + INT8_SIZE;\n      return Uint8;\n    }\n    function parseUint8(dataView, offset2) {\n      var Uint8 = dataView.getUint8(offset2.value);\n      offset2.value = offset2.value + INT8_SIZE;\n      return Uint8;\n    }\n    const parseInt64 = function(dataView, offset2) {\n      let int;\n      if (\"getBigInt64\" in DataView.prototype) {\n        int = Number(dataView.getBigInt64(offset2.value, true));\n      } else {\n        int = dataView.getUint32(offset2.value + 4, true) + Number(dataView.getUint32(offset2.value, true) << 32);\n      }\n      offset2.value += ULONG_SIZE;\n      return int;\n    };\n    function parseFloat32(dataView, offset2) {\n      var float = dataView.getFloat32(offset2.value, true);\n      offset2.value += FLOAT32_SIZE;\n      return float;\n    }\n    function decodeFloat32(dataView, offset2) {\n      return DataUtils.toHalfFloat(parseFloat32(dataView, offset2));\n    }\n    function decodeFloat16(binary) {\n      var exponent = (binary & 31744) >> 10, fraction = binary & 1023;\n      return (binary >> 15 ? -1 : 1) * (exponent ? exponent === 31 ? fraction ? NaN : Infinity : Math.pow(2, exponent - 15) * (1 + fraction / 1024) : 6103515625e-14 * (fraction / 1024));\n    }\n    function parseUint16(dataView, offset2) {\n      var Uint16 = dataView.getUint16(offset2.value, true);\n      offset2.value += INT16_SIZE;\n      return Uint16;\n    }\n    function parseFloat16(buffer2, offset2) {\n      return decodeFloat16(parseUint16(buffer2, offset2));\n    }\n    function parseChlist(dataView, buffer2, offset2, size) {\n      var startOffset = offset2.value;\n      var channels = [];\n      while (offset2.value < startOffset + size - 1) {\n        var name = parseNullTerminatedString(buffer2, offset2);\n        var pixelType = parseInt32(dataView, offset2);\n        var pLinear = parseUint8(dataView, offset2);\n        offset2.value += 3;\n        var xSampling = parseInt32(dataView, offset2);\n        var ySampling = parseInt32(dataView, offset2);\n        channels.push({\n          name,\n          pixelType,\n          pLinear,\n          xSampling,\n          ySampling\n        });\n      }\n      offset2.value += 1;\n      return channels;\n    }\n    function parseChromaticities(dataView, offset2) {\n      var redX = parseFloat32(dataView, offset2);\n      var redY = parseFloat32(dataView, offset2);\n      var greenX = parseFloat32(dataView, offset2);\n      var greenY = parseFloat32(dataView, offset2);\n      var blueX = parseFloat32(dataView, offset2);\n      var blueY = parseFloat32(dataView, offset2);\n      var whiteX = parseFloat32(dataView, offset2);\n      var whiteY = parseFloat32(dataView, offset2);\n      return {\n        redX,\n        redY,\n        greenX,\n        greenY,\n        blueX,\n        blueY,\n        whiteX,\n        whiteY\n      };\n    }\n    function parseCompression(dataView, offset2) {\n      var compressionCodes = [\n        \"NO_COMPRESSION\",\n        \"RLE_COMPRESSION\",\n        \"ZIPS_COMPRESSION\",\n        \"ZIP_COMPRESSION\",\n        \"PIZ_COMPRESSION\",\n        \"PXR24_COMPRESSION\",\n        \"B44_COMPRESSION\",\n        \"B44A_COMPRESSION\",\n        \"DWAA_COMPRESSION\",\n        \"DWAB_COMPRESSION\"\n      ];\n      var compression = parseUint8(dataView, offset2);\n      return compressionCodes[compression];\n    }\n    function parseBox2i(dataView, offset2) {\n      var xMin = parseUint32(dataView, offset2);\n      var yMin = parseUint32(dataView, offset2);\n      var xMax = parseUint32(dataView, offset2);\n      var yMax = parseUint32(dataView, offset2);\n      return { xMin, yMin, xMax, yMax };\n    }\n    function parseLineOrder(dataView, offset2) {\n      var lineOrders = [\"INCREASING_Y\"];\n      var lineOrder = parseUint8(dataView, offset2);\n      return lineOrders[lineOrder];\n    }\n    function parseV2f(dataView, offset2) {\n      var x = parseFloat32(dataView, offset2);\n      var y = parseFloat32(dataView, offset2);\n      return [x, y];\n    }\n    function parseV3f(dataView, offset2) {\n      var x = parseFloat32(dataView, offset2);\n      var y = parseFloat32(dataView, offset2);\n      var z = parseFloat32(dataView, offset2);\n      return [x, y, z];\n    }\n    function parseValue(dataView, buffer2, offset2, type, size) {\n      if (type === \"string\" || type === \"stringvector\" || type === \"iccProfile\") {\n        return parseFixedLengthString(buffer2, offset2, size);\n      } else if (type === \"chlist\") {\n        return parseChlist(dataView, buffer2, offset2, size);\n      } else if (type === \"chromaticities\") {\n        return parseChromaticities(dataView, offset2);\n      } else if (type === \"compression\") {\n        return parseCompression(dataView, offset2);\n      } else if (type === \"box2i\") {\n        return parseBox2i(dataView, offset2);\n      } else if (type === \"lineOrder\") {\n        return parseLineOrder(dataView, offset2);\n      } else if (type === \"float\") {\n        return parseFloat32(dataView, offset2);\n      } else if (type === \"v2f\") {\n        return parseV2f(dataView, offset2);\n      } else if (type === \"v3f\") {\n        return parseV3f(dataView, offset2);\n      } else if (type === \"int\") {\n        return parseInt32(dataView, offset2);\n      } else if (type === \"rational\") {\n        return parseRational(dataView, offset2);\n      } else if (type === \"timecode\") {\n        return parseTimecode(dataView, offset2);\n      } else if (type === \"preview\") {\n        offset2.value += size;\n        return \"skipped\";\n      } else {\n        offset2.value += size;\n        return void 0;\n      }\n    }\n    function parseHeader(dataView, buffer2, offset2) {\n      const EXRHeader2 = {};\n      if (dataView.getUint32(0, true) != 20000630) {\n        throw \"THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.\";\n      }\n      EXRHeader2.version = dataView.getUint8(4);\n      const spec = dataView.getUint8(5);\n      EXRHeader2.spec = {\n        singleTile: !!(spec & 2),\n        longName: !!(spec & 4),\n        deepFormat: !!(spec & 8),\n        multiPart: !!(spec & 16)\n      };\n      offset2.value = 8;\n      var keepReading = true;\n      while (keepReading) {\n        var attributeName = parseNullTerminatedString(buffer2, offset2);\n        if (attributeName == 0) {\n          keepReading = false;\n        } else {\n          var attributeType = parseNullTerminatedString(buffer2, offset2);\n          var attributeSize = parseUint32(dataView, offset2);\n          var attributeValue = parseValue(dataView, buffer2, offset2, attributeType, attributeSize);\n          if (attributeValue === void 0) {\n            console.warn(`EXRLoader.parse: skipped unknown header attribute type '${attributeType}'.`);\n          } else {\n            EXRHeader2[attributeName] = attributeValue;\n          }\n        }\n      }\n      if (spec != 0) {\n        console.error(\"EXRHeader:\", EXRHeader2);\n        throw \"THREE.EXRLoader: provided file is currently unsupported.\";\n      }\n      return EXRHeader2;\n    }\n    function setupDecoder(EXRHeader2, dataView, uInt8Array2, offset2, outputType) {\n      const EXRDecoder2 = {\n        size: 0,\n        viewer: dataView,\n        array: uInt8Array2,\n        offset: offset2,\n        width: EXRHeader2.dataWindow.xMax - EXRHeader2.dataWindow.xMin + 1,\n        height: EXRHeader2.dataWindow.yMax - EXRHeader2.dataWindow.yMin + 1,\n        channels: EXRHeader2.channels.length,\n        bytesPerLine: null,\n        lines: null,\n        inputSize: null,\n        type: EXRHeader2.channels[0].pixelType,\n        uncompress: null,\n        getter: null,\n        format: null,\n        [hasColorSpace ? \"colorSpace\" : \"encoding\"]: null\n      };\n      switch (EXRHeader2.compression) {\n        case \"NO_COMPRESSION\":\n          EXRDecoder2.lines = 1;\n          EXRDecoder2.uncompress = uncompressRAW;\n          break;\n        case \"RLE_COMPRESSION\":\n          EXRDecoder2.lines = 1;\n          EXRDecoder2.uncompress = uncompressRLE;\n          break;\n        case \"ZIPS_COMPRESSION\":\n          EXRDecoder2.lines = 1;\n          EXRDecoder2.uncompress = uncompressZIP;\n          break;\n        case \"ZIP_COMPRESSION\":\n          EXRDecoder2.lines = 16;\n          EXRDecoder2.uncompress = uncompressZIP;\n          break;\n        case \"PIZ_COMPRESSION\":\n          EXRDecoder2.lines = 32;\n          EXRDecoder2.uncompress = uncompressPIZ;\n          break;\n        case \"PXR24_COMPRESSION\":\n          EXRDecoder2.lines = 16;\n          EXRDecoder2.uncompress = uncompressPXR;\n          break;\n        case \"DWAA_COMPRESSION\":\n          EXRDecoder2.lines = 32;\n          EXRDecoder2.uncompress = uncompressDWA;\n          break;\n        case \"DWAB_COMPRESSION\":\n          EXRDecoder2.lines = 256;\n          EXRDecoder2.uncompress = uncompressDWA;\n          break;\n        default:\n          throw \"EXRLoader.parse: \" + EXRHeader2.compression + \" is unsupported\";\n      }\n      EXRDecoder2.scanlineBlockSize = EXRDecoder2.lines;\n      if (EXRDecoder2.type == 1) {\n        switch (outputType) {\n          case FloatType:\n            EXRDecoder2.getter = parseFloat16;\n            EXRDecoder2.inputSize = INT16_SIZE;\n            break;\n          case HalfFloatType:\n            EXRDecoder2.getter = parseUint16;\n            EXRDecoder2.inputSize = INT16_SIZE;\n            break;\n        }\n      } else if (EXRDecoder2.type == 2) {\n        switch (outputType) {\n          case FloatType:\n            EXRDecoder2.getter = parseFloat32;\n            EXRDecoder2.inputSize = FLOAT32_SIZE;\n            break;\n          case HalfFloatType:\n            EXRDecoder2.getter = decodeFloat32;\n            EXRDecoder2.inputSize = FLOAT32_SIZE;\n        }\n      } else {\n        throw \"EXRLoader.parse: unsupported pixelType \" + EXRDecoder2.type + \" for \" + EXRHeader2.compression + \".\";\n      }\n      EXRDecoder2.blockCount = (EXRHeader2.dataWindow.yMax + 1) / EXRDecoder2.scanlineBlockSize;\n      for (var i = 0; i < EXRDecoder2.blockCount; i++)\n        parseInt64(dataView, offset2);\n      EXRDecoder2.outputChannels = EXRDecoder2.channels == 3 ? 4 : EXRDecoder2.channels;\n      const size = EXRDecoder2.width * EXRDecoder2.height * EXRDecoder2.outputChannels;\n      switch (outputType) {\n        case FloatType:\n          EXRDecoder2.byteArray = new Float32Array(size);\n          if (EXRDecoder2.channels < EXRDecoder2.outputChannels)\n            EXRDecoder2.byteArray.fill(1, 0, size);\n          break;\n        case HalfFloatType:\n          EXRDecoder2.byteArray = new Uint16Array(size);\n          if (EXRDecoder2.channels < EXRDecoder2.outputChannels)\n            EXRDecoder2.byteArray.fill(15360, 0, size);\n          break;\n        default:\n          console.error(\"THREE.EXRLoader: unsupported type: \", outputType);\n          break;\n      }\n      EXRDecoder2.bytesPerLine = EXRDecoder2.width * EXRDecoder2.inputSize * EXRDecoder2.channels;\n      if (EXRDecoder2.outputChannels == 4)\n        EXRDecoder2.format = RGBAFormat;\n      else\n        EXRDecoder2.format = RedFormat;\n      if (hasColorSpace)\n        EXRDecoder2.colorSpace = \"srgb-linear\";\n      else\n        EXRDecoder2.encoding = 3e3;\n      return EXRDecoder2;\n    }\n    const bufferDataView = new DataView(buffer);\n    const uInt8Array = new Uint8Array(buffer);\n    const offset = { value: 0 };\n    const EXRHeader = parseHeader(bufferDataView, buffer, offset);\n    const EXRDecoder = setupDecoder(EXRHeader, bufferDataView, uInt8Array, offset, this.type);\n    const tmpOffset = { value: 0 };\n    const channelOffsets = { R: 0, G: 1, B: 2, A: 3, Y: 0 };\n    for (let scanlineBlockIdx = 0; scanlineBlockIdx < EXRDecoder.height / EXRDecoder.scanlineBlockSize; scanlineBlockIdx++) {\n      const line = parseUint32(bufferDataView, offset);\n      EXRDecoder.size = parseUint32(bufferDataView, offset);\n      EXRDecoder.lines = line + EXRDecoder.scanlineBlockSize > EXRDecoder.height ? EXRDecoder.height - line : EXRDecoder.scanlineBlockSize;\n      const isCompressed = EXRDecoder.size < EXRDecoder.lines * EXRDecoder.bytesPerLine;\n      const viewer = isCompressed ? EXRDecoder.uncompress(EXRDecoder) : uncompressRAW(EXRDecoder);\n      offset.value += EXRDecoder.size;\n      for (let line_y = 0; line_y < EXRDecoder.scanlineBlockSize; line_y++) {\n        const true_y = line_y + scanlineBlockIdx * EXRDecoder.scanlineBlockSize;\n        if (true_y >= EXRDecoder.height)\n          break;\n        for (let channelID = 0; channelID < EXRDecoder.channels; channelID++) {\n          const cOff = channelOffsets[EXRHeader.channels[channelID].name];\n          for (let x = 0; x < EXRDecoder.width; x++) {\n            tmpOffset.value = (line_y * (EXRDecoder.channels * EXRDecoder.width) + channelID * EXRDecoder.width + x) * EXRDecoder.inputSize;\n            const outIndex = (EXRDecoder.height - 1 - true_y) * (EXRDecoder.width * EXRDecoder.outputChannels) + x * EXRDecoder.outputChannels + cOff;\n            EXRDecoder.byteArray[outIndex] = EXRDecoder.getter(viewer, tmpOffset);\n          }\n        }\n      }\n    }\n    return {\n      header: EXRHeader,\n      width: EXRDecoder.width,\n      height: EXRDecoder.height,\n      data: EXRDecoder.byteArray,\n      format: EXRDecoder.format,\n      [hasColorSpace ? \"colorSpace\" : \"encoding\"]: EXRDecoder[hasColorSpace ? \"colorSpace\" : \"encoding\"],\n      type: this.type\n    };\n  }\n  setDataType(value) {\n    this.type = value;\n    return this;\n  }\n  load(url, onLoad, onProgress, onError) {\n    function onLoadCallback(texture, texData) {\n      if (hasColorSpace)\n        texture.colorSpace = texData.colorSpace;\n      else\n        texture.encoding = texData.encoding;\n      texture.minFilter = LinearFilter;\n      texture.magFilter = LinearFilter;\n      texture.generateMipmaps = false;\n      texture.flipY = false;\n      if (onLoad)\n        onLoad(texture, texData);\n    }\n    return super.load(url, onLoadCallback, onProgress, onError);\n  }\n}\nexport {\n  EXRLoader\n};\n"]},"metadata":{},"sourceType":"module"}