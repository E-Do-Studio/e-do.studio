{"ast":null,"code":"import _regeneratorRuntime from \"/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _createClass from \"/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _classCallCheck from \"/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _assertThisInitialized from \"/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { Vector3, ShaderMaterial, UniformsUtils, UniformsLib, Color, LineSegments, Ray, FileLoader, Matrix4, Group, BufferGeometry, BufferAttribute, Mesh, Loader, MeshStandardMaterial, LineBasicMaterial } from \"three\";\nvar FINISH_TYPE_DEFAULT = 0;\nvar FINISH_TYPE_CHROME = 1;\nvar FINISH_TYPE_PEARLESCENT = 2;\nvar FINISH_TYPE_RUBBER = 3;\nvar FINISH_TYPE_MATTE_METALLIC = 4;\nvar FINISH_TYPE_METAL = 5;\nvar FILE_LOCATION_AS_IS = 0;\nvar FILE_LOCATION_TRY_PARTS = 1;\nvar FILE_LOCATION_TRY_P = 2;\nvar FILE_LOCATION_TRY_MODELS = 3;\nvar FILE_LOCATION_TRY_RELATIVE = 4;\nvar FILE_LOCATION_TRY_ABSOLUTE = 5;\nvar FILE_LOCATION_NOT_FOUND = 6;\nvar MAIN_COLOUR_CODE = \"16\";\nvar MAIN_EDGE_COLOUR_CODE = \"24\";\n\nvar _tempVec0 = /* @__PURE__ */new Vector3();\n\nvar _tempVec1 = /* @__PURE__ */new Vector3();\n\nvar LDrawConditionalLineMaterial = /*#__PURE__*/function (_ShaderMaterial) {\n  _inherits(LDrawConditionalLineMaterial, _ShaderMaterial);\n\n  var _super = _createSuper(LDrawConditionalLineMaterial);\n\n  function LDrawConditionalLineMaterial(parameters) {\n    var _this;\n\n    _classCallCheck(this, LDrawConditionalLineMaterial);\n\n    _this = _super.call(this, {\n      uniforms: UniformsUtils.merge([UniformsLib.fog, {\n        diffuse: {\n          value: new Color()\n        },\n        opacity: {\n          value: 1\n        }\n      }]),\n      vertexShader:\n      /* glsl */\n      \"\\n        attribute vec3 control0;\\n        attribute vec3 control1;\\n        attribute vec3 direction;\\n        varying float discardFlag;\\n\\n        #include <common>\\n        #include <color_pars_vertex>\\n        #include <fog_pars_vertex>\\n        #include <logdepthbuf_pars_vertex>\\n        #include <clipping_planes_pars_vertex>\\n\\n        void main() {\\n          #include <color_vertex>\\n\\n          vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\\n          gl_Position = projectionMatrix * mvPosition;\\n\\n          // Transform the line segment ends and control points into camera clip space\\n          vec4 c0 = projectionMatrix * modelViewMatrix * vec4(control0, 1.0);\\n          vec4 c1 = projectionMatrix * modelViewMatrix * vec4(control1, 1.0);\\n          vec4 p0 = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\\n          vec4 p1 = projectionMatrix * modelViewMatrix * vec4(position + direction, 1.0);\\n\\n          c0.xy /= c0.w;\\n          c1.xy /= c1.w;\\n          p0.xy /= p0.w;\\n          p1.xy /= p1.w;\\n\\n          // Get the direction of the segment and an orthogonal vector\\n          vec2 dir = p1.xy - p0.xy;\\n          vec2 norm = vec2(-dir.y, dir.x);\\n\\n          // Get control point directions from the line\\n          vec2 c0dir = c0.xy - p1.xy;\\n          vec2 c1dir = c1.xy - p1.xy;\\n\\n          // If the vectors to the controls points are pointed in different directions away\\n          // from the line segment then the line should not be drawn.\\n          float d0 = dot(normalize(norm), normalize(c0dir));\\n          float d1 = dot(normalize(norm), normalize(c1dir));\\n          discardFlag = float(sign(d0) != sign(d1));\\n\\n          #include <logdepthbuf_vertex>\\n          #include <clipping_planes_vertex>\\n          #include <fog_vertex>\\n        }\\n      \",\n      fragmentShader:\n      /* glsl */\n      \"\\n        uniform vec3 diffuse;\\n        uniform float opacity;\\n        varying float discardFlag;\\n\\n        #include <common>\\n        #include <color_pars_fragment>\\n        #include <fog_pars_fragment>\\n        #include <logdepthbuf_pars_fragment>\\n        #include <clipping_planes_pars_fragment>\\n\\n        void main() {\\n          if (discardFlag > 0.5) discard;\\n\\n          #include <clipping_planes_fragment>\\n          vec3 outgoingLight = vec3(0.0);\\n          vec4 diffuseColor = vec4(diffuse, opacity);\\n          #include <logdepthbuf_fragment>\\n          #include <color_fragment>\\n          outgoingLight = diffuseColor.rgb; // simple shader\\n          gl_FragColor = vec4(outgoingLight, diffuseColor.a);\\n          #include <tonemapping_fragment>\\n          #include <encodings_fragment>\\n          #include <fog_fragment>\\n          #include <premultiplied_alpha_fragment>\\n        }\\n      \"\n    });\n    Object.defineProperties(_assertThisInitialized(_this), {\n      opacity: {\n        get: function get() {\n          return this.uniforms.opacity.value;\n        },\n        set: function set(value) {\n          this.uniforms.opacity.value = value;\n        }\n      },\n      color: {\n        get: function get() {\n          return this.uniforms.diffuse.value;\n        }\n      }\n    });\n\n    _this.setValues(parameters);\n\n    _this.isLDrawConditionalLineMaterial = true;\n    return _this;\n  }\n\n  return LDrawConditionalLineMaterial;\n}(ShaderMaterial);\n\nvar ConditionalLineSegments = /*#__PURE__*/function (_LineSegments) {\n  _inherits(ConditionalLineSegments, _LineSegments);\n\n  var _super2 = _createSuper(ConditionalLineSegments);\n\n  function ConditionalLineSegments(geometry, material) {\n    var _this2;\n\n    _classCallCheck(this, ConditionalLineSegments);\n\n    _this2 = _super2.call(this, geometry, material);\n    _this2.isConditionalLine = true;\n    return _this2;\n  }\n\n  return ConditionalLineSegments;\n}(LineSegments);\n\nfunction generateFaceNormals(faces) {\n  for (var i = 0, l = faces.length; i < l; i++) {\n    var face = faces[i];\n    var vertices = face.vertices;\n    var v0 = vertices[0];\n    var v1 = vertices[1];\n    var v2 = vertices[2];\n\n    _tempVec0.subVectors(v1, v0);\n\n    _tempVec1.subVectors(v2, v1);\n\n    face.faceNormal = new Vector3().crossVectors(_tempVec0, _tempVec1).normalize();\n  }\n}\n\nvar _ray = /* @__PURE__ */new Ray();\n\nfunction smoothNormals(faces, lineSegments) {\n  var checkSubSegments = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var hashMultiplier = (1 + 1e-10) * 100;\n\n  function hashVertex(v) {\n    var x = ~~(v.x * hashMultiplier);\n    var y = ~~(v.y * hashMultiplier);\n    var z = ~~(v.z * hashMultiplier);\n    return \"\".concat(x, \",\").concat(y, \",\").concat(z);\n  }\n\n  function hashEdge(v0, v1) {\n    return \"\".concat(hashVertex(v0), \"_\").concat(hashVertex(v1));\n  }\n\n  function toNormalizedRay(v0, v1, targetRay) {\n    targetRay.direction.subVectors(v1, v0).normalize();\n    var scalar = v0.dot(targetRay.direction);\n    targetRay.origin.copy(v0).addScaledVector(targetRay.direction, -scalar);\n    return targetRay;\n  }\n\n  function hashRay(ray) {\n    return hashEdge(ray.origin, ray.direction);\n  }\n\n  var hardEdges = /* @__PURE__ */new Set();\n  var hardEdgeRays = /* @__PURE__ */new Map();\n  var halfEdgeList = {};\n  var normals = [];\n\n  for (var i = 0, l = lineSegments.length; i < l; i++) {\n    var ls = lineSegments[i];\n    var vertices = ls.vertices;\n    var v0 = vertices[0];\n    var v1 = vertices[1];\n    hardEdges.add(hashEdge(v0, v1));\n    hardEdges.add(hashEdge(v1, v0));\n\n    if (checkSubSegments) {\n      var ray = toNormalizedRay(v0, v1, new Ray());\n      var rh1 = hashRay(ray);\n\n      if (!hardEdgeRays.has(rh1)) {\n        toNormalizedRay(v1, v0, ray);\n        var rh2 = hashRay(ray);\n        var info2 = {\n          ray: ray,\n          distances: []\n        };\n        hardEdgeRays.set(rh1, info2);\n        hardEdgeRays.set(rh2, info2);\n      }\n\n      var info = hardEdgeRays.get(rh1);\n      var d0 = info.ray.direction.dot(v0);\n      var d1 = info.ray.direction.dot(v1);\n\n      if (d0 > d1) {\n        ;\n        var _ref = [d1, d0];\n        d0 = _ref[0];\n        d1 = _ref[1];\n      }\n\n      info.distances.push(d0, d1);\n    }\n  }\n\n  for (var _i = 0, _l = faces.length; _i < _l; _i++) {\n    var tri = faces[_i];\n    var _vertices = tri.vertices;\n    var vertCount = _vertices.length;\n\n    for (var i2 = 0; i2 < vertCount; i2++) {\n      var index = i2;\n      var next = (i2 + 1) % vertCount;\n      var _v = _vertices[index];\n      var _v2 = _vertices[next];\n      var hash = hashEdge(_v, _v2);\n\n      if (hardEdges.has(hash)) {\n        continue;\n      }\n\n      if (checkSubSegments) {\n        toNormalizedRay(_v, _v2, _ray);\n        var rayHash = hashRay(_ray);\n\n        if (hardEdgeRays.has(rayHash)) {\n          var _info2 = hardEdgeRays.get(rayHash);\n\n          var _ray2 = _info2.ray,\n              distances = _info2.distances;\n\n          var _d = _ray2.direction.dot(_v);\n\n          var _d2 = _ray2.direction.dot(_v2);\n\n          if (_d > _d2) {\n            ;\n            var _ref2 = [_d2, _d];\n            _d = _ref2[0];\n            _d2 = _ref2[1];\n          }\n\n          var found = false;\n\n          for (var i3 = 0, l2 = distances.length; i3 < l2; i3 += 2) {\n            if (_d >= distances[i3] && _d2 <= distances[i3 + 1]) {\n              found = true;\n              break;\n            }\n          }\n\n          if (found) {\n            continue;\n          }\n        }\n      }\n\n      var _info = {\n        index: index,\n        tri: tri\n      };\n      halfEdgeList[hash] = _info;\n    }\n  }\n\n  while (true) {\n    var halfEdge = null;\n\n    for (var key in halfEdgeList) {\n      halfEdge = halfEdgeList[key];\n      break;\n    }\n\n    if (halfEdge === null) {\n      break;\n    }\n\n    var queue = [halfEdge];\n\n    while (queue.length > 0) {\n      var _tri = queue.pop().tri;\n      var _vertices2 = _tri.vertices;\n      var vertNormals = _tri.normals;\n      var faceNormal = _tri.faceNormal;\n      var _vertCount = _vertices2.length;\n\n      for (var _i2 = 0; _i2 < _vertCount; _i2++) {\n        var _index = _i2;\n\n        var _next = (_i2 + 1) % _vertCount;\n\n        var _v3 = _vertices2[_index];\n        var _v4 = _vertices2[_next];\n\n        var _hash = hashEdge(_v3, _v4);\n\n        delete halfEdgeList[_hash];\n        var reverseHash = hashEdge(_v4, _v3);\n        var otherInfo = halfEdgeList[reverseHash];\n\n        if (otherInfo) {\n          var otherTri = otherInfo.tri;\n          var otherIndex = otherInfo.index;\n          var otherNormals = otherTri.normals;\n          var otherVertCount = otherNormals.length;\n          var otherFaceNormal = otherTri.faceNormal;\n\n          if (Math.abs(otherTri.faceNormal.dot(_tri.faceNormal)) < 0.25) {\n            continue;\n          }\n\n          if (reverseHash in halfEdgeList) {\n            queue.push(otherInfo);\n            delete halfEdgeList[reverseHash];\n          }\n\n          var otherNext = (otherIndex + 1) % otherVertCount;\n\n          if (vertNormals[_index] && otherNormals[otherNext] && vertNormals[_index] !== otherNormals[otherNext]) {\n            otherNormals[otherNext].norm.add(vertNormals[_index].norm);\n            vertNormals[_index].norm = otherNormals[otherNext].norm;\n          }\n\n          var sharedNormal1 = vertNormals[_index] || otherNormals[otherNext];\n\n          if (sharedNormal1 === null) {\n            sharedNormal1 = {\n              norm: new Vector3()\n            };\n            normals.push(sharedNormal1.norm);\n          }\n\n          if (vertNormals[_index] === null) {\n            vertNormals[_index] = sharedNormal1;\n            sharedNormal1.norm.add(faceNormal);\n          }\n\n          if (otherNormals[otherNext] === null) {\n            otherNormals[otherNext] = sharedNormal1;\n            sharedNormal1.norm.add(otherFaceNormal);\n          }\n\n          if (vertNormals[_next] && otherNormals[otherIndex] && vertNormals[_next] !== otherNormals[otherIndex]) {\n            otherNormals[otherIndex].norm.add(vertNormals[_next].norm);\n            vertNormals[_next].norm = otherNormals[otherIndex].norm;\n          }\n\n          var sharedNormal2 = vertNormals[_next] || otherNormals[otherIndex];\n\n          if (sharedNormal2 === null) {\n            sharedNormal2 = {\n              norm: new Vector3()\n            };\n            normals.push(sharedNormal2.norm);\n          }\n\n          if (vertNormals[_next] === null) {\n            vertNormals[_next] = sharedNormal2;\n            sharedNormal2.norm.add(faceNormal);\n          }\n\n          if (otherNormals[otherIndex] === null) {\n            otherNormals[otherIndex] = sharedNormal2;\n            sharedNormal2.norm.add(otherFaceNormal);\n          }\n        }\n      }\n    }\n  }\n\n  for (var _i3 = 0, _l2 = normals.length; _i3 < _l2; _i3++) {\n    normals[_i3].normalize();\n  }\n}\n\nfunction isPartType(type) {\n  return type === \"Part\" || type === \"Unofficial_Part\";\n}\n\nfunction isPrimitiveType(type) {\n  return /primitive/i.test(type) || type === \"Subpart\";\n}\n\nvar LineParser = /*#__PURE__*/function () {\n  function LineParser(line, lineNumber) {\n    _classCallCheck(this, LineParser);\n\n    this.line = line;\n    this.lineLength = line.length;\n    this.currentCharIndex = 0;\n    this.currentChar = \" \";\n    this.lineNumber = lineNumber;\n  }\n\n  _createClass(LineParser, [{\n    key: \"seekNonSpace\",\n    value: function seekNonSpace() {\n      while (this.currentCharIndex < this.lineLength) {\n        this.currentChar = this.line.charAt(this.currentCharIndex);\n\n        if (this.currentChar !== \" \" && this.currentChar !== \"\t\") {\n          return;\n        }\n\n        this.currentCharIndex++;\n      }\n    }\n  }, {\n    key: \"getToken\",\n    value: function getToken() {\n      var pos0 = this.currentCharIndex++;\n\n      while (this.currentCharIndex < this.lineLength) {\n        this.currentChar = this.line.charAt(this.currentCharIndex);\n\n        if (this.currentChar === \" \" || this.currentChar === \"\t\") {\n          break;\n        }\n\n        this.currentCharIndex++;\n      }\n\n      var pos1 = this.currentCharIndex;\n      this.seekNonSpace();\n      return this.line.substring(pos0, pos1);\n    }\n  }, {\n    key: \"getVector\",\n    value: function getVector() {\n      return new Vector3(parseFloat(this.getToken()), parseFloat(this.getToken()), parseFloat(this.getToken()));\n    }\n  }, {\n    key: \"getRemainingString\",\n    value: function getRemainingString() {\n      return this.line.substring(this.currentCharIndex, this.lineLength);\n    }\n  }, {\n    key: \"isAtTheEnd\",\n    value: function isAtTheEnd() {\n      return this.currentCharIndex >= this.lineLength;\n    }\n  }, {\n    key: \"setToEnd\",\n    value: function setToEnd() {\n      this.currentCharIndex = this.lineLength;\n    }\n  }, {\n    key: \"getLineNumberString\",\n    value: function getLineNumberString() {\n      return this.lineNumber >= 0 ? \" at line \" + this.lineNumber : \"\";\n    }\n  }]);\n\n  return LineParser;\n}();\n\nvar LDrawParsedCache = /*#__PURE__*/function () {\n  function LDrawParsedCache(loader) {\n    _classCallCheck(this, LDrawParsedCache);\n\n    this.loader = loader;\n    this._cache = {};\n  }\n\n  _createClass(LDrawParsedCache, [{\n    key: \"cloneResult\",\n    value: function cloneResult(original) {\n      var result = {};\n      result.faces = original.faces.map(function (face) {\n        return {\n          colorCode: face.colorCode,\n          material: face.material,\n          vertices: face.vertices.map(function (v) {\n            return v.clone();\n          }),\n          normals: face.normals.map(function () {\n            return null;\n          }),\n          faceNormal: null\n        };\n      });\n      result.conditionalSegments = original.conditionalSegments.map(function (face) {\n        return {\n          colorCode: face.colorCode,\n          material: face.material,\n          vertices: face.vertices.map(function (v) {\n            return v.clone();\n          }),\n          controlPoints: face.controlPoints.map(function (v) {\n            return v.clone();\n          })\n        };\n      });\n      result.lineSegments = original.lineSegments.map(function (face) {\n        return {\n          colorCode: face.colorCode,\n          material: face.material,\n          vertices: face.vertices.map(function (v) {\n            return v.clone();\n          })\n        };\n      });\n      result.type = original.type;\n      result.category = original.category;\n      result.keywords = original.keywords;\n      result.subobjects = original.subobjects;\n      result.totalFaces = original.totalFaces;\n      result.startingConstructionStep = original.startingConstructionStep;\n      result.materials = original.materials;\n      result.group = null;\n      return result;\n    }\n  }, {\n    key: \"fetchData\",\n    value: function () {\n      var _fetchData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(fileName) {\n        var triedLowerCase, locationState, subobjectURL, loader, fileLoader, text;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                triedLowerCase = false;\n                locationState = FILE_LOCATION_AS_IS;\n\n              case 2:\n                if (!(locationState !== FILE_LOCATION_NOT_FOUND)) {\n                  _context.next = 40;\n                  break;\n                }\n\n                subobjectURL = fileName;\n                _context.t0 = locationState;\n                _context.next = _context.t0 === FILE_LOCATION_AS_IS ? 7 : _context.t0 === FILE_LOCATION_TRY_PARTS ? 9 : _context.t0 === FILE_LOCATION_TRY_P ? 12 : _context.t0 === FILE_LOCATION_TRY_MODELS ? 15 : _context.t0 === FILE_LOCATION_TRY_RELATIVE ? 18 : _context.t0 === FILE_LOCATION_TRY_ABSOLUTE ? 21 : 23;\n                break;\n\n              case 7:\n                locationState = locationState + 1;\n                return _context.abrupt(\"break\", 23);\n\n              case 9:\n                subobjectURL = \"parts/\" + subobjectURL;\n                locationState = locationState + 1;\n                return _context.abrupt(\"break\", 23);\n\n              case 12:\n                subobjectURL = \"p/\" + subobjectURL;\n                locationState = locationState + 1;\n                return _context.abrupt(\"break\", 23);\n\n              case 15:\n                subobjectURL = \"models/\" + subobjectURL;\n                locationState = locationState + 1;\n                return _context.abrupt(\"break\", 23);\n\n              case 18:\n                subobjectURL = fileName.substring(0, fileName.lastIndexOf(\"/\") + 1) + subobjectURL;\n                locationState = locationState + 1;\n                return _context.abrupt(\"break\", 23);\n\n              case 21:\n                if (triedLowerCase) {\n                  locationState = FILE_LOCATION_NOT_FOUND;\n                } else {\n                  fileName = fileName.toLowerCase();\n                  subobjectURL = fileName;\n                  triedLowerCase = true;\n                  locationState = FILE_LOCATION_AS_IS;\n                }\n\n                return _context.abrupt(\"break\", 23);\n\n              case 23:\n                loader = this.loader;\n                fileLoader = new FileLoader(loader.manager);\n                fileLoader.setPath(loader.partsLibraryPath);\n                fileLoader.setRequestHeader(loader.requestHeader);\n                fileLoader.setWithCredentials(loader.withCredentials);\n                _context.prev = 28;\n                _context.next = 31;\n                return fileLoader.loadAsync(subobjectURL);\n\n              case 31:\n                text = _context.sent;\n                return _context.abrupt(\"return\", text);\n\n              case 35:\n                _context.prev = 35;\n                _context.t1 = _context[\"catch\"](28);\n                return _context.abrupt(\"continue\", 2);\n\n              case 38:\n                _context.next = 2;\n                break;\n\n              case 40:\n                throw new Error('LDrawLoader: Subobject \"' + fileName + '\" could not be loaded.');\n\n              case 41:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[28, 35]]);\n      }));\n\n      function fetchData(_x) {\n        return _fetchData.apply(this, arguments);\n      }\n\n      return fetchData;\n    }()\n  }, {\n    key: \"parse\",\n    value: function parse(text) {\n      var fileName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var loader = this.loader;\n      var faces = [];\n      var lineSegments = [];\n      var conditionalSegments = [];\n      var subobjects = [];\n      var materials = {};\n\n      var getLocalMaterial = function getLocalMaterial(colorCode) {\n        return materials[colorCode] || null;\n      };\n\n      var type = \"Model\";\n      var category = null;\n      var keywords = null;\n      var totalFaces = 0;\n\n      if (text.indexOf(\"\\r\\n\") !== -1) {\n        text = text.replace(/\\r\\n/g, \"\\n\");\n      }\n\n      var lines = text.split(\"\\n\");\n      var numLines = lines.length;\n      var parsingEmbeddedFiles = false;\n      var currentEmbeddedFileName = null;\n      var currentEmbeddedText = null;\n      var bfcCertified = false;\n      var bfcCCW = true;\n      var bfcInverted = false;\n      var bfcCull = true;\n      var startingConstructionStep = false;\n\n      for (var lineIndex = 0; lineIndex < numLines; lineIndex++) {\n        var line = lines[lineIndex];\n        if (line.length === 0) continue;\n\n        if (parsingEmbeddedFiles) {\n          if (line.startsWith(\"0 FILE \")) {\n            this.setData(currentEmbeddedFileName, currentEmbeddedText);\n            currentEmbeddedFileName = line.substring(7);\n            currentEmbeddedText = \"\";\n          } else {\n            currentEmbeddedText += line + \"\\n\";\n          }\n\n          continue;\n        }\n\n        var lp = new LineParser(line, lineIndex + 1);\n        lp.seekNonSpace();\n\n        if (lp.isAtTheEnd()) {\n          continue;\n        }\n\n        var lineType = lp.getToken();\n        var material = void 0;\n        var colorCode = void 0;\n        var segment = void 0;\n        var ccw = void 0;\n        var doubleSided = void 0;\n        var v0 = void 0,\n            v1 = void 0,\n            v2 = void 0,\n            v3 = void 0,\n            c0 = void 0,\n            c1 = void 0;\n\n        switch (lineType) {\n          case \"0\":\n            var meta = lp.getToken();\n\n            if (meta) {\n              switch (meta) {\n                case \"!LDRAW_ORG\":\n                  type = lp.getToken();\n                  break;\n\n                case \"!COLOUR\":\n                  material = loader.parseColorMetaDirective(lp);\n\n                  if (material) {\n                    materials[material.userData.code] = material;\n                  } else {\n                    console.warn(\"LDrawLoader: Error parsing material\" + lp.getLineNumberString());\n                  }\n\n                  break;\n\n                case \"!CATEGORY\":\n                  category = lp.getToken();\n                  break;\n\n                case \"!KEYWORDS\":\n                  var newKeywords = lp.getRemainingString().split(\",\");\n\n                  if (newKeywords.length > 0) {\n                    if (!keywords) {\n                      keywords = [];\n                    }\n\n                    newKeywords.forEach(function (keyword) {\n                      keywords.push(keyword.trim());\n                    });\n                  }\n\n                  break;\n\n                case \"FILE\":\n                  if (lineIndex > 0) {\n                    parsingEmbeddedFiles = true;\n                    currentEmbeddedFileName = lp.getRemainingString();\n                    currentEmbeddedText = \"\";\n                    bfcCertified = false;\n                    bfcCCW = true;\n                  }\n\n                  break;\n\n                case \"BFC\":\n                  while (!lp.isAtTheEnd()) {\n                    var token = lp.getToken();\n\n                    switch (token) {\n                      case \"CERTIFY\":\n                      case \"NOCERTIFY\":\n                        bfcCertified = token === \"CERTIFY\";\n                        bfcCCW = true;\n                        break;\n\n                      case \"CW\":\n                      case \"CCW\":\n                        bfcCCW = token === \"CCW\";\n                        break;\n\n                      case \"INVERTNEXT\":\n                        bfcInverted = true;\n                        break;\n\n                      case \"CLIP\":\n                      case \"NOCLIP\":\n                        bfcCull = token === \"CLIP\";\n                        break;\n\n                      default:\n                        console.warn('THREE.LDrawLoader: BFC directive \"' + token + '\" is unknown.');\n                        break;\n                    }\n                  }\n\n                  break;\n\n                case \"STEP\":\n                  startingConstructionStep = true;\n                  break;\n\n                default:\n                  break;\n              }\n            }\n\n            break;\n\n          case \"1\":\n            colorCode = lp.getToken();\n            material = getLocalMaterial(colorCode);\n            var posX = parseFloat(lp.getToken());\n            var posY = parseFloat(lp.getToken());\n            var posZ = parseFloat(lp.getToken());\n            var m0 = parseFloat(lp.getToken());\n            var m1 = parseFloat(lp.getToken());\n            var m2 = parseFloat(lp.getToken());\n            var m3 = parseFloat(lp.getToken());\n            var m4 = parseFloat(lp.getToken());\n            var m5 = parseFloat(lp.getToken());\n            var m6 = parseFloat(lp.getToken());\n            var m7 = parseFloat(lp.getToken());\n            var m8 = parseFloat(lp.getToken());\n            var matrix = new Matrix4().set(m0, m1, m2, posX, m3, m4, m5, posY, m6, m7, m8, posZ, 0, 0, 0, 1);\n            var fileName2 = lp.getRemainingString().trim().replace(/\\\\/g, \"/\");\n\n            if (loader.fileMap[fileName2]) {\n              fileName2 = loader.fileMap[fileName2];\n            } else {\n              if (fileName2.startsWith(\"s/\")) {\n                fileName2 = \"parts/\" + fileName2;\n              } else if (fileName2.startsWith(\"48/\")) {\n                fileName2 = \"p/\" + fileName2;\n              }\n            }\n\n            subobjects.push({\n              material: material,\n              colorCode: colorCode,\n              matrix: matrix,\n              fileName: fileName2,\n              inverted: bfcInverted,\n              startingConstructionStep: startingConstructionStep\n            });\n            bfcInverted = false;\n            break;\n\n          case \"2\":\n            colorCode = lp.getToken();\n            material = getLocalMaterial(colorCode);\n            v0 = lp.getVector();\n            v1 = lp.getVector();\n            segment = {\n              material: material,\n              colorCode: colorCode,\n              vertices: [v0, v1]\n            };\n            lineSegments.push(segment);\n            break;\n\n          case \"5\":\n            colorCode = lp.getToken();\n            material = getLocalMaterial(colorCode);\n            v0 = lp.getVector();\n            v1 = lp.getVector();\n            c0 = lp.getVector();\n            c1 = lp.getVector();\n            segment = {\n              material: material,\n              colorCode: colorCode,\n              vertices: [v0, v1],\n              controlPoints: [c0, c1]\n            };\n            conditionalSegments.push(segment);\n            break;\n\n          case \"3\":\n            colorCode = lp.getToken();\n            material = getLocalMaterial(colorCode);\n            ccw = bfcCCW;\n            doubleSided = !bfcCertified || !bfcCull;\n\n            if (ccw === true) {\n              v0 = lp.getVector();\n              v1 = lp.getVector();\n              v2 = lp.getVector();\n            } else {\n              v2 = lp.getVector();\n              v1 = lp.getVector();\n              v0 = lp.getVector();\n            }\n\n            faces.push({\n              material: material,\n              colorCode: colorCode,\n              faceNormal: null,\n              vertices: [v0, v1, v2],\n              normals: [null, null, null]\n            });\n            totalFaces++;\n\n            if (doubleSided === true) {\n              faces.push({\n                material: material,\n                colorCode: colorCode,\n                faceNormal: null,\n                vertices: [v2, v1, v0],\n                normals: [null, null, null]\n              });\n              totalFaces++;\n            }\n\n            break;\n\n          case \"4\":\n            colorCode = lp.getToken();\n            material = getLocalMaterial(colorCode);\n            ccw = bfcCCW;\n            doubleSided = !bfcCertified || !bfcCull;\n\n            if (ccw === true) {\n              v0 = lp.getVector();\n              v1 = lp.getVector();\n              v2 = lp.getVector();\n              v3 = lp.getVector();\n            } else {\n              v3 = lp.getVector();\n              v2 = lp.getVector();\n              v1 = lp.getVector();\n              v0 = lp.getVector();\n            }\n\n            faces.push({\n              material: material,\n              colorCode: colorCode,\n              faceNormal: null,\n              vertices: [v0, v1, v2, v3],\n              normals: [null, null, null, null]\n            });\n            totalFaces += 2;\n\n            if (doubleSided === true) {\n              faces.push({\n                material: material,\n                colorCode: colorCode,\n                faceNormal: null,\n                vertices: [v3, v2, v1, v0],\n                normals: [null, null, null, null]\n              });\n              totalFaces += 2;\n            }\n\n            break;\n\n          default:\n            throw new Error('LDrawLoader: Unknown line type \"' + lineType + '\"' + lp.getLineNumberString() + \".\");\n        }\n      }\n\n      if (parsingEmbeddedFiles) {\n        this.setData(currentEmbeddedFileName, currentEmbeddedText);\n      }\n\n      return {\n        faces: faces,\n        conditionalSegments: conditionalSegments,\n        lineSegments: lineSegments,\n        type: type,\n        category: category,\n        keywords: keywords,\n        subobjects: subobjects,\n        totalFaces: totalFaces,\n        startingConstructionStep: startingConstructionStep,\n        materials: materials,\n        fileName: fileName,\n        group: null\n      };\n    } // returns an (optionally cloned) instance of the data\n\n  }, {\n    key: \"getData\",\n    value: function getData(fileName) {\n      var clone = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var key = fileName.toLowerCase();\n      var result = this._cache[key];\n\n      if (result === null || result instanceof Promise) {\n        return null;\n      }\n\n      if (clone) {\n        return this.cloneResult(result);\n      } else {\n        return result;\n      }\n    } // kicks off a fetch and parse of the requested data if it hasn't already been loaded. Returns when\n    // the data is ready to use and can be retrieved synchronously with \"getData\".\n\n  }, {\n    key: \"ensureDataLoaded\",\n    value: function () {\n      var _ensureDataLoaded = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(fileName) {\n        var _this3 = this;\n\n        var key;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                key = fileName.toLowerCase();\n\n                if (!(key in this._cache)) {\n                  this._cache[key] = this.fetchData(fileName).then(function (text) {\n                    var info = _this3.parse(text, fileName);\n\n                    _this3._cache[key] = info;\n                    return info;\n                  });\n                }\n\n                _context2.next = 4;\n                return this._cache[key];\n\n              case 4:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function ensureDataLoaded(_x2) {\n        return _ensureDataLoaded.apply(this, arguments);\n      }\n\n      return ensureDataLoaded;\n    }() // sets the data in the cache from parsed data\n\n  }, {\n    key: \"setData\",\n    value: function setData(fileName, text) {\n      var key = fileName.toLowerCase();\n      this._cache[key] = this.parse(text, fileName);\n    }\n  }]);\n\n  return LDrawParsedCache;\n}();\n\nfunction getMaterialFromCode(colorCode, parentColorCode, materialHierarchy, forEdge) {\n  var isPassthrough = !forEdge && colorCode === MAIN_COLOUR_CODE || forEdge && colorCode === MAIN_EDGE_COLOUR_CODE;\n\n  if (isPassthrough) {\n    colorCode = parentColorCode;\n  }\n\n  return materialHierarchy[colorCode] || null;\n}\n\nvar LDrawPartsGeometryCache = /*#__PURE__*/function () {\n  function LDrawPartsGeometryCache(loader) {\n    _classCallCheck(this, LDrawPartsGeometryCache);\n\n    this.loader = loader;\n    this.parseCache = new LDrawParsedCache(loader);\n    this._cache = {};\n  } // Convert the given file information into a mesh by processing subobjects.\n\n\n  _createClass(LDrawPartsGeometryCache, [{\n    key: \"processIntoMesh\",\n    value: function () {\n      var _processIntoMesh = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(info) {\n        var _this4 = this;\n\n        var loader, parseCache, faceMaterials, processInfoSubobjects, i, l, checkSubSegments, group;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                loader = this.loader;\n                parseCache = this.parseCache;\n                faceMaterials = /* @__PURE__ */new Set();\n\n                processInfoSubobjects = /*#__PURE__*/function () {\n                  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(info2) {\n                    var subobject,\n                        subobjects,\n                        promises,\n                        _loop,\n                        i,\n                        l,\n                        group2,\n                        subobjectInfos,\n                        _i4,\n                        _l3,\n                        subobject2,\n                        subobjectInfo,\n                        subobjectGroup,\n                        parentLineSegments,\n                        parentConditionalSegments,\n                        parentFaces,\n                        lineSegments,\n                        conditionalSegments,\n                        faces,\n                        matrix,\n                        inverted,\n                        matrixScaleInverted,\n                        colorCode,\n                        lineColorCode,\n                        i2,\n                        l2,\n                        ls,\n                        vertices,\n                        _i5,\n                        _l4,\n                        os,\n                        _vertices3,\n                        controlPoints,\n                        _i6,\n                        _l5,\n                        tri,\n                        _vertices4,\n                        i3,\n                        l3,\n                        _args3 = arguments;\n\n                    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n                      while (1) {\n                        switch (_context3.prev = _context3.next) {\n                          case 0:\n                            subobject = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : null;\n                            subobjects = info2.subobjects;\n                            promises = [];\n\n                            _loop = function _loop(i, l) {\n                              var subobject2 = subobjects[i];\n                              var promise = parseCache.ensureDataLoaded(subobject2.fileName).then(function () {\n                                var subobjectInfo = parseCache.getData(subobject2.fileName, false);\n\n                                if (!isPrimitiveType(subobjectInfo.type)) {\n                                  return _this4.loadModel(subobject2.fileName).catch(function (error) {\n                                    console.warn(error);\n                                    return null;\n                                  });\n                                }\n\n                                return processInfoSubobjects(parseCache.getData(subobject2.fileName), subobject2);\n                              });\n                              promises.push(promise);\n                            };\n\n                            for (i = 0, l = subobjects.length; i < l; i++) {\n                              _loop(i, l);\n                            }\n\n                            group2 = new Group();\n                            group2.userData.category = info2.category;\n                            group2.userData.keywords = info2.keywords;\n                            info2.group = group2;\n                            _context3.next = 11;\n                            return Promise.all(promises);\n\n                          case 11:\n                            subobjectInfos = _context3.sent;\n                            _i4 = 0, _l3 = subobjectInfos.length;\n\n                          case 13:\n                            if (!(_i4 < _l3)) {\n                              _context3.next = 45;\n                              break;\n                            }\n\n                            subobject2 = info2.subobjects[_i4];\n                            subobjectInfo = subobjectInfos[_i4];\n\n                            if (!(subobjectInfo === null)) {\n                              _context3.next = 18;\n                              break;\n                            }\n\n                            return _context3.abrupt(\"continue\", 42);\n\n                          case 18:\n                            if (!subobjectInfo.isGroup) {\n                              _context3.next = 26;\n                              break;\n                            }\n\n                            subobjectGroup = subobjectInfo;\n                            subobject2.matrix.decompose(subobjectGroup.position, subobjectGroup.quaternion, subobjectGroup.scale);\n                            subobjectGroup.userData.startingConstructionStep = subobject2.startingConstructionStep;\n                            subobjectGroup.name = subobject2.fileName;\n                            loader.applyMaterialsToMesh(subobjectGroup, subobject2.colorCode, info2.materials);\n                            group2.add(subobjectGroup);\n                            return _context3.abrupt(\"continue\", 42);\n\n                          case 26:\n                            if (subobjectInfo.group.children.length) {\n                              group2.add(subobjectInfo.group);\n                            }\n\n                            parentLineSegments = info2.lineSegments;\n                            parentConditionalSegments = info2.conditionalSegments;\n                            parentFaces = info2.faces;\n                            lineSegments = subobjectInfo.lineSegments;\n                            conditionalSegments = subobjectInfo.conditionalSegments;\n                            faces = subobjectInfo.faces;\n                            matrix = subobject2.matrix;\n                            inverted = subobject2.inverted;\n                            matrixScaleInverted = matrix.determinant() < 0;\n                            colorCode = subobject2.colorCode;\n                            lineColorCode = colorCode === MAIN_COLOUR_CODE ? MAIN_EDGE_COLOUR_CODE : colorCode;\n\n                            for (i2 = 0, l2 = lineSegments.length; i2 < l2; i2++) {\n                              ls = lineSegments[i2];\n                              vertices = ls.vertices;\n                              vertices[0].applyMatrix4(matrix);\n                              vertices[1].applyMatrix4(matrix);\n                              ls.colorCode = ls.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : ls.colorCode;\n                              ls.material = ls.material || getMaterialFromCode(ls.colorCode, ls.colorCode, info2.materials, true);\n                              parentLineSegments.push(ls);\n                            }\n\n                            for (_i5 = 0, _l4 = conditionalSegments.length; _i5 < _l4; _i5++) {\n                              os = conditionalSegments[_i5];\n                              _vertices3 = os.vertices;\n                              controlPoints = os.controlPoints;\n\n                              _vertices3[0].applyMatrix4(matrix);\n\n                              _vertices3[1].applyMatrix4(matrix);\n\n                              controlPoints[0].applyMatrix4(matrix);\n                              controlPoints[1].applyMatrix4(matrix);\n                              os.colorCode = os.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : os.colorCode;\n                              os.material = os.material || getMaterialFromCode(os.colorCode, os.colorCode, info2.materials, true);\n                              parentConditionalSegments.push(os);\n                            }\n\n                            for (_i6 = 0, _l5 = faces.length; _i6 < _l5; _i6++) {\n                              tri = faces[_i6];\n                              _vertices4 = tri.vertices;\n\n                              for (i3 = 0, l3 = _vertices4.length; i3 < l3; i3++) {\n                                _vertices4[i3].applyMatrix4(matrix);\n                              }\n\n                              tri.colorCode = tri.colorCode === MAIN_COLOUR_CODE ? colorCode : tri.colorCode;\n                              tri.material = tri.material || getMaterialFromCode(tri.colorCode, colorCode, info2.materials, false);\n                              faceMaterials.add(tri.colorCode);\n\n                              if (matrixScaleInverted !== inverted) {\n                                _vertices4.reverse();\n                              }\n\n                              parentFaces.push(tri);\n                            }\n\n                            info2.totalFaces += subobjectInfo.totalFaces;\n\n                          case 42:\n                            _i4++;\n                            _context3.next = 13;\n                            break;\n\n                          case 45:\n                            if (subobject) {\n                              loader.applyMaterialsToMesh(group2, subobject.colorCode, info2.materials);\n                            }\n\n                            return _context3.abrupt(\"return\", info2);\n\n                          case 47:\n                          case \"end\":\n                            return _context3.stop();\n                        }\n                      }\n                    }, _callee3);\n                  }));\n\n                  return function processInfoSubobjects(_x4) {\n                    return _ref3.apply(this, arguments);\n                  };\n                }();\n\n                for (i = 0, l = info.faces; i < l; i++) {\n                  faceMaterials.add(info.faces[i].colorCode);\n                }\n\n                _context4.next = 7;\n                return processInfoSubobjects(info);\n\n              case 7:\n                if (loader.smoothNormals) {\n                  checkSubSegments = faceMaterials.size > 1;\n                  generateFaceNormals(info.faces);\n                  smoothNormals(info.faces, info.lineSegments, checkSubSegments);\n                }\n\n                group = info.group;\n\n                if (info.faces.length > 0) {\n                  group.add(createObject(info.faces, 3, false, info.totalFaces));\n                }\n\n                if (info.lineSegments.length > 0) {\n                  group.add(createObject(info.lineSegments, 2));\n                }\n\n                if (info.conditionalSegments.length > 0) {\n                  group.add(createObject(info.conditionalSegments, 2, true));\n                }\n\n                return _context4.abrupt(\"return\", group);\n\n              case 13:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function processIntoMesh(_x3) {\n        return _processIntoMesh.apply(this, arguments);\n      }\n\n      return processIntoMesh;\n    }()\n  }, {\n    key: \"hasCachedModel\",\n    value: function hasCachedModel(fileName) {\n      return fileName !== null && fileName.toLowerCase() in this._cache;\n    }\n  }, {\n    key: \"getCachedModel\",\n    value: function () {\n      var _getCachedModel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(fileName) {\n        var key, group;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                if (!(fileName !== null && this.hasCachedModel(fileName))) {\n                  _context5.next = 8;\n                  break;\n                }\n\n                key = fileName.toLowerCase();\n                _context5.next = 4;\n                return this._cache[key];\n\n              case 4:\n                group = _context5.sent;\n                return _context5.abrupt(\"return\", group.clone());\n\n              case 8:\n                return _context5.abrupt(\"return\", null);\n\n              case 9:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function getCachedModel(_x5) {\n        return _getCachedModel.apply(this, arguments);\n      }\n\n      return getCachedModel;\n    }() // Loads and parses the model with the given file name. Returns a cached copy if available.\n\n  }, {\n    key: \"loadModel\",\n    value: function () {\n      var _loadModel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(fileName) {\n        var parseCache, key, info, promise, group;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                parseCache = this.parseCache;\n                key = fileName.toLowerCase();\n\n                if (!this.hasCachedModel(fileName)) {\n                  _context6.next = 6;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\", this.getCachedModel(fileName));\n\n              case 6:\n                _context6.next = 8;\n                return parseCache.ensureDataLoaded(fileName);\n\n              case 8:\n                info = parseCache.getData(fileName);\n                promise = this.processIntoMesh(info);\n\n                if (!this.hasCachedModel(fileName)) {\n                  _context6.next = 12;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\", this.getCachedModel(fileName));\n\n              case 12:\n                if (isPartType(info.type)) {\n                  this._cache[key] = promise;\n                }\n\n                _context6.next = 15;\n                return promise;\n\n              case 15:\n                group = _context6.sent;\n                return _context6.abrupt(\"return\", group.clone());\n\n              case 17:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function loadModel(_x6) {\n        return _loadModel.apply(this, arguments);\n      }\n\n      return loadModel;\n    }() // parses the given model text into a renderable object. Returns cached copy if available.\n\n  }, {\n    key: \"parseModel\",\n    value: function () {\n      var _parseModel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(text) {\n        var parseCache, info;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                parseCache = this.parseCache;\n                info = parseCache.parse(text);\n\n                if (!(isPartType(info.type) && this.hasCachedModel(info.fileName))) {\n                  _context7.next = 4;\n                  break;\n                }\n\n                return _context7.abrupt(\"return\", this.getCachedModel(info.fileName));\n\n              case 4:\n                return _context7.abrupt(\"return\", this.processIntoMesh(info));\n\n              case 5:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function parseModel(_x7) {\n        return _parseModel.apply(this, arguments);\n      }\n\n      return parseModel;\n    }()\n  }]);\n\n  return LDrawPartsGeometryCache;\n}();\n\nfunction sortByMaterial(a, b) {\n  if (a.colorCode === b.colorCode) {\n    return 0;\n  }\n\n  if (a.colorCode < b.colorCode) {\n    return -1;\n  }\n\n  return 1;\n}\n\nfunction createObject(elements, elementSize) {\n  var isConditionalSegments = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var totalElements = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  elements.sort(sortByMaterial);\n\n  if (totalElements === null) {\n    totalElements = elements.length;\n  }\n\n  var positions = new Float32Array(elementSize * totalElements * 3);\n  var normals = elementSize === 3 ? new Float32Array(elementSize * totalElements * 3) : null;\n  var materials = [];\n  var quadArray = new Array(6);\n  var bufferGeometry = new BufferGeometry();\n  var prevMaterial = null;\n  var index0 = 0;\n  var numGroupVerts = 0;\n  var offset = 0;\n\n  for (var iElem = 0, nElem = elements.length; iElem < nElem; iElem++) {\n    var elem = elements[iElem];\n    var vertices = elem.vertices;\n\n    if (vertices.length === 4) {\n      quadArray[0] = vertices[0];\n      quadArray[1] = vertices[1];\n      quadArray[2] = vertices[2];\n      quadArray[3] = vertices[0];\n      quadArray[4] = vertices[2];\n      quadArray[5] = vertices[3];\n      vertices = quadArray;\n    }\n\n    for (var j = 0, l = vertices.length; j < l; j++) {\n      var v = vertices[j];\n      var index = offset + j * 3;\n      positions[index + 0] = v.x;\n      positions[index + 1] = v.y;\n      positions[index + 2] = v.z;\n    }\n\n    if (elementSize === 3) {\n      if (!elem.faceNormal) {\n        var v0 = vertices[0];\n        var v1 = vertices[1];\n        var v2 = vertices[2];\n\n        _tempVec0.subVectors(v1, v0);\n\n        _tempVec1.subVectors(v2, v1);\n\n        elem.faceNormal = new Vector3().crossVectors(_tempVec0, _tempVec1).normalize();\n      }\n\n      var elemNormals = elem.normals;\n\n      if (elemNormals.length === 4) {\n        quadArray[0] = elemNormals[0];\n        quadArray[1] = elemNormals[1];\n        quadArray[2] = elemNormals[2];\n        quadArray[3] = elemNormals[0];\n        quadArray[4] = elemNormals[2];\n        quadArray[5] = elemNormals[3];\n        elemNormals = quadArray;\n      }\n\n      for (var _j = 0, _l6 = elemNormals.length; _j < _l6; _j++) {\n        var n = elem.faceNormal;\n\n        if (elemNormals[_j]) {\n          n = elemNormals[_j].norm;\n        }\n\n        var _index2 = offset + _j * 3;\n\n        normals[_index2 + 0] = n.x;\n        normals[_index2 + 1] = n.y;\n        normals[_index2 + 2] = n.z;\n      }\n    }\n\n    if (prevMaterial !== elem.colorCode) {\n      if (prevMaterial !== null) {\n        bufferGeometry.addGroup(index0, numGroupVerts, materials.length - 1);\n      }\n\n      var material = elem.material;\n\n      if (material !== null) {\n        if (elementSize === 3) {\n          materials.push(material);\n        } else if (elementSize === 2) {\n          if (material !== null) {\n            if (isConditionalSegments) {\n              materials.push(material.userData.edgeMaterial.userData.conditionalEdgeMaterial);\n            } else {\n              materials.push(material.userData.edgeMaterial);\n            }\n          } else {\n            materials.push(null);\n          }\n        }\n      } else {\n        materials.push(elem.colorCode);\n      }\n\n      prevMaterial = elem.colorCode;\n      index0 = offset / 3;\n      numGroupVerts = vertices.length;\n    } else {\n      numGroupVerts += vertices.length;\n    }\n\n    offset += 3 * vertices.length;\n  }\n\n  if (numGroupVerts > 0) {\n    bufferGeometry.addGroup(index0, Infinity, materials.length - 1);\n  }\n\n  bufferGeometry.setAttribute(\"position\", new BufferAttribute(positions, 3));\n\n  if (normals !== null) {\n    bufferGeometry.setAttribute(\"normal\", new BufferAttribute(normals, 3));\n  }\n\n  var object3d = null;\n\n  if (elementSize === 2) {\n    if (isConditionalSegments) {\n      object3d = new ConditionalLineSegments(bufferGeometry, materials.length === 1 ? materials[0] : materials);\n    } else {\n      object3d = new LineSegments(bufferGeometry, materials.length === 1 ? materials[0] : materials);\n    }\n  } else if (elementSize === 3) {\n    object3d = new Mesh(bufferGeometry, materials.length === 1 ? materials[0] : materials);\n  }\n\n  if (isConditionalSegments) {\n    object3d.isConditionalLine = true;\n    var controlArray0 = new Float32Array(elements.length * 3 * 2);\n    var controlArray1 = new Float32Array(elements.length * 3 * 2);\n    var directionArray = new Float32Array(elements.length * 3 * 2);\n\n    for (var i = 0, _l7 = elements.length; i < _l7; i++) {\n      var os = elements[i];\n      var _vertices5 = os.vertices;\n      var controlPoints = os.controlPoints;\n      var c0 = controlPoints[0];\n      var c1 = controlPoints[1];\n      var _v5 = _vertices5[0];\n      var _v6 = _vertices5[1];\n\n      var _index3 = i * 3 * 2;\n\n      controlArray0[_index3 + 0] = c0.x;\n      controlArray0[_index3 + 1] = c0.y;\n      controlArray0[_index3 + 2] = c0.z;\n      controlArray0[_index3 + 3] = c0.x;\n      controlArray0[_index3 + 4] = c0.y;\n      controlArray0[_index3 + 5] = c0.z;\n      controlArray1[_index3 + 0] = c1.x;\n      controlArray1[_index3 + 1] = c1.y;\n      controlArray1[_index3 + 2] = c1.z;\n      controlArray1[_index3 + 3] = c1.x;\n      controlArray1[_index3 + 4] = c1.y;\n      controlArray1[_index3 + 5] = c1.z;\n      directionArray[_index3 + 0] = _v6.x - _v5.x;\n      directionArray[_index3 + 1] = _v6.y - _v5.y;\n      directionArray[_index3 + 2] = _v6.z - _v5.z;\n      directionArray[_index3 + 3] = _v6.x - _v5.x;\n      directionArray[_index3 + 4] = _v6.y - _v5.y;\n      directionArray[_index3 + 5] = _v6.z - _v5.z;\n    }\n\n    bufferGeometry.setAttribute(\"control0\", new BufferAttribute(controlArray0, 3, false));\n    bufferGeometry.setAttribute(\"control1\", new BufferAttribute(controlArray1, 3, false));\n    bufferGeometry.setAttribute(\"direction\", new BufferAttribute(directionArray, 3, false));\n  }\n\n  return object3d;\n}\n\nvar LDrawLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(LDrawLoader, _Loader);\n\n  var _super3 = _createSuper(LDrawLoader);\n\n  function LDrawLoader(manager) {\n    var _this5;\n\n    _classCallCheck(this, LDrawLoader);\n\n    _this5 = _super3.call(this, manager);\n    _this5.materials = [];\n    _this5.materialLibrary = {};\n    _this5.partsCache = new LDrawPartsGeometryCache(_assertThisInitialized(_this5));\n    _this5.fileMap = {};\n\n    _this5.setMaterials([]);\n\n    _this5.smoothNormals = true;\n    _this5.partsLibraryPath = \"\";\n    return _this5;\n  }\n\n  _createClass(LDrawLoader, [{\n    key: \"setPartsLibraryPath\",\n    value: function setPartsLibraryPath(path) {\n      this.partsLibraryPath = path;\n      return this;\n    }\n  }, {\n    key: \"preloadMaterials\",\n    value: function () {\n      var _preloadMaterials = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(url) {\n        var fileLoader, text, colorLineRegex, lines, materials, i, l, line, directive, material;\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                fileLoader = new FileLoader(this.manager);\n                fileLoader.setPath(this.path);\n                fileLoader.setRequestHeader(this.requestHeader);\n                fileLoader.setWithCredentials(this.withCredentials);\n                _context8.next = 6;\n                return fileLoader.loadAsync(url);\n\n              case 6:\n                text = _context8.sent;\n                colorLineRegex = /^0 !COLOUR/;\n                lines = text.split(/[\\n\\r]/g);\n                materials = [];\n\n                for (i = 0, l = lines.length; i < l; i++) {\n                  line = lines[i];\n\n                  if (colorLineRegex.test(line)) {\n                    directive = line.replace(colorLineRegex, \"\");\n                    material = this.parseColorMetaDirective(new LineParser(directive));\n                    materials.push(material);\n                  }\n                }\n\n                this.setMaterials(materials);\n\n              case 12:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function preloadMaterials(_x8) {\n        return _preloadMaterials.apply(this, arguments);\n      }\n\n      return preloadMaterials;\n    }()\n  }, {\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var _this6 = this;\n\n      var fileLoader = new FileLoader(this.manager);\n      fileLoader.setPath(this.path);\n      fileLoader.setRequestHeader(this.requestHeader);\n      fileLoader.setWithCredentials(this.withCredentials);\n      fileLoader.load(url, function (text) {\n        _this6.partsCache.parseModel(text, _this6.materialLibrary).then(function (group) {\n          _this6.applyMaterialsToMesh(group, MAIN_COLOUR_CODE, _this6.materialLibrary, true);\n\n          _this6.computeConstructionSteps(group);\n\n          onLoad(group);\n        }).catch(onError);\n      }, onProgress, onError);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(text, onLoad) {\n      var _this7 = this;\n\n      this.partsCache.parseModel(text, this.materialLibrary).then(function (group) {\n        _this7.computeConstructionSteps(group);\n\n        onLoad(group);\n      });\n    }\n  }, {\n    key: \"setMaterials\",\n    value: function setMaterials(materials) {\n      this.materialLibrary = {};\n      this.materials = [];\n\n      for (var i = 0, l = materials.length; i < l; i++) {\n        this.addMaterial(materials[i]);\n      }\n\n      this.addMaterial(this.parseColorMetaDirective(new LineParser(\"Main_Colour CODE 16 VALUE #FF8080 EDGE #333333\")));\n      this.addMaterial(this.parseColorMetaDirective(new LineParser(\"Edge_Colour CODE 24 VALUE #A0A0A0 EDGE #333333\")));\n      return this;\n    }\n  }, {\n    key: \"setFileMap\",\n    value: function setFileMap(fileMap) {\n      this.fileMap = fileMap;\n      return this;\n    }\n  }, {\n    key: \"addMaterial\",\n    value: function addMaterial(material) {\n      var matLib = this.materialLibrary;\n\n      if (!matLib[material.userData.code]) {\n        this.materials.push(material);\n        matLib[material.userData.code] = material;\n      }\n\n      return this;\n    }\n  }, {\n    key: \"getMaterial\",\n    value: function getMaterial(colorCode) {\n      if (colorCode.startsWith(\"0x2\")) {\n        var color = colorCode.substring(3);\n        return this.parseColorMetaDirective(new LineParser(\"Direct_Color_\" + color + \" CODE -1 VALUE #\" + color + \" EDGE #\" + color));\n      }\n\n      return this.materialLibrary[colorCode] || null;\n    } // Applies the appropriate materials to a prebuilt hierarchy of geometry. Assumes that color codes are present\n    // in the material array if they need to be filled in.\n\n  }, {\n    key: \"applyMaterialsToMesh\",\n    value: function applyMaterialsToMesh(group, parentColorCode, materialHierarchy) {\n      var finalMaterialPass = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      var loader = this;\n      var parentIsPassthrough = parentColorCode === MAIN_COLOUR_CODE;\n      group.traverse(function (c) {\n        if (c.isMesh || c.isLineSegments) {\n          if (Array.isArray(c.material)) {\n            for (var i = 0, l = c.material.length; i < l; i++) {\n              if (!c.material[i].isMaterial) {\n                c.material[i] = getMaterial(c, c.material[i]);\n              }\n            }\n          } else if (!c.material.isMaterial) {\n            c.material = getMaterial(c, c.material);\n          }\n        }\n      });\n\n      function getMaterial(c, colorCode) {\n        if (parentIsPassthrough && !(colorCode in materialHierarchy) && !finalMaterialPass) {\n          return colorCode;\n        }\n\n        var forEdge = c.isLineSegments || c.isConditionalLine;\n        var isPassthrough = !forEdge && colorCode === MAIN_COLOUR_CODE || forEdge && colorCode === MAIN_EDGE_COLOUR_CODE;\n\n        if (isPassthrough) {\n          colorCode = parentColorCode;\n        }\n\n        var material = null;\n\n        if (colorCode in materialHierarchy) {\n          material = materialHierarchy[colorCode];\n        } else if (finalMaterialPass) {\n          material = loader.getMaterial(colorCode);\n\n          if (material === null) {\n            throw new Error(\"LDrawLoader: Material properties for code \".concat(colorCode, \" not available.\"));\n          }\n        } else {\n          return colorCode;\n        }\n\n        if (c.isLineSegments) {\n          material = material.userData.edgeMaterial;\n\n          if (c.isConditionalLine) {\n            material = material.userData.conditionalEdgeMaterial;\n          }\n        }\n\n        return material;\n      }\n    }\n  }, {\n    key: \"getMainMaterial\",\n    value: function getMainMaterial() {\n      return this.getMaterial(MAIN_COLOUR_CODE);\n    }\n  }, {\n    key: \"getMainEdgeMaterial\",\n    value: function getMainEdgeMaterial() {\n      return this.getMaterial(MAIN_EDGE_COLOUR_CODE);\n    }\n  }, {\n    key: \"parseColorMetaDirective\",\n    value: function parseColorMetaDirective(lineParser) {\n      var code = null;\n      var color = 16711935;\n      var edgeColor = 16711935;\n      var alpha = 1;\n      var isTransparent = false;\n      var luminance = 0;\n      var finishType = FINISH_TYPE_DEFAULT;\n      var edgeMaterial = null;\n      var name = lineParser.getToken();\n\n      if (!name) {\n        throw new Error('LDrawLoader: Material name was expected after \"!COLOUR tag' + lineParser.getLineNumberString() + \".\");\n      }\n\n      var token = null;\n\n      while (true) {\n        token = lineParser.getToken();\n\n        if (!token) {\n          break;\n        }\n\n        switch (token.toUpperCase()) {\n          case \"CODE\":\n            code = lineParser.getToken();\n            break;\n\n          case \"VALUE\":\n            color = lineParser.getToken();\n\n            if (color.startsWith(\"0x\")) {\n              color = \"#\" + color.substring(2);\n            } else if (!color.startsWith(\"#\")) {\n              throw new Error(\"LDrawLoader: Invalid color while parsing material\" + lineParser.getLineNumberString() + \".\");\n            }\n\n            break;\n\n          case \"EDGE\":\n            edgeColor = lineParser.getToken();\n\n            if (edgeColor.startsWith(\"0x\")) {\n              edgeColor = \"#\" + edgeColor.substring(2);\n            } else if (!edgeColor.startsWith(\"#\")) {\n              edgeMaterial = this.getMaterial(edgeColor);\n\n              if (!edgeMaterial) {\n                throw new Error(\"LDrawLoader: Invalid edge color while parsing material\" + lineParser.getLineNumberString() + \".\");\n              }\n\n              edgeMaterial = edgeMaterial.userData.edgeMaterial;\n            }\n\n            break;\n\n          case \"ALPHA\":\n            alpha = parseInt(lineParser.getToken());\n\n            if (isNaN(alpha)) {\n              throw new Error(\"LDrawLoader: Invalid alpha value in material definition\" + lineParser.getLineNumberString() + \".\");\n            }\n\n            alpha = Math.max(0, Math.min(1, alpha / 255));\n\n            if (alpha < 1) {\n              isTransparent = true;\n            }\n\n            break;\n\n          case \"LUMINANCE\":\n            luminance = parseInt(lineParser.getToken());\n\n            if (isNaN(luminance)) {\n              throw new Error(\"LDrawLoader: Invalid luminance value in material definition\" + LineParser.getLineNumberString() + \".\");\n            }\n\n            luminance = Math.max(0, Math.min(1, luminance / 255));\n            break;\n\n          case \"CHROME\":\n            finishType = FINISH_TYPE_CHROME;\n            break;\n\n          case \"PEARLESCENT\":\n            finishType = FINISH_TYPE_PEARLESCENT;\n            break;\n\n          case \"RUBBER\":\n            finishType = FINISH_TYPE_RUBBER;\n            break;\n\n          case \"MATTE_METALLIC\":\n            finishType = FINISH_TYPE_MATTE_METALLIC;\n            break;\n\n          case \"METAL\":\n            finishType = FINISH_TYPE_METAL;\n            break;\n\n          case \"MATERIAL\":\n            lineParser.setToEnd();\n            break;\n\n          default:\n            throw new Error('LDrawLoader: Unknown token \"' + token + '\" while parsing material' + lineParser.getLineNumberString() + \".\");\n        }\n      }\n\n      var material = null;\n\n      switch (finishType) {\n        case FINISH_TYPE_DEFAULT:\n          material = new MeshStandardMaterial({\n            color: color,\n            roughness: 0.3,\n            metalness: 0\n          });\n          break;\n\n        case FINISH_TYPE_PEARLESCENT:\n          material = new MeshStandardMaterial({\n            color: color,\n            roughness: 0.3,\n            metalness: 0.25\n          });\n          break;\n\n        case FINISH_TYPE_CHROME:\n          material = new MeshStandardMaterial({\n            color: color,\n            roughness: 0,\n            metalness: 1\n          });\n          break;\n\n        case FINISH_TYPE_RUBBER:\n          material = new MeshStandardMaterial({\n            color: color,\n            roughness: 0.9,\n            metalness: 0\n          });\n          break;\n\n        case FINISH_TYPE_MATTE_METALLIC:\n          material = new MeshStandardMaterial({\n            color: color,\n            roughness: 0.8,\n            metalness: 0.4\n          });\n          break;\n\n        case FINISH_TYPE_METAL:\n          material = new MeshStandardMaterial({\n            color: color,\n            roughness: 0.2,\n            metalness: 0.85\n          });\n          break;\n\n        default:\n          break;\n      }\n\n      material.transparent = isTransparent;\n      material.premultipliedAlpha = true;\n      material.opacity = alpha;\n      material.depthWrite = !isTransparent;\n      material.polygonOffset = true;\n      material.polygonOffsetFactor = 1;\n\n      if (luminance !== 0) {\n        material.emissive.set(material.color).multiplyScalar(luminance);\n      }\n\n      if (!edgeMaterial) {\n        edgeMaterial = new LineBasicMaterial({\n          color: edgeColor,\n          transparent: isTransparent,\n          opacity: alpha,\n          depthWrite: !isTransparent\n        });\n        edgeMaterial.userData.code = code;\n        edgeMaterial.name = name + \" - Edge\";\n        edgeMaterial.userData.conditionalEdgeMaterial = new LDrawConditionalLineMaterial({\n          fog: true,\n          transparent: isTransparent,\n          depthWrite: !isTransparent,\n          color: edgeColor,\n          opacity: alpha\n        });\n      }\n\n      material.userData.code = code;\n      material.name = name;\n      material.userData.edgeMaterial = edgeMaterial;\n      this.addMaterial(material);\n      return material;\n    }\n  }, {\n    key: \"computeConstructionSteps\",\n    value: function computeConstructionSteps(model) {\n      var stepNumber = 0;\n      model.traverse(function (c) {\n        if (c.isGroup) {\n          if (c.userData.startingConstructionStep) {\n            stepNumber++;\n          }\n\n          c.userData.constructionStep = stepNumber;\n        }\n      });\n      model.userData.numConstructionSteps = stepNumber + 1;\n    }\n  }]);\n\n  return LDrawLoader;\n}(Loader);\n\nexport { LDrawLoader };","map":{"version":3,"sources":["/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/three-stdlib/loaders/LDrawLoader.js"],"names":["Vector3","ShaderMaterial","UniformsUtils","UniformsLib","Color","LineSegments","Ray","FileLoader","Matrix4","Group","BufferGeometry","BufferAttribute","Mesh","Loader","MeshStandardMaterial","LineBasicMaterial","FINISH_TYPE_DEFAULT","FINISH_TYPE_CHROME","FINISH_TYPE_PEARLESCENT","FINISH_TYPE_RUBBER","FINISH_TYPE_MATTE_METALLIC","FINISH_TYPE_METAL","FILE_LOCATION_AS_IS","FILE_LOCATION_TRY_PARTS","FILE_LOCATION_TRY_P","FILE_LOCATION_TRY_MODELS","FILE_LOCATION_TRY_RELATIVE","FILE_LOCATION_TRY_ABSOLUTE","FILE_LOCATION_NOT_FOUND","MAIN_COLOUR_CODE","MAIN_EDGE_COLOUR_CODE","_tempVec0","_tempVec1","LDrawConditionalLineMaterial","parameters","uniforms","merge","fog","diffuse","value","opacity","vertexShader","fragmentShader","Object","defineProperties","get","set","color","setValues","isLDrawConditionalLineMaterial","ConditionalLineSegments","geometry","material","isConditionalLine","generateFaceNormals","faces","i","l","length","face","vertices","v0","v1","v2","subVectors","faceNormal","crossVectors","normalize","_ray","smoothNormals","lineSegments","checkSubSegments","hashMultiplier","hashVertex","v","x","y","z","hashEdge","toNormalizedRay","targetRay","direction","scalar","dot","origin","copy","addScaledVector","hashRay","ray","hardEdges","Set","hardEdgeRays","Map","halfEdgeList","normals","ls","add","rh1","has","rh2","info2","distances","info","d0","d1","push","tri","vertCount","i2","index","next","hash","rayHash","found","i3","l2","halfEdge","key","queue","pop","vertNormals","reverseHash","otherInfo","otherTri","otherIndex","otherNormals","otherVertCount","otherFaceNormal","Math","abs","otherNext","norm","sharedNormal1","sharedNormal2","isPartType","type","isPrimitiveType","test","LineParser","line","lineNumber","lineLength","currentCharIndex","currentChar","charAt","pos0","pos1","seekNonSpace","substring","parseFloat","getToken","LDrawParsedCache","loader","_cache","original","result","map","colorCode","clone","conditionalSegments","controlPoints","category","keywords","subobjects","totalFaces","startingConstructionStep","materials","group","fileName","triedLowerCase","locationState","subobjectURL","lastIndexOf","toLowerCase","fileLoader","manager","setPath","partsLibraryPath","setRequestHeader","requestHeader","setWithCredentials","withCredentials","loadAsync","text","Error","getLocalMaterial","indexOf","replace","lines","split","numLines","parsingEmbeddedFiles","currentEmbeddedFileName","currentEmbeddedText","bfcCertified","bfcCCW","bfcInverted","bfcCull","lineIndex","startsWith","setData","lp","isAtTheEnd","lineType","segment","ccw","doubleSided","v3","c0","c1","meta","parseColorMetaDirective","userData","code","console","warn","getLineNumberString","newKeywords","getRemainingString","forEach","keyword","trim","token","posX","posY","posZ","m0","m1","m2","m3","m4","m5","m6","m7","m8","matrix","fileName2","fileMap","inverted","getVector","Promise","cloneResult","fetchData","then","parse","getMaterialFromCode","parentColorCode","materialHierarchy","forEdge","isPassthrough","LDrawPartsGeometryCache","parseCache","faceMaterials","processInfoSubobjects","subobject","promises","subobject2","promise","ensureDataLoaded","subobjectInfo","getData","loadModel","catch","error","group2","all","subobjectInfos","isGroup","subobjectGroup","decompose","position","quaternion","scale","name","applyMaterialsToMesh","children","parentLineSegments","parentConditionalSegments","parentFaces","matrixScaleInverted","determinant","lineColorCode","applyMatrix4","os","l3","reverse","size","createObject","hasCachedModel","getCachedModel","processIntoMesh","sortByMaterial","a","b","elements","elementSize","isConditionalSegments","totalElements","sort","positions","Float32Array","quadArray","Array","bufferGeometry","prevMaterial","index0","numGroupVerts","offset","iElem","nElem","elem","j","elemNormals","n","addGroup","edgeMaterial","conditionalEdgeMaterial","Infinity","setAttribute","object3d","controlArray0","controlArray1","directionArray","LDrawLoader","materialLibrary","partsCache","setMaterials","path","url","colorLineRegex","directive","onLoad","onProgress","onError","load","parseModel","computeConstructionSteps","addMaterial","matLib","finalMaterialPass","parentIsPassthrough","traverse","c","isMesh","isLineSegments","isArray","isMaterial","getMaterial","lineParser","edgeColor","alpha","isTransparent","luminance","finishType","toUpperCase","parseInt","isNaN","max","min","setToEnd","roughness","metalness","transparent","premultipliedAlpha","depthWrite","polygonOffset","polygonOffsetFactor","emissive","multiplyScalar","model","stepNumber","constructionStep","numConstructionSteps"],"mappings":"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","sourcesContent":["import { Vector3, ShaderMaterial, UniformsUtils, UniformsLib, Color, LineSegments, Ray, FileLoader, Matrix4, Group, BufferGeometry, BufferAttribute, Mesh, Loader, MeshStandardMaterial, LineBasicMaterial } from \"three\";\nconst FINISH_TYPE_DEFAULT = 0;\nconst FINISH_TYPE_CHROME = 1;\nconst FINISH_TYPE_PEARLESCENT = 2;\nconst FINISH_TYPE_RUBBER = 3;\nconst FINISH_TYPE_MATTE_METALLIC = 4;\nconst FINISH_TYPE_METAL = 5;\nconst FILE_LOCATION_AS_IS = 0;\nconst FILE_LOCATION_TRY_PARTS = 1;\nconst FILE_LOCATION_TRY_P = 2;\nconst FILE_LOCATION_TRY_MODELS = 3;\nconst FILE_LOCATION_TRY_RELATIVE = 4;\nconst FILE_LOCATION_TRY_ABSOLUTE = 5;\nconst FILE_LOCATION_NOT_FOUND = 6;\nconst MAIN_COLOUR_CODE = \"16\";\nconst MAIN_EDGE_COLOUR_CODE = \"24\";\nconst _tempVec0 = /* @__PURE__ */ new Vector3();\nconst _tempVec1 = /* @__PURE__ */ new Vector3();\nclass LDrawConditionalLineMaterial extends ShaderMaterial {\n  constructor(parameters) {\n    super({\n      uniforms: UniformsUtils.merge([\n        UniformsLib.fog,\n        {\n          diffuse: {\n            value: new Color()\n          },\n          opacity: {\n            value: 1\n          }\n        }\n      ]),\n      vertexShader: (\n        /* glsl */\n        `\n        attribute vec3 control0;\n        attribute vec3 control1;\n        attribute vec3 direction;\n        varying float discardFlag;\n\n        #include <common>\n        #include <color_pars_vertex>\n        #include <fog_pars_vertex>\n        #include <logdepthbuf_pars_vertex>\n        #include <clipping_planes_pars_vertex>\n\n        void main() {\n          #include <color_vertex>\n\n          vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n          gl_Position = projectionMatrix * mvPosition;\n\n          // Transform the line segment ends and control points into camera clip space\n          vec4 c0 = projectionMatrix * modelViewMatrix * vec4(control0, 1.0);\n          vec4 c1 = projectionMatrix * modelViewMatrix * vec4(control1, 1.0);\n          vec4 p0 = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n          vec4 p1 = projectionMatrix * modelViewMatrix * vec4(position + direction, 1.0);\n\n          c0.xy /= c0.w;\n          c1.xy /= c1.w;\n          p0.xy /= p0.w;\n          p1.xy /= p1.w;\n\n          // Get the direction of the segment and an orthogonal vector\n          vec2 dir = p1.xy - p0.xy;\n          vec2 norm = vec2(-dir.y, dir.x);\n\n          // Get control point directions from the line\n          vec2 c0dir = c0.xy - p1.xy;\n          vec2 c1dir = c1.xy - p1.xy;\n\n          // If the vectors to the controls points are pointed in different directions away\n          // from the line segment then the line should not be drawn.\n          float d0 = dot(normalize(norm), normalize(c0dir));\n          float d1 = dot(normalize(norm), normalize(c1dir));\n          discardFlag = float(sign(d0) != sign(d1));\n\n          #include <logdepthbuf_vertex>\n          #include <clipping_planes_vertex>\n          #include <fog_vertex>\n        }\n      `\n      ),\n      fragmentShader: (\n        /* glsl */\n        `\n        uniform vec3 diffuse;\n        uniform float opacity;\n        varying float discardFlag;\n\n        #include <common>\n        #include <color_pars_fragment>\n        #include <fog_pars_fragment>\n        #include <logdepthbuf_pars_fragment>\n        #include <clipping_planes_pars_fragment>\n\n        void main() {\n          if (discardFlag > 0.5) discard;\n\n          #include <clipping_planes_fragment>\n          vec3 outgoingLight = vec3(0.0);\n          vec4 diffuseColor = vec4(diffuse, opacity);\n          #include <logdepthbuf_fragment>\n          #include <color_fragment>\n          outgoingLight = diffuseColor.rgb; // simple shader\n          gl_FragColor = vec4(outgoingLight, diffuseColor.a);\n          #include <tonemapping_fragment>\n          #include <encodings_fragment>\n          #include <fog_fragment>\n          #include <premultiplied_alpha_fragment>\n        }\n      `\n      )\n    });\n    Object.defineProperties(this, {\n      opacity: {\n        get: function() {\n          return this.uniforms.opacity.value;\n        },\n        set: function(value) {\n          this.uniforms.opacity.value = value;\n        }\n      },\n      color: {\n        get: function() {\n          return this.uniforms.diffuse.value;\n        }\n      }\n    });\n    this.setValues(parameters);\n    this.isLDrawConditionalLineMaterial = true;\n  }\n}\nclass ConditionalLineSegments extends LineSegments {\n  constructor(geometry, material) {\n    super(geometry, material);\n    this.isConditionalLine = true;\n  }\n}\nfunction generateFaceNormals(faces) {\n  for (let i = 0, l = faces.length; i < l; i++) {\n    const face = faces[i];\n    const vertices = face.vertices;\n    const v0 = vertices[0];\n    const v1 = vertices[1];\n    const v2 = vertices[2];\n    _tempVec0.subVectors(v1, v0);\n    _tempVec1.subVectors(v2, v1);\n    face.faceNormal = new Vector3().crossVectors(_tempVec0, _tempVec1).normalize();\n  }\n}\nconst _ray = /* @__PURE__ */ new Ray();\nfunction smoothNormals(faces, lineSegments, checkSubSegments = false) {\n  const hashMultiplier = (1 + 1e-10) * 100;\n  function hashVertex(v) {\n    const x = ~~(v.x * hashMultiplier);\n    const y = ~~(v.y * hashMultiplier);\n    const z = ~~(v.z * hashMultiplier);\n    return `${x},${y},${z}`;\n  }\n  function hashEdge(v0, v1) {\n    return `${hashVertex(v0)}_${hashVertex(v1)}`;\n  }\n  function toNormalizedRay(v0, v1, targetRay) {\n    targetRay.direction.subVectors(v1, v0).normalize();\n    const scalar = v0.dot(targetRay.direction);\n    targetRay.origin.copy(v0).addScaledVector(targetRay.direction, -scalar);\n    return targetRay;\n  }\n  function hashRay(ray) {\n    return hashEdge(ray.origin, ray.direction);\n  }\n  const hardEdges = /* @__PURE__ */ new Set();\n  const hardEdgeRays = /* @__PURE__ */ new Map();\n  const halfEdgeList = {};\n  const normals = [];\n  for (let i = 0, l = lineSegments.length; i < l; i++) {\n    const ls = lineSegments[i];\n    const vertices = ls.vertices;\n    const v0 = vertices[0];\n    const v1 = vertices[1];\n    hardEdges.add(hashEdge(v0, v1));\n    hardEdges.add(hashEdge(v1, v0));\n    if (checkSubSegments) {\n      const ray = toNormalizedRay(v0, v1, new Ray());\n      const rh1 = hashRay(ray);\n      if (!hardEdgeRays.has(rh1)) {\n        toNormalizedRay(v1, v0, ray);\n        const rh2 = hashRay(ray);\n        const info2 = {\n          ray,\n          distances: []\n        };\n        hardEdgeRays.set(rh1, info2);\n        hardEdgeRays.set(rh2, info2);\n      }\n      const info = hardEdgeRays.get(rh1);\n      let d0 = info.ray.direction.dot(v0);\n      let d1 = info.ray.direction.dot(v1);\n      if (d0 > d1) {\n        ;\n        [d0, d1] = [d1, d0];\n      }\n      info.distances.push(d0, d1);\n    }\n  }\n  for (let i = 0, l = faces.length; i < l; i++) {\n    const tri = faces[i];\n    const vertices = tri.vertices;\n    const vertCount = vertices.length;\n    for (let i2 = 0; i2 < vertCount; i2++) {\n      const index = i2;\n      const next = (i2 + 1) % vertCount;\n      const v0 = vertices[index];\n      const v1 = vertices[next];\n      const hash = hashEdge(v0, v1);\n      if (hardEdges.has(hash)) {\n        continue;\n      }\n      if (checkSubSegments) {\n        toNormalizedRay(v0, v1, _ray);\n        const rayHash = hashRay(_ray);\n        if (hardEdgeRays.has(rayHash)) {\n          const info2 = hardEdgeRays.get(rayHash);\n          const { ray, distances } = info2;\n          let d0 = ray.direction.dot(v0);\n          let d1 = ray.direction.dot(v1);\n          if (d0 > d1) {\n            ;\n            [d0, d1] = [d1, d0];\n          }\n          let found = false;\n          for (let i3 = 0, l2 = distances.length; i3 < l2; i3 += 2) {\n            if (d0 >= distances[i3] && d1 <= distances[i3 + 1]) {\n              found = true;\n              break;\n            }\n          }\n          if (found) {\n            continue;\n          }\n        }\n      }\n      const info = {\n        index,\n        tri\n      };\n      halfEdgeList[hash] = info;\n    }\n  }\n  while (true) {\n    let halfEdge = null;\n    for (const key in halfEdgeList) {\n      halfEdge = halfEdgeList[key];\n      break;\n    }\n    if (halfEdge === null) {\n      break;\n    }\n    const queue = [halfEdge];\n    while (queue.length > 0) {\n      const tri = queue.pop().tri;\n      const vertices = tri.vertices;\n      const vertNormals = tri.normals;\n      const faceNormal = tri.faceNormal;\n      const vertCount = vertices.length;\n      for (let i2 = 0; i2 < vertCount; i2++) {\n        const index = i2;\n        const next = (i2 + 1) % vertCount;\n        const v0 = vertices[index];\n        const v1 = vertices[next];\n        const hash = hashEdge(v0, v1);\n        delete halfEdgeList[hash];\n        const reverseHash = hashEdge(v1, v0);\n        const otherInfo = halfEdgeList[reverseHash];\n        if (otherInfo) {\n          const otherTri = otherInfo.tri;\n          const otherIndex = otherInfo.index;\n          const otherNormals = otherTri.normals;\n          const otherVertCount = otherNormals.length;\n          const otherFaceNormal = otherTri.faceNormal;\n          if (Math.abs(otherTri.faceNormal.dot(tri.faceNormal)) < 0.25) {\n            continue;\n          }\n          if (reverseHash in halfEdgeList) {\n            queue.push(otherInfo);\n            delete halfEdgeList[reverseHash];\n          }\n          const otherNext = (otherIndex + 1) % otherVertCount;\n          if (vertNormals[index] && otherNormals[otherNext] && vertNormals[index] !== otherNormals[otherNext]) {\n            otherNormals[otherNext].norm.add(vertNormals[index].norm);\n            vertNormals[index].norm = otherNormals[otherNext].norm;\n          }\n          let sharedNormal1 = vertNormals[index] || otherNormals[otherNext];\n          if (sharedNormal1 === null) {\n            sharedNormal1 = { norm: new Vector3() };\n            normals.push(sharedNormal1.norm);\n          }\n          if (vertNormals[index] === null) {\n            vertNormals[index] = sharedNormal1;\n            sharedNormal1.norm.add(faceNormal);\n          }\n          if (otherNormals[otherNext] === null) {\n            otherNormals[otherNext] = sharedNormal1;\n            sharedNormal1.norm.add(otherFaceNormal);\n          }\n          if (vertNormals[next] && otherNormals[otherIndex] && vertNormals[next] !== otherNormals[otherIndex]) {\n            otherNormals[otherIndex].norm.add(vertNormals[next].norm);\n            vertNormals[next].norm = otherNormals[otherIndex].norm;\n          }\n          let sharedNormal2 = vertNormals[next] || otherNormals[otherIndex];\n          if (sharedNormal2 === null) {\n            sharedNormal2 = { norm: new Vector3() };\n            normals.push(sharedNormal2.norm);\n          }\n          if (vertNormals[next] === null) {\n            vertNormals[next] = sharedNormal2;\n            sharedNormal2.norm.add(faceNormal);\n          }\n          if (otherNormals[otherIndex] === null) {\n            otherNormals[otherIndex] = sharedNormal2;\n            sharedNormal2.norm.add(otherFaceNormal);\n          }\n        }\n      }\n    }\n  }\n  for (let i = 0, l = normals.length; i < l; i++) {\n    normals[i].normalize();\n  }\n}\nfunction isPartType(type) {\n  return type === \"Part\" || type === \"Unofficial_Part\";\n}\nfunction isPrimitiveType(type) {\n  return /primitive/i.test(type) || type === \"Subpart\";\n}\nclass LineParser {\n  constructor(line, lineNumber) {\n    this.line = line;\n    this.lineLength = line.length;\n    this.currentCharIndex = 0;\n    this.currentChar = \" \";\n    this.lineNumber = lineNumber;\n  }\n  seekNonSpace() {\n    while (this.currentCharIndex < this.lineLength) {\n      this.currentChar = this.line.charAt(this.currentCharIndex);\n      if (this.currentChar !== \" \" && this.currentChar !== \"\t\") {\n        return;\n      }\n      this.currentCharIndex++;\n    }\n  }\n  getToken() {\n    const pos0 = this.currentCharIndex++;\n    while (this.currentCharIndex < this.lineLength) {\n      this.currentChar = this.line.charAt(this.currentCharIndex);\n      if (this.currentChar === \" \" || this.currentChar === \"\t\") {\n        break;\n      }\n      this.currentCharIndex++;\n    }\n    const pos1 = this.currentCharIndex;\n    this.seekNonSpace();\n    return this.line.substring(pos0, pos1);\n  }\n  getVector() {\n    return new Vector3(parseFloat(this.getToken()), parseFloat(this.getToken()), parseFloat(this.getToken()));\n  }\n  getRemainingString() {\n    return this.line.substring(this.currentCharIndex, this.lineLength);\n  }\n  isAtTheEnd() {\n    return this.currentCharIndex >= this.lineLength;\n  }\n  setToEnd() {\n    this.currentCharIndex = this.lineLength;\n  }\n  getLineNumberString() {\n    return this.lineNumber >= 0 ? \" at line \" + this.lineNumber : \"\";\n  }\n}\nclass LDrawParsedCache {\n  constructor(loader) {\n    this.loader = loader;\n    this._cache = {};\n  }\n  cloneResult(original) {\n    const result = {};\n    result.faces = original.faces.map((face) => {\n      return {\n        colorCode: face.colorCode,\n        material: face.material,\n        vertices: face.vertices.map((v) => v.clone()),\n        normals: face.normals.map(() => null),\n        faceNormal: null\n      };\n    });\n    result.conditionalSegments = original.conditionalSegments.map((face) => {\n      return {\n        colorCode: face.colorCode,\n        material: face.material,\n        vertices: face.vertices.map((v) => v.clone()),\n        controlPoints: face.controlPoints.map((v) => v.clone())\n      };\n    });\n    result.lineSegments = original.lineSegments.map((face) => {\n      return {\n        colorCode: face.colorCode,\n        material: face.material,\n        vertices: face.vertices.map((v) => v.clone())\n      };\n    });\n    result.type = original.type;\n    result.category = original.category;\n    result.keywords = original.keywords;\n    result.subobjects = original.subobjects;\n    result.totalFaces = original.totalFaces;\n    result.startingConstructionStep = original.startingConstructionStep;\n    result.materials = original.materials;\n    result.group = null;\n    return result;\n  }\n  async fetchData(fileName) {\n    let triedLowerCase = false;\n    let locationState = FILE_LOCATION_AS_IS;\n    while (locationState !== FILE_LOCATION_NOT_FOUND) {\n      let subobjectURL = fileName;\n      switch (locationState) {\n        case FILE_LOCATION_AS_IS:\n          locationState = locationState + 1;\n          break;\n        case FILE_LOCATION_TRY_PARTS:\n          subobjectURL = \"parts/\" + subobjectURL;\n          locationState = locationState + 1;\n          break;\n        case FILE_LOCATION_TRY_P:\n          subobjectURL = \"p/\" + subobjectURL;\n          locationState = locationState + 1;\n          break;\n        case FILE_LOCATION_TRY_MODELS:\n          subobjectURL = \"models/\" + subobjectURL;\n          locationState = locationState + 1;\n          break;\n        case FILE_LOCATION_TRY_RELATIVE:\n          subobjectURL = fileName.substring(0, fileName.lastIndexOf(\"/\") + 1) + subobjectURL;\n          locationState = locationState + 1;\n          break;\n        case FILE_LOCATION_TRY_ABSOLUTE:\n          if (triedLowerCase) {\n            locationState = FILE_LOCATION_NOT_FOUND;\n          } else {\n            fileName = fileName.toLowerCase();\n            subobjectURL = fileName;\n            triedLowerCase = true;\n            locationState = FILE_LOCATION_AS_IS;\n          }\n          break;\n      }\n      const loader = this.loader;\n      const fileLoader = new FileLoader(loader.manager);\n      fileLoader.setPath(loader.partsLibraryPath);\n      fileLoader.setRequestHeader(loader.requestHeader);\n      fileLoader.setWithCredentials(loader.withCredentials);\n      try {\n        const text = await fileLoader.loadAsync(subobjectURL);\n        return text;\n      } catch (e) {\n        continue;\n      }\n    }\n    throw new Error('LDrawLoader: Subobject \"' + fileName + '\" could not be loaded.');\n  }\n  parse(text, fileName = null) {\n    const loader = this.loader;\n    const faces = [];\n    const lineSegments = [];\n    const conditionalSegments = [];\n    const subobjects = [];\n    const materials = {};\n    const getLocalMaterial = (colorCode) => {\n      return materials[colorCode] || null;\n    };\n    let type = \"Model\";\n    let category = null;\n    let keywords = null;\n    let totalFaces = 0;\n    if (text.indexOf(\"\\r\\n\") !== -1) {\n      text = text.replace(/\\r\\n/g, \"\\n\");\n    }\n    const lines = text.split(\"\\n\");\n    const numLines = lines.length;\n    let parsingEmbeddedFiles = false;\n    let currentEmbeddedFileName = null;\n    let currentEmbeddedText = null;\n    let bfcCertified = false;\n    let bfcCCW = true;\n    let bfcInverted = false;\n    let bfcCull = true;\n    let startingConstructionStep = false;\n    for (let lineIndex = 0; lineIndex < numLines; lineIndex++) {\n      const line = lines[lineIndex];\n      if (line.length === 0)\n        continue;\n      if (parsingEmbeddedFiles) {\n        if (line.startsWith(\"0 FILE \")) {\n          this.setData(currentEmbeddedFileName, currentEmbeddedText);\n          currentEmbeddedFileName = line.substring(7);\n          currentEmbeddedText = \"\";\n        } else {\n          currentEmbeddedText += line + \"\\n\";\n        }\n        continue;\n      }\n      const lp = new LineParser(line, lineIndex + 1);\n      lp.seekNonSpace();\n      if (lp.isAtTheEnd()) {\n        continue;\n      }\n      const lineType = lp.getToken();\n      let material;\n      let colorCode;\n      let segment;\n      let ccw;\n      let doubleSided;\n      let v0, v1, v2, v3, c0, c1;\n      switch (lineType) {\n        case \"0\":\n          const meta = lp.getToken();\n          if (meta) {\n            switch (meta) {\n              case \"!LDRAW_ORG\":\n                type = lp.getToken();\n                break;\n              case \"!COLOUR\":\n                material = loader.parseColorMetaDirective(lp);\n                if (material) {\n                  materials[material.userData.code] = material;\n                } else {\n                  console.warn(\"LDrawLoader: Error parsing material\" + lp.getLineNumberString());\n                }\n                break;\n              case \"!CATEGORY\":\n                category = lp.getToken();\n                break;\n              case \"!KEYWORDS\":\n                const newKeywords = lp.getRemainingString().split(\",\");\n                if (newKeywords.length > 0) {\n                  if (!keywords) {\n                    keywords = [];\n                  }\n                  newKeywords.forEach(function(keyword) {\n                    keywords.push(keyword.trim());\n                  });\n                }\n                break;\n              case \"FILE\":\n                if (lineIndex > 0) {\n                  parsingEmbeddedFiles = true;\n                  currentEmbeddedFileName = lp.getRemainingString();\n                  currentEmbeddedText = \"\";\n                  bfcCertified = false;\n                  bfcCCW = true;\n                }\n                break;\n              case \"BFC\":\n                while (!lp.isAtTheEnd()) {\n                  const token = lp.getToken();\n                  switch (token) {\n                    case \"CERTIFY\":\n                    case \"NOCERTIFY\":\n                      bfcCertified = token === \"CERTIFY\";\n                      bfcCCW = true;\n                      break;\n                    case \"CW\":\n                    case \"CCW\":\n                      bfcCCW = token === \"CCW\";\n                      break;\n                    case \"INVERTNEXT\":\n                      bfcInverted = true;\n                      break;\n                    case \"CLIP\":\n                    case \"NOCLIP\":\n                      bfcCull = token === \"CLIP\";\n                      break;\n                    default:\n                      console.warn('THREE.LDrawLoader: BFC directive \"' + token + '\" is unknown.');\n                      break;\n                  }\n                }\n                break;\n              case \"STEP\":\n                startingConstructionStep = true;\n                break;\n              default:\n                break;\n            }\n          }\n          break;\n        case \"1\":\n          colorCode = lp.getToken();\n          material = getLocalMaterial(colorCode);\n          const posX = parseFloat(lp.getToken());\n          const posY = parseFloat(lp.getToken());\n          const posZ = parseFloat(lp.getToken());\n          const m0 = parseFloat(lp.getToken());\n          const m1 = parseFloat(lp.getToken());\n          const m2 = parseFloat(lp.getToken());\n          const m3 = parseFloat(lp.getToken());\n          const m4 = parseFloat(lp.getToken());\n          const m5 = parseFloat(lp.getToken());\n          const m6 = parseFloat(lp.getToken());\n          const m7 = parseFloat(lp.getToken());\n          const m8 = parseFloat(lp.getToken());\n          const matrix = new Matrix4().set(m0, m1, m2, posX, m3, m4, m5, posY, m6, m7, m8, posZ, 0, 0, 0, 1);\n          let fileName2 = lp.getRemainingString().trim().replace(/\\\\/g, \"/\");\n          if (loader.fileMap[fileName2]) {\n            fileName2 = loader.fileMap[fileName2];\n          } else {\n            if (fileName2.startsWith(\"s/\")) {\n              fileName2 = \"parts/\" + fileName2;\n            } else if (fileName2.startsWith(\"48/\")) {\n              fileName2 = \"p/\" + fileName2;\n            }\n          }\n          subobjects.push({\n            material,\n            colorCode,\n            matrix,\n            fileName: fileName2,\n            inverted: bfcInverted,\n            startingConstructionStep\n          });\n          bfcInverted = false;\n          break;\n        case \"2\":\n          colorCode = lp.getToken();\n          material = getLocalMaterial(colorCode);\n          v0 = lp.getVector();\n          v1 = lp.getVector();\n          segment = {\n            material,\n            colorCode,\n            vertices: [v0, v1]\n          };\n          lineSegments.push(segment);\n          break;\n        case \"5\":\n          colorCode = lp.getToken();\n          material = getLocalMaterial(colorCode);\n          v0 = lp.getVector();\n          v1 = lp.getVector();\n          c0 = lp.getVector();\n          c1 = lp.getVector();\n          segment = {\n            material,\n            colorCode,\n            vertices: [v0, v1],\n            controlPoints: [c0, c1]\n          };\n          conditionalSegments.push(segment);\n          break;\n        case \"3\":\n          colorCode = lp.getToken();\n          material = getLocalMaterial(colorCode);\n          ccw = bfcCCW;\n          doubleSided = !bfcCertified || !bfcCull;\n          if (ccw === true) {\n            v0 = lp.getVector();\n            v1 = lp.getVector();\n            v2 = lp.getVector();\n          } else {\n            v2 = lp.getVector();\n            v1 = lp.getVector();\n            v0 = lp.getVector();\n          }\n          faces.push({\n            material,\n            colorCode,\n            faceNormal: null,\n            vertices: [v0, v1, v2],\n            normals: [null, null, null]\n          });\n          totalFaces++;\n          if (doubleSided === true) {\n            faces.push({\n              material,\n              colorCode,\n              faceNormal: null,\n              vertices: [v2, v1, v0],\n              normals: [null, null, null]\n            });\n            totalFaces++;\n          }\n          break;\n        case \"4\":\n          colorCode = lp.getToken();\n          material = getLocalMaterial(colorCode);\n          ccw = bfcCCW;\n          doubleSided = !bfcCertified || !bfcCull;\n          if (ccw === true) {\n            v0 = lp.getVector();\n            v1 = lp.getVector();\n            v2 = lp.getVector();\n            v3 = lp.getVector();\n          } else {\n            v3 = lp.getVector();\n            v2 = lp.getVector();\n            v1 = lp.getVector();\n            v0 = lp.getVector();\n          }\n          faces.push({\n            material,\n            colorCode,\n            faceNormal: null,\n            vertices: [v0, v1, v2, v3],\n            normals: [null, null, null, null]\n          });\n          totalFaces += 2;\n          if (doubleSided === true) {\n            faces.push({\n              material,\n              colorCode,\n              faceNormal: null,\n              vertices: [v3, v2, v1, v0],\n              normals: [null, null, null, null]\n            });\n            totalFaces += 2;\n          }\n          break;\n        default:\n          throw new Error('LDrawLoader: Unknown line type \"' + lineType + '\"' + lp.getLineNumberString() + \".\");\n      }\n    }\n    if (parsingEmbeddedFiles) {\n      this.setData(currentEmbeddedFileName, currentEmbeddedText);\n    }\n    return {\n      faces,\n      conditionalSegments,\n      lineSegments,\n      type,\n      category,\n      keywords,\n      subobjects,\n      totalFaces,\n      startingConstructionStep,\n      materials,\n      fileName,\n      group: null\n    };\n  }\n  // returns an (optionally cloned) instance of the data\n  getData(fileName, clone = true) {\n    const key = fileName.toLowerCase();\n    const result = this._cache[key];\n    if (result === null || result instanceof Promise) {\n      return null;\n    }\n    if (clone) {\n      return this.cloneResult(result);\n    } else {\n      return result;\n    }\n  }\n  // kicks off a fetch and parse of the requested data if it hasn't already been loaded. Returns when\n  // the data is ready to use and can be retrieved synchronously with \"getData\".\n  async ensureDataLoaded(fileName) {\n    const key = fileName.toLowerCase();\n    if (!(key in this._cache)) {\n      this._cache[key] = this.fetchData(fileName).then((text) => {\n        const info = this.parse(text, fileName);\n        this._cache[key] = info;\n        return info;\n      });\n    }\n    await this._cache[key];\n  }\n  // sets the data in the cache from parsed data\n  setData(fileName, text) {\n    const key = fileName.toLowerCase();\n    this._cache[key] = this.parse(text, fileName);\n  }\n}\nfunction getMaterialFromCode(colorCode, parentColorCode, materialHierarchy, forEdge) {\n  const isPassthrough = !forEdge && colorCode === MAIN_COLOUR_CODE || forEdge && colorCode === MAIN_EDGE_COLOUR_CODE;\n  if (isPassthrough) {\n    colorCode = parentColorCode;\n  }\n  return materialHierarchy[colorCode] || null;\n}\nclass LDrawPartsGeometryCache {\n  constructor(loader) {\n    this.loader = loader;\n    this.parseCache = new LDrawParsedCache(loader);\n    this._cache = {};\n  }\n  // Convert the given file information into a mesh by processing subobjects.\n  async processIntoMesh(info) {\n    const loader = this.loader;\n    const parseCache = this.parseCache;\n    const faceMaterials = /* @__PURE__ */ new Set();\n    const processInfoSubobjects = async (info2, subobject = null) => {\n      const subobjects = info2.subobjects;\n      const promises = [];\n      for (let i = 0, l = subobjects.length; i < l; i++) {\n        const subobject2 = subobjects[i];\n        const promise = parseCache.ensureDataLoaded(subobject2.fileName).then(() => {\n          const subobjectInfo = parseCache.getData(subobject2.fileName, false);\n          if (!isPrimitiveType(subobjectInfo.type)) {\n            return this.loadModel(subobject2.fileName).catch((error) => {\n              console.warn(error);\n              return null;\n            });\n          }\n          return processInfoSubobjects(parseCache.getData(subobject2.fileName), subobject2);\n        });\n        promises.push(promise);\n      }\n      const group2 = new Group();\n      group2.userData.category = info2.category;\n      group2.userData.keywords = info2.keywords;\n      info2.group = group2;\n      const subobjectInfos = await Promise.all(promises);\n      for (let i = 0, l = subobjectInfos.length; i < l; i++) {\n        const subobject2 = info2.subobjects[i];\n        const subobjectInfo = subobjectInfos[i];\n        if (subobjectInfo === null) {\n          continue;\n        }\n        if (subobjectInfo.isGroup) {\n          const subobjectGroup = subobjectInfo;\n          subobject2.matrix.decompose(subobjectGroup.position, subobjectGroup.quaternion, subobjectGroup.scale);\n          subobjectGroup.userData.startingConstructionStep = subobject2.startingConstructionStep;\n          subobjectGroup.name = subobject2.fileName;\n          loader.applyMaterialsToMesh(subobjectGroup, subobject2.colorCode, info2.materials);\n          group2.add(subobjectGroup);\n          continue;\n        }\n        if (subobjectInfo.group.children.length) {\n          group2.add(subobjectInfo.group);\n        }\n        const parentLineSegments = info2.lineSegments;\n        const parentConditionalSegments = info2.conditionalSegments;\n        const parentFaces = info2.faces;\n        const lineSegments = subobjectInfo.lineSegments;\n        const conditionalSegments = subobjectInfo.conditionalSegments;\n        const faces = subobjectInfo.faces;\n        const matrix = subobject2.matrix;\n        const inverted = subobject2.inverted;\n        const matrixScaleInverted = matrix.determinant() < 0;\n        const colorCode = subobject2.colorCode;\n        const lineColorCode = colorCode === MAIN_COLOUR_CODE ? MAIN_EDGE_COLOUR_CODE : colorCode;\n        for (let i2 = 0, l2 = lineSegments.length; i2 < l2; i2++) {\n          const ls = lineSegments[i2];\n          const vertices = ls.vertices;\n          vertices[0].applyMatrix4(matrix);\n          vertices[1].applyMatrix4(matrix);\n          ls.colorCode = ls.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : ls.colorCode;\n          ls.material = ls.material || getMaterialFromCode(ls.colorCode, ls.colorCode, info2.materials, true);\n          parentLineSegments.push(ls);\n        }\n        for (let i2 = 0, l2 = conditionalSegments.length; i2 < l2; i2++) {\n          const os = conditionalSegments[i2];\n          const vertices = os.vertices;\n          const controlPoints = os.controlPoints;\n          vertices[0].applyMatrix4(matrix);\n          vertices[1].applyMatrix4(matrix);\n          controlPoints[0].applyMatrix4(matrix);\n          controlPoints[1].applyMatrix4(matrix);\n          os.colorCode = os.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : os.colorCode;\n          os.material = os.material || getMaterialFromCode(os.colorCode, os.colorCode, info2.materials, true);\n          parentConditionalSegments.push(os);\n        }\n        for (let i2 = 0, l2 = faces.length; i2 < l2; i2++) {\n          const tri = faces[i2];\n          const vertices = tri.vertices;\n          for (let i3 = 0, l3 = vertices.length; i3 < l3; i3++) {\n            vertices[i3].applyMatrix4(matrix);\n          }\n          tri.colorCode = tri.colorCode === MAIN_COLOUR_CODE ? colorCode : tri.colorCode;\n          tri.material = tri.material || getMaterialFromCode(tri.colorCode, colorCode, info2.materials, false);\n          faceMaterials.add(tri.colorCode);\n          if (matrixScaleInverted !== inverted) {\n            vertices.reverse();\n          }\n          parentFaces.push(tri);\n        }\n        info2.totalFaces += subobjectInfo.totalFaces;\n      }\n      if (subobject) {\n        loader.applyMaterialsToMesh(group2, subobject.colorCode, info2.materials);\n      }\n      return info2;\n    };\n    for (let i = 0, l = info.faces; i < l; i++) {\n      faceMaterials.add(info.faces[i].colorCode);\n    }\n    await processInfoSubobjects(info);\n    if (loader.smoothNormals) {\n      const checkSubSegments = faceMaterials.size > 1;\n      generateFaceNormals(info.faces);\n      smoothNormals(info.faces, info.lineSegments, checkSubSegments);\n    }\n    const group = info.group;\n    if (info.faces.length > 0) {\n      group.add(createObject(info.faces, 3, false, info.totalFaces));\n    }\n    if (info.lineSegments.length > 0) {\n      group.add(createObject(info.lineSegments, 2));\n    }\n    if (info.conditionalSegments.length > 0) {\n      group.add(createObject(info.conditionalSegments, 2, true));\n    }\n    return group;\n  }\n  hasCachedModel(fileName) {\n    return fileName !== null && fileName.toLowerCase() in this._cache;\n  }\n  async getCachedModel(fileName) {\n    if (fileName !== null && this.hasCachedModel(fileName)) {\n      const key = fileName.toLowerCase();\n      const group = await this._cache[key];\n      return group.clone();\n    } else {\n      return null;\n    }\n  }\n  // Loads and parses the model with the given file name. Returns a cached copy if available.\n  async loadModel(fileName) {\n    const parseCache = this.parseCache;\n    const key = fileName.toLowerCase();\n    if (this.hasCachedModel(fileName)) {\n      return this.getCachedModel(fileName);\n    } else {\n      await parseCache.ensureDataLoaded(fileName);\n      const info = parseCache.getData(fileName);\n      const promise = this.processIntoMesh(info);\n      if (this.hasCachedModel(fileName)) {\n        return this.getCachedModel(fileName);\n      }\n      if (isPartType(info.type)) {\n        this._cache[key] = promise;\n      }\n      const group = await promise;\n      return group.clone();\n    }\n  }\n  // parses the given model text into a renderable object. Returns cached copy if available.\n  async parseModel(text) {\n    const parseCache = this.parseCache;\n    const info = parseCache.parse(text);\n    if (isPartType(info.type) && this.hasCachedModel(info.fileName)) {\n      return this.getCachedModel(info.fileName);\n    }\n    return this.processIntoMesh(info);\n  }\n}\nfunction sortByMaterial(a, b) {\n  if (a.colorCode === b.colorCode) {\n    return 0;\n  }\n  if (a.colorCode < b.colorCode) {\n    return -1;\n  }\n  return 1;\n}\nfunction createObject(elements, elementSize, isConditionalSegments = false, totalElements = null) {\n  elements.sort(sortByMaterial);\n  if (totalElements === null) {\n    totalElements = elements.length;\n  }\n  const positions = new Float32Array(elementSize * totalElements * 3);\n  const normals = elementSize === 3 ? new Float32Array(elementSize * totalElements * 3) : null;\n  const materials = [];\n  const quadArray = new Array(6);\n  const bufferGeometry = new BufferGeometry();\n  let prevMaterial = null;\n  let index0 = 0;\n  let numGroupVerts = 0;\n  let offset = 0;\n  for (let iElem = 0, nElem = elements.length; iElem < nElem; iElem++) {\n    const elem = elements[iElem];\n    let vertices = elem.vertices;\n    if (vertices.length === 4) {\n      quadArray[0] = vertices[0];\n      quadArray[1] = vertices[1];\n      quadArray[2] = vertices[2];\n      quadArray[3] = vertices[0];\n      quadArray[4] = vertices[2];\n      quadArray[5] = vertices[3];\n      vertices = quadArray;\n    }\n    for (let j = 0, l = vertices.length; j < l; j++) {\n      const v = vertices[j];\n      const index = offset + j * 3;\n      positions[index + 0] = v.x;\n      positions[index + 1] = v.y;\n      positions[index + 2] = v.z;\n    }\n    if (elementSize === 3) {\n      if (!elem.faceNormal) {\n        const v0 = vertices[0];\n        const v1 = vertices[1];\n        const v2 = vertices[2];\n        _tempVec0.subVectors(v1, v0);\n        _tempVec1.subVectors(v2, v1);\n        elem.faceNormal = new Vector3().crossVectors(_tempVec0, _tempVec1).normalize();\n      }\n      let elemNormals = elem.normals;\n      if (elemNormals.length === 4) {\n        quadArray[0] = elemNormals[0];\n        quadArray[1] = elemNormals[1];\n        quadArray[2] = elemNormals[2];\n        quadArray[3] = elemNormals[0];\n        quadArray[4] = elemNormals[2];\n        quadArray[5] = elemNormals[3];\n        elemNormals = quadArray;\n      }\n      for (let j = 0, l = elemNormals.length; j < l; j++) {\n        let n = elem.faceNormal;\n        if (elemNormals[j]) {\n          n = elemNormals[j].norm;\n        }\n        const index = offset + j * 3;\n        normals[index + 0] = n.x;\n        normals[index + 1] = n.y;\n        normals[index + 2] = n.z;\n      }\n    }\n    if (prevMaterial !== elem.colorCode) {\n      if (prevMaterial !== null) {\n        bufferGeometry.addGroup(index0, numGroupVerts, materials.length - 1);\n      }\n      const material = elem.material;\n      if (material !== null) {\n        if (elementSize === 3) {\n          materials.push(material);\n        } else if (elementSize === 2) {\n          if (material !== null) {\n            if (isConditionalSegments) {\n              materials.push(material.userData.edgeMaterial.userData.conditionalEdgeMaterial);\n            } else {\n              materials.push(material.userData.edgeMaterial);\n            }\n          } else {\n            materials.push(null);\n          }\n        }\n      } else {\n        materials.push(elem.colorCode);\n      }\n      prevMaterial = elem.colorCode;\n      index0 = offset / 3;\n      numGroupVerts = vertices.length;\n    } else {\n      numGroupVerts += vertices.length;\n    }\n    offset += 3 * vertices.length;\n  }\n  if (numGroupVerts > 0) {\n    bufferGeometry.addGroup(index0, Infinity, materials.length - 1);\n  }\n  bufferGeometry.setAttribute(\"position\", new BufferAttribute(positions, 3));\n  if (normals !== null) {\n    bufferGeometry.setAttribute(\"normal\", new BufferAttribute(normals, 3));\n  }\n  let object3d = null;\n  if (elementSize === 2) {\n    if (isConditionalSegments) {\n      object3d = new ConditionalLineSegments(bufferGeometry, materials.length === 1 ? materials[0] : materials);\n    } else {\n      object3d = new LineSegments(bufferGeometry, materials.length === 1 ? materials[0] : materials);\n    }\n  } else if (elementSize === 3) {\n    object3d = new Mesh(bufferGeometry, materials.length === 1 ? materials[0] : materials);\n  }\n  if (isConditionalSegments) {\n    object3d.isConditionalLine = true;\n    const controlArray0 = new Float32Array(elements.length * 3 * 2);\n    const controlArray1 = new Float32Array(elements.length * 3 * 2);\n    const directionArray = new Float32Array(elements.length * 3 * 2);\n    for (let i = 0, l = elements.length; i < l; i++) {\n      const os = elements[i];\n      const vertices = os.vertices;\n      const controlPoints = os.controlPoints;\n      const c0 = controlPoints[0];\n      const c1 = controlPoints[1];\n      const v0 = vertices[0];\n      const v1 = vertices[1];\n      const index = i * 3 * 2;\n      controlArray0[index + 0] = c0.x;\n      controlArray0[index + 1] = c0.y;\n      controlArray0[index + 2] = c0.z;\n      controlArray0[index + 3] = c0.x;\n      controlArray0[index + 4] = c0.y;\n      controlArray0[index + 5] = c0.z;\n      controlArray1[index + 0] = c1.x;\n      controlArray1[index + 1] = c1.y;\n      controlArray1[index + 2] = c1.z;\n      controlArray1[index + 3] = c1.x;\n      controlArray1[index + 4] = c1.y;\n      controlArray1[index + 5] = c1.z;\n      directionArray[index + 0] = v1.x - v0.x;\n      directionArray[index + 1] = v1.y - v0.y;\n      directionArray[index + 2] = v1.z - v0.z;\n      directionArray[index + 3] = v1.x - v0.x;\n      directionArray[index + 4] = v1.y - v0.y;\n      directionArray[index + 5] = v1.z - v0.z;\n    }\n    bufferGeometry.setAttribute(\"control0\", new BufferAttribute(controlArray0, 3, false));\n    bufferGeometry.setAttribute(\"control1\", new BufferAttribute(controlArray1, 3, false));\n    bufferGeometry.setAttribute(\"direction\", new BufferAttribute(directionArray, 3, false));\n  }\n  return object3d;\n}\nclass LDrawLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.materials = [];\n    this.materialLibrary = {};\n    this.partsCache = new LDrawPartsGeometryCache(this);\n    this.fileMap = {};\n    this.setMaterials([]);\n    this.smoothNormals = true;\n    this.partsLibraryPath = \"\";\n  }\n  setPartsLibraryPath(path) {\n    this.partsLibraryPath = path;\n    return this;\n  }\n  async preloadMaterials(url) {\n    const fileLoader = new FileLoader(this.manager);\n    fileLoader.setPath(this.path);\n    fileLoader.setRequestHeader(this.requestHeader);\n    fileLoader.setWithCredentials(this.withCredentials);\n    const text = await fileLoader.loadAsync(url);\n    const colorLineRegex = /^0 !COLOUR/;\n    const lines = text.split(/[\\n\\r]/g);\n    const materials = [];\n    for (let i = 0, l = lines.length; i < l; i++) {\n      const line = lines[i];\n      if (colorLineRegex.test(line)) {\n        const directive = line.replace(colorLineRegex, \"\");\n        const material = this.parseColorMetaDirective(new LineParser(directive));\n        materials.push(material);\n      }\n    }\n    this.setMaterials(materials);\n  }\n  load(url, onLoad, onProgress, onError) {\n    const fileLoader = new FileLoader(this.manager);\n    fileLoader.setPath(this.path);\n    fileLoader.setRequestHeader(this.requestHeader);\n    fileLoader.setWithCredentials(this.withCredentials);\n    fileLoader.load(\n      url,\n      (text) => {\n        this.partsCache.parseModel(text, this.materialLibrary).then((group) => {\n          this.applyMaterialsToMesh(group, MAIN_COLOUR_CODE, this.materialLibrary, true);\n          this.computeConstructionSteps(group);\n          onLoad(group);\n        }).catch(onError);\n      },\n      onProgress,\n      onError\n    );\n  }\n  parse(text, onLoad) {\n    this.partsCache.parseModel(text, this.materialLibrary).then((group) => {\n      this.computeConstructionSteps(group);\n      onLoad(group);\n    });\n  }\n  setMaterials(materials) {\n    this.materialLibrary = {};\n    this.materials = [];\n    for (let i = 0, l = materials.length; i < l; i++) {\n      this.addMaterial(materials[i]);\n    }\n    this.addMaterial(this.parseColorMetaDirective(new LineParser(\"Main_Colour CODE 16 VALUE #FF8080 EDGE #333333\")));\n    this.addMaterial(this.parseColorMetaDirective(new LineParser(\"Edge_Colour CODE 24 VALUE #A0A0A0 EDGE #333333\")));\n    return this;\n  }\n  setFileMap(fileMap) {\n    this.fileMap = fileMap;\n    return this;\n  }\n  addMaterial(material) {\n    const matLib = this.materialLibrary;\n    if (!matLib[material.userData.code]) {\n      this.materials.push(material);\n      matLib[material.userData.code] = material;\n    }\n    return this;\n  }\n  getMaterial(colorCode) {\n    if (colorCode.startsWith(\"0x2\")) {\n      const color = colorCode.substring(3);\n      return this.parseColorMetaDirective(\n        new LineParser(\"Direct_Color_\" + color + \" CODE -1 VALUE #\" + color + \" EDGE #\" + color)\n      );\n    }\n    return this.materialLibrary[colorCode] || null;\n  }\n  // Applies the appropriate materials to a prebuilt hierarchy of geometry. Assumes that color codes are present\n  // in the material array if they need to be filled in.\n  applyMaterialsToMesh(group, parentColorCode, materialHierarchy, finalMaterialPass = false) {\n    const loader = this;\n    const parentIsPassthrough = parentColorCode === MAIN_COLOUR_CODE;\n    group.traverse((c) => {\n      if (c.isMesh || c.isLineSegments) {\n        if (Array.isArray(c.material)) {\n          for (let i = 0, l = c.material.length; i < l; i++) {\n            if (!c.material[i].isMaterial) {\n              c.material[i] = getMaterial(c, c.material[i]);\n            }\n          }\n        } else if (!c.material.isMaterial) {\n          c.material = getMaterial(c, c.material);\n        }\n      }\n    });\n    function getMaterial(c, colorCode) {\n      if (parentIsPassthrough && !(colorCode in materialHierarchy) && !finalMaterialPass) {\n        return colorCode;\n      }\n      const forEdge = c.isLineSegments || c.isConditionalLine;\n      const isPassthrough = !forEdge && colorCode === MAIN_COLOUR_CODE || forEdge && colorCode === MAIN_EDGE_COLOUR_CODE;\n      if (isPassthrough) {\n        colorCode = parentColorCode;\n      }\n      let material = null;\n      if (colorCode in materialHierarchy) {\n        material = materialHierarchy[colorCode];\n      } else if (finalMaterialPass) {\n        material = loader.getMaterial(colorCode);\n        if (material === null) {\n          throw new Error(`LDrawLoader: Material properties for code ${colorCode} not available.`);\n        }\n      } else {\n        return colorCode;\n      }\n      if (c.isLineSegments) {\n        material = material.userData.edgeMaterial;\n        if (c.isConditionalLine) {\n          material = material.userData.conditionalEdgeMaterial;\n        }\n      }\n      return material;\n    }\n  }\n  getMainMaterial() {\n    return this.getMaterial(MAIN_COLOUR_CODE);\n  }\n  getMainEdgeMaterial() {\n    return this.getMaterial(MAIN_EDGE_COLOUR_CODE);\n  }\n  parseColorMetaDirective(lineParser) {\n    let code = null;\n    let color = 16711935;\n    let edgeColor = 16711935;\n    let alpha = 1;\n    let isTransparent = false;\n    let luminance = 0;\n    let finishType = FINISH_TYPE_DEFAULT;\n    let edgeMaterial = null;\n    const name = lineParser.getToken();\n    if (!name) {\n      throw new Error(\n        'LDrawLoader: Material name was expected after \"!COLOUR tag' + lineParser.getLineNumberString() + \".\"\n      );\n    }\n    let token = null;\n    while (true) {\n      token = lineParser.getToken();\n      if (!token) {\n        break;\n      }\n      switch (token.toUpperCase()) {\n        case \"CODE\":\n          code = lineParser.getToken();\n          break;\n        case \"VALUE\":\n          color = lineParser.getToken();\n          if (color.startsWith(\"0x\")) {\n            color = \"#\" + color.substring(2);\n          } else if (!color.startsWith(\"#\")) {\n            throw new Error(\n              \"LDrawLoader: Invalid color while parsing material\" + lineParser.getLineNumberString() + \".\"\n            );\n          }\n          break;\n        case \"EDGE\":\n          edgeColor = lineParser.getToken();\n          if (edgeColor.startsWith(\"0x\")) {\n            edgeColor = \"#\" + edgeColor.substring(2);\n          } else if (!edgeColor.startsWith(\"#\")) {\n            edgeMaterial = this.getMaterial(edgeColor);\n            if (!edgeMaterial) {\n              throw new Error(\n                \"LDrawLoader: Invalid edge color while parsing material\" + lineParser.getLineNumberString() + \".\"\n              );\n            }\n            edgeMaterial = edgeMaterial.userData.edgeMaterial;\n          }\n          break;\n        case \"ALPHA\":\n          alpha = parseInt(lineParser.getToken());\n          if (isNaN(alpha)) {\n            throw new Error(\n              \"LDrawLoader: Invalid alpha value in material definition\" + lineParser.getLineNumberString() + \".\"\n            );\n          }\n          alpha = Math.max(0, Math.min(1, alpha / 255));\n          if (alpha < 1) {\n            isTransparent = true;\n          }\n          break;\n        case \"LUMINANCE\":\n          luminance = parseInt(lineParser.getToken());\n          if (isNaN(luminance)) {\n            throw new Error(\n              \"LDrawLoader: Invalid luminance value in material definition\" + LineParser.getLineNumberString() + \".\"\n            );\n          }\n          luminance = Math.max(0, Math.min(1, luminance / 255));\n          break;\n        case \"CHROME\":\n          finishType = FINISH_TYPE_CHROME;\n          break;\n        case \"PEARLESCENT\":\n          finishType = FINISH_TYPE_PEARLESCENT;\n          break;\n        case \"RUBBER\":\n          finishType = FINISH_TYPE_RUBBER;\n          break;\n        case \"MATTE_METALLIC\":\n          finishType = FINISH_TYPE_MATTE_METALLIC;\n          break;\n        case \"METAL\":\n          finishType = FINISH_TYPE_METAL;\n          break;\n        case \"MATERIAL\":\n          lineParser.setToEnd();\n          break;\n        default:\n          throw new Error(\n            'LDrawLoader: Unknown token \"' + token + '\" while parsing material' + lineParser.getLineNumberString() + \".\"\n          );\n      }\n    }\n    let material = null;\n    switch (finishType) {\n      case FINISH_TYPE_DEFAULT:\n        material = new MeshStandardMaterial({ color, roughness: 0.3, metalness: 0 });\n        break;\n      case FINISH_TYPE_PEARLESCENT:\n        material = new MeshStandardMaterial({ color, roughness: 0.3, metalness: 0.25 });\n        break;\n      case FINISH_TYPE_CHROME:\n        material = new MeshStandardMaterial({ color, roughness: 0, metalness: 1 });\n        break;\n      case FINISH_TYPE_RUBBER:\n        material = new MeshStandardMaterial({ color, roughness: 0.9, metalness: 0 });\n        break;\n      case FINISH_TYPE_MATTE_METALLIC:\n        material = new MeshStandardMaterial({ color, roughness: 0.8, metalness: 0.4 });\n        break;\n      case FINISH_TYPE_METAL:\n        material = new MeshStandardMaterial({ color, roughness: 0.2, metalness: 0.85 });\n        break;\n      default:\n        break;\n    }\n    material.transparent = isTransparent;\n    material.premultipliedAlpha = true;\n    material.opacity = alpha;\n    material.depthWrite = !isTransparent;\n    material.polygonOffset = true;\n    material.polygonOffsetFactor = 1;\n    if (luminance !== 0) {\n      material.emissive.set(material.color).multiplyScalar(luminance);\n    }\n    if (!edgeMaterial) {\n      edgeMaterial = new LineBasicMaterial({\n        color: edgeColor,\n        transparent: isTransparent,\n        opacity: alpha,\n        depthWrite: !isTransparent\n      });\n      edgeMaterial.userData.code = code;\n      edgeMaterial.name = name + \" - Edge\";\n      edgeMaterial.userData.conditionalEdgeMaterial = new LDrawConditionalLineMaterial({\n        fog: true,\n        transparent: isTransparent,\n        depthWrite: !isTransparent,\n        color: edgeColor,\n        opacity: alpha\n      });\n    }\n    material.userData.code = code;\n    material.name = name;\n    material.userData.edgeMaterial = edgeMaterial;\n    this.addMaterial(material);\n    return material;\n  }\n  computeConstructionSteps(model) {\n    let stepNumber = 0;\n    model.traverse((c) => {\n      if (c.isGroup) {\n        if (c.userData.startingConstructionStep) {\n          stepNumber++;\n        }\n        c.userData.constructionStep = stepNumber;\n      }\n    });\n    model.userData.numConstructionSteps = stepNumber + 1;\n  }\n}\nexport {\n  LDrawLoader\n};\n"]},"metadata":{},"sourceType":"module"}