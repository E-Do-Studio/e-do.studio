{"ast":null,"code":"import _classCallCheck from \"/Users/theodaguier/_workdir/dev/pro/e-do/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/theodaguier/_workdir/dev/pro/e-do/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/theodaguier/_workdir/dev/pro/e-do/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/theodaguier/_workdir/dev/pro/e-do/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { UniformsUtils, ShaderMaterial, NoBlending, WebGLRenderTarget, LinearMipmapLinearFilter, MeshBasicMaterial } from \"three\";\nimport { Pass, FullScreenQuad } from \"./Pass.js\";\nimport { CopyShader } from \"../shaders/CopyShader.js\";\nimport { LuminosityShader } from \"../shaders/LuminosityShader.js\";\nimport { ToneMapShader } from \"../shaders/ToneMapShader.js\";\n\nvar AdaptiveToneMappingPass = /*#__PURE__*/function (_Pass) {\n  _inherits(AdaptiveToneMappingPass, _Pass);\n\n  var _super = _createSuper(AdaptiveToneMappingPass);\n\n  function AdaptiveToneMappingPass(adaptive, resolution) {\n    var _this;\n\n    _classCallCheck(this, AdaptiveToneMappingPass);\n\n    _this = _super.call(this);\n    _this.resolution = resolution !== void 0 ? resolution : 256;\n    _this.needsInit = true;\n    _this.adaptive = adaptive !== void 0 ? !!adaptive : true;\n    _this.luminanceRT = null;\n    _this.previousLuminanceRT = null;\n    _this.currentLuminanceRT = null;\n    var copyShader = CopyShader;\n    _this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);\n    _this.materialCopy = new ShaderMaterial({\n      uniforms: _this.copyUniforms,\n      vertexShader: copyShader.vertexShader,\n      fragmentShader: copyShader.fragmentShader,\n      blending: NoBlending,\n      depthTest: false\n    });\n    _this.materialLuminance = new ShaderMaterial({\n      uniforms: UniformsUtils.clone(LuminosityShader.uniforms),\n      vertexShader: LuminosityShader.vertexShader,\n      fragmentShader: LuminosityShader.fragmentShader,\n      blending: NoBlending\n    });\n    _this.adaptLuminanceShader = {\n      defines: {\n        MIP_LEVEL_1X1: (Math.log(_this.resolution) / Math.log(2)).toFixed(1)\n      },\n      uniforms: {\n        lastLum: {\n          value: null\n        },\n        currentLum: {\n          value: null\n        },\n        minLuminance: {\n          value: 0.01\n        },\n        delta: {\n          value: 0.016\n        },\n        tau: {\n          value: 1\n        }\n      },\n      vertexShader: \"varying vec2 vUv;\\n\\n\\t\\t\\t\\tvoid main() {\\n\\n\\t\\t\\t\\t\\tvUv = uv;\\n\\t\\t\\t\\t\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\n\\t\\t\\t\\t}\",\n      fragmentShader: \"varying vec2 vUv;\\n\\n\\t\\t\\t\\tuniform sampler2D lastLum;\\n\\t\\t\\t\\tuniform sampler2D currentLum;\\n\\t\\t\\t\\tuniform float minLuminance;\\n\\t\\t\\t\\tuniform float delta;\\n\\t\\t\\t\\tuniform float tau;\\n\\n\\t\\t\\t\\tvoid main() {\\n\\n\\t\\t\\t\\t\\tvec4 lastLum = texture2D( lastLum, vUv, MIP_LEVEL_1X1 );\\n\\t\\t\\t\\t\\tvec4 currentLum = texture2D( currentLum, vUv, MIP_LEVEL_1X1 );\\n\\n\\t\\t\\t\\t\\tfloat fLastLum = max( minLuminance, lastLum.r );\\n\\t\\t\\t\\t\\tfloat fCurrentLum = max( minLuminance, currentLum.r );\\n\\n\\t\\t\\t\\t\\t//The adaption seems to work better in extreme lighting differences\\n\\t\\t\\t\\t\\t//if the input luminance is squared.\\n\\t\\t\\t\\t\\tfCurrentLum *= fCurrentLum;\\n\\n\\t\\t\\t\\t\\t// Adapt the luminance using Pattanaik's technique\\n\\t\\t\\t\\t\\tfloat fAdaptedLum = fLastLum + (fCurrentLum - fLastLum) * (1.0 - exp(-delta * tau));\\n\\t\\t\\t\\t\\t// \\\"fAdaptedLum = sqrt(fAdaptedLum);\\n\\t\\t\\t\\t\\tgl_FragColor.r = fAdaptedLum;\\n\\t\\t\\t\\t}\"\n    };\n    _this.materialAdaptiveLum = new ShaderMaterial({\n      uniforms: UniformsUtils.clone(_this.adaptLuminanceShader.uniforms),\n      vertexShader: _this.adaptLuminanceShader.vertexShader,\n      fragmentShader: _this.adaptLuminanceShader.fragmentShader,\n      defines: Object.assign({}, _this.adaptLuminanceShader.defines),\n      blending: NoBlending\n    });\n    _this.materialToneMap = new ShaderMaterial({\n      uniforms: UniformsUtils.clone(ToneMapShader.uniforms),\n      vertexShader: ToneMapShader.vertexShader,\n      fragmentShader: ToneMapShader.fragmentShader,\n      blending: NoBlending\n    });\n    _this.fsQuad = new FullScreenQuad(null);\n    return _this;\n  }\n\n  _createClass(AdaptiveToneMappingPass, [{\n    key: \"render\",\n    value: function render(renderer, writeBuffer, readBuffer, deltaTime) {\n      if (this.needsInit) {\n        this.reset(renderer);\n        this.luminanceRT.texture.type = readBuffer.texture.type;\n        this.previousLuminanceRT.texture.type = readBuffer.texture.type;\n        this.currentLuminanceRT.texture.type = readBuffer.texture.type;\n        this.needsInit = false;\n      }\n\n      if (this.adaptive) {\n        this.fsQuad.material = this.materialLuminance;\n        this.materialLuminance.uniforms.tDiffuse.value = readBuffer.texture;\n        renderer.setRenderTarget(this.currentLuminanceRT);\n        this.fsQuad.render(renderer);\n        this.fsQuad.material = this.materialAdaptiveLum;\n        this.materialAdaptiveLum.uniforms.delta.value = deltaTime;\n        this.materialAdaptiveLum.uniforms.lastLum.value = this.previousLuminanceRT.texture;\n        this.materialAdaptiveLum.uniforms.currentLum.value = this.currentLuminanceRT.texture;\n        renderer.setRenderTarget(this.luminanceRT);\n        this.fsQuad.render(renderer);\n        this.fsQuad.material = this.materialCopy;\n        this.copyUniforms.tDiffuse.value = this.luminanceRT.texture;\n        renderer.setRenderTarget(this.previousLuminanceRT);\n        this.fsQuad.render(renderer);\n      }\n\n      this.fsQuad.material = this.materialToneMap;\n      this.materialToneMap.uniforms.tDiffuse.value = readBuffer.texture;\n\n      if (this.renderToScreen) {\n        renderer.setRenderTarget(null);\n        this.fsQuad.render(renderer);\n      } else {\n        renderer.setRenderTarget(writeBuffer);\n        if (this.clear) renderer.clear();\n        this.fsQuad.render(renderer);\n      }\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      if (this.luminanceRT) {\n        this.luminanceRT.dispose();\n      }\n\n      if (this.currentLuminanceRT) {\n        this.currentLuminanceRT.dispose();\n      }\n\n      if (this.previousLuminanceRT) {\n        this.previousLuminanceRT.dispose();\n      }\n\n      this.luminanceRT = new WebGLRenderTarget(this.resolution, this.resolution);\n      this.luminanceRT.texture.name = \"AdaptiveToneMappingPass.l\";\n      this.luminanceRT.texture.generateMipmaps = false;\n      this.previousLuminanceRT = new WebGLRenderTarget(this.resolution, this.resolution);\n      this.previousLuminanceRT.texture.name = \"AdaptiveToneMappingPass.pl\";\n      this.previousLuminanceRT.texture.generateMipmaps = false;\n      var pars = {\n        minFilter: LinearMipmapLinearFilter,\n        generateMipmaps: true\n      };\n      this.currentLuminanceRT = new WebGLRenderTarget(this.resolution, this.resolution, pars);\n      this.currentLuminanceRT.texture.name = \"AdaptiveToneMappingPass.cl\";\n\n      if (this.adaptive) {\n        this.materialToneMap.defines[\"ADAPTED_LUMINANCE\"] = \"\";\n        this.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT.texture;\n      }\n\n      this.fsQuad.material = new MeshBasicMaterial({\n        color: 7829367\n      });\n      this.materialLuminance.needsUpdate = true;\n      this.materialAdaptiveLum.needsUpdate = true;\n      this.materialToneMap.needsUpdate = true;\n    }\n  }, {\n    key: \"setAdaptive\",\n    value: function setAdaptive(adaptive) {\n      if (adaptive) {\n        this.adaptive = true;\n        this.materialToneMap.defines[\"ADAPTED_LUMINANCE\"] = \"\";\n        this.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT.texture;\n      } else {\n        this.adaptive = false;\n        delete this.materialToneMap.defines[\"ADAPTED_LUMINANCE\"];\n        this.materialToneMap.uniforms.luminanceMap.value = null;\n      }\n\n      this.materialToneMap.needsUpdate = true;\n    }\n  }, {\n    key: \"setAdaptionRate\",\n    value: function setAdaptionRate(rate) {\n      if (rate) {\n        this.materialAdaptiveLum.uniforms.tau.value = Math.abs(rate);\n      }\n    }\n  }, {\n    key: \"setMinLuminance\",\n    value: function setMinLuminance(minLum) {\n      if (minLum) {\n        this.materialToneMap.uniforms.minLuminance.value = minLum;\n        this.materialAdaptiveLum.uniforms.minLuminance.value = minLum;\n      }\n    }\n  }, {\n    key: \"setMaxLuminance\",\n    value: function setMaxLuminance(maxLum) {\n      if (maxLum) {\n        this.materialToneMap.uniforms.maxLuminance.value = maxLum;\n      }\n    }\n  }, {\n    key: \"setAverageLuminance\",\n    value: function setAverageLuminance(avgLum) {\n      if (avgLum) {\n        this.materialToneMap.uniforms.averageLuminance.value = avgLum;\n      }\n    }\n  }, {\n    key: \"setMiddleGrey\",\n    value: function setMiddleGrey(middleGrey) {\n      if (middleGrey) {\n        this.materialToneMap.uniforms.middleGrey.value = middleGrey;\n      }\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      if (this.luminanceRT) {\n        this.luminanceRT.dispose();\n      }\n\n      if (this.previousLuminanceRT) {\n        this.previousLuminanceRT.dispose();\n      }\n\n      if (this.currentLuminanceRT) {\n        this.currentLuminanceRT.dispose();\n      }\n\n      if (this.materialLuminance) {\n        this.materialLuminance.dispose();\n      }\n\n      if (this.materialAdaptiveLum) {\n        this.materialAdaptiveLum.dispose();\n      }\n\n      if (this.materialCopy) {\n        this.materialCopy.dispose();\n      }\n\n      if (this.materialToneMap) {\n        this.materialToneMap.dispose();\n      }\n    }\n  }]);\n\n  return AdaptiveToneMappingPass;\n}(Pass);\n\nexport { AdaptiveToneMappingPass };","map":{"version":3,"sources":["/Users/theodaguier/_workdir/dev/pro/e-do/E-Do-Studio/node_modules/three-stdlib/postprocessing/AdaptiveToneMappingPass.js"],"names":["UniformsUtils","ShaderMaterial","NoBlending","WebGLRenderTarget","LinearMipmapLinearFilter","MeshBasicMaterial","Pass","FullScreenQuad","CopyShader","LuminosityShader","ToneMapShader","AdaptiveToneMappingPass","adaptive","resolution","needsInit","luminanceRT","previousLuminanceRT","currentLuminanceRT","copyShader","copyUniforms","clone","uniforms","materialCopy","vertexShader","fragmentShader","blending","depthTest","materialLuminance","adaptLuminanceShader","defines","MIP_LEVEL_1X1","Math","log","toFixed","lastLum","value","currentLum","minLuminance","delta","tau","materialAdaptiveLum","Object","assign","materialToneMap","fsQuad","renderer","writeBuffer","readBuffer","deltaTime","reset","texture","type","material","tDiffuse","setRenderTarget","render","renderToScreen","clear","dispose","name","generateMipmaps","pars","minFilter","luminanceMap","color","needsUpdate","rate","abs","minLum","maxLum","maxLuminance","avgLum","averageLuminance","middleGrey"],"mappings":"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","sourcesContent":["import { UniformsUtils, ShaderMaterial, NoBlending, WebGLRenderTarget, LinearMipmapLinearFilter, MeshBasicMaterial } from \"three\";\nimport { Pass, FullScreenQuad } from \"./Pass.js\";\nimport { CopyShader } from \"../shaders/CopyShader.js\";\nimport { LuminosityShader } from \"../shaders/LuminosityShader.js\";\nimport { ToneMapShader } from \"../shaders/ToneMapShader.js\";\nclass AdaptiveToneMappingPass extends Pass {\n  constructor(adaptive, resolution) {\n    super();\n    this.resolution = resolution !== void 0 ? resolution : 256;\n    this.needsInit = true;\n    this.adaptive = adaptive !== void 0 ? !!adaptive : true;\n    this.luminanceRT = null;\n    this.previousLuminanceRT = null;\n    this.currentLuminanceRT = null;\n    const copyShader = CopyShader;\n    this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);\n    this.materialCopy = new ShaderMaterial({\n      uniforms: this.copyUniforms,\n      vertexShader: copyShader.vertexShader,\n      fragmentShader: copyShader.fragmentShader,\n      blending: NoBlending,\n      depthTest: false\n    });\n    this.materialLuminance = new ShaderMaterial({\n      uniforms: UniformsUtils.clone(LuminosityShader.uniforms),\n      vertexShader: LuminosityShader.vertexShader,\n      fragmentShader: LuminosityShader.fragmentShader,\n      blending: NoBlending\n    });\n    this.adaptLuminanceShader = {\n      defines: {\n        MIP_LEVEL_1X1: (Math.log(this.resolution) / Math.log(2)).toFixed(1)\n      },\n      uniforms: {\n        lastLum: { value: null },\n        currentLum: { value: null },\n        minLuminance: { value: 0.01 },\n        delta: { value: 0.016 },\n        tau: { value: 1 }\n      },\n      vertexShader: `varying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}`,\n      fragmentShader: `varying vec2 vUv;\n\n\t\t\t\tuniform sampler2D lastLum;\n\t\t\t\tuniform sampler2D currentLum;\n\t\t\t\tuniform float minLuminance;\n\t\t\t\tuniform float delta;\n\t\t\t\tuniform float tau;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec4 lastLum = texture2D( lastLum, vUv, MIP_LEVEL_1X1 );\n\t\t\t\t\tvec4 currentLum = texture2D( currentLum, vUv, MIP_LEVEL_1X1 );\n\n\t\t\t\t\tfloat fLastLum = max( minLuminance, lastLum.r );\n\t\t\t\t\tfloat fCurrentLum = max( minLuminance, currentLum.r );\n\n\t\t\t\t\t//The adaption seems to work better in extreme lighting differences\n\t\t\t\t\t//if the input luminance is squared.\n\t\t\t\t\tfCurrentLum *= fCurrentLum;\n\n\t\t\t\t\t// Adapt the luminance using Pattanaik's technique\n\t\t\t\t\tfloat fAdaptedLum = fLastLum + (fCurrentLum - fLastLum) * (1.0 - exp(-delta * tau));\n\t\t\t\t\t// \"fAdaptedLum = sqrt(fAdaptedLum);\n\t\t\t\t\tgl_FragColor.r = fAdaptedLum;\n\t\t\t\t}`\n    };\n    this.materialAdaptiveLum = new ShaderMaterial({\n      uniforms: UniformsUtils.clone(this.adaptLuminanceShader.uniforms),\n      vertexShader: this.adaptLuminanceShader.vertexShader,\n      fragmentShader: this.adaptLuminanceShader.fragmentShader,\n      defines: Object.assign({}, this.adaptLuminanceShader.defines),\n      blending: NoBlending\n    });\n    this.materialToneMap = new ShaderMaterial({\n      uniforms: UniformsUtils.clone(ToneMapShader.uniforms),\n      vertexShader: ToneMapShader.vertexShader,\n      fragmentShader: ToneMapShader.fragmentShader,\n      blending: NoBlending\n    });\n    this.fsQuad = new FullScreenQuad(null);\n  }\n  render(renderer, writeBuffer, readBuffer, deltaTime) {\n    if (this.needsInit) {\n      this.reset(renderer);\n      this.luminanceRT.texture.type = readBuffer.texture.type;\n      this.previousLuminanceRT.texture.type = readBuffer.texture.type;\n      this.currentLuminanceRT.texture.type = readBuffer.texture.type;\n      this.needsInit = false;\n    }\n    if (this.adaptive) {\n      this.fsQuad.material = this.materialLuminance;\n      this.materialLuminance.uniforms.tDiffuse.value = readBuffer.texture;\n      renderer.setRenderTarget(this.currentLuminanceRT);\n      this.fsQuad.render(renderer);\n      this.fsQuad.material = this.materialAdaptiveLum;\n      this.materialAdaptiveLum.uniforms.delta.value = deltaTime;\n      this.materialAdaptiveLum.uniforms.lastLum.value = this.previousLuminanceRT.texture;\n      this.materialAdaptiveLum.uniforms.currentLum.value = this.currentLuminanceRT.texture;\n      renderer.setRenderTarget(this.luminanceRT);\n      this.fsQuad.render(renderer);\n      this.fsQuad.material = this.materialCopy;\n      this.copyUniforms.tDiffuse.value = this.luminanceRT.texture;\n      renderer.setRenderTarget(this.previousLuminanceRT);\n      this.fsQuad.render(renderer);\n    }\n    this.fsQuad.material = this.materialToneMap;\n    this.materialToneMap.uniforms.tDiffuse.value = readBuffer.texture;\n    if (this.renderToScreen) {\n      renderer.setRenderTarget(null);\n      this.fsQuad.render(renderer);\n    } else {\n      renderer.setRenderTarget(writeBuffer);\n      if (this.clear)\n        renderer.clear();\n      this.fsQuad.render(renderer);\n    }\n  }\n  reset() {\n    if (this.luminanceRT) {\n      this.luminanceRT.dispose();\n    }\n    if (this.currentLuminanceRT) {\n      this.currentLuminanceRT.dispose();\n    }\n    if (this.previousLuminanceRT) {\n      this.previousLuminanceRT.dispose();\n    }\n    this.luminanceRT = new WebGLRenderTarget(this.resolution, this.resolution);\n    this.luminanceRT.texture.name = \"AdaptiveToneMappingPass.l\";\n    this.luminanceRT.texture.generateMipmaps = false;\n    this.previousLuminanceRT = new WebGLRenderTarget(this.resolution, this.resolution);\n    this.previousLuminanceRT.texture.name = \"AdaptiveToneMappingPass.pl\";\n    this.previousLuminanceRT.texture.generateMipmaps = false;\n    const pars = { minFilter: LinearMipmapLinearFilter, generateMipmaps: true };\n    this.currentLuminanceRT = new WebGLRenderTarget(this.resolution, this.resolution, pars);\n    this.currentLuminanceRT.texture.name = \"AdaptiveToneMappingPass.cl\";\n    if (this.adaptive) {\n      this.materialToneMap.defines[\"ADAPTED_LUMINANCE\"] = \"\";\n      this.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT.texture;\n    }\n    this.fsQuad.material = new MeshBasicMaterial({ color: 7829367 });\n    this.materialLuminance.needsUpdate = true;\n    this.materialAdaptiveLum.needsUpdate = true;\n    this.materialToneMap.needsUpdate = true;\n  }\n  setAdaptive(adaptive) {\n    if (adaptive) {\n      this.adaptive = true;\n      this.materialToneMap.defines[\"ADAPTED_LUMINANCE\"] = \"\";\n      this.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT.texture;\n    } else {\n      this.adaptive = false;\n      delete this.materialToneMap.defines[\"ADAPTED_LUMINANCE\"];\n      this.materialToneMap.uniforms.luminanceMap.value = null;\n    }\n    this.materialToneMap.needsUpdate = true;\n  }\n  setAdaptionRate(rate) {\n    if (rate) {\n      this.materialAdaptiveLum.uniforms.tau.value = Math.abs(rate);\n    }\n  }\n  setMinLuminance(minLum) {\n    if (minLum) {\n      this.materialToneMap.uniforms.minLuminance.value = minLum;\n      this.materialAdaptiveLum.uniforms.minLuminance.value = minLum;\n    }\n  }\n  setMaxLuminance(maxLum) {\n    if (maxLum) {\n      this.materialToneMap.uniforms.maxLuminance.value = maxLum;\n    }\n  }\n  setAverageLuminance(avgLum) {\n    if (avgLum) {\n      this.materialToneMap.uniforms.averageLuminance.value = avgLum;\n    }\n  }\n  setMiddleGrey(middleGrey) {\n    if (middleGrey) {\n      this.materialToneMap.uniforms.middleGrey.value = middleGrey;\n    }\n  }\n  dispose() {\n    if (this.luminanceRT) {\n      this.luminanceRT.dispose();\n    }\n    if (this.previousLuminanceRT) {\n      this.previousLuminanceRT.dispose();\n    }\n    if (this.currentLuminanceRT) {\n      this.currentLuminanceRT.dispose();\n    }\n    if (this.materialLuminance) {\n      this.materialLuminance.dispose();\n    }\n    if (this.materialAdaptiveLum) {\n      this.materialAdaptiveLum.dispose();\n    }\n    if (this.materialCopy) {\n      this.materialCopy.dispose();\n    }\n    if (this.materialToneMap) {\n      this.materialToneMap.dispose();\n    }\n  }\n}\nexport {\n  AdaptiveToneMappingPass\n};\n"]},"metadata":{},"sourceType":"module"}