{"ast":null,"code":"import { Object3D, MeshLambertMaterial, Mesh, TextureLoader, UVMapping, Box3, AnimationMixer } from \"three\";\nimport { MD2Loader } from \"../loaders/MD2Loader.js\";\n\nclass MD2Character {\n  constructor() {\n    this.scale = 1;\n    this.animationFPS = 6;\n    this.root = new Object3D();\n    this.meshBody = null;\n    this.meshWeapon = null;\n    this.skinsBody = [];\n    this.skinsWeapon = [];\n    this.weapons = [];\n    this.activeAnimation = null;\n    this.mixer = null;\n\n    this.onLoadComplete = function () {};\n\n    this.loadCounter = 0;\n  }\n\n  loadParts(config) {\n    const scope = this;\n\n    function createPart(geometry, skinMap) {\n      const materialWireframe = new MeshLambertMaterial({\n        color: 16755200,\n        wireframe: true,\n        morphTargets: true,\n        morphNormals: true\n      });\n      const materialTexture = new MeshLambertMaterial({\n        color: 16777215,\n        wireframe: false,\n        map: skinMap,\n        morphTargets: true,\n        morphNormals: true\n      });\n      const mesh = new Mesh(geometry, materialTexture);\n      mesh.rotation.y = -Math.PI / 2;\n      mesh.castShadow = true;\n      mesh.receiveShadow = true;\n      mesh.materialTexture = materialTexture;\n      mesh.materialWireframe = materialWireframe;\n      return mesh;\n    }\n\n    function loadTextures(baseUrl, textureUrls) {\n      const textureLoader = new TextureLoader();\n      const textures = [];\n\n      for (let i = 0; i < textureUrls.length; i++) {\n        textures[i] = textureLoader.load(baseUrl + textureUrls[i], checkLoadingComplete);\n        textures[i].mapping = UVMapping;\n        textures[i].name = textureUrls[i];\n        if (\"colorSpace\" in textures[i]) textures[i].colorSpace = \"srgb\";else textures[i].encoding = 3001;\n      }\n\n      return textures;\n    }\n\n    function checkLoadingComplete() {\n      scope.loadCounter -= 1;\n      if (scope.loadCounter === 0) scope.onLoadComplete();\n    }\n\n    this.loadCounter = config.weapons.length * 2 + config.skins.length + 1;\n    const weaponsTextures = [];\n\n    for (let i = 0; i < config.weapons.length; i++) weaponsTextures[i] = config.weapons[i][1];\n\n    this.skinsBody = loadTextures(config.baseUrl + \"skins/\", config.skins);\n    this.skinsWeapon = loadTextures(config.baseUrl + \"skins/\", weaponsTextures);\n    const loader = new MD2Loader();\n    loader.load(config.baseUrl + config.body, function (geo) {\n      const boundingBox = new Box3();\n      boundingBox.setFromBufferAttribute(geo.attributes.position);\n      scope.root.position.y = -scope.scale * boundingBox.min.y;\n      const mesh = createPart(geo, scope.skinsBody[0]);\n      mesh.scale.set(scope.scale, scope.scale, scope.scale);\n      scope.root.add(mesh);\n      scope.meshBody = mesh;\n      scope.meshBody.clipOffset = 0;\n      scope.activeAnimationClipName = mesh.geometry.animations[0].name;\n      scope.mixer = new AnimationMixer(mesh);\n      checkLoadingComplete();\n    });\n\n    const generateCallback = function (index, name) {\n      return function (geo) {\n        const mesh = createPart(geo, scope.skinsWeapon[index]);\n        mesh.scale.set(scope.scale, scope.scale, scope.scale);\n        mesh.visible = false;\n        mesh.name = name;\n        scope.root.add(mesh);\n        scope.weapons[index] = mesh;\n        scope.meshWeapon = mesh;\n        checkLoadingComplete();\n      };\n    };\n\n    for (let i = 0; i < config.weapons.length; i++) {\n      loader.load(config.baseUrl + config.weapons[i][0], generateCallback(i, config.weapons[i][0]));\n    }\n  }\n\n  setPlaybackRate(rate) {\n    if (rate !== 0) {\n      this.mixer.timeScale = 1 / rate;\n    } else {\n      this.mixer.timeScale = 0;\n    }\n  }\n\n  setWireframe(wireframeEnabled) {\n    if (wireframeEnabled) {\n      if (this.meshBody) this.meshBody.material = this.meshBody.materialWireframe;\n      if (this.meshWeapon) this.meshWeapon.material = this.meshWeapon.materialWireframe;\n    } else {\n      if (this.meshBody) this.meshBody.material = this.meshBody.materialTexture;\n      if (this.meshWeapon) this.meshWeapon.material = this.meshWeapon.materialTexture;\n    }\n  }\n\n  setSkin(index) {\n    if (this.meshBody && this.meshBody.material.wireframe === false) {\n      this.meshBody.material.map = this.skinsBody[index];\n    }\n  }\n\n  setWeapon(index) {\n    for (let i = 0; i < this.weapons.length; i++) this.weapons[i].visible = false;\n\n    const activeWeapon = this.weapons[index];\n\n    if (activeWeapon) {\n      activeWeapon.visible = true;\n      this.meshWeapon = activeWeapon;\n      this.syncWeaponAnimation();\n    }\n  }\n\n  setAnimation(clipName) {\n    if (this.meshBody) {\n      if (this.meshBody.activeAction) {\n        this.meshBody.activeAction.stop();\n        this.meshBody.activeAction = null;\n      }\n\n      const action = this.mixer.clipAction(clipName, this.meshBody);\n\n      if (action) {\n        this.meshBody.activeAction = action.play();\n      }\n    }\n\n    this.activeClipName = clipName;\n    this.syncWeaponAnimation();\n  }\n\n  syncWeaponAnimation() {\n    const clipName = this.activeClipName;\n\n    if (this.meshWeapon) {\n      if (this.meshWeapon.activeAction) {\n        this.meshWeapon.activeAction.stop();\n        this.meshWeapon.activeAction = null;\n      }\n\n      const action = this.mixer.clipAction(clipName, this.meshWeapon);\n\n      if (action) {\n        this.meshWeapon.activeAction = action.syncWith(this.meshBody.activeAction).play();\n      }\n    }\n  }\n\n  update(delta) {\n    if (this.mixer) this.mixer.update(delta);\n  }\n\n}\n\nexport { MD2Character };","map":{"version":3,"sources":["/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/three-stdlib/misc/MD2Character.js"],"names":["Object3D","MeshLambertMaterial","Mesh","TextureLoader","UVMapping","Box3","AnimationMixer","MD2Loader","MD2Character","constructor","scale","animationFPS","root","meshBody","meshWeapon","skinsBody","skinsWeapon","weapons","activeAnimation","mixer","onLoadComplete","loadCounter","loadParts","config","scope","createPart","geometry","skinMap","materialWireframe","color","wireframe","morphTargets","morphNormals","materialTexture","map","mesh","rotation","y","Math","PI","castShadow","receiveShadow","loadTextures","baseUrl","textureUrls","textureLoader","textures","i","length","load","checkLoadingComplete","mapping","name","colorSpace","encoding","skins","weaponsTextures","loader","body","geo","boundingBox","setFromBufferAttribute","attributes","position","min","set","add","clipOffset","activeAnimationClipName","animations","generateCallback","index","visible","setPlaybackRate","rate","timeScale","setWireframe","wireframeEnabled","material","setSkin","setWeapon","activeWeapon","syncWeaponAnimation","setAnimation","clipName","activeAction","stop","action","clipAction","play","activeClipName","syncWith","update","delta"],"mappings":"AAAA,SAASA,QAAT,EAAmBC,mBAAnB,EAAwCC,IAAxC,EAA8CC,aAA9C,EAA6DC,SAA7D,EAAwEC,IAAxE,EAA8EC,cAA9E,QAAoG,OAApG;AACA,SAASC,SAAT,QAA0B,yBAA1B;;AACA,MAAMC,YAAN,CAAmB;AACjBC,EAAAA,WAAW,GAAG;AACZ,SAAKC,KAAL,GAAa,CAAb;AACA,SAAKC,YAAL,GAAoB,CAApB;AACA,SAAKC,IAAL,GAAY,IAAIZ,QAAJ,EAAZ;AACA,SAAKa,QAAL,GAAgB,IAAhB;AACA,SAAKC,UAAL,GAAkB,IAAlB;AACA,SAAKC,SAAL,GAAiB,EAAjB;AACA,SAAKC,WAAL,GAAmB,EAAnB;AACA,SAAKC,OAAL,GAAe,EAAf;AACA,SAAKC,eAAL,GAAuB,IAAvB;AACA,SAAKC,KAAL,GAAa,IAAb;;AACA,SAAKC,cAAL,GAAsB,YAAW,CAChC,CADD;;AAEA,SAAKC,WAAL,GAAmB,CAAnB;AACD;;AACDC,EAAAA,SAAS,CAACC,MAAD,EAAS;AAChB,UAAMC,KAAK,GAAG,IAAd;;AACA,aAASC,UAAT,CAAoBC,QAApB,EAA8BC,OAA9B,EAAuC;AACrC,YAAMC,iBAAiB,GAAG,IAAI3B,mBAAJ,CAAwB;AAChD4B,QAAAA,KAAK,EAAE,QADyC;AAEhDC,QAAAA,SAAS,EAAE,IAFqC;AAGhDC,QAAAA,YAAY,EAAE,IAHkC;AAIhDC,QAAAA,YAAY,EAAE;AAJkC,OAAxB,CAA1B;AAMA,YAAMC,eAAe,GAAG,IAAIhC,mBAAJ,CAAwB;AAC9C4B,QAAAA,KAAK,EAAE,QADuC;AAE9CC,QAAAA,SAAS,EAAE,KAFmC;AAG9CI,QAAAA,GAAG,EAAEP,OAHyC;AAI9CI,QAAAA,YAAY,EAAE,IAJgC;AAK9CC,QAAAA,YAAY,EAAE;AALgC,OAAxB,CAAxB;AAOA,YAAMG,IAAI,GAAG,IAAIjC,IAAJ,CAASwB,QAAT,EAAmBO,eAAnB,CAAb;AACAE,MAAAA,IAAI,CAACC,QAAL,CAAcC,CAAd,GAAkB,CAACC,IAAI,CAACC,EAAN,GAAW,CAA7B;AACAJ,MAAAA,IAAI,CAACK,UAAL,GAAkB,IAAlB;AACAL,MAAAA,IAAI,CAACM,aAAL,GAAqB,IAArB;AACAN,MAAAA,IAAI,CAACF,eAAL,GAAuBA,eAAvB;AACAE,MAAAA,IAAI,CAACP,iBAAL,GAAyBA,iBAAzB;AACA,aAAOO,IAAP;AACD;;AACD,aAASO,YAAT,CAAsBC,OAAtB,EAA+BC,WAA/B,EAA4C;AAC1C,YAAMC,aAAa,GAAG,IAAI1C,aAAJ,EAAtB;AACA,YAAM2C,QAAQ,GAAG,EAAjB;;AACA,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,WAAW,CAACI,MAAhC,EAAwCD,CAAC,EAAzC,EAA6C;AAC3CD,QAAAA,QAAQ,CAACC,CAAD,CAAR,GAAcF,aAAa,CAACI,IAAd,CAAmBN,OAAO,GAAGC,WAAW,CAACG,CAAD,CAAxC,EAA6CG,oBAA7C,CAAd;AACAJ,QAAAA,QAAQ,CAACC,CAAD,CAAR,CAAYI,OAAZ,GAAsB/C,SAAtB;AACA0C,QAAAA,QAAQ,CAACC,CAAD,CAAR,CAAYK,IAAZ,GAAmBR,WAAW,CAACG,CAAD,CAA9B;AACA,YAAI,gBAAgBD,QAAQ,CAACC,CAAD,CAA5B,EACED,QAAQ,CAACC,CAAD,CAAR,CAAYM,UAAZ,GAAyB,MAAzB,CADF,KAGEP,QAAQ,CAACC,CAAD,CAAR,CAAYO,QAAZ,GAAuB,IAAvB;AACH;;AACD,aAAOR,QAAP;AACD;;AACD,aAASI,oBAAT,GAAgC;AAC9B1B,MAAAA,KAAK,CAACH,WAAN,IAAqB,CAArB;AACA,UAAIG,KAAK,CAACH,WAAN,KAAsB,CAA1B,EACEG,KAAK,CAACJ,cAAN;AACH;;AACD,SAAKC,WAAL,GAAmBE,MAAM,CAACN,OAAP,CAAe+B,MAAf,GAAwB,CAAxB,GAA4BzB,MAAM,CAACgC,KAAP,CAAaP,MAAzC,GAAkD,CAArE;AACA,UAAMQ,eAAe,GAAG,EAAxB;;AACA,SAAK,IAAIT,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGxB,MAAM,CAACN,OAAP,CAAe+B,MAAnC,EAA2CD,CAAC,EAA5C,EACES,eAAe,CAACT,CAAD,CAAf,GAAqBxB,MAAM,CAACN,OAAP,CAAe8B,CAAf,EAAkB,CAAlB,CAArB;;AACF,SAAKhC,SAAL,GAAiB2B,YAAY,CAACnB,MAAM,CAACoB,OAAP,GAAiB,QAAlB,EAA4BpB,MAAM,CAACgC,KAAnC,CAA7B;AACA,SAAKvC,WAAL,GAAmB0B,YAAY,CAACnB,MAAM,CAACoB,OAAP,GAAiB,QAAlB,EAA4Ba,eAA5B,CAA/B;AACA,UAAMC,MAAM,GAAG,IAAIlD,SAAJ,EAAf;AACAkD,IAAAA,MAAM,CAACR,IAAP,CAAY1B,MAAM,CAACoB,OAAP,GAAiBpB,MAAM,CAACmC,IAApC,EAA0C,UAASC,GAAT,EAAc;AACtD,YAAMC,WAAW,GAAG,IAAIvD,IAAJ,EAApB;AACAuD,MAAAA,WAAW,CAACC,sBAAZ,CAAmCF,GAAG,CAACG,UAAJ,CAAeC,QAAlD;AACAvC,MAAAA,KAAK,CAACZ,IAAN,CAAWmD,QAAX,CAAoB1B,CAApB,GAAwB,CAACb,KAAK,CAACd,KAAP,GAAekD,WAAW,CAACI,GAAZ,CAAgB3B,CAAvD;AACA,YAAMF,IAAI,GAAGV,UAAU,CAACkC,GAAD,EAAMnC,KAAK,CAACT,SAAN,CAAgB,CAAhB,CAAN,CAAvB;AACAoB,MAAAA,IAAI,CAACzB,KAAL,CAAWuD,GAAX,CAAezC,KAAK,CAACd,KAArB,EAA4Bc,KAAK,CAACd,KAAlC,EAAyCc,KAAK,CAACd,KAA/C;AACAc,MAAAA,KAAK,CAACZ,IAAN,CAAWsD,GAAX,CAAe/B,IAAf;AACAX,MAAAA,KAAK,CAACX,QAAN,GAAiBsB,IAAjB;AACAX,MAAAA,KAAK,CAACX,QAAN,CAAesD,UAAf,GAA4B,CAA5B;AACA3C,MAAAA,KAAK,CAAC4C,uBAAN,GAAgCjC,IAAI,CAACT,QAAL,CAAc2C,UAAd,CAAyB,CAAzB,EAA4BjB,IAA5D;AACA5B,MAAAA,KAAK,CAACL,KAAN,GAAc,IAAIb,cAAJ,CAAmB6B,IAAnB,CAAd;AACAe,MAAAA,oBAAoB;AACrB,KAZD;;AAaA,UAAMoB,gBAAgB,GAAG,UAASC,KAAT,EAAgBnB,IAAhB,EAAsB;AAC7C,aAAO,UAASO,GAAT,EAAc;AACnB,cAAMxB,IAAI,GAAGV,UAAU,CAACkC,GAAD,EAAMnC,KAAK,CAACR,WAAN,CAAkBuD,KAAlB,CAAN,CAAvB;AACApC,QAAAA,IAAI,CAACzB,KAAL,CAAWuD,GAAX,CAAezC,KAAK,CAACd,KAArB,EAA4Bc,KAAK,CAACd,KAAlC,EAAyCc,KAAK,CAACd,KAA/C;AACAyB,QAAAA,IAAI,CAACqC,OAAL,GAAe,KAAf;AACArC,QAAAA,IAAI,CAACiB,IAAL,GAAYA,IAAZ;AACA5B,QAAAA,KAAK,CAACZ,IAAN,CAAWsD,GAAX,CAAe/B,IAAf;AACAX,QAAAA,KAAK,CAACP,OAAN,CAAcsD,KAAd,IAAuBpC,IAAvB;AACAX,QAAAA,KAAK,CAACV,UAAN,GAAmBqB,IAAnB;AACAe,QAAAA,oBAAoB;AACrB,OATD;AAUD,KAXD;;AAYA,SAAK,IAAIH,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGxB,MAAM,CAACN,OAAP,CAAe+B,MAAnC,EAA2CD,CAAC,EAA5C,EAAgD;AAC9CU,MAAAA,MAAM,CAACR,IAAP,CAAY1B,MAAM,CAACoB,OAAP,GAAiBpB,MAAM,CAACN,OAAP,CAAe8B,CAAf,EAAkB,CAAlB,CAA7B,EAAmDuB,gBAAgB,CAACvB,CAAD,EAAIxB,MAAM,CAACN,OAAP,CAAe8B,CAAf,EAAkB,CAAlB,CAAJ,CAAnE;AACD;AACF;;AACD0B,EAAAA,eAAe,CAACC,IAAD,EAAO;AACpB,QAAIA,IAAI,KAAK,CAAb,EAAgB;AACd,WAAKvD,KAAL,CAAWwD,SAAX,GAAuB,IAAID,IAA3B;AACD,KAFD,MAEO;AACL,WAAKvD,KAAL,CAAWwD,SAAX,GAAuB,CAAvB;AACD;AACF;;AACDC,EAAAA,YAAY,CAACC,gBAAD,EAAmB;AAC7B,QAAIA,gBAAJ,EAAsB;AACpB,UAAI,KAAKhE,QAAT,EACE,KAAKA,QAAL,CAAciE,QAAd,GAAyB,KAAKjE,QAAL,CAAce,iBAAvC;AACF,UAAI,KAAKd,UAAT,EACE,KAAKA,UAAL,CAAgBgE,QAAhB,GAA2B,KAAKhE,UAAL,CAAgBc,iBAA3C;AACH,KALD,MAKO;AACL,UAAI,KAAKf,QAAT,EACE,KAAKA,QAAL,CAAciE,QAAd,GAAyB,KAAKjE,QAAL,CAAcoB,eAAvC;AACF,UAAI,KAAKnB,UAAT,EACE,KAAKA,UAAL,CAAgBgE,QAAhB,GAA2B,KAAKhE,UAAL,CAAgBmB,eAA3C;AACH;AACF;;AACD8C,EAAAA,OAAO,CAACR,KAAD,EAAQ;AACb,QAAI,KAAK1D,QAAL,IAAiB,KAAKA,QAAL,CAAciE,QAAd,CAAuBhD,SAAvB,KAAqC,KAA1D,EAAiE;AAC/D,WAAKjB,QAAL,CAAciE,QAAd,CAAuB5C,GAAvB,GAA6B,KAAKnB,SAAL,CAAewD,KAAf,CAA7B;AACD;AACF;;AACDS,EAAAA,SAAS,CAACT,KAAD,EAAQ;AACf,SAAK,IAAIxB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAK9B,OAAL,CAAa+B,MAAjC,EAAyCD,CAAC,EAA1C,EACE,KAAK9B,OAAL,CAAa8B,CAAb,EAAgByB,OAAhB,GAA0B,KAA1B;;AACF,UAAMS,YAAY,GAAG,KAAKhE,OAAL,CAAasD,KAAb,CAArB;;AACA,QAAIU,YAAJ,EAAkB;AAChBA,MAAAA,YAAY,CAACT,OAAb,GAAuB,IAAvB;AACA,WAAK1D,UAAL,GAAkBmE,YAAlB;AACA,WAAKC,mBAAL;AACD;AACF;;AACDC,EAAAA,YAAY,CAACC,QAAD,EAAW;AACrB,QAAI,KAAKvE,QAAT,EAAmB;AACjB,UAAI,KAAKA,QAAL,CAAcwE,YAAlB,EAAgC;AAC9B,aAAKxE,QAAL,CAAcwE,YAAd,CAA2BC,IAA3B;AACA,aAAKzE,QAAL,CAAcwE,YAAd,GAA6B,IAA7B;AACD;;AACD,YAAME,MAAM,GAAG,KAAKpE,KAAL,CAAWqE,UAAX,CAAsBJ,QAAtB,EAAgC,KAAKvE,QAArC,CAAf;;AACA,UAAI0E,MAAJ,EAAY;AACV,aAAK1E,QAAL,CAAcwE,YAAd,GAA6BE,MAAM,CAACE,IAAP,EAA7B;AACD;AACF;;AACD,SAAKC,cAAL,GAAsBN,QAAtB;AACA,SAAKF,mBAAL;AACD;;AACDA,EAAAA,mBAAmB,GAAG;AACpB,UAAME,QAAQ,GAAG,KAAKM,cAAtB;;AACA,QAAI,KAAK5E,UAAT,EAAqB;AACnB,UAAI,KAAKA,UAAL,CAAgBuE,YAApB,EAAkC;AAChC,aAAKvE,UAAL,CAAgBuE,YAAhB,CAA6BC,IAA7B;AACA,aAAKxE,UAAL,CAAgBuE,YAAhB,GAA+B,IAA/B;AACD;;AACD,YAAME,MAAM,GAAG,KAAKpE,KAAL,CAAWqE,UAAX,CAAsBJ,QAAtB,EAAgC,KAAKtE,UAArC,CAAf;;AACA,UAAIyE,MAAJ,EAAY;AACV,aAAKzE,UAAL,CAAgBuE,YAAhB,GAA+BE,MAAM,CAACI,QAAP,CAAgB,KAAK9E,QAAL,CAAcwE,YAA9B,EAA4CI,IAA5C,EAA/B;AACD;AACF;AACF;;AACDG,EAAAA,MAAM,CAACC,KAAD,EAAQ;AACZ,QAAI,KAAK1E,KAAT,EACE,KAAKA,KAAL,CAAWyE,MAAX,CAAkBC,KAAlB;AACH;;AAhKgB;;AAkKnB,SACErF,YADF","sourcesContent":["import { Object3D, MeshLambertMaterial, Mesh, TextureLoader, UVMapping, Box3, AnimationMixer } from \"three\";\nimport { MD2Loader } from \"../loaders/MD2Loader.js\";\nclass MD2Character {\n  constructor() {\n    this.scale = 1;\n    this.animationFPS = 6;\n    this.root = new Object3D();\n    this.meshBody = null;\n    this.meshWeapon = null;\n    this.skinsBody = [];\n    this.skinsWeapon = [];\n    this.weapons = [];\n    this.activeAnimation = null;\n    this.mixer = null;\n    this.onLoadComplete = function() {\n    };\n    this.loadCounter = 0;\n  }\n  loadParts(config) {\n    const scope = this;\n    function createPart(geometry, skinMap) {\n      const materialWireframe = new MeshLambertMaterial({\n        color: 16755200,\n        wireframe: true,\n        morphTargets: true,\n        morphNormals: true\n      });\n      const materialTexture = new MeshLambertMaterial({\n        color: 16777215,\n        wireframe: false,\n        map: skinMap,\n        morphTargets: true,\n        morphNormals: true\n      });\n      const mesh = new Mesh(geometry, materialTexture);\n      mesh.rotation.y = -Math.PI / 2;\n      mesh.castShadow = true;\n      mesh.receiveShadow = true;\n      mesh.materialTexture = materialTexture;\n      mesh.materialWireframe = materialWireframe;\n      return mesh;\n    }\n    function loadTextures(baseUrl, textureUrls) {\n      const textureLoader = new TextureLoader();\n      const textures = [];\n      for (let i = 0; i < textureUrls.length; i++) {\n        textures[i] = textureLoader.load(baseUrl + textureUrls[i], checkLoadingComplete);\n        textures[i].mapping = UVMapping;\n        textures[i].name = textureUrls[i];\n        if (\"colorSpace\" in textures[i])\n          textures[i].colorSpace = \"srgb\";\n        else\n          textures[i].encoding = 3001;\n      }\n      return textures;\n    }\n    function checkLoadingComplete() {\n      scope.loadCounter -= 1;\n      if (scope.loadCounter === 0)\n        scope.onLoadComplete();\n    }\n    this.loadCounter = config.weapons.length * 2 + config.skins.length + 1;\n    const weaponsTextures = [];\n    for (let i = 0; i < config.weapons.length; i++)\n      weaponsTextures[i] = config.weapons[i][1];\n    this.skinsBody = loadTextures(config.baseUrl + \"skins/\", config.skins);\n    this.skinsWeapon = loadTextures(config.baseUrl + \"skins/\", weaponsTextures);\n    const loader = new MD2Loader();\n    loader.load(config.baseUrl + config.body, function(geo) {\n      const boundingBox = new Box3();\n      boundingBox.setFromBufferAttribute(geo.attributes.position);\n      scope.root.position.y = -scope.scale * boundingBox.min.y;\n      const mesh = createPart(geo, scope.skinsBody[0]);\n      mesh.scale.set(scope.scale, scope.scale, scope.scale);\n      scope.root.add(mesh);\n      scope.meshBody = mesh;\n      scope.meshBody.clipOffset = 0;\n      scope.activeAnimationClipName = mesh.geometry.animations[0].name;\n      scope.mixer = new AnimationMixer(mesh);\n      checkLoadingComplete();\n    });\n    const generateCallback = function(index, name) {\n      return function(geo) {\n        const mesh = createPart(geo, scope.skinsWeapon[index]);\n        mesh.scale.set(scope.scale, scope.scale, scope.scale);\n        mesh.visible = false;\n        mesh.name = name;\n        scope.root.add(mesh);\n        scope.weapons[index] = mesh;\n        scope.meshWeapon = mesh;\n        checkLoadingComplete();\n      };\n    };\n    for (let i = 0; i < config.weapons.length; i++) {\n      loader.load(config.baseUrl + config.weapons[i][0], generateCallback(i, config.weapons[i][0]));\n    }\n  }\n  setPlaybackRate(rate) {\n    if (rate !== 0) {\n      this.mixer.timeScale = 1 / rate;\n    } else {\n      this.mixer.timeScale = 0;\n    }\n  }\n  setWireframe(wireframeEnabled) {\n    if (wireframeEnabled) {\n      if (this.meshBody)\n        this.meshBody.material = this.meshBody.materialWireframe;\n      if (this.meshWeapon)\n        this.meshWeapon.material = this.meshWeapon.materialWireframe;\n    } else {\n      if (this.meshBody)\n        this.meshBody.material = this.meshBody.materialTexture;\n      if (this.meshWeapon)\n        this.meshWeapon.material = this.meshWeapon.materialTexture;\n    }\n  }\n  setSkin(index) {\n    if (this.meshBody && this.meshBody.material.wireframe === false) {\n      this.meshBody.material.map = this.skinsBody[index];\n    }\n  }\n  setWeapon(index) {\n    for (let i = 0; i < this.weapons.length; i++)\n      this.weapons[i].visible = false;\n    const activeWeapon = this.weapons[index];\n    if (activeWeapon) {\n      activeWeapon.visible = true;\n      this.meshWeapon = activeWeapon;\n      this.syncWeaponAnimation();\n    }\n  }\n  setAnimation(clipName) {\n    if (this.meshBody) {\n      if (this.meshBody.activeAction) {\n        this.meshBody.activeAction.stop();\n        this.meshBody.activeAction = null;\n      }\n      const action = this.mixer.clipAction(clipName, this.meshBody);\n      if (action) {\n        this.meshBody.activeAction = action.play();\n      }\n    }\n    this.activeClipName = clipName;\n    this.syncWeaponAnimation();\n  }\n  syncWeaponAnimation() {\n    const clipName = this.activeClipName;\n    if (this.meshWeapon) {\n      if (this.meshWeapon.activeAction) {\n        this.meshWeapon.activeAction.stop();\n        this.meshWeapon.activeAction = null;\n      }\n      const action = this.mixer.clipAction(clipName, this.meshWeapon);\n      if (action) {\n        this.meshWeapon.activeAction = action.syncWith(this.meshBody.activeAction).play();\n      }\n    }\n  }\n  update(delta) {\n    if (this.mixer)\n      this.mixer.update(delta);\n  }\n}\nexport {\n  MD2Character\n};\n"]},"metadata":{},"sourceType":"module"}