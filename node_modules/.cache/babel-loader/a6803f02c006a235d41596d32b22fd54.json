{"ast":null,"code":"import _get from \"/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _classCallCheck from \"/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { Quaternion, Vector3, Matrix4, Object3D, SphereGeometry, MeshBasicMaterial, Color, LineBasicMaterial, BufferGeometry, BufferAttribute, Mesh, Line } from \"three\";\n\nvar _q = /* @__PURE__ */new Quaternion();\n\nvar _targetPos = /* @__PURE__ */new Vector3();\n\nvar _targetVec = /* @__PURE__ */new Vector3();\n\nvar _effectorPos = /* @__PURE__ */new Vector3();\n\nvar _effectorVec = /* @__PURE__ */new Vector3();\n\nvar _linkPos = /* @__PURE__ */new Vector3();\n\nvar _invLinkQ = /* @__PURE__ */new Quaternion();\n\nvar _linkScale = /* @__PURE__ */new Vector3();\n\nvar _axis = /* @__PURE__ */new Vector3();\n\nvar _vector = /* @__PURE__ */new Vector3();\n\nvar _matrix = /* @__PURE__ */new Matrix4();\n\nvar CCDIKSolver = /*#__PURE__*/function () {\n  /**\n   * @param {THREE.SkinnedMesh} mesh\n   * @param {Array<Object>} iks\n   */\n  function CCDIKSolver(mesh) {\n    var iks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n    _classCallCheck(this, CCDIKSolver);\n\n    this.mesh = mesh;\n    this.iks = iks;\n\n    this._valid();\n  }\n  /**\n   * Update all IK bones.\n   *\n   * @return {CCDIKSolver}\n   */\n\n\n  _createClass(CCDIKSolver, [{\n    key: \"update\",\n    value: function update() {\n      var iks = this.iks;\n\n      for (var i = 0, il = iks.length; i < il; i++) {\n        this.updateOne(iks[i]);\n      }\n\n      return this;\n    }\n    /**\n     * Update one IK bone\n     *\n     * @param {Object} ik parameter\n     * @return {CCDIKSolver}\n     */\n\n  }, {\n    key: \"updateOne\",\n    value: function updateOne(ik) {\n      var bones = this.mesh.skeleton.bones;\n      var math = Math;\n      var effector = bones[ik.effector];\n      var target = bones[ik.target];\n\n      _targetPos.setFromMatrixPosition(target.matrixWorld);\n\n      var links = ik.links;\n      var iteration = ik.iteration !== void 0 ? ik.iteration : 1;\n\n      for (var i = 0; i < iteration; i++) {\n        var rotated = false;\n\n        for (var j = 0, jl = links.length; j < jl; j++) {\n          var link = bones[links[j].index];\n          if (links[j].enabled === false) break;\n          var limitation = links[j].limitation;\n          var rotationMin = links[j].rotationMin;\n          var rotationMax = links[j].rotationMax;\n          link.matrixWorld.decompose(_linkPos, _invLinkQ, _linkScale);\n\n          _invLinkQ.invert();\n\n          _effectorPos.setFromMatrixPosition(effector.matrixWorld);\n\n          _effectorVec.subVectors(_effectorPos, _linkPos);\n\n          _effectorVec.applyQuaternion(_invLinkQ);\n\n          _effectorVec.normalize();\n\n          _targetVec.subVectors(_targetPos, _linkPos);\n\n          _targetVec.applyQuaternion(_invLinkQ);\n\n          _targetVec.normalize();\n\n          var angle = _targetVec.dot(_effectorVec);\n\n          if (angle > 1) {\n            angle = 1;\n          } else if (angle < -1) {\n            angle = -1;\n          }\n\n          angle = math.acos(angle);\n          if (angle < 1e-5) continue;\n\n          if (ik.minAngle !== void 0 && angle < ik.minAngle) {\n            angle = ik.minAngle;\n          }\n\n          if (ik.maxAngle !== void 0 && angle > ik.maxAngle) {\n            angle = ik.maxAngle;\n          }\n\n          _axis.crossVectors(_effectorVec, _targetVec);\n\n          _axis.normalize();\n\n          _q.setFromAxisAngle(_axis, angle);\n\n          link.quaternion.multiply(_q);\n\n          if (limitation !== void 0) {\n            var c = link.quaternion.w;\n            if (c > 1) c = 1;\n            var c2 = math.sqrt(1 - c * c);\n            link.quaternion.set(limitation.x * c2, limitation.y * c2, limitation.z * c2, c);\n          }\n\n          if (rotationMin !== void 0) {\n            link.rotation.setFromVector3(_vector.setFromEuler(link.rotation).max(rotationMin));\n          }\n\n          if (rotationMax !== void 0) {\n            link.rotation.setFromVector3(_vector.setFromEuler(link.rotation).min(rotationMax));\n          }\n\n          link.updateMatrixWorld(true);\n          rotated = true;\n        }\n\n        if (!rotated) break;\n      }\n\n      return this;\n    }\n    /**\n     * Creates Helper\n     *\n     * @return {CCDIKHelper}\n     */\n\n  }, {\n    key: \"createHelper\",\n    value: function createHelper() {\n      return new CCDIKHelper(this.mesh, this.iks);\n    } // private methods\n\n  }, {\n    key: \"_valid\",\n    value: function _valid() {\n      var iks = this.iks;\n      var bones = this.mesh.skeleton.bones;\n\n      for (var i = 0, il = iks.length; i < il; i++) {\n        var ik = iks[i];\n        var effector = bones[ik.effector];\n        var links = ik.links;\n        var link0 = void 0,\n            link1 = void 0;\n        link0 = effector;\n\n        for (var j = 0, jl = links.length; j < jl; j++) {\n          link1 = bones[links[j].index];\n\n          if (link0.parent !== link1) {\n            console.warn(\"THREE.CCDIKSolver: bone \" + link0.name + \" is not the child of bone \" + link1.name);\n          }\n\n          link0 = link1;\n        }\n      }\n    }\n  }]);\n\n  return CCDIKSolver;\n}();\n\nfunction getPosition(bone, matrixWorldInv) {\n  return _vector.setFromMatrixPosition(bone.matrixWorld).applyMatrix4(matrixWorldInv);\n}\n\nfunction setPositionOfBoneToAttributeArray(array, index, bone, matrixWorldInv) {\n  var v = getPosition(bone, matrixWorldInv);\n  array[index * 3 + 0] = v.x;\n  array[index * 3 + 1] = v.y;\n  array[index * 3 + 2] = v.z;\n}\n\nvar CCDIKHelper = /*#__PURE__*/function (_Object3D) {\n  _inherits(CCDIKHelper, _Object3D);\n\n  var _super = _createSuper(CCDIKHelper);\n\n  function CCDIKHelper(mesh) {\n    var _this;\n\n    var iks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    var sphereSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.25;\n\n    _classCallCheck(this, CCDIKHelper);\n\n    _this = _super.call(this);\n    _this.root = mesh;\n    _this.iks = iks;\n\n    _this.matrix.copy(mesh.matrixWorld);\n\n    _this.matrixAutoUpdate = false;\n    _this.sphereGeometry = new SphereGeometry(sphereSize, 16, 8);\n    _this.targetSphereMaterial = new MeshBasicMaterial({\n      color: new Color(16746632),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    _this.effectorSphereMaterial = new MeshBasicMaterial({\n      color: new Color(8978312),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    _this.linkSphereMaterial = new MeshBasicMaterial({\n      color: new Color(8947967),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    _this.lineMaterial = new LineBasicMaterial({\n      color: new Color(16711680),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n\n    _this._init();\n\n    return _this;\n  }\n  /**\n   * Updates IK bones visualization.\n   */\n\n\n  _createClass(CCDIKHelper, [{\n    key: \"updateMatrixWorld\",\n    value: function updateMatrixWorld(force) {\n      var mesh = this.root;\n\n      if (this.visible) {\n        var offset = 0;\n        var iks = this.iks;\n        var bones = mesh.skeleton.bones;\n\n        _matrix.copy(mesh.matrixWorld).invert();\n\n        for (var i = 0, il = iks.length; i < il; i++) {\n          var ik = iks[i];\n          var targetBone = bones[ik.target];\n          var effectorBone = bones[ik.effector];\n          var targetMesh = this.children[offset++];\n          var effectorMesh = this.children[offset++];\n          targetMesh.position.copy(getPosition(targetBone, _matrix));\n          effectorMesh.position.copy(getPosition(effectorBone, _matrix));\n\n          for (var j = 0, jl = ik.links.length; j < jl; j++) {\n            var link = ik.links[j];\n            var linkBone = bones[link.index];\n            var linkMesh = this.children[offset++];\n            linkMesh.position.copy(getPosition(linkBone, _matrix));\n          }\n\n          var line = this.children[offset++];\n          var array = line.geometry.attributes.position.array;\n          setPositionOfBoneToAttributeArray(array, 0, targetBone, _matrix);\n          setPositionOfBoneToAttributeArray(array, 1, effectorBone, _matrix);\n\n          for (var _j = 0, _jl = ik.links.length; _j < _jl; _j++) {\n            var _link = ik.links[_j];\n            var _linkBone = bones[_link.index];\n            setPositionOfBoneToAttributeArray(array, _j + 2, _linkBone, _matrix);\n          }\n\n          line.geometry.attributes.position.needsUpdate = true;\n        }\n      }\n\n      this.matrix.copy(mesh.matrixWorld);\n\n      _get(_getPrototypeOf(CCDIKHelper.prototype), \"updateMatrixWorld\", this).call(this, force);\n    }\n    /**\n     * Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app.\n     */\n\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.sphereGeometry.dispose();\n      this.targetSphereMaterial.dispose();\n      this.effectorSphereMaterial.dispose();\n      this.linkSphereMaterial.dispose();\n      this.lineMaterial.dispose();\n      var children = this.children;\n\n      for (var i = 0; i < children.length; i++) {\n        var child = children[i];\n        if (child.isLine) child.geometry.dispose();\n      }\n    } // private method\n\n  }, {\n    key: \"_init\",\n    value: function _init() {\n      var scope = this;\n      var iks = this.iks;\n\n      function createLineGeometry(ik) {\n        var geometry = new BufferGeometry();\n        var vertices = new Float32Array((2 + ik.links.length) * 3);\n        geometry.setAttribute(\"position\", new BufferAttribute(vertices, 3));\n        return geometry;\n      }\n\n      function createTargetMesh() {\n        return new Mesh(scope.sphereGeometry, scope.targetSphereMaterial);\n      }\n\n      function createEffectorMesh() {\n        return new Mesh(scope.sphereGeometry, scope.effectorSphereMaterial);\n      }\n\n      function createLinkMesh() {\n        return new Mesh(scope.sphereGeometry, scope.linkSphereMaterial);\n      }\n\n      function createLine(ik) {\n        return new Line(createLineGeometry(ik), scope.lineMaterial);\n      }\n\n      for (var i = 0, il = iks.length; i < il; i++) {\n        var ik = iks[i];\n        this.add(createTargetMesh());\n        this.add(createEffectorMesh());\n\n        for (var j = 0, jl = ik.links.length; j < jl; j++) {\n          this.add(createLinkMesh());\n        }\n\n        this.add(createLine(ik));\n      }\n    }\n  }]);\n\n  return CCDIKHelper;\n}(Object3D);\n\nexport { CCDIKHelper, CCDIKSolver };","map":{"version":3,"sources":["/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/three-stdlib/animation/CCDIKSolver.js"],"names":["Quaternion","Vector3","Matrix4","Object3D","SphereGeometry","MeshBasicMaterial","Color","LineBasicMaterial","BufferGeometry","BufferAttribute","Mesh","Line","_q","_targetPos","_targetVec","_effectorPos","_effectorVec","_linkPos","_invLinkQ","_linkScale","_axis","_vector","_matrix","CCDIKSolver","mesh","iks","_valid","i","il","length","updateOne","ik","bones","skeleton","math","Math","effector","target","setFromMatrixPosition","matrixWorld","links","iteration","rotated","j","jl","link","index","enabled","limitation","rotationMin","rotationMax","decompose","invert","subVectors","applyQuaternion","normalize","angle","dot","acos","minAngle","maxAngle","crossVectors","setFromAxisAngle","quaternion","multiply","c","w","c2","sqrt","set","x","y","z","rotation","setFromVector3","setFromEuler","max","min","updateMatrixWorld","CCDIKHelper","link0","link1","parent","console","warn","name","getPosition","bone","matrixWorldInv","applyMatrix4","setPositionOfBoneToAttributeArray","array","v","sphereSize","root","matrix","copy","matrixAutoUpdate","sphereGeometry","targetSphereMaterial","color","depthTest","depthWrite","transparent","effectorSphereMaterial","linkSphereMaterial","lineMaterial","_init","force","visible","offset","targetBone","effectorBone","targetMesh","children","effectorMesh","position","linkBone","linkMesh","line","geometry","attributes","needsUpdate","dispose","child","isLine","scope","createLineGeometry","vertices","Float32Array","setAttribute","createTargetMesh","createEffectorMesh","createLinkMesh","createLine","add"],"mappings":"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","sourcesContent":["import { Quaternion, Vector3, Matrix4, Object3D, SphereGeometry, MeshBasicMaterial, Color, LineBasicMaterial, BufferGeometry, BufferAttribute, Mesh, Line } from \"three\";\nconst _q = /* @__PURE__ */ new Quaternion();\nconst _targetPos = /* @__PURE__ */ new Vector3();\nconst _targetVec = /* @__PURE__ */ new Vector3();\nconst _effectorPos = /* @__PURE__ */ new Vector3();\nconst _effectorVec = /* @__PURE__ */ new Vector3();\nconst _linkPos = /* @__PURE__ */ new Vector3();\nconst _invLinkQ = /* @__PURE__ */ new Quaternion();\nconst _linkScale = /* @__PURE__ */ new Vector3();\nconst _axis = /* @__PURE__ */ new Vector3();\nconst _vector = /* @__PURE__ */ new Vector3();\nconst _matrix = /* @__PURE__ */ new Matrix4();\nclass CCDIKSolver {\n  /**\n   * @param {THREE.SkinnedMesh} mesh\n   * @param {Array<Object>} iks\n   */\n  constructor(mesh, iks = []) {\n    this.mesh = mesh;\n    this.iks = iks;\n    this._valid();\n  }\n  /**\n   * Update all IK bones.\n   *\n   * @return {CCDIKSolver}\n   */\n  update() {\n    const iks = this.iks;\n    for (let i = 0, il = iks.length; i < il; i++) {\n      this.updateOne(iks[i]);\n    }\n    return this;\n  }\n  /**\n   * Update one IK bone\n   *\n   * @param {Object} ik parameter\n   * @return {CCDIKSolver}\n   */\n  updateOne(ik) {\n    const bones = this.mesh.skeleton.bones;\n    const math = Math;\n    const effector = bones[ik.effector];\n    const target = bones[ik.target];\n    _targetPos.setFromMatrixPosition(target.matrixWorld);\n    const links = ik.links;\n    const iteration = ik.iteration !== void 0 ? ik.iteration : 1;\n    for (let i = 0; i < iteration; i++) {\n      let rotated = false;\n      for (let j = 0, jl = links.length; j < jl; j++) {\n        const link = bones[links[j].index];\n        if (links[j].enabled === false)\n          break;\n        const limitation = links[j].limitation;\n        const rotationMin = links[j].rotationMin;\n        const rotationMax = links[j].rotationMax;\n        link.matrixWorld.decompose(_linkPos, _invLinkQ, _linkScale);\n        _invLinkQ.invert();\n        _effectorPos.setFromMatrixPosition(effector.matrixWorld);\n        _effectorVec.subVectors(_effectorPos, _linkPos);\n        _effectorVec.applyQuaternion(_invLinkQ);\n        _effectorVec.normalize();\n        _targetVec.subVectors(_targetPos, _linkPos);\n        _targetVec.applyQuaternion(_invLinkQ);\n        _targetVec.normalize();\n        let angle = _targetVec.dot(_effectorVec);\n        if (angle > 1) {\n          angle = 1;\n        } else if (angle < -1) {\n          angle = -1;\n        }\n        angle = math.acos(angle);\n        if (angle < 1e-5)\n          continue;\n        if (ik.minAngle !== void 0 && angle < ik.minAngle) {\n          angle = ik.minAngle;\n        }\n        if (ik.maxAngle !== void 0 && angle > ik.maxAngle) {\n          angle = ik.maxAngle;\n        }\n        _axis.crossVectors(_effectorVec, _targetVec);\n        _axis.normalize();\n        _q.setFromAxisAngle(_axis, angle);\n        link.quaternion.multiply(_q);\n        if (limitation !== void 0) {\n          let c = link.quaternion.w;\n          if (c > 1)\n            c = 1;\n          const c2 = math.sqrt(1 - c * c);\n          link.quaternion.set(limitation.x * c2, limitation.y * c2, limitation.z * c2, c);\n        }\n        if (rotationMin !== void 0) {\n          link.rotation.setFromVector3(_vector.setFromEuler(link.rotation).max(rotationMin));\n        }\n        if (rotationMax !== void 0) {\n          link.rotation.setFromVector3(_vector.setFromEuler(link.rotation).min(rotationMax));\n        }\n        link.updateMatrixWorld(true);\n        rotated = true;\n      }\n      if (!rotated)\n        break;\n    }\n    return this;\n  }\n  /**\n   * Creates Helper\n   *\n   * @return {CCDIKHelper}\n   */\n  createHelper() {\n    return new CCDIKHelper(this.mesh, this.iks);\n  }\n  // private methods\n  _valid() {\n    const iks = this.iks;\n    const bones = this.mesh.skeleton.bones;\n    for (let i = 0, il = iks.length; i < il; i++) {\n      const ik = iks[i];\n      const effector = bones[ik.effector];\n      const links = ik.links;\n      let link0, link1;\n      link0 = effector;\n      for (let j = 0, jl = links.length; j < jl; j++) {\n        link1 = bones[links[j].index];\n        if (link0.parent !== link1) {\n          console.warn(\"THREE.CCDIKSolver: bone \" + link0.name + \" is not the child of bone \" + link1.name);\n        }\n        link0 = link1;\n      }\n    }\n  }\n}\nfunction getPosition(bone, matrixWorldInv) {\n  return _vector.setFromMatrixPosition(bone.matrixWorld).applyMatrix4(matrixWorldInv);\n}\nfunction setPositionOfBoneToAttributeArray(array, index, bone, matrixWorldInv) {\n  const v = getPosition(bone, matrixWorldInv);\n  array[index * 3 + 0] = v.x;\n  array[index * 3 + 1] = v.y;\n  array[index * 3 + 2] = v.z;\n}\nclass CCDIKHelper extends Object3D {\n  constructor(mesh, iks = [], sphereSize = 0.25) {\n    super();\n    this.root = mesh;\n    this.iks = iks;\n    this.matrix.copy(mesh.matrixWorld);\n    this.matrixAutoUpdate = false;\n    this.sphereGeometry = new SphereGeometry(sphereSize, 16, 8);\n    this.targetSphereMaterial = new MeshBasicMaterial({\n      color: new Color(16746632),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    this.effectorSphereMaterial = new MeshBasicMaterial({\n      color: new Color(8978312),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    this.linkSphereMaterial = new MeshBasicMaterial({\n      color: new Color(8947967),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    this.lineMaterial = new LineBasicMaterial({\n      color: new Color(16711680),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    this._init();\n  }\n  /**\n   * Updates IK bones visualization.\n   */\n  updateMatrixWorld(force) {\n    const mesh = this.root;\n    if (this.visible) {\n      let offset = 0;\n      const iks = this.iks;\n      const bones = mesh.skeleton.bones;\n      _matrix.copy(mesh.matrixWorld).invert();\n      for (let i = 0, il = iks.length; i < il; i++) {\n        const ik = iks[i];\n        const targetBone = bones[ik.target];\n        const effectorBone = bones[ik.effector];\n        const targetMesh = this.children[offset++];\n        const effectorMesh = this.children[offset++];\n        targetMesh.position.copy(getPosition(targetBone, _matrix));\n        effectorMesh.position.copy(getPosition(effectorBone, _matrix));\n        for (let j = 0, jl = ik.links.length; j < jl; j++) {\n          const link = ik.links[j];\n          const linkBone = bones[link.index];\n          const linkMesh = this.children[offset++];\n          linkMesh.position.copy(getPosition(linkBone, _matrix));\n        }\n        const line = this.children[offset++];\n        const array = line.geometry.attributes.position.array;\n        setPositionOfBoneToAttributeArray(array, 0, targetBone, _matrix);\n        setPositionOfBoneToAttributeArray(array, 1, effectorBone, _matrix);\n        for (let j = 0, jl = ik.links.length; j < jl; j++) {\n          const link = ik.links[j];\n          const linkBone = bones[link.index];\n          setPositionOfBoneToAttributeArray(array, j + 2, linkBone, _matrix);\n        }\n        line.geometry.attributes.position.needsUpdate = true;\n      }\n    }\n    this.matrix.copy(mesh.matrixWorld);\n    super.updateMatrixWorld(force);\n  }\n  /**\n   * Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app.\n   */\n  dispose() {\n    this.sphereGeometry.dispose();\n    this.targetSphereMaterial.dispose();\n    this.effectorSphereMaterial.dispose();\n    this.linkSphereMaterial.dispose();\n    this.lineMaterial.dispose();\n    const children = this.children;\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      if (child.isLine)\n        child.geometry.dispose();\n    }\n  }\n  // private method\n  _init() {\n    const scope = this;\n    const iks = this.iks;\n    function createLineGeometry(ik) {\n      const geometry = new BufferGeometry();\n      const vertices = new Float32Array((2 + ik.links.length) * 3);\n      geometry.setAttribute(\"position\", new BufferAttribute(vertices, 3));\n      return geometry;\n    }\n    function createTargetMesh() {\n      return new Mesh(scope.sphereGeometry, scope.targetSphereMaterial);\n    }\n    function createEffectorMesh() {\n      return new Mesh(scope.sphereGeometry, scope.effectorSphereMaterial);\n    }\n    function createLinkMesh() {\n      return new Mesh(scope.sphereGeometry, scope.linkSphereMaterial);\n    }\n    function createLine(ik) {\n      return new Line(createLineGeometry(ik), scope.lineMaterial);\n    }\n    for (let i = 0, il = iks.length; i < il; i++) {\n      const ik = iks[i];\n      this.add(createTargetMesh());\n      this.add(createEffectorMesh());\n      for (let j = 0, jl = ik.links.length; j < jl; j++) {\n        this.add(createLinkMesh());\n      }\n      this.add(createLine(ik));\n    }\n  }\n}\nexport {\n  CCDIKHelper,\n  CCDIKSolver\n};\n"]},"metadata":{},"sourceType":"module"}