{"ast":null,"code":"import { Triangle, Vector3 } from \"three\";\n\nconst _face = /* @__PURE__ */new Triangle();\n\nconst _color = /* @__PURE__ */new Vector3();\n\nclass MeshSurfaceSampler {\n  constructor(mesh) {\n    let geometry = mesh.geometry;\n\n    if (geometry.index) {\n      console.warn(\"THREE.MeshSurfaceSampler: Converting geometry to non-indexed BufferGeometry.\");\n      geometry = geometry.toNonIndexed();\n    }\n\n    this.geometry = geometry;\n    this.randomFunction = Math.random;\n    this.positionAttribute = this.geometry.getAttribute(\"position\");\n    this.colorAttribute = this.geometry.getAttribute(\"color\");\n    this.weightAttribute = null;\n    this.distribution = null;\n  }\n\n  setWeightAttribute(name) {\n    this.weightAttribute = name ? this.geometry.getAttribute(name) : null;\n    return this;\n  }\n\n  build() {\n    const positionAttribute = this.positionAttribute;\n    const weightAttribute = this.weightAttribute;\n    const faceWeights = new Float32Array(positionAttribute.count / 3);\n\n    for (let i = 0; i < positionAttribute.count; i += 3) {\n      let faceWeight = 1;\n\n      if (weightAttribute) {\n        faceWeight = weightAttribute.getX(i) + weightAttribute.getX(i + 1) + weightAttribute.getX(i + 2);\n      }\n\n      _face.a.fromBufferAttribute(positionAttribute, i);\n\n      _face.b.fromBufferAttribute(positionAttribute, i + 1);\n\n      _face.c.fromBufferAttribute(positionAttribute, i + 2);\n\n      faceWeight *= _face.getArea();\n      faceWeights[i / 3] = faceWeight;\n    }\n\n    this.distribution = new Float32Array(positionAttribute.count / 3);\n    let cumulativeTotal = 0;\n\n    for (let i = 0; i < faceWeights.length; i++) {\n      cumulativeTotal += faceWeights[i];\n      this.distribution[i] = cumulativeTotal;\n    }\n\n    return this;\n  }\n\n  setRandomGenerator(randomFunction) {\n    this.randomFunction = randomFunction;\n    return this;\n  }\n\n  sample(targetPosition, targetNormal, targetColor) {\n    const faceIndex = this.sampleFaceIndex();\n    return this.sampleFace(faceIndex, targetPosition, targetNormal, targetColor);\n  }\n\n  sampleFaceIndex() {\n    const cumulativeTotal = this.distribution[this.distribution.length - 1];\n    return this.binarySearch(this.randomFunction() * cumulativeTotal);\n  }\n\n  binarySearch(x) {\n    const dist = this.distribution;\n    let start = 0;\n    let end = dist.length - 1;\n    let index = -1;\n\n    while (start <= end) {\n      const mid = Math.ceil((start + end) / 2);\n\n      if (mid === 0 || dist[mid - 1] <= x && dist[mid] > x) {\n        index = mid;\n        break;\n      } else if (x < dist[mid]) {\n        end = mid - 1;\n      } else {\n        start = mid + 1;\n      }\n    }\n\n    return index;\n  }\n\n  sampleFace(faceIndex, targetPosition, targetNormal, targetColor) {\n    let u = this.randomFunction();\n    let v = this.randomFunction();\n\n    if (u + v > 1) {\n      u = 1 - u;\n      v = 1 - v;\n    }\n\n    _face.a.fromBufferAttribute(this.positionAttribute, faceIndex * 3);\n\n    _face.b.fromBufferAttribute(this.positionAttribute, faceIndex * 3 + 1);\n\n    _face.c.fromBufferAttribute(this.positionAttribute, faceIndex * 3 + 2);\n\n    targetPosition.set(0, 0, 0).addScaledVector(_face.a, u).addScaledVector(_face.b, v).addScaledVector(_face.c, 1 - (u + v));\n\n    if (targetNormal !== void 0) {\n      _face.getNormal(targetNormal);\n    }\n\n    if (targetColor !== void 0 && this.colorAttribute !== void 0) {\n      _face.a.fromBufferAttribute(this.colorAttribute, faceIndex * 3);\n\n      _face.b.fromBufferAttribute(this.colorAttribute, faceIndex * 3 + 1);\n\n      _face.c.fromBufferAttribute(this.colorAttribute, faceIndex * 3 + 2);\n\n      _color.set(0, 0, 0).addScaledVector(_face.a, u).addScaledVector(_face.b, v).addScaledVector(_face.c, 1 - (u + v));\n\n      targetColor.r = _color.x;\n      targetColor.g = _color.y;\n      targetColor.b = _color.z;\n    }\n\n    return this;\n  }\n\n}\n\nexport { MeshSurfaceSampler };","map":{"version":3,"sources":["/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/three-stdlib/math/MeshSurfaceSampler.js"],"names":["Triangle","Vector3","_face","_color","MeshSurfaceSampler","constructor","mesh","geometry","index","console","warn","toNonIndexed","randomFunction","Math","random","positionAttribute","getAttribute","colorAttribute","weightAttribute","distribution","setWeightAttribute","name","build","faceWeights","Float32Array","count","i","faceWeight","getX","a","fromBufferAttribute","b","c","getArea","cumulativeTotal","length","setRandomGenerator","sample","targetPosition","targetNormal","targetColor","faceIndex","sampleFaceIndex","sampleFace","binarySearch","x","dist","start","end","mid","ceil","u","v","set","addScaledVector","getNormal","r","g","y","z"],"mappings":"AAAA,SAASA,QAAT,EAAmBC,OAAnB,QAAkC,OAAlC;;AACA,MAAMC,KAAK,GAAG,eAAgB,IAAIF,QAAJ,EAA9B;;AACA,MAAMG,MAAM,GAAG,eAAgB,IAAIF,OAAJ,EAA/B;;AACA,MAAMG,kBAAN,CAAyB;AACvBC,EAAAA,WAAW,CAACC,IAAD,EAAO;AAChB,QAAIC,QAAQ,GAAGD,IAAI,CAACC,QAApB;;AACA,QAAIA,QAAQ,CAACC,KAAb,EAAoB;AAClBC,MAAAA,OAAO,CAACC,IAAR,CAAa,8EAAb;AACAH,MAAAA,QAAQ,GAAGA,QAAQ,CAACI,YAAT,EAAX;AACD;;AACD,SAAKJ,QAAL,GAAgBA,QAAhB;AACA,SAAKK,cAAL,GAAsBC,IAAI,CAACC,MAA3B;AACA,SAAKC,iBAAL,GAAyB,KAAKR,QAAL,CAAcS,YAAd,CAA2B,UAA3B,CAAzB;AACA,SAAKC,cAAL,GAAsB,KAAKV,QAAL,CAAcS,YAAd,CAA2B,OAA3B,CAAtB;AACA,SAAKE,eAAL,GAAuB,IAAvB;AACA,SAAKC,YAAL,GAAoB,IAApB;AACD;;AACDC,EAAAA,kBAAkB,CAACC,IAAD,EAAO;AACvB,SAAKH,eAAL,GAAuBG,IAAI,GAAG,KAAKd,QAAL,CAAcS,YAAd,CAA2BK,IAA3B,CAAH,GAAsC,IAAjE;AACA,WAAO,IAAP;AACD;;AACDC,EAAAA,KAAK,GAAG;AACN,UAAMP,iBAAiB,GAAG,KAAKA,iBAA/B;AACA,UAAMG,eAAe,GAAG,KAAKA,eAA7B;AACA,UAAMK,WAAW,GAAG,IAAIC,YAAJ,CAAiBT,iBAAiB,CAACU,KAAlB,GAA0B,CAA3C,CAApB;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGX,iBAAiB,CAACU,KAAtC,EAA6CC,CAAC,IAAI,CAAlD,EAAqD;AACnD,UAAIC,UAAU,GAAG,CAAjB;;AACA,UAAIT,eAAJ,EAAqB;AACnBS,QAAAA,UAAU,GAAGT,eAAe,CAACU,IAAhB,CAAqBF,CAArB,IAA0BR,eAAe,CAACU,IAAhB,CAAqBF,CAAC,GAAG,CAAzB,CAA1B,GAAwDR,eAAe,CAACU,IAAhB,CAAqBF,CAAC,GAAG,CAAzB,CAArE;AACD;;AACDxB,MAAAA,KAAK,CAAC2B,CAAN,CAAQC,mBAAR,CAA4Bf,iBAA5B,EAA+CW,CAA/C;;AACAxB,MAAAA,KAAK,CAAC6B,CAAN,CAAQD,mBAAR,CAA4Bf,iBAA5B,EAA+CW,CAAC,GAAG,CAAnD;;AACAxB,MAAAA,KAAK,CAAC8B,CAAN,CAAQF,mBAAR,CAA4Bf,iBAA5B,EAA+CW,CAAC,GAAG,CAAnD;;AACAC,MAAAA,UAAU,IAAIzB,KAAK,CAAC+B,OAAN,EAAd;AACAV,MAAAA,WAAW,CAACG,CAAC,GAAG,CAAL,CAAX,GAAqBC,UAArB;AACD;;AACD,SAAKR,YAAL,GAAoB,IAAIK,YAAJ,CAAiBT,iBAAiB,CAACU,KAAlB,GAA0B,CAA3C,CAApB;AACA,QAAIS,eAAe,GAAG,CAAtB;;AACA,SAAK,IAAIR,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,WAAW,CAACY,MAAhC,EAAwCT,CAAC,EAAzC,EAA6C;AAC3CQ,MAAAA,eAAe,IAAIX,WAAW,CAACG,CAAD,CAA9B;AACA,WAAKP,YAAL,CAAkBO,CAAlB,IAAuBQ,eAAvB;AACD;;AACD,WAAO,IAAP;AACD;;AACDE,EAAAA,kBAAkB,CAACxB,cAAD,EAAiB;AACjC,SAAKA,cAAL,GAAsBA,cAAtB;AACA,WAAO,IAAP;AACD;;AACDyB,EAAAA,MAAM,CAACC,cAAD,EAAiBC,YAAjB,EAA+BC,WAA/B,EAA4C;AAChD,UAAMC,SAAS,GAAG,KAAKC,eAAL,EAAlB;AACA,WAAO,KAAKC,UAAL,CAAgBF,SAAhB,EAA2BH,cAA3B,EAA2CC,YAA3C,EAAyDC,WAAzD,CAAP;AACD;;AACDE,EAAAA,eAAe,GAAG;AAChB,UAAMR,eAAe,GAAG,KAAKf,YAAL,CAAkB,KAAKA,YAAL,CAAkBgB,MAAlB,GAA2B,CAA7C,CAAxB;AACA,WAAO,KAAKS,YAAL,CAAkB,KAAKhC,cAAL,KAAwBsB,eAA1C,CAAP;AACD;;AACDU,EAAAA,YAAY,CAACC,CAAD,EAAI;AACd,UAAMC,IAAI,GAAG,KAAK3B,YAAlB;AACA,QAAI4B,KAAK,GAAG,CAAZ;AACA,QAAIC,GAAG,GAAGF,IAAI,CAACX,MAAL,GAAc,CAAxB;AACA,QAAI3B,KAAK,GAAG,CAAC,CAAb;;AACA,WAAOuC,KAAK,IAAIC,GAAhB,EAAqB;AACnB,YAAMC,GAAG,GAAGpC,IAAI,CAACqC,IAAL,CAAU,CAACH,KAAK,GAAGC,GAAT,IAAgB,CAA1B,CAAZ;;AACA,UAAIC,GAAG,KAAK,CAAR,IAAaH,IAAI,CAACG,GAAG,GAAG,CAAP,CAAJ,IAAiBJ,CAAjB,IAAsBC,IAAI,CAACG,GAAD,CAAJ,GAAYJ,CAAnD,EAAsD;AACpDrC,QAAAA,KAAK,GAAGyC,GAAR;AACA;AACD,OAHD,MAGO,IAAIJ,CAAC,GAAGC,IAAI,CAACG,GAAD,CAAZ,EAAmB;AACxBD,QAAAA,GAAG,GAAGC,GAAG,GAAG,CAAZ;AACD,OAFM,MAEA;AACLF,QAAAA,KAAK,GAAGE,GAAG,GAAG,CAAd;AACD;AACF;;AACD,WAAOzC,KAAP;AACD;;AACDmC,EAAAA,UAAU,CAACF,SAAD,EAAYH,cAAZ,EAA4BC,YAA5B,EAA0CC,WAA1C,EAAuD;AAC/D,QAAIW,CAAC,GAAG,KAAKvC,cAAL,EAAR;AACA,QAAIwC,CAAC,GAAG,KAAKxC,cAAL,EAAR;;AACA,QAAIuC,CAAC,GAAGC,CAAJ,GAAQ,CAAZ,EAAe;AACbD,MAAAA,CAAC,GAAG,IAAIA,CAAR;AACAC,MAAAA,CAAC,GAAG,IAAIA,CAAR;AACD;;AACDlD,IAAAA,KAAK,CAAC2B,CAAN,CAAQC,mBAAR,CAA4B,KAAKf,iBAAjC,EAAoD0B,SAAS,GAAG,CAAhE;;AACAvC,IAAAA,KAAK,CAAC6B,CAAN,CAAQD,mBAAR,CAA4B,KAAKf,iBAAjC,EAAoD0B,SAAS,GAAG,CAAZ,GAAgB,CAApE;;AACAvC,IAAAA,KAAK,CAAC8B,CAAN,CAAQF,mBAAR,CAA4B,KAAKf,iBAAjC,EAAoD0B,SAAS,GAAG,CAAZ,GAAgB,CAApE;;AACAH,IAAAA,cAAc,CAACe,GAAf,CAAmB,CAAnB,EAAsB,CAAtB,EAAyB,CAAzB,EAA4BC,eAA5B,CAA4CpD,KAAK,CAAC2B,CAAlD,EAAqDsB,CAArD,EAAwDG,eAAxD,CAAwEpD,KAAK,CAAC6B,CAA9E,EAAiFqB,CAAjF,EAAoFE,eAApF,CAAoGpD,KAAK,CAAC8B,CAA1G,EAA6G,KAAKmB,CAAC,GAAGC,CAAT,CAA7G;;AACA,QAAIb,YAAY,KAAK,KAAK,CAA1B,EAA6B;AAC3BrC,MAAAA,KAAK,CAACqD,SAAN,CAAgBhB,YAAhB;AACD;;AACD,QAAIC,WAAW,KAAK,KAAK,CAArB,IAA0B,KAAKvB,cAAL,KAAwB,KAAK,CAA3D,EAA8D;AAC5Df,MAAAA,KAAK,CAAC2B,CAAN,CAAQC,mBAAR,CAA4B,KAAKb,cAAjC,EAAiDwB,SAAS,GAAG,CAA7D;;AACAvC,MAAAA,KAAK,CAAC6B,CAAN,CAAQD,mBAAR,CAA4B,KAAKb,cAAjC,EAAiDwB,SAAS,GAAG,CAAZ,GAAgB,CAAjE;;AACAvC,MAAAA,KAAK,CAAC8B,CAAN,CAAQF,mBAAR,CAA4B,KAAKb,cAAjC,EAAiDwB,SAAS,GAAG,CAAZ,GAAgB,CAAjE;;AACAtC,MAAAA,MAAM,CAACkD,GAAP,CAAW,CAAX,EAAc,CAAd,EAAiB,CAAjB,EAAoBC,eAApB,CAAoCpD,KAAK,CAAC2B,CAA1C,EAA6CsB,CAA7C,EAAgDG,eAAhD,CAAgEpD,KAAK,CAAC6B,CAAtE,EAAyEqB,CAAzE,EAA4EE,eAA5E,CAA4FpD,KAAK,CAAC8B,CAAlG,EAAqG,KAAKmB,CAAC,GAAGC,CAAT,CAArG;;AACAZ,MAAAA,WAAW,CAACgB,CAAZ,GAAgBrD,MAAM,CAAC0C,CAAvB;AACAL,MAAAA,WAAW,CAACiB,CAAZ,GAAgBtD,MAAM,CAACuD,CAAvB;AACAlB,MAAAA,WAAW,CAACT,CAAZ,GAAgB5B,MAAM,CAACwD,CAAvB;AACD;;AACD,WAAO,IAAP;AACD;;AA/FsB;;AAiGzB,SACEvD,kBADF","sourcesContent":["import { Triangle, Vector3 } from \"three\";\nconst _face = /* @__PURE__ */ new Triangle();\nconst _color = /* @__PURE__ */ new Vector3();\nclass MeshSurfaceSampler {\n  constructor(mesh) {\n    let geometry = mesh.geometry;\n    if (geometry.index) {\n      console.warn(\"THREE.MeshSurfaceSampler: Converting geometry to non-indexed BufferGeometry.\");\n      geometry = geometry.toNonIndexed();\n    }\n    this.geometry = geometry;\n    this.randomFunction = Math.random;\n    this.positionAttribute = this.geometry.getAttribute(\"position\");\n    this.colorAttribute = this.geometry.getAttribute(\"color\");\n    this.weightAttribute = null;\n    this.distribution = null;\n  }\n  setWeightAttribute(name) {\n    this.weightAttribute = name ? this.geometry.getAttribute(name) : null;\n    return this;\n  }\n  build() {\n    const positionAttribute = this.positionAttribute;\n    const weightAttribute = this.weightAttribute;\n    const faceWeights = new Float32Array(positionAttribute.count / 3);\n    for (let i = 0; i < positionAttribute.count; i += 3) {\n      let faceWeight = 1;\n      if (weightAttribute) {\n        faceWeight = weightAttribute.getX(i) + weightAttribute.getX(i + 1) + weightAttribute.getX(i + 2);\n      }\n      _face.a.fromBufferAttribute(positionAttribute, i);\n      _face.b.fromBufferAttribute(positionAttribute, i + 1);\n      _face.c.fromBufferAttribute(positionAttribute, i + 2);\n      faceWeight *= _face.getArea();\n      faceWeights[i / 3] = faceWeight;\n    }\n    this.distribution = new Float32Array(positionAttribute.count / 3);\n    let cumulativeTotal = 0;\n    for (let i = 0; i < faceWeights.length; i++) {\n      cumulativeTotal += faceWeights[i];\n      this.distribution[i] = cumulativeTotal;\n    }\n    return this;\n  }\n  setRandomGenerator(randomFunction) {\n    this.randomFunction = randomFunction;\n    return this;\n  }\n  sample(targetPosition, targetNormal, targetColor) {\n    const faceIndex = this.sampleFaceIndex();\n    return this.sampleFace(faceIndex, targetPosition, targetNormal, targetColor);\n  }\n  sampleFaceIndex() {\n    const cumulativeTotal = this.distribution[this.distribution.length - 1];\n    return this.binarySearch(this.randomFunction() * cumulativeTotal);\n  }\n  binarySearch(x) {\n    const dist = this.distribution;\n    let start = 0;\n    let end = dist.length - 1;\n    let index = -1;\n    while (start <= end) {\n      const mid = Math.ceil((start + end) / 2);\n      if (mid === 0 || dist[mid - 1] <= x && dist[mid] > x) {\n        index = mid;\n        break;\n      } else if (x < dist[mid]) {\n        end = mid - 1;\n      } else {\n        start = mid + 1;\n      }\n    }\n    return index;\n  }\n  sampleFace(faceIndex, targetPosition, targetNormal, targetColor) {\n    let u = this.randomFunction();\n    let v = this.randomFunction();\n    if (u + v > 1) {\n      u = 1 - u;\n      v = 1 - v;\n    }\n    _face.a.fromBufferAttribute(this.positionAttribute, faceIndex * 3);\n    _face.b.fromBufferAttribute(this.positionAttribute, faceIndex * 3 + 1);\n    _face.c.fromBufferAttribute(this.positionAttribute, faceIndex * 3 + 2);\n    targetPosition.set(0, 0, 0).addScaledVector(_face.a, u).addScaledVector(_face.b, v).addScaledVector(_face.c, 1 - (u + v));\n    if (targetNormal !== void 0) {\n      _face.getNormal(targetNormal);\n    }\n    if (targetColor !== void 0 && this.colorAttribute !== void 0) {\n      _face.a.fromBufferAttribute(this.colorAttribute, faceIndex * 3);\n      _face.b.fromBufferAttribute(this.colorAttribute, faceIndex * 3 + 1);\n      _face.c.fromBufferAttribute(this.colorAttribute, faceIndex * 3 + 2);\n      _color.set(0, 0, 0).addScaledVector(_face.a, u).addScaledVector(_face.b, v).addScaledVector(_face.c, 1 - (u + v));\n      targetColor.r = _color.x;\n      targetColor.g = _color.y;\n      targetColor.b = _color.z;\n    }\n    return this;\n  }\n}\nexport {\n  MeshSurfaceSampler\n};\n"]},"metadata":{},"sourceType":"module"}