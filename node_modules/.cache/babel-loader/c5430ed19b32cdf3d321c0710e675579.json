{"ast":null,"code":"import { Vector2 } from \"three\";\nconst ConvolutionShader = {\n  defines: {\n    KERNEL_SIZE_FLOAT: \"25.0\",\n    KERNEL_SIZE_INT: \"25\"\n  },\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    uImageIncrement: {\n      value: /* @__PURE__ */new Vector2(1953125e-9, 0)\n    },\n    cKernel: {\n      value: []\n    }\n  },\n  vertexShader: [\"uniform vec2 uImageIncrement;\", \"varying vec2 vUv;\", \"void main() {\", \"\tvUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;\", \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n  fragmentShader: [\"uniform float cKernel[ KERNEL_SIZE_INT ];\", \"uniform sampler2D tDiffuse;\", \"uniform vec2 uImageIncrement;\", \"varying vec2 vUv;\", \"void main() {\", \"\tvec2 imageCoord = vUv;\", \"\tvec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );\", \"\tfor( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {\", \"\t\tsum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];\", \"\t\timageCoord += uImageIncrement;\", \"\t}\", \"\tgl_FragColor = sum;\", \"}\"].join(\"\\n\"),\n  buildKernel: function (sigma) {\n    function gauss(x, sigma2) {\n      return Math.exp(-(x * x) / (2 * sigma2 * sigma2));\n    }\n\n    const kMaxKernelSize = 25;\n    const kernelSize = Math.min(2 * Math.ceil(sigma * 3) + 1, kMaxKernelSize);\n    const halfWidth = (kernelSize - 1) * 0.5;\n    const values = new Array(kernelSize);\n    let sum = 0;\n\n    for (let i = 0; i < kernelSize; ++i) {\n      values[i] = gauss(i - halfWidth, sigma);\n      sum += values[i];\n    }\n\n    for (let i = 0; i < kernelSize; ++i) values[i] /= sum;\n\n    return values;\n  }\n};\nexport { ConvolutionShader };","map":{"version":3,"sources":["/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/three-stdlib/shaders/ConvolutionShader.js"],"names":["Vector2","ConvolutionShader","defines","KERNEL_SIZE_FLOAT","KERNEL_SIZE_INT","uniforms","tDiffuse","value","uImageIncrement","cKernel","vertexShader","join","fragmentShader","buildKernel","sigma","gauss","x","sigma2","Math","exp","kMaxKernelSize","kernelSize","min","ceil","halfWidth","values","Array","sum","i"],"mappings":"AAAA,SAASA,OAAT,QAAwB,OAAxB;AACA,MAAMC,iBAAiB,GAAG;AACxBC,EAAAA,OAAO,EAAE;AACPC,IAAAA,iBAAiB,EAAE,MADZ;AAEPC,IAAAA,eAAe,EAAE;AAFV,GADe;AAKxBC,EAAAA,QAAQ,EAAE;AACRC,IAAAA,QAAQ,EAAE;AAAEC,MAAAA,KAAK,EAAE;AAAT,KADF;AAERC,IAAAA,eAAe,EAAE;AAAED,MAAAA,KAAK,EAAE,eAAgB,IAAIP,OAAJ,CAAY,UAAZ,EAAwB,CAAxB;AAAzB,KAFT;AAGRS,IAAAA,OAAO,EAAE;AAAEF,MAAAA,KAAK,EAAE;AAAT;AAHD,GALc;AAUxBG,EAAAA,YAAY,EAAE,CACZ,+BADY,EAEZ,mBAFY,EAGZ,eAHY,EAIZ,sEAJY,EAKZ,4EALY,EAMZ,GANY,EAOZC,IAPY,CAOP,IAPO,CAVU;AAkBxBC,EAAAA,cAAc,EAAE,CACd,2CADc,EAEd,6BAFc,EAGd,+BAHc,EAId,mBAJc,EAKd,eALc,EAMd,yBANc,EAOd,yCAPc,EAQd,gDARc,EASd,4DATc,EAUd,kCAVc,EAWd,IAXc,EAYd,sBAZc,EAad,GAbc,EAcdD,IAdc,CAcT,IAdS,CAlBQ;AAiCxBE,EAAAA,WAAW,EAAE,UAASC,KAAT,EAAgB;AAC3B,aAASC,KAAT,CAAeC,CAAf,EAAkBC,MAAlB,EAA0B;AACxB,aAAOC,IAAI,CAACC,GAAL,CAAS,EAAEH,CAAC,GAAGA,CAAN,KAAY,IAAIC,MAAJ,GAAaA,MAAzB,CAAT,CAAP;AACD;;AACD,UAAMG,cAAc,GAAG,EAAvB;AACA,UAAMC,UAAU,GAAGH,IAAI,CAACI,GAAL,CAAS,IAAIJ,IAAI,CAACK,IAAL,CAAUT,KAAK,GAAG,CAAlB,CAAJ,GAA2B,CAApC,EAAuCM,cAAvC,CAAnB;AACA,UAAMI,SAAS,GAAG,CAACH,UAAU,GAAG,CAAd,IAAmB,GAArC;AACA,UAAMI,MAAM,GAAG,IAAIC,KAAJ,CAAUL,UAAV,CAAf;AACA,QAAIM,GAAG,GAAG,CAAV;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGP,UAApB,EAAgC,EAAEO,CAAlC,EAAqC;AACnCH,MAAAA,MAAM,CAACG,CAAD,CAAN,GAAYb,KAAK,CAACa,CAAC,GAAGJ,SAAL,EAAgBV,KAAhB,CAAjB;AACAa,MAAAA,GAAG,IAAIF,MAAM,CAACG,CAAD,CAAb;AACD;;AACD,SAAK,IAAIA,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGP,UAApB,EAAgC,EAAEO,CAAlC,EACEH,MAAM,CAACG,CAAD,CAAN,IAAaD,GAAb;;AACF,WAAOF,MAAP;AACD;AAjDuB,CAA1B;AAmDA,SACExB,iBADF","sourcesContent":["import { Vector2 } from \"three\";\nconst ConvolutionShader = {\n  defines: {\n    KERNEL_SIZE_FLOAT: \"25.0\",\n    KERNEL_SIZE_INT: \"25\"\n  },\n  uniforms: {\n    tDiffuse: { value: null },\n    uImageIncrement: { value: /* @__PURE__ */ new Vector2(1953125e-9, 0) },\n    cKernel: { value: [] }\n  },\n  vertexShader: [\n    \"uniform vec2 uImageIncrement;\",\n    \"varying vec2 vUv;\",\n    \"void main() {\",\n    \"\tvUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;\",\n    \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n    \"}\"\n  ].join(\"\\n\"),\n  fragmentShader: [\n    \"uniform float cKernel[ KERNEL_SIZE_INT ];\",\n    \"uniform sampler2D tDiffuse;\",\n    \"uniform vec2 uImageIncrement;\",\n    \"varying vec2 vUv;\",\n    \"void main() {\",\n    \"\tvec2 imageCoord = vUv;\",\n    \"\tvec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );\",\n    \"\tfor( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {\",\n    \"\t\tsum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];\",\n    \"\t\timageCoord += uImageIncrement;\",\n    \"\t}\",\n    \"\tgl_FragColor = sum;\",\n    \"}\"\n  ].join(\"\\n\"),\n  buildKernel: function(sigma) {\n    function gauss(x, sigma2) {\n      return Math.exp(-(x * x) / (2 * sigma2 * sigma2));\n    }\n    const kMaxKernelSize = 25;\n    const kernelSize = Math.min(2 * Math.ceil(sigma * 3) + 1, kMaxKernelSize);\n    const halfWidth = (kernelSize - 1) * 0.5;\n    const values = new Array(kernelSize);\n    let sum = 0;\n    for (let i = 0; i < kernelSize; ++i) {\n      values[i] = gauss(i - halfWidth, sigma);\n      sum += values[i];\n    }\n    for (let i = 0; i < kernelSize; ++i)\n      values[i] /= sum;\n    return values;\n  }\n};\nexport {\n  ConvolutionShader\n};\n"]},"metadata":{},"sourceType":"module"}