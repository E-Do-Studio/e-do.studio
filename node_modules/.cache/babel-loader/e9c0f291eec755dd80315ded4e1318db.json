{"ast":null,"code":"import { Vector2 } from \"three\";\nvar FreiChenShader = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    aspect: {\n      value: /* @__PURE__ */new Vector2(512, 512)\n    }\n  },\n  vertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"\tvUv = uv;\", \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n  fragmentShader: [\"uniform sampler2D tDiffuse;\", \"varying vec2 vUv;\", \"uniform vec2 aspect;\", \"vec2 texel = vec2(1.0 / aspect.x, 1.0 / aspect.y);\", \"mat3 G[9];\", // hard coded matrix values!!!! as suggested in https://github.com/neilmendoza/ofxPostProcessing/blob/master/src/EdgePass.cpp#L45\n  \"const mat3 g0 = mat3( 0.3535533845424652, 0, -0.3535533845424652, 0.5, 0, -0.5, 0.3535533845424652, 0, -0.3535533845424652 );\", \"const mat3 g1 = mat3( 0.3535533845424652, 0.5, 0.3535533845424652, 0, 0, 0, -0.3535533845424652, -0.5, -0.3535533845424652 );\", \"const mat3 g2 = mat3( 0, 0.3535533845424652, -0.5, -0.3535533845424652, 0, 0.3535533845424652, 0.5, -0.3535533845424652, 0 );\", \"const mat3 g3 = mat3( 0.5, -0.3535533845424652, 0, -0.3535533845424652, 0, 0.3535533845424652, 0, 0.3535533845424652, -0.5 );\", \"const mat3 g4 = mat3( 0, -0.5, 0, 0.5, 0, 0.5, 0, -0.5, 0 );\", \"const mat3 g5 = mat3( -0.5, 0, 0.5, 0, 0, 0, 0.5, 0, -0.5 );\", \"const mat3 g6 = mat3( 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.6666666865348816, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204 );\", \"const mat3 g7 = mat3( -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, 0.6666666865348816, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408 );\", \"const mat3 g8 = mat3( 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408 );\", \"void main(void)\", \"{\", \"\tG[0] = g0,\", \"\tG[1] = g1,\", \"\tG[2] = g2,\", \"\tG[3] = g3,\", \"\tG[4] = g4,\", \"\tG[5] = g5,\", \"\tG[6] = g6,\", \"\tG[7] = g7,\", \"\tG[8] = g8;\", \"\tmat3 I;\", \"\tfloat cnv[9];\", \"\tvec3 sample;\",\n  /* fetch the 3x3 neighbourhood and use the RGB vector's length as intensity value */\n  \"\tfor (float i=0.0; i<3.0; i++) {\", \"\t\tfor (float j=0.0; j<3.0; j++) {\", \"\t\t\tsample = texture2D(tDiffuse, vUv + texel * vec2(i-1.0,j-1.0) ).rgb;\", \"\t\t\tI[int(i)][int(j)] = length(sample);\", \"\t\t}\", \"\t}\",\n  /* calculate the convolution values for all the masks */\n  \"\tfor (int i=0; i<9; i++) {\", \"\t\tfloat dp3 = dot(G[i][0], I[0]) + dot(G[i][1], I[1]) + dot(G[i][2], I[2]);\", \"\t\tcnv[i] = dp3 * dp3;\", \"\t}\", \"\tfloat M = (cnv[0] + cnv[1]) + (cnv[2] + cnv[3]);\", \"\tfloat S = (cnv[4] + cnv[5]) + (cnv[6] + cnv[7]) + (cnv[8] + M);\", \"\tgl_FragColor = vec4(vec3(sqrt(M/S)), 1.0);\", \"}\"].join(\"\\n\")\n};\nexport { FreiChenShader };","map":{"version":3,"sources":["/Users/theodaguier/_workdir/dev/pro/e-do/E-Do-Studio/node_modules/three-stdlib/shaders/FreiChenShader.js"],"names":["Vector2","FreiChenShader","uniforms","tDiffuse","value","aspect","vertexShader","join","fragmentShader"],"mappings":"AAAA,SAASA,OAAT,QAAwB,OAAxB;AACA,IAAMC,cAAc,GAAG;AACrBC,EAAAA,QAAQ,EAAE;AACRC,IAAAA,QAAQ,EAAE;AAAEC,MAAAA,KAAK,EAAE;AAAT,KADF;AAERC,IAAAA,MAAM,EAAE;AAAED,MAAAA,KAAK,EAAE,eAAgB,IAAIJ,OAAJ,CAAY,GAAZ,EAAiB,GAAjB;AAAzB;AAFA,GADW;AAKrBM,EAAAA,YAAY,EAAE,CACZ,mBADY,EAEZ,eAFY,EAGZ,YAHY,EAIZ,4EAJY,EAKZ,GALY,EAMZC,IANY,CAMP,IANO,CALO;AAYrBC,EAAAA,cAAc,EAAE,CACd,6BADc,EAEd,mBAFc,EAGd,sBAHc,EAId,oDAJc,EAKd,YALc,EAMd;AACA,iIAPc,EAQd,+HARc,EASd,+HATc,EAUd,+HAVc,EAWd,8DAXc,EAYd,8DAZc,EAad,iNAbc,EAcd,iNAdc,EAed,6MAfc,EAgBd,iBAhBc,EAiBd,GAjBc,EAkBd,aAlBc,EAmBd,aAnBc,EAoBd,aApBc,EAqBd,aArBc,EAsBd,aAtBc,EAuBd,aAvBc,EAwBd,aAxBc,EAyBd,aAzBc,EA0Bd,aA1Bc,EA2Bd,UA3Bc,EA4Bd,gBA5Bc,EA6Bd,eA7Bc;AA8Bd;AACA,oCA/Bc,EAgCd,mCAhCc,EAiCd,wEAjCc,EAkCd,wCAlCc,EAmCd,KAnCc,EAoCd,IApCc;AAqCd;AACA,8BAtCc,EAuCd,6EAvCc,EAwCd,uBAxCc,EAyCd,IAzCc,EA0Cd,mDA1Cc,EA2Cd,kEA3Cc,EA4Cd,6CA5Cc,EA6Cd,GA7Cc,EA8CdD,IA9Cc,CA8CT,IA9CS;AAZK,CAAvB;AA4DA,SACEN,cADF","sourcesContent":["import { Vector2 } from \"three\";\nconst FreiChenShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    aspect: { value: /* @__PURE__ */ new Vector2(512, 512) }\n  },\n  vertexShader: [\n    \"varying vec2 vUv;\",\n    \"void main() {\",\n    \"\tvUv = uv;\",\n    \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n    \"}\"\n  ].join(\"\\n\"),\n  fragmentShader: [\n    \"uniform sampler2D tDiffuse;\",\n    \"varying vec2 vUv;\",\n    \"uniform vec2 aspect;\",\n    \"vec2 texel = vec2(1.0 / aspect.x, 1.0 / aspect.y);\",\n    \"mat3 G[9];\",\n    // hard coded matrix values!!!! as suggested in https://github.com/neilmendoza/ofxPostProcessing/blob/master/src/EdgePass.cpp#L45\n    \"const mat3 g0 = mat3( 0.3535533845424652, 0, -0.3535533845424652, 0.5, 0, -0.5, 0.3535533845424652, 0, -0.3535533845424652 );\",\n    \"const mat3 g1 = mat3( 0.3535533845424652, 0.5, 0.3535533845424652, 0, 0, 0, -0.3535533845424652, -0.5, -0.3535533845424652 );\",\n    \"const mat3 g2 = mat3( 0, 0.3535533845424652, -0.5, -0.3535533845424652, 0, 0.3535533845424652, 0.5, -0.3535533845424652, 0 );\",\n    \"const mat3 g3 = mat3( 0.5, -0.3535533845424652, 0, -0.3535533845424652, 0, 0.3535533845424652, 0, 0.3535533845424652, -0.5 );\",\n    \"const mat3 g4 = mat3( 0, -0.5, 0, 0.5, 0, 0.5, 0, -0.5, 0 );\",\n    \"const mat3 g5 = mat3( -0.5, 0, 0.5, 0, 0, 0, 0.5, 0, -0.5 );\",\n    \"const mat3 g6 = mat3( 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.6666666865348816, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204 );\",\n    \"const mat3 g7 = mat3( -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, 0.6666666865348816, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408 );\",\n    \"const mat3 g8 = mat3( 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408 );\",\n    \"void main(void)\",\n    \"{\",\n    \"\tG[0] = g0,\",\n    \"\tG[1] = g1,\",\n    \"\tG[2] = g2,\",\n    \"\tG[3] = g3,\",\n    \"\tG[4] = g4,\",\n    \"\tG[5] = g5,\",\n    \"\tG[6] = g6,\",\n    \"\tG[7] = g7,\",\n    \"\tG[8] = g8;\",\n    \"\tmat3 I;\",\n    \"\tfloat cnv[9];\",\n    \"\tvec3 sample;\",\n    /* fetch the 3x3 neighbourhood and use the RGB vector's length as intensity value */\n    \"\tfor (float i=0.0; i<3.0; i++) {\",\n    \"\t\tfor (float j=0.0; j<3.0; j++) {\",\n    \"\t\t\tsample = texture2D(tDiffuse, vUv + texel * vec2(i-1.0,j-1.0) ).rgb;\",\n    \"\t\t\tI[int(i)][int(j)] = length(sample);\",\n    \"\t\t}\",\n    \"\t}\",\n    /* calculate the convolution values for all the masks */\n    \"\tfor (int i=0; i<9; i++) {\",\n    \"\t\tfloat dp3 = dot(G[i][0], I[0]) + dot(G[i][1], I[1]) + dot(G[i][2], I[2]);\",\n    \"\t\tcnv[i] = dp3 * dp3;\",\n    \"\t}\",\n    \"\tfloat M = (cnv[0] + cnv[1]) + (cnv[2] + cnv[3]);\",\n    \"\tfloat S = (cnv[4] + cnv[5]) + (cnv[6] + cnv[7]) + (cnv[8] + M);\",\n    \"\tgl_FragColor = vec4(vec3(sqrt(M/S)), 1.0);\",\n    \"}\"\n  ].join(\"\\n\")\n};\nexport {\n  FreiChenShader\n};\n"]},"metadata":{},"sourceType":"module"}