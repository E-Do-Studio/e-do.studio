{"ast":null,"code":"import _classCallCheck from \"/Users/theodaguier/_workdir/dev/pro/e-do/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport { OrthographicCamera, Scene, StereoCamera, LinearFilter, NearestFilter, RGBAFormat, WebGLRenderTarget, ShaderMaterial, Mesh, PlaneGeometry } from \"three\";\n\nvar ParallaxBarrierEffect = function ParallaxBarrierEffect(renderer) {\n  _classCallCheck(this, ParallaxBarrierEffect);\n\n  var _camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);\n\n  var _scene = new Scene();\n\n  var _stereo = new StereoCamera();\n\n  var _params = {\n    minFilter: LinearFilter,\n    magFilter: NearestFilter,\n    format: RGBAFormat\n  };\n\n  var _renderTargetL = new WebGLRenderTarget(512, 512, _params);\n\n  var _renderTargetR = new WebGLRenderTarget(512, 512, _params);\n\n  var _material = new ShaderMaterial({\n    uniforms: {\n      mapLeft: {\n        value: _renderTargetL.texture\n      },\n      mapRight: {\n        value: _renderTargetR.texture\n      }\n    },\n    vertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"\tvUv = vec2( uv.x, uv.y );\", \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n    fragmentShader: [\"uniform sampler2D mapLeft;\", \"uniform sampler2D mapRight;\", \"varying vec2 vUv;\", \"void main() {\", \"\tvec2 uv = vUv;\", \"\tif ( ( mod( gl_FragCoord.y, 2.0 ) ) > 1.00 ) {\", \"\t\tgl_FragColor = texture2D( mapLeft, uv );\", \"\t} else {\", \"\t\tgl_FragColor = texture2D( mapRight, uv );\", \"\t}\", \"\t#include <tonemapping_fragment>\", \"\t#include <encodings_fragment>\", \"}\"].join(\"\\n\")\n  });\n\n  var mesh = new Mesh(new PlaneGeometry(2, 2), _material);\n\n  _scene.add(mesh);\n\n  this.setSize = function (width, height) {\n    renderer.setSize(width, height);\n    var pixelRatio = renderer.getPixelRatio();\n\n    _renderTargetL.setSize(width * pixelRatio, height * pixelRatio);\n\n    _renderTargetR.setSize(width * pixelRatio, height * pixelRatio);\n  };\n\n  this.render = function (scene, camera) {\n    if (scene.matrixWorldAutoUpdate === true) scene.updateMatrixWorld();\n    if (camera.parent === null && camera.matrixWorldAutoUpdate === true) camera.updateMatrixWorld();\n\n    _stereo.update(camera);\n\n    renderer.setRenderTarget(_renderTargetL);\n    renderer.clear();\n    renderer.render(scene, _stereo.cameraL);\n    renderer.setRenderTarget(_renderTargetR);\n    renderer.clear();\n    renderer.render(scene, _stereo.cameraR);\n    renderer.setRenderTarget(null);\n    renderer.render(_scene, _camera);\n  };\n};\n\nexport { ParallaxBarrierEffect };","map":{"version":3,"sources":["/Users/theodaguier/_workdir/dev/pro/e-do/E-Do-Studio/node_modules/three-stdlib/effects/ParallaxBarrierEffect.js"],"names":["OrthographicCamera","Scene","StereoCamera","LinearFilter","NearestFilter","RGBAFormat","WebGLRenderTarget","ShaderMaterial","Mesh","PlaneGeometry","ParallaxBarrierEffect","renderer","_camera","_scene","_stereo","_params","minFilter","magFilter","format","_renderTargetL","_renderTargetR","_material","uniforms","mapLeft","value","texture","mapRight","vertexShader","join","fragmentShader","mesh","add","setSize","width","height","pixelRatio","getPixelRatio","render","scene","camera","matrixWorldAutoUpdate","updateMatrixWorld","parent","update","setRenderTarget","clear","cameraL","cameraR"],"mappings":"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","sourcesContent":["import { OrthographicCamera, Scene, StereoCamera, LinearFilter, NearestFilter, RGBAFormat, WebGLRenderTarget, ShaderMaterial, Mesh, PlaneGeometry } from \"three\";\nclass ParallaxBarrierEffect {\n  constructor(renderer) {\n    const _camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);\n    const _scene = new Scene();\n    const _stereo = new StereoCamera();\n    const _params = { minFilter: LinearFilter, magFilter: NearestFilter, format: RGBAFormat };\n    const _renderTargetL = new WebGLRenderTarget(512, 512, _params);\n    const _renderTargetR = new WebGLRenderTarget(512, 512, _params);\n    const _material = new ShaderMaterial({\n      uniforms: {\n        mapLeft: { value: _renderTargetL.texture },\n        mapRight: { value: _renderTargetR.texture }\n      },\n      vertexShader: [\n        \"varying vec2 vUv;\",\n        \"void main() {\",\n        \"\tvUv = vec2( uv.x, uv.y );\",\n        \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n        \"}\"\n      ].join(\"\\n\"),\n      fragmentShader: [\n        \"uniform sampler2D mapLeft;\",\n        \"uniform sampler2D mapRight;\",\n        \"varying vec2 vUv;\",\n        \"void main() {\",\n        \"\tvec2 uv = vUv;\",\n        \"\tif ( ( mod( gl_FragCoord.y, 2.0 ) ) > 1.00 ) {\",\n        \"\t\tgl_FragColor = texture2D( mapLeft, uv );\",\n        \"\t} else {\",\n        \"\t\tgl_FragColor = texture2D( mapRight, uv );\",\n        \"\t}\",\n        \"\t#include <tonemapping_fragment>\",\n        \"\t#include <encodings_fragment>\",\n        \"}\"\n      ].join(\"\\n\")\n    });\n    const mesh = new Mesh(new PlaneGeometry(2, 2), _material);\n    _scene.add(mesh);\n    this.setSize = function(width, height) {\n      renderer.setSize(width, height);\n      const pixelRatio = renderer.getPixelRatio();\n      _renderTargetL.setSize(width * pixelRatio, height * pixelRatio);\n      _renderTargetR.setSize(width * pixelRatio, height * pixelRatio);\n    };\n    this.render = function(scene, camera) {\n      if (scene.matrixWorldAutoUpdate === true)\n        scene.updateMatrixWorld();\n      if (camera.parent === null && camera.matrixWorldAutoUpdate === true)\n        camera.updateMatrixWorld();\n      _stereo.update(camera);\n      renderer.setRenderTarget(_renderTargetL);\n      renderer.clear();\n      renderer.render(scene, _stereo.cameraL);\n      renderer.setRenderTarget(_renderTargetR);\n      renderer.clear();\n      renderer.render(scene, _stereo.cameraR);\n      renderer.setRenderTarget(null);\n      renderer.render(_scene, _camera);\n    };\n  }\n}\nexport {\n  ParallaxBarrierEffect\n};\n"]},"metadata":{},"sourceType":"module"}