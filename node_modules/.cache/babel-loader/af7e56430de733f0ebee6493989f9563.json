{"ast":null,"code":"import _classCallCheck from \"/Users/theodaguier/_workdir/dev/pro/e-do/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/theodaguier/_workdir/dev/pro/e-do/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { Vector3, Line3, Plane, Triangle } from \"three\";\nvar Visible = 0;\nvar Deleted = 1;\n\nvar _v1 = /* @__PURE__ */new Vector3();\n\nvar _line3 = /* @__PURE__ */new Line3();\n\nvar _plane = /* @__PURE__ */new Plane();\n\nvar _closestPoint = /* @__PURE__ */new Vector3();\n\nvar _triangle = /* @__PURE__ */new Triangle();\n\nvar ConvexHull = /*#__PURE__*/function () {\n  function ConvexHull() {\n    _classCallCheck(this, ConvexHull);\n\n    this.tolerance = -1;\n    this.faces = [];\n    this.newFaces = [];\n    this.assigned = new VertexList();\n    this.unassigned = new VertexList();\n    this.vertices = [];\n  }\n\n  _createClass(ConvexHull, [{\n    key: \"setFromPoints\",\n    value: function setFromPoints(points) {\n      if (points.length >= 4) {\n        this.makeEmpty();\n\n        for (var i = 0, l = points.length; i < l; i++) {\n          this.vertices.push(new VertexNode(points[i]));\n        }\n\n        this.compute();\n      }\n\n      return this;\n    }\n  }, {\n    key: \"setFromObject\",\n    value: function setFromObject(object) {\n      var points = [];\n      object.updateMatrixWorld(true);\n      object.traverse(function (node) {\n        var geometry = node.geometry;\n\n        if (geometry !== void 0) {\n          var attribute = geometry.attributes.position;\n\n          if (attribute !== void 0) {\n            for (var i = 0, l = attribute.count; i < l; i++) {\n              var point = new Vector3();\n              point.fromBufferAttribute(attribute, i).applyMatrix4(node.matrixWorld);\n              points.push(point);\n            }\n          }\n        }\n      });\n      return this.setFromPoints(points);\n    }\n  }, {\n    key: \"containsPoint\",\n    value: function containsPoint(point) {\n      var faces = this.faces;\n\n      for (var i = 0, l = faces.length; i < l; i++) {\n        var face = faces[i];\n        if (face.distanceToPoint(point) > this.tolerance) return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"intersectRay\",\n    value: function intersectRay(ray, target) {\n      var faces = this.faces;\n      var tNear = -Infinity;\n      var tFar = Infinity;\n\n      for (var i = 0, l = faces.length; i < l; i++) {\n        var face = faces[i];\n        var vN = face.distanceToPoint(ray.origin);\n        var vD = face.normal.dot(ray.direction);\n        if (vN > 0 && vD >= 0) return null;\n        var t = vD !== 0 ? -vN / vD : 0;\n        if (t <= 0) continue;\n\n        if (vD > 0) {\n          tFar = Math.min(t, tFar);\n        } else {\n          tNear = Math.max(t, tNear);\n        }\n\n        if (tNear > tFar) {\n          return null;\n        }\n      }\n\n      if (tNear !== -Infinity) {\n        ray.at(tNear, target);\n      } else {\n        ray.at(tFar, target);\n      }\n\n      return target;\n    }\n  }, {\n    key: \"intersectsRay\",\n    value: function intersectsRay(ray) {\n      return this.intersectRay(ray, _v1) !== null;\n    }\n  }, {\n    key: \"makeEmpty\",\n    value: function makeEmpty() {\n      this.faces = [];\n      this.vertices = [];\n      return this;\n    } // Adds a vertex to the 'assigned' list of vertices and assigns it to the given face\n\n  }, {\n    key: \"addVertexToFace\",\n    value: function addVertexToFace(vertex, face) {\n      vertex.face = face;\n\n      if (face.outside === null) {\n        this.assigned.append(vertex);\n      } else {\n        this.assigned.insertBefore(face.outside, vertex);\n      }\n\n      face.outside = vertex;\n      return this;\n    } // Removes a vertex from the 'assigned' list of vertices and from the given face\n\n  }, {\n    key: \"removeVertexFromFace\",\n    value: function removeVertexFromFace(vertex, face) {\n      if (vertex === face.outside) {\n        if (vertex.next !== null && vertex.next.face === face) {\n          face.outside = vertex.next;\n        } else {\n          face.outside = null;\n        }\n      }\n\n      this.assigned.remove(vertex);\n      return this;\n    } // Removes all the visible vertices that a given face is able to see which are stored in the 'assigned' vertex list\n\n  }, {\n    key: \"removeAllVerticesFromFace\",\n    value: function removeAllVerticesFromFace(face) {\n      if (face.outside !== null) {\n        var start = face.outside;\n        var end = face.outside;\n\n        while (end.next !== null && end.next.face === face) {\n          end = end.next;\n        }\n\n        this.assigned.removeSubList(start, end);\n        start.prev = end.next = null;\n        face.outside = null;\n        return start;\n      }\n    } // Removes all the visible vertices that 'face' is able to see\n\n  }, {\n    key: \"deleteFaceVertices\",\n    value: function deleteFaceVertices(face, absorbingFace) {\n      var faceVertices = this.removeAllVerticesFromFace(face);\n\n      if (faceVertices !== void 0) {\n        if (absorbingFace === void 0) {\n          this.unassigned.appendChain(faceVertices);\n        } else {\n          var vertex = faceVertices;\n\n          do {\n            var nextVertex = vertex.next;\n            var distance = absorbingFace.distanceToPoint(vertex.point);\n\n            if (distance > this.tolerance) {\n              this.addVertexToFace(vertex, absorbingFace);\n            } else {\n              this.unassigned.append(vertex);\n            }\n\n            vertex = nextVertex;\n          } while (vertex !== null);\n        }\n      }\n\n      return this;\n    } // Reassigns as many vertices as possible from the unassigned list to the new faces\n\n  }, {\n    key: \"resolveUnassignedPoints\",\n    value: function resolveUnassignedPoints(newFaces) {\n      if (this.unassigned.isEmpty() === false) {\n        var vertex = this.unassigned.first();\n\n        do {\n          var nextVertex = vertex.next;\n          var maxDistance = this.tolerance;\n          var maxFace = null;\n\n          for (var i = 0; i < newFaces.length; i++) {\n            var face = newFaces[i];\n\n            if (face.mark === Visible) {\n              var distance = face.distanceToPoint(vertex.point);\n\n              if (distance > maxDistance) {\n                maxDistance = distance;\n                maxFace = face;\n              }\n\n              if (maxDistance > 1e3 * this.tolerance) break;\n            }\n          }\n\n          if (maxFace !== null) {\n            this.addVertexToFace(vertex, maxFace);\n          }\n\n          vertex = nextVertex;\n        } while (vertex !== null);\n      }\n\n      return this;\n    } // Computes the extremes of a simplex which will be the initial hull\n\n  }, {\n    key: \"computeExtremes\",\n    value: function computeExtremes() {\n      var min = new Vector3();\n      var max = new Vector3();\n      var minVertices = [];\n      var maxVertices = [];\n\n      for (var i = 0; i < 3; i++) {\n        minVertices[i] = maxVertices[i] = this.vertices[0];\n      }\n\n      min.copy(this.vertices[0].point);\n      max.copy(this.vertices[0].point);\n\n      for (var _i = 0, l = this.vertices.length; _i < l; _i++) {\n        var vertex = this.vertices[_i];\n        var point = vertex.point;\n\n        for (var j = 0; j < 3; j++) {\n          if (point.getComponent(j) < min.getComponent(j)) {\n            min.setComponent(j, point.getComponent(j));\n            minVertices[j] = vertex;\n          }\n        }\n\n        for (var _j = 0; _j < 3; _j++) {\n          if (point.getComponent(_j) > max.getComponent(_j)) {\n            max.setComponent(_j, point.getComponent(_j));\n            maxVertices[_j] = vertex;\n          }\n        }\n      }\n\n      this.tolerance = 3 * Number.EPSILON * (Math.max(Math.abs(min.x), Math.abs(max.x)) + Math.max(Math.abs(min.y), Math.abs(max.y)) + Math.max(Math.abs(min.z), Math.abs(max.z)));\n      return {\n        min: minVertices,\n        max: maxVertices\n      };\n    } // Computes the initial simplex assigning to its faces all the points\n    // that are candidates to form part of the hull\n\n  }, {\n    key: \"computeInitialHull\",\n    value: function computeInitialHull() {\n      var vertices = this.vertices;\n      var extremes = this.computeExtremes();\n      var min = extremes.min;\n      var max = extremes.max;\n      var maxDistance = 0;\n      var index = 0;\n\n      for (var i = 0; i < 3; i++) {\n        var distance = max[i].point.getComponent(i) - min[i].point.getComponent(i);\n\n        if (distance > maxDistance) {\n          maxDistance = distance;\n          index = i;\n        }\n      }\n\n      var v0 = min[index];\n      var v1 = max[index];\n      var v2;\n      var v3;\n      maxDistance = 0;\n\n      _line3.set(v0.point, v1.point);\n\n      for (var _i2 = 0, l = this.vertices.length; _i2 < l; _i2++) {\n        var vertex = vertices[_i2];\n\n        if (vertex !== v0 && vertex !== v1) {\n          _line3.closestPointToPoint(vertex.point, true, _closestPoint);\n\n          var _distance = _closestPoint.distanceToSquared(vertex.point);\n\n          if (_distance > maxDistance) {\n            maxDistance = _distance;\n            v2 = vertex;\n          }\n        }\n      }\n\n      maxDistance = -1;\n\n      _plane.setFromCoplanarPoints(v0.point, v1.point, v2.point);\n\n      for (var _i3 = 0, _l = this.vertices.length; _i3 < _l; _i3++) {\n        var _vertex = vertices[_i3];\n\n        if (_vertex !== v0 && _vertex !== v1 && _vertex !== v2) {\n          var _distance2 = Math.abs(_plane.distanceToPoint(_vertex.point));\n\n          if (_distance2 > maxDistance) {\n            maxDistance = _distance2;\n            v3 = _vertex;\n          }\n        }\n      }\n\n      var faces = [];\n\n      if (_plane.distanceToPoint(v3.point) < 0) {\n        faces.push(Face.create(v0, v1, v2), Face.create(v3, v1, v0), Face.create(v3, v2, v1), Face.create(v3, v0, v2));\n\n        for (var _i4 = 0; _i4 < 3; _i4++) {\n          var j = (_i4 + 1) % 3;\n\n          faces[_i4 + 1].getEdge(2).setTwin(faces[0].getEdge(j));\n\n          faces[_i4 + 1].getEdge(1).setTwin(faces[j + 1].getEdge(0));\n        }\n      } else {\n        faces.push(Face.create(v0, v2, v1), Face.create(v3, v0, v1), Face.create(v3, v1, v2), Face.create(v3, v2, v0));\n\n        for (var _i5 = 0; _i5 < 3; _i5++) {\n          var _j2 = (_i5 + 1) % 3;\n\n          faces[_i5 + 1].getEdge(2).setTwin(faces[0].getEdge((3 - _i5) % 3));\n\n          faces[_i5 + 1].getEdge(0).setTwin(faces[_j2 + 1].getEdge(1));\n        }\n      }\n\n      for (var _i6 = 0; _i6 < 4; _i6++) {\n        this.faces.push(faces[_i6]);\n      }\n\n      for (var _i7 = 0, _l2 = vertices.length; _i7 < _l2; _i7++) {\n        var _vertex2 = vertices[_i7];\n\n        if (_vertex2 !== v0 && _vertex2 !== v1 && _vertex2 !== v2 && _vertex2 !== v3) {\n          maxDistance = this.tolerance;\n          var maxFace = null;\n\n          for (var _j3 = 0; _j3 < 4; _j3++) {\n            var _distance3 = this.faces[_j3].distanceToPoint(_vertex2.point);\n\n            if (_distance3 > maxDistance) {\n              maxDistance = _distance3;\n              maxFace = this.faces[_j3];\n            }\n          }\n\n          if (maxFace !== null) {\n            this.addVertexToFace(_vertex2, maxFace);\n          }\n        }\n      }\n\n      return this;\n    } // Removes inactive faces\n\n  }, {\n    key: \"reindexFaces\",\n    value: function reindexFaces() {\n      var activeFaces = [];\n\n      for (var i = 0; i < this.faces.length; i++) {\n        var face = this.faces[i];\n\n        if (face.mark === Visible) {\n          activeFaces.push(face);\n        }\n      }\n\n      this.faces = activeFaces;\n      return this;\n    } // Finds the next vertex to create faces with the current hull\n\n  }, {\n    key: \"nextVertexToAdd\",\n    value: function nextVertexToAdd() {\n      if (this.assigned.isEmpty() === false) {\n        var eyeVertex,\n            maxDistance = 0;\n        var eyeFace = this.assigned.first().face;\n        var vertex = eyeFace.outside;\n\n        do {\n          var distance = eyeFace.distanceToPoint(vertex.point);\n\n          if (distance > maxDistance) {\n            maxDistance = distance;\n            eyeVertex = vertex;\n          }\n\n          vertex = vertex.next;\n        } while (vertex !== null && vertex.face === eyeFace);\n\n        return eyeVertex;\n      }\n    } // Computes a chain of half edges in CCW order called the 'horizon'.\n    // For an edge to be part of the horizon it must join a face that can see\n    // 'eyePoint' and a face that cannot see 'eyePoint'.\n\n  }, {\n    key: \"computeHorizon\",\n    value: function computeHorizon(eyePoint, crossEdge, face, horizon) {\n      this.deleteFaceVertices(face);\n      face.mark = Deleted;\n      var edge;\n\n      if (crossEdge === null) {\n        edge = crossEdge = face.getEdge(0);\n      } else {\n        edge = crossEdge.next;\n      }\n\n      do {\n        var twinEdge = edge.twin;\n        var oppositeFace = twinEdge.face;\n\n        if (oppositeFace.mark === Visible) {\n          if (oppositeFace.distanceToPoint(eyePoint) > this.tolerance) {\n            this.computeHorizon(eyePoint, twinEdge, oppositeFace, horizon);\n          } else {\n            horizon.push(edge);\n          }\n        }\n\n        edge = edge.next;\n      } while (edge !== crossEdge);\n\n      return this;\n    } // Creates a face with the vertices 'eyeVertex.point', 'horizonEdge.tail' and 'horizonEdge.head' in CCW order\n\n  }, {\n    key: \"addAdjoiningFace\",\n    value: function addAdjoiningFace(eyeVertex, horizonEdge) {\n      var face = Face.create(eyeVertex, horizonEdge.tail(), horizonEdge.head());\n      this.faces.push(face);\n      face.getEdge(-1).setTwin(horizonEdge.twin);\n      return face.getEdge(0);\n    } //  Adds 'horizon.length' faces to the hull, each face will be linked with the\n    //  horizon opposite face and the face on the left/right\n\n  }, {\n    key: \"addNewFaces\",\n    value: function addNewFaces(eyeVertex, horizon) {\n      this.newFaces = [];\n      var firstSideEdge = null;\n      var previousSideEdge = null;\n\n      for (var i = 0; i < horizon.length; i++) {\n        var horizonEdge = horizon[i];\n        var sideEdge = this.addAdjoiningFace(eyeVertex, horizonEdge);\n\n        if (firstSideEdge === null) {\n          firstSideEdge = sideEdge;\n        } else {\n          sideEdge.next.setTwin(previousSideEdge);\n        }\n\n        this.newFaces.push(sideEdge.face);\n        previousSideEdge = sideEdge;\n      }\n\n      firstSideEdge.next.setTwin(previousSideEdge);\n      return this;\n    } // Adds a vertex to the hull\n\n  }, {\n    key: \"addVertexToHull\",\n    value: function addVertexToHull(eyeVertex) {\n      var horizon = [];\n      this.unassigned.clear();\n      this.removeVertexFromFace(eyeVertex, eyeVertex.face);\n      this.computeHorizon(eyeVertex.point, null, eyeVertex.face, horizon);\n      this.addNewFaces(eyeVertex, horizon);\n      this.resolveUnassignedPoints(this.newFaces);\n      return this;\n    }\n  }, {\n    key: \"cleanup\",\n    value: function cleanup() {\n      this.assigned.clear();\n      this.unassigned.clear();\n      this.newFaces = [];\n      return this;\n    }\n  }, {\n    key: \"compute\",\n    value: function compute() {\n      var vertex;\n      this.computeInitialHull();\n\n      while ((vertex = this.nextVertexToAdd()) !== void 0) {\n        this.addVertexToHull(vertex);\n      }\n\n      this.reindexFaces();\n      this.cleanup();\n      return this;\n    }\n  }]);\n\n  return ConvexHull;\n}();\n\nvar Face = /*#__PURE__*/function () {\n  function Face() {\n    _classCallCheck(this, Face);\n\n    this.normal = new Vector3();\n    this.midpoint = new Vector3();\n    this.area = 0;\n    this.constant = 0;\n    this.outside = null;\n    this.mark = Visible;\n    this.edge = null;\n  }\n\n  _createClass(Face, [{\n    key: \"getEdge\",\n    value: function getEdge(i) {\n      var edge = this.edge;\n\n      while (i > 0) {\n        edge = edge.next;\n        i--;\n      }\n\n      while (i < 0) {\n        edge = edge.prev;\n        i++;\n      }\n\n      return edge;\n    }\n  }, {\n    key: \"compute\",\n    value: function compute() {\n      var a = this.edge.tail();\n      var b = this.edge.head();\n      var c = this.edge.next.head();\n\n      _triangle.set(a.point, b.point, c.point);\n\n      _triangle.getNormal(this.normal);\n\n      _triangle.getMidpoint(this.midpoint);\n\n      this.area = _triangle.getArea();\n      this.constant = this.normal.dot(this.midpoint);\n      return this;\n    }\n  }, {\n    key: \"distanceToPoint\",\n    value: function distanceToPoint(point) {\n      return this.normal.dot(point) - this.constant;\n    }\n  }], [{\n    key: \"create\",\n    value: function create(a, b, c) {\n      var face = new Face();\n      var e0 = new HalfEdge(a, face);\n      var e1 = new HalfEdge(b, face);\n      var e2 = new HalfEdge(c, face);\n      e0.next = e2.prev = e1;\n      e1.next = e0.prev = e2;\n      e2.next = e1.prev = e0;\n      face.edge = e0;\n      return face.compute();\n    }\n  }]);\n\n  return Face;\n}();\n\nvar HalfEdge = /*#__PURE__*/function () {\n  function HalfEdge(vertex, face) {\n    _classCallCheck(this, HalfEdge);\n\n    this.vertex = vertex;\n    this.prev = null;\n    this.next = null;\n    this.twin = null;\n    this.face = face;\n  }\n\n  _createClass(HalfEdge, [{\n    key: \"head\",\n    value: function head() {\n      return this.vertex;\n    }\n  }, {\n    key: \"tail\",\n    value: function tail() {\n      return this.prev ? this.prev.vertex : null;\n    }\n  }, {\n    key: \"length\",\n    value: function length() {\n      var head = this.head();\n      var tail = this.tail();\n\n      if (tail !== null) {\n        return tail.point.distanceTo(head.point);\n      }\n\n      return -1;\n    }\n  }, {\n    key: \"lengthSquared\",\n    value: function lengthSquared() {\n      var head = this.head();\n      var tail = this.tail();\n\n      if (tail !== null) {\n        return tail.point.distanceToSquared(head.point);\n      }\n\n      return -1;\n    }\n  }, {\n    key: \"setTwin\",\n    value: function setTwin(edge) {\n      this.twin = edge;\n      edge.twin = this;\n      return this;\n    }\n  }]);\n\n  return HalfEdge;\n}();\n\nvar VertexNode = function VertexNode(point) {\n  _classCallCheck(this, VertexNode);\n\n  this.point = point;\n  this.prev = null;\n  this.next = null;\n  this.face = null;\n};\n\nvar VertexList = /*#__PURE__*/function () {\n  function VertexList() {\n    _classCallCheck(this, VertexList);\n\n    this.head = null;\n    this.tail = null;\n  }\n\n  _createClass(VertexList, [{\n    key: \"first\",\n    value: function first() {\n      return this.head;\n    }\n  }, {\n    key: \"last\",\n    value: function last() {\n      return this.tail;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.head = this.tail = null;\n      return this;\n    } // Inserts a vertex before the target vertex\n\n  }, {\n    key: \"insertBefore\",\n    value: function insertBefore(target, vertex) {\n      vertex.prev = target.prev;\n      vertex.next = target;\n\n      if (vertex.prev === null) {\n        this.head = vertex;\n      } else {\n        vertex.prev.next = vertex;\n      }\n\n      target.prev = vertex;\n      return this;\n    } // Inserts a vertex after the target vertex\n\n  }, {\n    key: \"insertAfter\",\n    value: function insertAfter(target, vertex) {\n      vertex.prev = target;\n      vertex.next = target.next;\n\n      if (vertex.next === null) {\n        this.tail = vertex;\n      } else {\n        vertex.next.prev = vertex;\n      }\n\n      target.next = vertex;\n      return this;\n    } // Appends a vertex to the end of the linked list\n\n  }, {\n    key: \"append\",\n    value: function append(vertex) {\n      if (this.head === null) {\n        this.head = vertex;\n      } else {\n        this.tail.next = vertex;\n      }\n\n      vertex.prev = this.tail;\n      vertex.next = null;\n      this.tail = vertex;\n      return this;\n    } // Appends a chain of vertices where 'vertex' is the head.\n\n  }, {\n    key: \"appendChain\",\n    value: function appendChain(vertex) {\n      if (this.head === null) {\n        this.head = vertex;\n      } else {\n        this.tail.next = vertex;\n      }\n\n      vertex.prev = this.tail;\n\n      while (vertex.next !== null) {\n        vertex = vertex.next;\n      }\n\n      this.tail = vertex;\n      return this;\n    } // Removes a vertex from the linked list\n\n  }, {\n    key: \"remove\",\n    value: function remove(vertex) {\n      if (vertex.prev === null) {\n        this.head = vertex.next;\n      } else {\n        vertex.prev.next = vertex.next;\n      }\n\n      if (vertex.next === null) {\n        this.tail = vertex.prev;\n      } else {\n        vertex.next.prev = vertex.prev;\n      }\n\n      return this;\n    } // Removes a list of vertices whose 'head' is 'a' and whose 'tail' is b\n\n  }, {\n    key: \"removeSubList\",\n    value: function removeSubList(a, b) {\n      if (a.prev === null) {\n        this.head = b.next;\n      } else {\n        a.prev.next = b.next;\n      }\n\n      if (b.next === null) {\n        this.tail = a.prev;\n      } else {\n        b.next.prev = a.prev;\n      }\n\n      return this;\n    }\n  }, {\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return this.head === null;\n    }\n  }]);\n\n  return VertexList;\n}();\n\nexport { ConvexHull, Face, HalfEdge, VertexList, VertexNode };","map":{"version":3,"sources":["/Users/theodaguier/_workdir/dev/pro/e-do/E-Do-Studio/node_modules/three-stdlib/math/ConvexHull.js"],"names":["Vector3","Line3","Plane","Triangle","Visible","Deleted","_v1","_line3","_plane","_closestPoint","_triangle","ConvexHull","tolerance","faces","newFaces","assigned","VertexList","unassigned","vertices","points","length","makeEmpty","i","l","push","VertexNode","compute","object","updateMatrixWorld","traverse","node","geometry","attribute","attributes","position","count","point","fromBufferAttribute","applyMatrix4","matrixWorld","setFromPoints","face","distanceToPoint","ray","target","tNear","Infinity","tFar","vN","origin","vD","normal","dot","direction","t","Math","min","max","at","intersectRay","vertex","outside","append","insertBefore","next","remove","start","end","removeSubList","prev","absorbingFace","faceVertices","removeAllVerticesFromFace","appendChain","nextVertex","distance","addVertexToFace","isEmpty","first","maxDistance","maxFace","mark","minVertices","maxVertices","copy","j","getComponent","setComponent","Number","EPSILON","abs","x","y","z","extremes","computeExtremes","index","v0","v1","v2","v3","set","closestPointToPoint","distanceToSquared","setFromCoplanarPoints","Face","create","getEdge","setTwin","activeFaces","eyeVertex","eyeFace","eyePoint","crossEdge","horizon","deleteFaceVertices","edge","twinEdge","twin","oppositeFace","computeHorizon","horizonEdge","tail","head","firstSideEdge","previousSideEdge","sideEdge","addAdjoiningFace","clear","removeVertexFromFace","addNewFaces","resolveUnassignedPoints","computeInitialHull","nextVertexToAdd","addVertexToHull","reindexFaces","cleanup","midpoint","area","constant","a","b","c","getNormal","getMidpoint","getArea","e0","HalfEdge","e1","e2","distanceTo"],"mappings":"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","sourcesContent":["import { Vector3, Line3, Plane, Triangle } from \"three\";\nconst Visible = 0;\nconst Deleted = 1;\nconst _v1 = /* @__PURE__ */ new Vector3();\nconst _line3 = /* @__PURE__ */ new Line3();\nconst _plane = /* @__PURE__ */ new Plane();\nconst _closestPoint = /* @__PURE__ */ new Vector3();\nconst _triangle = /* @__PURE__ */ new Triangle();\nclass ConvexHull {\n  constructor() {\n    this.tolerance = -1;\n    this.faces = [];\n    this.newFaces = [];\n    this.assigned = new VertexList();\n    this.unassigned = new VertexList();\n    this.vertices = [];\n  }\n  setFromPoints(points) {\n    if (points.length >= 4) {\n      this.makeEmpty();\n      for (let i = 0, l = points.length; i < l; i++) {\n        this.vertices.push(new VertexNode(points[i]));\n      }\n      this.compute();\n    }\n    return this;\n  }\n  setFromObject(object) {\n    const points = [];\n    object.updateMatrixWorld(true);\n    object.traverse(function(node) {\n      const geometry = node.geometry;\n      if (geometry !== void 0) {\n        const attribute = geometry.attributes.position;\n        if (attribute !== void 0) {\n          for (let i = 0, l = attribute.count; i < l; i++) {\n            const point = new Vector3();\n            point.fromBufferAttribute(attribute, i).applyMatrix4(node.matrixWorld);\n            points.push(point);\n          }\n        }\n      }\n    });\n    return this.setFromPoints(points);\n  }\n  containsPoint(point) {\n    const faces = this.faces;\n    for (let i = 0, l = faces.length; i < l; i++) {\n      const face = faces[i];\n      if (face.distanceToPoint(point) > this.tolerance)\n        return false;\n    }\n    return true;\n  }\n  intersectRay(ray, target) {\n    const faces = this.faces;\n    let tNear = -Infinity;\n    let tFar = Infinity;\n    for (let i = 0, l = faces.length; i < l; i++) {\n      const face = faces[i];\n      const vN = face.distanceToPoint(ray.origin);\n      const vD = face.normal.dot(ray.direction);\n      if (vN > 0 && vD >= 0)\n        return null;\n      const t = vD !== 0 ? -vN / vD : 0;\n      if (t <= 0)\n        continue;\n      if (vD > 0) {\n        tFar = Math.min(t, tFar);\n      } else {\n        tNear = Math.max(t, tNear);\n      }\n      if (tNear > tFar) {\n        return null;\n      }\n    }\n    if (tNear !== -Infinity) {\n      ray.at(tNear, target);\n    } else {\n      ray.at(tFar, target);\n    }\n    return target;\n  }\n  intersectsRay(ray) {\n    return this.intersectRay(ray, _v1) !== null;\n  }\n  makeEmpty() {\n    this.faces = [];\n    this.vertices = [];\n    return this;\n  }\n  // Adds a vertex to the 'assigned' list of vertices and assigns it to the given face\n  addVertexToFace(vertex, face) {\n    vertex.face = face;\n    if (face.outside === null) {\n      this.assigned.append(vertex);\n    } else {\n      this.assigned.insertBefore(face.outside, vertex);\n    }\n    face.outside = vertex;\n    return this;\n  }\n  // Removes a vertex from the 'assigned' list of vertices and from the given face\n  removeVertexFromFace(vertex, face) {\n    if (vertex === face.outside) {\n      if (vertex.next !== null && vertex.next.face === face) {\n        face.outside = vertex.next;\n      } else {\n        face.outside = null;\n      }\n    }\n    this.assigned.remove(vertex);\n    return this;\n  }\n  // Removes all the visible vertices that a given face is able to see which are stored in the 'assigned' vertex list\n  removeAllVerticesFromFace(face) {\n    if (face.outside !== null) {\n      const start = face.outside;\n      let end = face.outside;\n      while (end.next !== null && end.next.face === face) {\n        end = end.next;\n      }\n      this.assigned.removeSubList(start, end);\n      start.prev = end.next = null;\n      face.outside = null;\n      return start;\n    }\n  }\n  // Removes all the visible vertices that 'face' is able to see\n  deleteFaceVertices(face, absorbingFace) {\n    const faceVertices = this.removeAllVerticesFromFace(face);\n    if (faceVertices !== void 0) {\n      if (absorbingFace === void 0) {\n        this.unassigned.appendChain(faceVertices);\n      } else {\n        let vertex = faceVertices;\n        do {\n          const nextVertex = vertex.next;\n          const distance = absorbingFace.distanceToPoint(vertex.point);\n          if (distance > this.tolerance) {\n            this.addVertexToFace(vertex, absorbingFace);\n          } else {\n            this.unassigned.append(vertex);\n          }\n          vertex = nextVertex;\n        } while (vertex !== null);\n      }\n    }\n    return this;\n  }\n  // Reassigns as many vertices as possible from the unassigned list to the new faces\n  resolveUnassignedPoints(newFaces) {\n    if (this.unassigned.isEmpty() === false) {\n      let vertex = this.unassigned.first();\n      do {\n        const nextVertex = vertex.next;\n        let maxDistance = this.tolerance;\n        let maxFace = null;\n        for (let i = 0; i < newFaces.length; i++) {\n          const face = newFaces[i];\n          if (face.mark === Visible) {\n            const distance = face.distanceToPoint(vertex.point);\n            if (distance > maxDistance) {\n              maxDistance = distance;\n              maxFace = face;\n            }\n            if (maxDistance > 1e3 * this.tolerance)\n              break;\n          }\n        }\n        if (maxFace !== null) {\n          this.addVertexToFace(vertex, maxFace);\n        }\n        vertex = nextVertex;\n      } while (vertex !== null);\n    }\n    return this;\n  }\n  // Computes the extremes of a simplex which will be the initial hull\n  computeExtremes() {\n    const min = new Vector3();\n    const max = new Vector3();\n    const minVertices = [];\n    const maxVertices = [];\n    for (let i = 0; i < 3; i++) {\n      minVertices[i] = maxVertices[i] = this.vertices[0];\n    }\n    min.copy(this.vertices[0].point);\n    max.copy(this.vertices[0].point);\n    for (let i = 0, l = this.vertices.length; i < l; i++) {\n      const vertex = this.vertices[i];\n      const point = vertex.point;\n      for (let j = 0; j < 3; j++) {\n        if (point.getComponent(j) < min.getComponent(j)) {\n          min.setComponent(j, point.getComponent(j));\n          minVertices[j] = vertex;\n        }\n      }\n      for (let j = 0; j < 3; j++) {\n        if (point.getComponent(j) > max.getComponent(j)) {\n          max.setComponent(j, point.getComponent(j));\n          maxVertices[j] = vertex;\n        }\n      }\n    }\n    this.tolerance = 3 * Number.EPSILON * (Math.max(Math.abs(min.x), Math.abs(max.x)) + Math.max(Math.abs(min.y), Math.abs(max.y)) + Math.max(Math.abs(min.z), Math.abs(max.z)));\n    return { min: minVertices, max: maxVertices };\n  }\n  // Computes the initial simplex assigning to its faces all the points\n  // that are candidates to form part of the hull\n  computeInitialHull() {\n    const vertices = this.vertices;\n    const extremes = this.computeExtremes();\n    const min = extremes.min;\n    const max = extremes.max;\n    let maxDistance = 0;\n    let index = 0;\n    for (let i = 0; i < 3; i++) {\n      const distance = max[i].point.getComponent(i) - min[i].point.getComponent(i);\n      if (distance > maxDistance) {\n        maxDistance = distance;\n        index = i;\n      }\n    }\n    const v0 = min[index];\n    const v1 = max[index];\n    let v2;\n    let v3;\n    maxDistance = 0;\n    _line3.set(v0.point, v1.point);\n    for (let i = 0, l = this.vertices.length; i < l; i++) {\n      const vertex = vertices[i];\n      if (vertex !== v0 && vertex !== v1) {\n        _line3.closestPointToPoint(vertex.point, true, _closestPoint);\n        const distance = _closestPoint.distanceToSquared(vertex.point);\n        if (distance > maxDistance) {\n          maxDistance = distance;\n          v2 = vertex;\n        }\n      }\n    }\n    maxDistance = -1;\n    _plane.setFromCoplanarPoints(v0.point, v1.point, v2.point);\n    for (let i = 0, l = this.vertices.length; i < l; i++) {\n      const vertex = vertices[i];\n      if (vertex !== v0 && vertex !== v1 && vertex !== v2) {\n        const distance = Math.abs(_plane.distanceToPoint(vertex.point));\n        if (distance > maxDistance) {\n          maxDistance = distance;\n          v3 = vertex;\n        }\n      }\n    }\n    const faces = [];\n    if (_plane.distanceToPoint(v3.point) < 0) {\n      faces.push(Face.create(v0, v1, v2), Face.create(v3, v1, v0), Face.create(v3, v2, v1), Face.create(v3, v0, v2));\n      for (let i = 0; i < 3; i++) {\n        const j = (i + 1) % 3;\n        faces[i + 1].getEdge(2).setTwin(faces[0].getEdge(j));\n        faces[i + 1].getEdge(1).setTwin(faces[j + 1].getEdge(0));\n      }\n    } else {\n      faces.push(Face.create(v0, v2, v1), Face.create(v3, v0, v1), Face.create(v3, v1, v2), Face.create(v3, v2, v0));\n      for (let i = 0; i < 3; i++) {\n        const j = (i + 1) % 3;\n        faces[i + 1].getEdge(2).setTwin(faces[0].getEdge((3 - i) % 3));\n        faces[i + 1].getEdge(0).setTwin(faces[j + 1].getEdge(1));\n      }\n    }\n    for (let i = 0; i < 4; i++) {\n      this.faces.push(faces[i]);\n    }\n    for (let i = 0, l = vertices.length; i < l; i++) {\n      const vertex = vertices[i];\n      if (vertex !== v0 && vertex !== v1 && vertex !== v2 && vertex !== v3) {\n        maxDistance = this.tolerance;\n        let maxFace = null;\n        for (let j = 0; j < 4; j++) {\n          const distance = this.faces[j].distanceToPoint(vertex.point);\n          if (distance > maxDistance) {\n            maxDistance = distance;\n            maxFace = this.faces[j];\n          }\n        }\n        if (maxFace !== null) {\n          this.addVertexToFace(vertex, maxFace);\n        }\n      }\n    }\n    return this;\n  }\n  // Removes inactive faces\n  reindexFaces() {\n    const activeFaces = [];\n    for (let i = 0; i < this.faces.length; i++) {\n      const face = this.faces[i];\n      if (face.mark === Visible) {\n        activeFaces.push(face);\n      }\n    }\n    this.faces = activeFaces;\n    return this;\n  }\n  // Finds the next vertex to create faces with the current hull\n  nextVertexToAdd() {\n    if (this.assigned.isEmpty() === false) {\n      let eyeVertex, maxDistance = 0;\n      const eyeFace = this.assigned.first().face;\n      let vertex = eyeFace.outside;\n      do {\n        const distance = eyeFace.distanceToPoint(vertex.point);\n        if (distance > maxDistance) {\n          maxDistance = distance;\n          eyeVertex = vertex;\n        }\n        vertex = vertex.next;\n      } while (vertex !== null && vertex.face === eyeFace);\n      return eyeVertex;\n    }\n  }\n  // Computes a chain of half edges in CCW order called the 'horizon'.\n  // For an edge to be part of the horizon it must join a face that can see\n  // 'eyePoint' and a face that cannot see 'eyePoint'.\n  computeHorizon(eyePoint, crossEdge, face, horizon) {\n    this.deleteFaceVertices(face);\n    face.mark = Deleted;\n    let edge;\n    if (crossEdge === null) {\n      edge = crossEdge = face.getEdge(0);\n    } else {\n      edge = crossEdge.next;\n    }\n    do {\n      const twinEdge = edge.twin;\n      const oppositeFace = twinEdge.face;\n      if (oppositeFace.mark === Visible) {\n        if (oppositeFace.distanceToPoint(eyePoint) > this.tolerance) {\n          this.computeHorizon(eyePoint, twinEdge, oppositeFace, horizon);\n        } else {\n          horizon.push(edge);\n        }\n      }\n      edge = edge.next;\n    } while (edge !== crossEdge);\n    return this;\n  }\n  // Creates a face with the vertices 'eyeVertex.point', 'horizonEdge.tail' and 'horizonEdge.head' in CCW order\n  addAdjoiningFace(eyeVertex, horizonEdge) {\n    const face = Face.create(eyeVertex, horizonEdge.tail(), horizonEdge.head());\n    this.faces.push(face);\n    face.getEdge(-1).setTwin(horizonEdge.twin);\n    return face.getEdge(0);\n  }\n  //  Adds 'horizon.length' faces to the hull, each face will be linked with the\n  //  horizon opposite face and the face on the left/right\n  addNewFaces(eyeVertex, horizon) {\n    this.newFaces = [];\n    let firstSideEdge = null;\n    let previousSideEdge = null;\n    for (let i = 0; i < horizon.length; i++) {\n      const horizonEdge = horizon[i];\n      const sideEdge = this.addAdjoiningFace(eyeVertex, horizonEdge);\n      if (firstSideEdge === null) {\n        firstSideEdge = sideEdge;\n      } else {\n        sideEdge.next.setTwin(previousSideEdge);\n      }\n      this.newFaces.push(sideEdge.face);\n      previousSideEdge = sideEdge;\n    }\n    firstSideEdge.next.setTwin(previousSideEdge);\n    return this;\n  }\n  // Adds a vertex to the hull\n  addVertexToHull(eyeVertex) {\n    const horizon = [];\n    this.unassigned.clear();\n    this.removeVertexFromFace(eyeVertex, eyeVertex.face);\n    this.computeHorizon(eyeVertex.point, null, eyeVertex.face, horizon);\n    this.addNewFaces(eyeVertex, horizon);\n    this.resolveUnassignedPoints(this.newFaces);\n    return this;\n  }\n  cleanup() {\n    this.assigned.clear();\n    this.unassigned.clear();\n    this.newFaces = [];\n    return this;\n  }\n  compute() {\n    let vertex;\n    this.computeInitialHull();\n    while ((vertex = this.nextVertexToAdd()) !== void 0) {\n      this.addVertexToHull(vertex);\n    }\n    this.reindexFaces();\n    this.cleanup();\n    return this;\n  }\n}\nclass Face {\n  constructor() {\n    this.normal = new Vector3();\n    this.midpoint = new Vector3();\n    this.area = 0;\n    this.constant = 0;\n    this.outside = null;\n    this.mark = Visible;\n    this.edge = null;\n  }\n  static create(a, b, c) {\n    const face = new Face();\n    const e0 = new HalfEdge(a, face);\n    const e1 = new HalfEdge(b, face);\n    const e2 = new HalfEdge(c, face);\n    e0.next = e2.prev = e1;\n    e1.next = e0.prev = e2;\n    e2.next = e1.prev = e0;\n    face.edge = e0;\n    return face.compute();\n  }\n  getEdge(i) {\n    let edge = this.edge;\n    while (i > 0) {\n      edge = edge.next;\n      i--;\n    }\n    while (i < 0) {\n      edge = edge.prev;\n      i++;\n    }\n    return edge;\n  }\n  compute() {\n    const a = this.edge.tail();\n    const b = this.edge.head();\n    const c = this.edge.next.head();\n    _triangle.set(a.point, b.point, c.point);\n    _triangle.getNormal(this.normal);\n    _triangle.getMidpoint(this.midpoint);\n    this.area = _triangle.getArea();\n    this.constant = this.normal.dot(this.midpoint);\n    return this;\n  }\n  distanceToPoint(point) {\n    return this.normal.dot(point) - this.constant;\n  }\n}\nclass HalfEdge {\n  constructor(vertex, face) {\n    this.vertex = vertex;\n    this.prev = null;\n    this.next = null;\n    this.twin = null;\n    this.face = face;\n  }\n  head() {\n    return this.vertex;\n  }\n  tail() {\n    return this.prev ? this.prev.vertex : null;\n  }\n  length() {\n    const head = this.head();\n    const tail = this.tail();\n    if (tail !== null) {\n      return tail.point.distanceTo(head.point);\n    }\n    return -1;\n  }\n  lengthSquared() {\n    const head = this.head();\n    const tail = this.tail();\n    if (tail !== null) {\n      return tail.point.distanceToSquared(head.point);\n    }\n    return -1;\n  }\n  setTwin(edge) {\n    this.twin = edge;\n    edge.twin = this;\n    return this;\n  }\n}\nclass VertexNode {\n  constructor(point) {\n    this.point = point;\n    this.prev = null;\n    this.next = null;\n    this.face = null;\n  }\n}\nclass VertexList {\n  constructor() {\n    this.head = null;\n    this.tail = null;\n  }\n  first() {\n    return this.head;\n  }\n  last() {\n    return this.tail;\n  }\n  clear() {\n    this.head = this.tail = null;\n    return this;\n  }\n  // Inserts a vertex before the target vertex\n  insertBefore(target, vertex) {\n    vertex.prev = target.prev;\n    vertex.next = target;\n    if (vertex.prev === null) {\n      this.head = vertex;\n    } else {\n      vertex.prev.next = vertex;\n    }\n    target.prev = vertex;\n    return this;\n  }\n  // Inserts a vertex after the target vertex\n  insertAfter(target, vertex) {\n    vertex.prev = target;\n    vertex.next = target.next;\n    if (vertex.next === null) {\n      this.tail = vertex;\n    } else {\n      vertex.next.prev = vertex;\n    }\n    target.next = vertex;\n    return this;\n  }\n  // Appends a vertex to the end of the linked list\n  append(vertex) {\n    if (this.head === null) {\n      this.head = vertex;\n    } else {\n      this.tail.next = vertex;\n    }\n    vertex.prev = this.tail;\n    vertex.next = null;\n    this.tail = vertex;\n    return this;\n  }\n  // Appends a chain of vertices where 'vertex' is the head.\n  appendChain(vertex) {\n    if (this.head === null) {\n      this.head = vertex;\n    } else {\n      this.tail.next = vertex;\n    }\n    vertex.prev = this.tail;\n    while (vertex.next !== null) {\n      vertex = vertex.next;\n    }\n    this.tail = vertex;\n    return this;\n  }\n  // Removes a vertex from the linked list\n  remove(vertex) {\n    if (vertex.prev === null) {\n      this.head = vertex.next;\n    } else {\n      vertex.prev.next = vertex.next;\n    }\n    if (vertex.next === null) {\n      this.tail = vertex.prev;\n    } else {\n      vertex.next.prev = vertex.prev;\n    }\n    return this;\n  }\n  // Removes a list of vertices whose 'head' is 'a' and whose 'tail' is b\n  removeSubList(a, b) {\n    if (a.prev === null) {\n      this.head = b.next;\n    } else {\n      a.prev.next = b.next;\n    }\n    if (b.next === null) {\n      this.tail = a.prev;\n    } else {\n      b.next.prev = a.prev;\n    }\n    return this;\n  }\n  isEmpty() {\n    return this.head === null;\n  }\n}\nexport {\n  ConvexHull,\n  Face,\n  HalfEdge,\n  VertexList,\n  VertexNode\n};\n"]},"metadata":{},"sourceType":"module"}