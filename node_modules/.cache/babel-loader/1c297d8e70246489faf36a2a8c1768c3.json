{"ast":null,"code":"var __defProp = Object.defineProperty;\n\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\n\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n\n  return value;\n};\n\nimport { BufferGeometry, Mesh, Points } from \"three\";\n\nconst _DRACOExporter = class {\n  parse(object, options = {\n    decodeSpeed: 5,\n    encodeSpeed: 5,\n    encoderMethod: _DRACOExporter.MESH_EDGEBREAKER_ENCODING,\n    quantization: [16, 8, 8, 8, 8],\n    exportUvs: true,\n    exportNormals: true,\n    exportColor: false\n  }) {\n    if (object instanceof BufferGeometry && object.isBufferGeometry) {\n      throw new Error(\"DRACOExporter: The first parameter of parse() is now an instance of Mesh or Points.\");\n    }\n\n    if (DracoEncoderModule === void 0) {\n      throw new Error(\"THREE.DRACOExporter: required the draco_encoder to work.\");\n    }\n\n    const geometry = object.geometry;\n    const dracoEncoder = DracoEncoderModule();\n    const encoder = new dracoEncoder.Encoder();\n    let builder;\n    let dracoObject;\n\n    if (!geometry.isBufferGeometry) {\n      throw new Error(\"THREE.DRACOExporter.parse(geometry, options): geometry is not a THREE.BufferGeometry instance.\");\n    }\n\n    if (object instanceof Mesh && object.isMesh) {\n      builder = new dracoEncoder.MeshBuilder();\n      dracoObject = new dracoEncoder.Mesh();\n      const vertices = geometry.getAttribute(\"position\");\n      builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.POSITION, vertices.count, vertices.itemSize, vertices.array);\n      const faces = geometry.getIndex();\n\n      if (faces !== null) {\n        builder.AddFacesToMesh(dracoObject, faces.count / 3, faces.array);\n      } else {\n        const faces2 = new (vertices.count > 65535 ? Uint32Array : Uint16Array)(vertices.count);\n\n        for (let i = 0; i < faces2.length; i++) {\n          faces2[i] = i;\n        }\n\n        builder.AddFacesToMesh(dracoObject, vertices.count, faces2);\n      }\n\n      if (options.exportNormals) {\n        const normals = geometry.getAttribute(\"normal\");\n\n        if (normals !== void 0) {\n          builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.NORMAL, normals.count, normals.itemSize, normals.array);\n        }\n      }\n\n      if (options.exportUvs) {\n        const uvs = geometry.getAttribute(\"uv\");\n\n        if (uvs !== void 0) {\n          builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.TEX_COORD, uvs.count, uvs.itemSize, uvs.array);\n        }\n      }\n\n      if (options.exportColor) {\n        const colors = geometry.getAttribute(\"color\");\n\n        if (colors !== void 0) {\n          builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.COLOR, colors.count, colors.itemSize, colors.array);\n        }\n      }\n    } else if (object instanceof Points && object.isPoints) {\n      builder = new dracoEncoder.PointCloudBuilder();\n      dracoObject = new dracoEncoder.PointCloud();\n      const vertices = geometry.getAttribute(\"position\");\n      builder.AddFloatAttribute(dracoObject, dracoEncoder.POSITION, vertices.count, vertices.itemSize, vertices.array);\n\n      if (options.exportColor) {\n        const colors = geometry.getAttribute(\"color\");\n\n        if (colors !== void 0) {\n          builder.AddFloatAttribute(dracoObject, dracoEncoder.COLOR, colors.count, colors.itemSize, colors.array);\n        }\n      }\n    } else {\n      throw new Error(\"DRACOExporter: Unsupported object type.\");\n    }\n\n    const encodedData = new dracoEncoder.DracoInt8Array();\n    const encodeSpeed = options.encodeSpeed !== void 0 ? options.encodeSpeed : 5;\n    const decodeSpeed = options.decodeSpeed !== void 0 ? options.decodeSpeed : 5;\n    encoder.SetSpeedOptions(encodeSpeed, decodeSpeed);\n\n    if (options.encoderMethod !== void 0) {\n      encoder.SetEncodingMethod(options.encoderMethod);\n    }\n\n    if (options.quantization !== void 0) {\n      for (let i = 0; i < 5; i++) {\n        if (options.quantization[i] !== void 0) {\n          encoder.SetAttributeQuantization(i, options.quantization[i]);\n        }\n      }\n    }\n\n    let length;\n\n    if (object instanceof Mesh && object.isMesh) {\n      length = encoder.EncodeMeshToDracoBuffer(dracoObject, encodedData);\n    } else {\n      length = encoder.EncodePointCloudToDracoBuffer(dracoObject, true, encodedData);\n    }\n\n    dracoEncoder.destroy(dracoObject);\n\n    if (length === 0) {\n      throw new Error(\"THREE.DRACOExporter: Draco encoding failed.\");\n    }\n\n    const outputData = new Int8Array(new ArrayBuffer(length));\n\n    for (let i = 0; i < length; i++) {\n      outputData[i] = encodedData.GetValue(i);\n    }\n\n    dracoEncoder.destroy(encodedData);\n    dracoEncoder.destroy(encoder);\n    dracoEncoder.destroy(builder);\n    return outputData;\n  }\n\n};\n\nlet DRACOExporter = _DRACOExporter; // Encoder methods\n\n__publicField(DRACOExporter, \"MESH_EDGEBREAKER_ENCODING\", 1);\n\n__publicField(DRACOExporter, \"MESH_SEQUENTIAL_ENCODING\", 0); // Geometry type\n\n\n__publicField(DRACOExporter, \"POINT_CLOUD\", 0);\n\n__publicField(DRACOExporter, \"TRIANGULAR_MESH\", 1); // Attribute type\n\n\n__publicField(DRACOExporter, \"INVALID\", -1);\n\n__publicField(DRACOExporter, \"POSITION\", 0);\n\n__publicField(DRACOExporter, \"NORMAL\", 1);\n\n__publicField(DRACOExporter, \"COLOR\", 2);\n\n__publicField(DRACOExporter, \"TEX_COORD\", 3);\n\n__publicField(DRACOExporter, \"GENERIC\", 4);\n\nexport { DRACOExporter };","map":{"version":3,"sources":["/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/three-stdlib/exporters/DRACOExporter.js"],"names":["__defProp","Object","defineProperty","__defNormalProp","obj","key","value","enumerable","configurable","writable","__publicField","BufferGeometry","Mesh","Points","_DRACOExporter","parse","object","options","decodeSpeed","encodeSpeed","encoderMethod","MESH_EDGEBREAKER_ENCODING","quantization","exportUvs","exportNormals","exportColor","isBufferGeometry","Error","DracoEncoderModule","geometry","dracoEncoder","encoder","Encoder","builder","dracoObject","isMesh","MeshBuilder","vertices","getAttribute","AddFloatAttributeToMesh","POSITION","count","itemSize","array","faces","getIndex","AddFacesToMesh","faces2","Uint32Array","Uint16Array","i","length","normals","NORMAL","uvs","TEX_COORD","colors","COLOR","isPoints","PointCloudBuilder","PointCloud","AddFloatAttribute","encodedData","DracoInt8Array","SetSpeedOptions","SetEncodingMethod","SetAttributeQuantization","EncodeMeshToDracoBuffer","EncodePointCloudToDracoBuffer","destroy","outputData","Int8Array","ArrayBuffer","GetValue","DRACOExporter"],"mappings":"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","sourcesContent":["var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { BufferGeometry, Mesh, Points } from \"three\";\nconst _DRACOExporter = class {\n  parse(object, options = {\n    decodeSpeed: 5,\n    encodeSpeed: 5,\n    encoderMethod: _DRACOExporter.MESH_EDGEBREAKER_ENCODING,\n    quantization: [16, 8, 8, 8, 8],\n    exportUvs: true,\n    exportNormals: true,\n    exportColor: false\n  }) {\n    if (object instanceof BufferGeometry && object.isBufferGeometry) {\n      throw new Error(\"DRACOExporter: The first parameter of parse() is now an instance of Mesh or Points.\");\n    }\n    if (DracoEncoderModule === void 0) {\n      throw new Error(\"THREE.DRACOExporter: required the draco_encoder to work.\");\n    }\n    const geometry = object.geometry;\n    const dracoEncoder = DracoEncoderModule();\n    const encoder = new dracoEncoder.Encoder();\n    let builder;\n    let dracoObject;\n    if (!geometry.isBufferGeometry) {\n      throw new Error(\"THREE.DRACOExporter.parse(geometry, options): geometry is not a THREE.BufferGeometry instance.\");\n    }\n    if (object instanceof Mesh && object.isMesh) {\n      builder = new dracoEncoder.MeshBuilder();\n      dracoObject = new dracoEncoder.Mesh();\n      const vertices = geometry.getAttribute(\"position\");\n      builder.AddFloatAttributeToMesh(\n        dracoObject,\n        dracoEncoder.POSITION,\n        vertices.count,\n        vertices.itemSize,\n        vertices.array\n      );\n      const faces = geometry.getIndex();\n      if (faces !== null) {\n        builder.AddFacesToMesh(dracoObject, faces.count / 3, faces.array);\n      } else {\n        const faces2 = new (vertices.count > 65535 ? Uint32Array : Uint16Array)(vertices.count);\n        for (let i = 0; i < faces2.length; i++) {\n          faces2[i] = i;\n        }\n        builder.AddFacesToMesh(dracoObject, vertices.count, faces2);\n      }\n      if (options.exportNormals) {\n        const normals = geometry.getAttribute(\"normal\");\n        if (normals !== void 0) {\n          builder.AddFloatAttributeToMesh(\n            dracoObject,\n            dracoEncoder.NORMAL,\n            normals.count,\n            normals.itemSize,\n            normals.array\n          );\n        }\n      }\n      if (options.exportUvs) {\n        const uvs = geometry.getAttribute(\"uv\");\n        if (uvs !== void 0) {\n          builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.TEX_COORD, uvs.count, uvs.itemSize, uvs.array);\n        }\n      }\n      if (options.exportColor) {\n        const colors = geometry.getAttribute(\"color\");\n        if (colors !== void 0) {\n          builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.COLOR, colors.count, colors.itemSize, colors.array);\n        }\n      }\n    } else if (object instanceof Points && object.isPoints) {\n      builder = new dracoEncoder.PointCloudBuilder();\n      dracoObject = new dracoEncoder.PointCloud();\n      const vertices = geometry.getAttribute(\"position\");\n      builder.AddFloatAttribute(dracoObject, dracoEncoder.POSITION, vertices.count, vertices.itemSize, vertices.array);\n      if (options.exportColor) {\n        const colors = geometry.getAttribute(\"color\");\n        if (colors !== void 0) {\n          builder.AddFloatAttribute(dracoObject, dracoEncoder.COLOR, colors.count, colors.itemSize, colors.array);\n        }\n      }\n    } else {\n      throw new Error(\"DRACOExporter: Unsupported object type.\");\n    }\n    const encodedData = new dracoEncoder.DracoInt8Array();\n    const encodeSpeed = options.encodeSpeed !== void 0 ? options.encodeSpeed : 5;\n    const decodeSpeed = options.decodeSpeed !== void 0 ? options.decodeSpeed : 5;\n    encoder.SetSpeedOptions(encodeSpeed, decodeSpeed);\n    if (options.encoderMethod !== void 0) {\n      encoder.SetEncodingMethod(options.encoderMethod);\n    }\n    if (options.quantization !== void 0) {\n      for (let i = 0; i < 5; i++) {\n        if (options.quantization[i] !== void 0) {\n          encoder.SetAttributeQuantization(i, options.quantization[i]);\n        }\n      }\n    }\n    let length;\n    if (object instanceof Mesh && object.isMesh) {\n      length = encoder.EncodeMeshToDracoBuffer(dracoObject, encodedData);\n    } else {\n      length = encoder.EncodePointCloudToDracoBuffer(dracoObject, true, encodedData);\n    }\n    dracoEncoder.destroy(dracoObject);\n    if (length === 0) {\n      throw new Error(\"THREE.DRACOExporter: Draco encoding failed.\");\n    }\n    const outputData = new Int8Array(new ArrayBuffer(length));\n    for (let i = 0; i < length; i++) {\n      outputData[i] = encodedData.GetValue(i);\n    }\n    dracoEncoder.destroy(encodedData);\n    dracoEncoder.destroy(encoder);\n    dracoEncoder.destroy(builder);\n    return outputData;\n  }\n};\nlet DRACOExporter = _DRACOExporter;\n// Encoder methods\n__publicField(DRACOExporter, \"MESH_EDGEBREAKER_ENCODING\", 1);\n__publicField(DRACOExporter, \"MESH_SEQUENTIAL_ENCODING\", 0);\n// Geometry type\n__publicField(DRACOExporter, \"POINT_CLOUD\", 0);\n__publicField(DRACOExporter, \"TRIANGULAR_MESH\", 1);\n// Attribute type\n__publicField(DRACOExporter, \"INVALID\", -1);\n__publicField(DRACOExporter, \"POSITION\", 0);\n__publicField(DRACOExporter, \"NORMAL\", 1);\n__publicField(DRACOExporter, \"COLOR\", 2);\n__publicField(DRACOExporter, \"TEX_COORD\", 3);\n__publicField(DRACOExporter, \"GENERIC\", 4);\nexport {\n  DRACOExporter\n};\n"]},"metadata":{},"sourceType":"module"}