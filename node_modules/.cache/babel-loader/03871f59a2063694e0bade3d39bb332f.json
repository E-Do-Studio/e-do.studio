{"ast":null,"code":"import _classCallCheck from \"/Users/theodaguier/Repositories/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/theodaguier/Repositories/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { Matrix4, Vector3 } from \"three\";\nvar inverseProjectionMatrix = /* @__PURE__ */new Matrix4();\n\nvar CSMFrustum = /*#__PURE__*/function () {\n  function CSMFrustum(data) {\n    _classCallCheck(this, CSMFrustum);\n\n    data = data || {};\n    this.vertices = {\n      near: [new Vector3(), new Vector3(), new Vector3(), new Vector3()],\n      far: [new Vector3(), new Vector3(), new Vector3(), new Vector3()]\n    };\n\n    if (data.projectionMatrix !== void 0) {\n      this.setFromProjectionMatrix(data.projectionMatrix, data.maxFar || 1e4);\n    }\n  }\n\n  _createClass(CSMFrustum, [{\n    key: \"setFromProjectionMatrix\",\n    value: function setFromProjectionMatrix(projectionMatrix, maxFar) {\n      var isOrthographic = projectionMatrix.elements[2 * 4 + 3] === 0;\n      inverseProjectionMatrix.copy(projectionMatrix).invert();\n      this.vertices.near[0].set(1, 1, -1);\n      this.vertices.near[1].set(1, -1, -1);\n      this.vertices.near[2].set(-1, -1, -1);\n      this.vertices.near[3].set(-1, 1, -1);\n      this.vertices.near.forEach(function (v) {\n        v.applyMatrix4(inverseProjectionMatrix);\n      });\n      this.vertices.far[0].set(1, 1, 1);\n      this.vertices.far[1].set(1, -1, 1);\n      this.vertices.far[2].set(-1, -1, 1);\n      this.vertices.far[3].set(-1, 1, 1);\n      this.vertices.far.forEach(function (v) {\n        v.applyMatrix4(inverseProjectionMatrix);\n        var absZ = Math.abs(v.z);\n\n        if (isOrthographic) {\n          v.z *= Math.min(maxFar / absZ, 1);\n        } else {\n          v.multiplyScalar(Math.min(maxFar / absZ, 1));\n        }\n      });\n      return this.vertices;\n    }\n  }, {\n    key: \"split\",\n    value: function split(breaks, target) {\n      while (breaks.length > target.length) {\n        target.push(new CSMFrustum());\n      }\n\n      target.length = breaks.length;\n\n      for (var i = 0; i < breaks.length; i++) {\n        var cascade = target[i];\n\n        if (i === 0) {\n          for (var j = 0; j < 4; j++) {\n            cascade.vertices.near[j].copy(this.vertices.near[j]);\n          }\n        } else {\n          for (var _j = 0; _j < 4; _j++) {\n            cascade.vertices.near[_j].lerpVectors(this.vertices.near[_j], this.vertices.far[_j], breaks[i - 1]);\n          }\n        }\n\n        if (i === breaks.length - 1) {\n          for (var _j2 = 0; _j2 < 4; _j2++) {\n            cascade.vertices.far[_j2].copy(this.vertices.far[_j2]);\n          }\n        } else {\n          for (var _j3 = 0; _j3 < 4; _j3++) {\n            cascade.vertices.far[_j3].lerpVectors(this.vertices.near[_j3], this.vertices.far[_j3], breaks[i]);\n          }\n        }\n      }\n    }\n  }, {\n    key: \"toSpace\",\n    value: function toSpace(cameraMatrix, target) {\n      for (var i = 0; i < 4; i++) {\n        target.vertices.near[i].copy(this.vertices.near[i]).applyMatrix4(cameraMatrix);\n        target.vertices.far[i].copy(this.vertices.far[i]).applyMatrix4(cameraMatrix);\n      }\n    }\n  }]);\n\n  return CSMFrustum;\n}();\n\nexport { CSMFrustum };","map":{"version":3,"sources":["/Users/theodaguier/Repositories/E-Do-Studio/node_modules/three-stdlib/csm/CSMFrustum.js"],"names":["Matrix4","Vector3","inverseProjectionMatrix","CSMFrustum","data","vertices","near","far","projectionMatrix","setFromProjectionMatrix","maxFar","isOrthographic","elements","copy","invert","set","forEach","v","applyMatrix4","absZ","Math","abs","z","min","multiplyScalar","breaks","target","length","push","i","cascade","j","lerpVectors","cameraMatrix"],"mappings":"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","sourcesContent":["import { Matrix4, Vector3 } from \"three\";\nconst inverseProjectionMatrix = /* @__PURE__ */ new Matrix4();\nclass CSMFrustum {\n  constructor(data) {\n    data = data || {};\n    this.vertices = {\n      near: [new Vector3(), new Vector3(), new Vector3(), new Vector3()],\n      far: [new Vector3(), new Vector3(), new Vector3(), new Vector3()]\n    };\n    if (data.projectionMatrix !== void 0) {\n      this.setFromProjectionMatrix(data.projectionMatrix, data.maxFar || 1e4);\n    }\n  }\n  setFromProjectionMatrix(projectionMatrix, maxFar) {\n    const isOrthographic = projectionMatrix.elements[2 * 4 + 3] === 0;\n    inverseProjectionMatrix.copy(projectionMatrix).invert();\n    this.vertices.near[0].set(1, 1, -1);\n    this.vertices.near[1].set(1, -1, -1);\n    this.vertices.near[2].set(-1, -1, -1);\n    this.vertices.near[3].set(-1, 1, -1);\n    this.vertices.near.forEach(function(v) {\n      v.applyMatrix4(inverseProjectionMatrix);\n    });\n    this.vertices.far[0].set(1, 1, 1);\n    this.vertices.far[1].set(1, -1, 1);\n    this.vertices.far[2].set(-1, -1, 1);\n    this.vertices.far[3].set(-1, 1, 1);\n    this.vertices.far.forEach(function(v) {\n      v.applyMatrix4(inverseProjectionMatrix);\n      const absZ = Math.abs(v.z);\n      if (isOrthographic) {\n        v.z *= Math.min(maxFar / absZ, 1);\n      } else {\n        v.multiplyScalar(Math.min(maxFar / absZ, 1));\n      }\n    });\n    return this.vertices;\n  }\n  split(breaks, target) {\n    while (breaks.length > target.length) {\n      target.push(new CSMFrustum());\n    }\n    target.length = breaks.length;\n    for (let i = 0; i < breaks.length; i++) {\n      const cascade = target[i];\n      if (i === 0) {\n        for (let j = 0; j < 4; j++) {\n          cascade.vertices.near[j].copy(this.vertices.near[j]);\n        }\n      } else {\n        for (let j = 0; j < 4; j++) {\n          cascade.vertices.near[j].lerpVectors(this.vertices.near[j], this.vertices.far[j], breaks[i - 1]);\n        }\n      }\n      if (i === breaks.length - 1) {\n        for (let j = 0; j < 4; j++) {\n          cascade.vertices.far[j].copy(this.vertices.far[j]);\n        }\n      } else {\n        for (let j = 0; j < 4; j++) {\n          cascade.vertices.far[j].lerpVectors(this.vertices.near[j], this.vertices.far[j], breaks[i]);\n        }\n      }\n    }\n  }\n  toSpace(cameraMatrix, target) {\n    for (let i = 0; i < 4; i++) {\n      target.vertices.near[i].copy(this.vertices.near[i]).applyMatrix4(cameraMatrix);\n      target.vertices.far[i].copy(this.vertices.far[i]).applyMatrix4(cameraMatrix);\n    }\n  }\n}\nexport {\n  CSMFrustum\n};\n"]},"metadata":{},"sourceType":"module"}