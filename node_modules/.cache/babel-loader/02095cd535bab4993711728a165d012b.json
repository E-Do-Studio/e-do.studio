{"ast":null,"code":"var __defProp = Object.defineProperty;\n\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\n\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n\n  return value;\n};\n\nimport { Mesh, Object3D, SphereGeometry, MeshBasicMaterial } from \"three\";\nimport { GLTFLoader } from \"../loaders/GLTFLoader.js\";\nimport { MotionControllerConstants, fetchProfile, MotionController } from \"../libs/MotionControllers.js\";\nconst DEFAULT_PROFILES_PATH = \"https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles\";\nconst DEFAULT_PROFILE = \"generic-trigger\";\n\nconst applyEnvironmentMap = (envMap, obj) => {\n  obj.traverse(child => {\n    if (child instanceof Mesh && \"envMap\" in child.material) {\n      child.material.envMap = envMap;\n      child.material.needsUpdate = true;\n    }\n  });\n};\n\nclass XRControllerModel extends Object3D {\n  constructor() {\n    super();\n\n    __publicField(this, \"envMap\");\n\n    __publicField(this, \"motionController\");\n\n    this.motionController = null;\n    this.envMap = null;\n  }\n\n  setEnvironmentMap(envMap) {\n    if (this.envMap == envMap) {\n      return this;\n    }\n\n    this.envMap = envMap;\n    applyEnvironmentMap(this.envMap, this);\n    return this;\n  }\n  /**\n   * Polls data from the XRInputSource and updates the model's components to match\n   * the real world data\n   */\n\n\n  updateMatrixWorld(force) {\n    super.updateMatrixWorld(force);\n    if (!this.motionController) return;\n    this.motionController.updateFromGamepad();\n    Object.values(this.motionController.components).forEach(component => {\n      Object.values(component.visualResponses).forEach(visualResponse => {\n        const {\n          valueNode,\n          minNode,\n          maxNode,\n          value,\n          valueNodeProperty\n        } = visualResponse;\n        if (!valueNode) return;\n\n        if (valueNodeProperty === MotionControllerConstants.VisualResponseProperty.VISIBILITY && typeof value === \"boolean\") {\n          valueNode.visible = value;\n        } else if (valueNodeProperty === MotionControllerConstants.VisualResponseProperty.TRANSFORM && minNode && maxNode && typeof value === \"number\") {\n          valueNode.quaternion.slerpQuaternions(minNode.quaternion, maxNode.quaternion, value);\n          valueNode.position.lerpVectors(minNode.position, maxNode.position, value);\n        }\n      });\n    });\n  }\n\n}\n\nfunction findNodes(motionController, scene) {\n  Object.values(motionController.components).forEach(component => {\n    const {\n      type,\n      touchPointNodeName,\n      visualResponses\n    } = component;\n\n    if (type === MotionControllerConstants.ComponentType.TOUCHPAD && touchPointNodeName) {\n      component.touchPointNode = scene.getObjectByName(touchPointNodeName);\n\n      if (component.touchPointNode) {\n        const sphereGeometry = new SphereGeometry(1e-3);\n        const material = new MeshBasicMaterial({\n          color: 255\n        });\n        const sphere = new Mesh(sphereGeometry, material);\n        component.touchPointNode.add(sphere);\n      } else {\n        console.warn(`Could not find touch dot, ${component.touchPointNodeName}, in touchpad component ${component.id}`);\n      }\n    }\n\n    Object.values(visualResponses).forEach(visualResponse => {\n      const {\n        valueNodeName,\n        minNodeName,\n        maxNodeName,\n        valueNodeProperty\n      } = visualResponse;\n\n      if (valueNodeProperty === MotionControllerConstants.VisualResponseProperty.TRANSFORM && minNodeName && maxNodeName) {\n        visualResponse.minNode = scene.getObjectByName(minNodeName);\n        visualResponse.maxNode = scene.getObjectByName(maxNodeName);\n\n        if (!visualResponse.minNode) {\n          console.warn(`Could not find ${minNodeName} in the model`);\n          return;\n        }\n\n        if (!visualResponse.maxNode) {\n          console.warn(`Could not find ${maxNodeName} in the model`);\n          return;\n        }\n      }\n\n      visualResponse.valueNode = scene.getObjectByName(valueNodeName);\n\n      if (!visualResponse.valueNode) {\n        console.warn(`Could not find ${valueNodeName} in the model`);\n      }\n    });\n  });\n}\n\nfunction addAssetSceneToControllerModel(controllerModel, scene) {\n  findNodes(controllerModel.motionController, scene);\n\n  if (controllerModel.envMap) {\n    applyEnvironmentMap(controllerModel.envMap, scene);\n  }\n\n  controllerModel.add(scene);\n}\n\nclass XRControllerModelFactory {\n  constructor(gltfLoader = null) {\n    __publicField(this, \"gltfLoader\");\n\n    __publicField(this, \"path\");\n\n    __publicField(this, \"_assetCache\");\n\n    this.gltfLoader = gltfLoader;\n    this.path = DEFAULT_PROFILES_PATH;\n    this._assetCache = {};\n\n    if (!this.gltfLoader) {\n      this.gltfLoader = new GLTFLoader();\n    }\n  }\n\n  createControllerModel(controller) {\n    const controllerModel = new XRControllerModel();\n    let scene = null;\n\n    const onConnected = event => {\n      const xrInputSource = event.data;\n      if (xrInputSource.targetRayMode !== \"tracked-pointer\" || !xrInputSource.gamepad) return;\n      fetchProfile(xrInputSource, this.path, DEFAULT_PROFILE).then(({\n        profile,\n        assetPath\n      }) => {\n        if (!assetPath) {\n          throw new Error(\"no asset path\");\n        }\n\n        controllerModel.motionController = new MotionController(xrInputSource, profile, assetPath);\n        const assetUrl = controllerModel.motionController.assetUrl;\n        const cachedAsset = this._assetCache[assetUrl];\n\n        if (cachedAsset) {\n          scene = cachedAsset.scene.clone();\n          addAssetSceneToControllerModel(controllerModel, scene);\n        } else {\n          if (!this.gltfLoader) {\n            throw new Error(\"GLTFLoader not set.\");\n          }\n\n          this.gltfLoader.setPath(\"\");\n          this.gltfLoader.load(controllerModel.motionController.assetUrl, asset => {\n            if (!controllerModel.motionController) {\n              console.warn(\"motionController gone while gltf load, bailing...\");\n              return;\n            }\n\n            this._assetCache[assetUrl] = asset;\n            scene = asset.scene.clone();\n            addAssetSceneToControllerModel(controllerModel, scene);\n          }, () => {}, () => {\n            throw new Error(`Asset ${assetUrl} missing or malformed.`);\n          });\n        }\n      }).catch(err => {\n        console.warn(err);\n      });\n    };\n\n    controller.addEventListener(\"connected\", onConnected);\n\n    const onDisconnected = () => {\n      controller.removeEventListener(\"connected\", onConnected);\n      controller.removeEventListener(\"disconnected\", onDisconnected);\n      controllerModel.motionController = null;\n\n      if (scene) {\n        controllerModel.remove(scene);\n      }\n\n      scene = null;\n    };\n\n    controller.addEventListener(\"disconnected\", onDisconnected);\n    return controllerModel;\n  }\n\n}\n\nexport { XRControllerModelFactory };","map":{"version":3,"sources":["/Users/theodaguier/Repositories/E-Do-Studio/node_modules/three-stdlib/webxr/XRControllerModelFactory.js"],"names":["__defProp","Object","defineProperty","__defNormalProp","obj","key","value","enumerable","configurable","writable","__publicField","Mesh","Object3D","SphereGeometry","MeshBasicMaterial","GLTFLoader","MotionControllerConstants","fetchProfile","MotionController","DEFAULT_PROFILES_PATH","DEFAULT_PROFILE","applyEnvironmentMap","envMap","traverse","child","material","needsUpdate","XRControllerModel","constructor","motionController","setEnvironmentMap","updateMatrixWorld","force","updateFromGamepad","values","components","forEach","component","visualResponses","visualResponse","valueNode","minNode","maxNode","valueNodeProperty","VisualResponseProperty","VISIBILITY","visible","TRANSFORM","quaternion","slerpQuaternions","position","lerpVectors","findNodes","scene","type","touchPointNodeName","ComponentType","TOUCHPAD","touchPointNode","getObjectByName","sphereGeometry","color","sphere","add","console","warn","id","valueNodeName","minNodeName","maxNodeName","addAssetSceneToControllerModel","controllerModel","XRControllerModelFactory","gltfLoader","path","_assetCache","createControllerModel","controller","onConnected","event","xrInputSource","data","targetRayMode","gamepad","then","profile","assetPath","Error","assetUrl","cachedAsset","clone","setPath","load","asset","catch","err","addEventListener","onDisconnected","removeEventListener","remove"],"mappings":"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","sourcesContent":["var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Mesh, Object3D, SphereGeometry, MeshBasicMaterial } from \"three\";\nimport { GLTFLoader } from \"../loaders/GLTFLoader.js\";\nimport { MotionControllerConstants, fetchProfile, MotionController } from \"../libs/MotionControllers.js\";\nconst DEFAULT_PROFILES_PATH = \"https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles\";\nconst DEFAULT_PROFILE = \"generic-trigger\";\nconst applyEnvironmentMap = (envMap, obj) => {\n  obj.traverse((child) => {\n    if (child instanceof Mesh && \"envMap\" in child.material) {\n      child.material.envMap = envMap;\n      child.material.needsUpdate = true;\n    }\n  });\n};\nclass XRControllerModel extends Object3D {\n  constructor() {\n    super();\n    __publicField(this, \"envMap\");\n    __publicField(this, \"motionController\");\n    this.motionController = null;\n    this.envMap = null;\n  }\n  setEnvironmentMap(envMap) {\n    if (this.envMap == envMap) {\n      return this;\n    }\n    this.envMap = envMap;\n    applyEnvironmentMap(this.envMap, this);\n    return this;\n  }\n  /**\n   * Polls data from the XRInputSource and updates the model's components to match\n   * the real world data\n   */\n  updateMatrixWorld(force) {\n    super.updateMatrixWorld(force);\n    if (!this.motionController)\n      return;\n    this.motionController.updateFromGamepad();\n    Object.values(this.motionController.components).forEach((component) => {\n      Object.values(component.visualResponses).forEach((visualResponse) => {\n        const { valueNode, minNode, maxNode, value, valueNodeProperty } = visualResponse;\n        if (!valueNode)\n          return;\n        if (valueNodeProperty === MotionControllerConstants.VisualResponseProperty.VISIBILITY && typeof value === \"boolean\") {\n          valueNode.visible = value;\n        } else if (valueNodeProperty === MotionControllerConstants.VisualResponseProperty.TRANSFORM && minNode && maxNode && typeof value === \"number\") {\n          valueNode.quaternion.slerpQuaternions(minNode.quaternion, maxNode.quaternion, value);\n          valueNode.position.lerpVectors(minNode.position, maxNode.position, value);\n        }\n      });\n    });\n  }\n}\nfunction findNodes(motionController, scene) {\n  Object.values(motionController.components).forEach((component) => {\n    const { type, touchPointNodeName, visualResponses } = component;\n    if (type === MotionControllerConstants.ComponentType.TOUCHPAD && touchPointNodeName) {\n      component.touchPointNode = scene.getObjectByName(touchPointNodeName);\n      if (component.touchPointNode) {\n        const sphereGeometry = new SphereGeometry(1e-3);\n        const material = new MeshBasicMaterial({ color: 255 });\n        const sphere = new Mesh(sphereGeometry, material);\n        component.touchPointNode.add(sphere);\n      } else {\n        console.warn(`Could not find touch dot, ${component.touchPointNodeName}, in touchpad component ${component.id}`);\n      }\n    }\n    Object.values(visualResponses).forEach((visualResponse) => {\n      const { valueNodeName, minNodeName, maxNodeName, valueNodeProperty } = visualResponse;\n      if (valueNodeProperty === MotionControllerConstants.VisualResponseProperty.TRANSFORM && minNodeName && maxNodeName) {\n        visualResponse.minNode = scene.getObjectByName(minNodeName);\n        visualResponse.maxNode = scene.getObjectByName(maxNodeName);\n        if (!visualResponse.minNode) {\n          console.warn(`Could not find ${minNodeName} in the model`);\n          return;\n        }\n        if (!visualResponse.maxNode) {\n          console.warn(`Could not find ${maxNodeName} in the model`);\n          return;\n        }\n      }\n      visualResponse.valueNode = scene.getObjectByName(valueNodeName);\n      if (!visualResponse.valueNode) {\n        console.warn(`Could not find ${valueNodeName} in the model`);\n      }\n    });\n  });\n}\nfunction addAssetSceneToControllerModel(controllerModel, scene) {\n  findNodes(controllerModel.motionController, scene);\n  if (controllerModel.envMap) {\n    applyEnvironmentMap(controllerModel.envMap, scene);\n  }\n  controllerModel.add(scene);\n}\nclass XRControllerModelFactory {\n  constructor(gltfLoader = null) {\n    __publicField(this, \"gltfLoader\");\n    __publicField(this, \"path\");\n    __publicField(this, \"_assetCache\");\n    this.gltfLoader = gltfLoader;\n    this.path = DEFAULT_PROFILES_PATH;\n    this._assetCache = {};\n    if (!this.gltfLoader) {\n      this.gltfLoader = new GLTFLoader();\n    }\n  }\n  createControllerModel(controller) {\n    const controllerModel = new XRControllerModel();\n    let scene = null;\n    const onConnected = (event) => {\n      const xrInputSource = event.data;\n      if (xrInputSource.targetRayMode !== \"tracked-pointer\" || !xrInputSource.gamepad)\n        return;\n      fetchProfile(xrInputSource, this.path, DEFAULT_PROFILE).then(({ profile, assetPath }) => {\n        if (!assetPath) {\n          throw new Error(\"no asset path\");\n        }\n        controllerModel.motionController = new MotionController(xrInputSource, profile, assetPath);\n        const assetUrl = controllerModel.motionController.assetUrl;\n        const cachedAsset = this._assetCache[assetUrl];\n        if (cachedAsset) {\n          scene = cachedAsset.scene.clone();\n          addAssetSceneToControllerModel(controllerModel, scene);\n        } else {\n          if (!this.gltfLoader) {\n            throw new Error(\"GLTFLoader not set.\");\n          }\n          this.gltfLoader.setPath(\"\");\n          this.gltfLoader.load(\n            controllerModel.motionController.assetUrl,\n            (asset) => {\n              if (!controllerModel.motionController) {\n                console.warn(\"motionController gone while gltf load, bailing...\");\n                return;\n              }\n              this._assetCache[assetUrl] = asset;\n              scene = asset.scene.clone();\n              addAssetSceneToControllerModel(controllerModel, scene);\n            },\n            () => {\n            },\n            () => {\n              throw new Error(`Asset ${assetUrl} missing or malformed.`);\n            }\n          );\n        }\n      }).catch((err) => {\n        console.warn(err);\n      });\n    };\n    controller.addEventListener(\"connected\", onConnected);\n    const onDisconnected = () => {\n      controller.removeEventListener(\"connected\", onConnected);\n      controller.removeEventListener(\"disconnected\", onDisconnected);\n      controllerModel.motionController = null;\n      if (scene) {\n        controllerModel.remove(scene);\n      }\n      scene = null;\n    };\n    controller.addEventListener(\"disconnected\", onDisconnected);\n    return controllerModel;\n  }\n}\nexport {\n  XRControllerModelFactory\n};\n"]},"metadata":{},"sourceType":"module"}