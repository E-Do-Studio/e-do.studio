{"ast":null,"code":"var __defProp = Object.defineProperty;\n\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\n\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n\n  return value;\n};\n\nimport { Loader, FileLoader, ShapePath } from \"three\";\n\nclass FontLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, response => {\n      if (typeof response !== \"string\") throw new Error(\"unsupported data type\");\n      const json = JSON.parse(response);\n      const font = this.parse(json);\n      if (onLoad) onLoad(font);\n    }, onProgress, onError);\n  }\n\n  loadAsync(url, onProgress) {\n    return super.loadAsync(url, onProgress);\n  }\n\n  parse(json) {\n    return new Font(json);\n  }\n\n}\n\nclass Font {\n  constructor(data) {\n    __publicField(this, \"data\");\n\n    this.data = data;\n  }\n\n  generateShapes(text, size = 100, _options) {\n    const shapes = [];\n    const options = {\n      letterSpacing: 0,\n      lineHeight: 1,\n      ..._options\n    };\n    const paths = createPaths(text, size, this.data, options);\n\n    for (let p = 0, pl = paths.length; p < pl; p++) {\n      Array.prototype.push.apply(shapes, paths[p].toShapes(false));\n    }\n\n    return shapes;\n  }\n\n}\n\n__publicField(Font, \"isFont\");\n\n__publicField(Font, \"type\");\n\nfunction createPaths(text, size, data, options) {\n  const chars = Array.from(text);\n  const scale = size / data.resolution;\n  const line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;\n  const paths = [];\n  let offsetX = 0,\n      offsetY = 0;\n\n  for (let i = 0; i < chars.length; i++) {\n    const char = chars[i];\n\n    if (char === \"\\n\") {\n      offsetX = 0;\n      offsetY -= line_height * options.lineHeight;\n    } else {\n      const ret = createPath(char, scale, offsetX, offsetY, data);\n\n      if (ret) {\n        offsetX += ret.offsetX + options.letterSpacing;\n        paths.push(ret.path);\n      }\n    }\n  }\n\n  return paths;\n}\n\nfunction createPath(char, scale, offsetX, offsetY, data) {\n  const glyph = data.glyphs[char] || data.glyphs[\"?\"];\n\n  if (!glyph) {\n    console.error('THREE.Font: character \"' + char + '\" does not exists in font family ' + data.familyName + \".\");\n    return;\n  }\n\n  const path = new ShapePath();\n  let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;\n\n  if (glyph.o) {\n    const outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(\" \"));\n\n    for (let i = 0, l = outline.length; i < l;) {\n      const action = outline[i++];\n\n      switch (action) {\n        case \"m\":\n          x = parseInt(outline[i++]) * scale + offsetX;\n          y = parseInt(outline[i++]) * scale + offsetY;\n          path.moveTo(x, y);\n          break;\n\n        case \"l\":\n          x = parseInt(outline[i++]) * scale + offsetX;\n          y = parseInt(outline[i++]) * scale + offsetY;\n          path.lineTo(x, y);\n          break;\n\n        case \"q\":\n          cpx = parseInt(outline[i++]) * scale + offsetX;\n          cpy = parseInt(outline[i++]) * scale + offsetY;\n          cpx1 = parseInt(outline[i++]) * scale + offsetX;\n          cpy1 = parseInt(outline[i++]) * scale + offsetY;\n          path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);\n          break;\n\n        case \"b\":\n          cpx = parseInt(outline[i++]) * scale + offsetX;\n          cpy = parseInt(outline[i++]) * scale + offsetY;\n          cpx1 = parseInt(outline[i++]) * scale + offsetX;\n          cpy1 = parseInt(outline[i++]) * scale + offsetY;\n          cpx2 = parseInt(outline[i++]) * scale + offsetX;\n          cpy2 = parseInt(outline[i++]) * scale + offsetY;\n          path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);\n          break;\n      }\n    }\n  }\n\n  return {\n    offsetX: glyph.ha * scale,\n    path\n  };\n}\n\nexport { Font, FontLoader };","map":{"version":3,"sources":["/Users/theodaguier/Repositories/E-Do-Studio/node_modules/three-stdlib/loaders/FontLoader.js"],"names":["__defProp","Object","defineProperty","__defNormalProp","obj","key","value","enumerable","configurable","writable","__publicField","Loader","FileLoader","ShapePath","FontLoader","constructor","manager","load","url","onLoad","onProgress","onError","loader","setPath","path","setRequestHeader","requestHeader","setWithCredentials","withCredentials","response","Error","json","JSON","parse","font","loadAsync","Font","data","generateShapes","text","size","_options","shapes","options","letterSpacing","lineHeight","paths","createPaths","p","pl","length","Array","prototype","push","apply","toShapes","chars","from","scale","resolution","line_height","boundingBox","yMax","yMin","underlineThickness","offsetX","offsetY","i","char","ret","createPath","glyph","glyphs","console","error","familyName","x","y","cpx","cpy","cpx1","cpy1","cpx2","cpy2","o","outline","_cachedOutline","split","l","action","parseInt","moveTo","lineTo","quadraticCurveTo","bezierCurveTo","ha"],"mappings":"AAAA,IAAIA,SAAS,GAAGC,MAAM,CAACC,cAAvB;;AACA,IAAIC,eAAe,GAAG,CAACC,GAAD,EAAMC,GAAN,EAAWC,KAAX,KAAqBD,GAAG,IAAID,GAAP,GAAaJ,SAAS,CAACI,GAAD,EAAMC,GAAN,EAAW;AAAEE,EAAAA,UAAU,EAAE,IAAd;AAAoBC,EAAAA,YAAY,EAAE,IAAlC;AAAwCC,EAAAA,QAAQ,EAAE,IAAlD;AAAwDH,EAAAA;AAAxD,CAAX,CAAtB,GAAoGF,GAAG,CAACC,GAAD,CAAH,GAAWC,KAA1J;;AACA,IAAII,aAAa,GAAG,CAACN,GAAD,EAAMC,GAAN,EAAWC,KAAX,KAAqB;AACvCH,EAAAA,eAAe,CAACC,GAAD,EAAM,OAAOC,GAAP,KAAe,QAAf,GAA0BA,GAAG,GAAG,EAAhC,GAAqCA,GAA3C,EAAgDC,KAAhD,CAAf;;AACA,SAAOA,KAAP;AACD,CAHD;;AAIA,SAASK,MAAT,EAAiBC,UAAjB,EAA6BC,SAA7B,QAA8C,OAA9C;;AACA,MAAMC,UAAN,SAAyBH,MAAzB,CAAgC;AAC9BI,EAAAA,WAAW,CAACC,OAAD,EAAU;AACnB,UAAMA,OAAN;AACD;;AACDC,EAAAA,IAAI,CAACC,GAAD,EAAMC,MAAN,EAAcC,UAAd,EAA0BC,OAA1B,EAAmC;AACrC,UAAMC,MAAM,GAAG,IAAIV,UAAJ,CAAe,KAAKI,OAApB,CAAf;AACAM,IAAAA,MAAM,CAACC,OAAP,CAAe,KAAKC,IAApB;AACAF,IAAAA,MAAM,CAACG,gBAAP,CAAwB,KAAKC,aAA7B;AACAJ,IAAAA,MAAM,CAACK,kBAAP,CAA0B,KAAKC,eAA/B;AACAN,IAAAA,MAAM,CAACL,IAAP,CACEC,GADF,EAEGW,QAAD,IAAc;AACZ,UAAI,OAAOA,QAAP,KAAoB,QAAxB,EACE,MAAM,IAAIC,KAAJ,CAAU,uBAAV,CAAN;AACF,YAAMC,IAAI,GAAGC,IAAI,CAACC,KAAL,CAAWJ,QAAX,CAAb;AACA,YAAMK,IAAI,GAAG,KAAKD,KAAL,CAAWF,IAAX,CAAb;AACA,UAAIZ,MAAJ,EACEA,MAAM,CAACe,IAAD,CAAN;AACH,KATH,EAUEd,UAVF,EAWEC,OAXF;AAaD;;AACDc,EAAAA,SAAS,CAACjB,GAAD,EAAME,UAAN,EAAkB;AACzB,WAAO,MAAMe,SAAN,CAAgBjB,GAAhB,EAAqBE,UAArB,CAAP;AACD;;AACDa,EAAAA,KAAK,CAACF,IAAD,EAAO;AACV,WAAO,IAAIK,IAAJ,CAASL,IAAT,CAAP;AACD;;AA5B6B;;AA8BhC,MAAMK,IAAN,CAAW;AACTrB,EAAAA,WAAW,CAACsB,IAAD,EAAO;AAChB3B,IAAAA,aAAa,CAAC,IAAD,EAAO,MAAP,CAAb;;AACA,SAAK2B,IAAL,GAAYA,IAAZ;AACD;;AACDC,EAAAA,cAAc,CAACC,IAAD,EAAOC,IAAI,GAAG,GAAd,EAAmBC,QAAnB,EAA6B;AACzC,UAAMC,MAAM,GAAG,EAAf;AACA,UAAMC,OAAO,GAAG;AAAEC,MAAAA,aAAa,EAAE,CAAjB;AAAoBC,MAAAA,UAAU,EAAE,CAAhC;AAAmC,SAAGJ;AAAtC,KAAhB;AACA,UAAMK,KAAK,GAAGC,WAAW,CAACR,IAAD,EAAOC,IAAP,EAAa,KAAKH,IAAlB,EAAwBM,OAAxB,CAAzB;;AACA,SAAK,IAAIK,CAAC,GAAG,CAAR,EAAWC,EAAE,GAAGH,KAAK,CAACI,MAA3B,EAAmCF,CAAC,GAAGC,EAAvC,EAA2CD,CAAC,EAA5C,EAAgD;AAC9CG,MAAAA,KAAK,CAACC,SAAN,CAAgBC,IAAhB,CAAqBC,KAArB,CAA2BZ,MAA3B,EAAmCI,KAAK,CAACE,CAAD,CAAL,CAASO,QAAT,CAAkB,KAAlB,CAAnC;AACD;;AACD,WAAOb,MAAP;AACD;;AAbQ;;AAeXhC,aAAa,CAAC0B,IAAD,EAAO,QAAP,CAAb;;AACA1B,aAAa,CAAC0B,IAAD,EAAO,MAAP,CAAb;;AACA,SAASW,WAAT,CAAqBR,IAArB,EAA2BC,IAA3B,EAAiCH,IAAjC,EAAuCM,OAAvC,EAAgD;AAC9C,QAAMa,KAAK,GAAGL,KAAK,CAACM,IAAN,CAAWlB,IAAX,CAAd;AACA,QAAMmB,KAAK,GAAGlB,IAAI,GAAGH,IAAI,CAACsB,UAA1B;AACA,QAAMC,WAAW,GAAG,CAACvB,IAAI,CAACwB,WAAL,CAAiBC,IAAjB,GAAwBzB,IAAI,CAACwB,WAAL,CAAiBE,IAAzC,GAAgD1B,IAAI,CAAC2B,kBAAtD,IAA4EN,KAAhG;AACA,QAAMZ,KAAK,GAAG,EAAd;AACA,MAAImB,OAAO,GAAG,CAAd;AAAA,MAAiBC,OAAO,GAAG,CAA3B;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGX,KAAK,CAACN,MAA1B,EAAkCiB,CAAC,EAAnC,EAAuC;AACrC,UAAMC,IAAI,GAAGZ,KAAK,CAACW,CAAD,CAAlB;;AACA,QAAIC,IAAI,KAAK,IAAb,EAAmB;AACjBH,MAAAA,OAAO,GAAG,CAAV;AACAC,MAAAA,OAAO,IAAIN,WAAW,GAAGjB,OAAO,CAACE,UAAjC;AACD,KAHD,MAGO;AACL,YAAMwB,GAAG,GAAGC,UAAU,CAACF,IAAD,EAAOV,KAAP,EAAcO,OAAd,EAAuBC,OAAvB,EAAgC7B,IAAhC,CAAtB;;AACA,UAAIgC,GAAJ,EAAS;AACPJ,QAAAA,OAAO,IAAII,GAAG,CAACJ,OAAJ,GAActB,OAAO,CAACC,aAAjC;AACAE,QAAAA,KAAK,CAACO,IAAN,CAAWgB,GAAG,CAAC7C,IAAf;AACD;AACF;AACF;;AACD,SAAOsB,KAAP;AACD;;AACD,SAASwB,UAAT,CAAoBF,IAApB,EAA0BV,KAA1B,EAAiCO,OAAjC,EAA0CC,OAA1C,EAAmD7B,IAAnD,EAAyD;AACvD,QAAMkC,KAAK,GAAGlC,IAAI,CAACmC,MAAL,CAAYJ,IAAZ,KAAqB/B,IAAI,CAACmC,MAAL,CAAY,GAAZ,CAAnC;;AACA,MAAI,CAACD,KAAL,EAAY;AACVE,IAAAA,OAAO,CAACC,KAAR,CAAc,4BAA4BN,IAA5B,GAAmC,mCAAnC,GAAyE/B,IAAI,CAACsC,UAA9E,GAA2F,GAAzG;AACA;AACD;;AACD,QAAMnD,IAAI,GAAG,IAAIX,SAAJ,EAAb;AACA,MAAI+D,CAAJ,EAAOC,CAAP,EAAUC,GAAV,EAAeC,GAAf,EAAoBC,IAApB,EAA0BC,IAA1B,EAAgCC,IAAhC,EAAsCC,IAAtC;;AACA,MAAIZ,KAAK,CAACa,CAAV,EAAa;AACX,UAAMC,OAAO,GAAGd,KAAK,CAACe,cAAN,KAAyBf,KAAK,CAACe,cAAN,GAAuBf,KAAK,CAACa,CAAN,CAAQG,KAAR,CAAc,GAAd,CAAhD,CAAhB;;AACA,SAAK,IAAIpB,CAAC,GAAG,CAAR,EAAWqB,CAAC,GAAGH,OAAO,CAACnC,MAA5B,EAAoCiB,CAAC,GAAGqB,CAAxC,GAA6C;AAC3C,YAAMC,MAAM,GAAGJ,OAAO,CAAClB,CAAC,EAAF,CAAtB;;AACA,cAAQsB,MAAR;AACE,aAAK,GAAL;AACEb,UAAAA,CAAC,GAAGc,QAAQ,CAACL,OAAO,CAAClB,CAAC,EAAF,CAAR,CAAR,GAAyBT,KAAzB,GAAiCO,OAArC;AACAY,UAAAA,CAAC,GAAGa,QAAQ,CAACL,OAAO,CAAClB,CAAC,EAAF,CAAR,CAAR,GAAyBT,KAAzB,GAAiCQ,OAArC;AACA1C,UAAAA,IAAI,CAACmE,MAAL,CAAYf,CAAZ,EAAeC,CAAf;AACA;;AACF,aAAK,GAAL;AACED,UAAAA,CAAC,GAAGc,QAAQ,CAACL,OAAO,CAAClB,CAAC,EAAF,CAAR,CAAR,GAAyBT,KAAzB,GAAiCO,OAArC;AACAY,UAAAA,CAAC,GAAGa,QAAQ,CAACL,OAAO,CAAClB,CAAC,EAAF,CAAR,CAAR,GAAyBT,KAAzB,GAAiCQ,OAArC;AACA1C,UAAAA,IAAI,CAACoE,MAAL,CAAYhB,CAAZ,EAAeC,CAAf;AACA;;AACF,aAAK,GAAL;AACEC,UAAAA,GAAG,GAAGY,QAAQ,CAACL,OAAO,CAAClB,CAAC,EAAF,CAAR,CAAR,GAAyBT,KAAzB,GAAiCO,OAAvC;AACAc,UAAAA,GAAG,GAAGW,QAAQ,CAACL,OAAO,CAAClB,CAAC,EAAF,CAAR,CAAR,GAAyBT,KAAzB,GAAiCQ,OAAvC;AACAc,UAAAA,IAAI,GAAGU,QAAQ,CAACL,OAAO,CAAClB,CAAC,EAAF,CAAR,CAAR,GAAyBT,KAAzB,GAAiCO,OAAxC;AACAgB,UAAAA,IAAI,GAAGS,QAAQ,CAACL,OAAO,CAAClB,CAAC,EAAF,CAAR,CAAR,GAAyBT,KAAzB,GAAiCQ,OAAxC;AACA1C,UAAAA,IAAI,CAACqE,gBAAL,CAAsBb,IAAtB,EAA4BC,IAA5B,EAAkCH,GAAlC,EAAuCC,GAAvC;AACA;;AACF,aAAK,GAAL;AACED,UAAAA,GAAG,GAAGY,QAAQ,CAACL,OAAO,CAAClB,CAAC,EAAF,CAAR,CAAR,GAAyBT,KAAzB,GAAiCO,OAAvC;AACAc,UAAAA,GAAG,GAAGW,QAAQ,CAACL,OAAO,CAAClB,CAAC,EAAF,CAAR,CAAR,GAAyBT,KAAzB,GAAiCQ,OAAvC;AACAc,UAAAA,IAAI,GAAGU,QAAQ,CAACL,OAAO,CAAClB,CAAC,EAAF,CAAR,CAAR,GAAyBT,KAAzB,GAAiCO,OAAxC;AACAgB,UAAAA,IAAI,GAAGS,QAAQ,CAACL,OAAO,CAAClB,CAAC,EAAF,CAAR,CAAR,GAAyBT,KAAzB,GAAiCQ,OAAxC;AACAgB,UAAAA,IAAI,GAAGQ,QAAQ,CAACL,OAAO,CAAClB,CAAC,EAAF,CAAR,CAAR,GAAyBT,KAAzB,GAAiCO,OAAxC;AACAkB,UAAAA,IAAI,GAAGO,QAAQ,CAACL,OAAO,CAAClB,CAAC,EAAF,CAAR,CAAR,GAAyBT,KAAzB,GAAiCQ,OAAxC;AACA1C,UAAAA,IAAI,CAACsE,aAAL,CAAmBd,IAAnB,EAAyBC,IAAzB,EAA+BC,IAA/B,EAAqCC,IAArC,EAA2CL,GAA3C,EAAgDC,GAAhD;AACA;AA1BJ;AA4BD;AACF;;AACD,SAAO;AAAEd,IAAAA,OAAO,EAAEM,KAAK,CAACwB,EAAN,GAAWrC,KAAtB;AAA6BlC,IAAAA;AAA7B,GAAP;AACD;;AACD,SACEY,IADF,EAEEtB,UAFF","sourcesContent":["var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Loader, FileLoader, ShapePath } from \"three\";\nclass FontLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  load(url, onLoad, onProgress, onError) {\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(\n      url,\n      (response) => {\n        if (typeof response !== \"string\")\n          throw new Error(\"unsupported data type\");\n        const json = JSON.parse(response);\n        const font = this.parse(json);\n        if (onLoad)\n          onLoad(font);\n      },\n      onProgress,\n      onError\n    );\n  }\n  loadAsync(url, onProgress) {\n    return super.loadAsync(url, onProgress);\n  }\n  parse(json) {\n    return new Font(json);\n  }\n}\nclass Font {\n  constructor(data) {\n    __publicField(this, \"data\");\n    this.data = data;\n  }\n  generateShapes(text, size = 100, _options) {\n    const shapes = [];\n    const options = { letterSpacing: 0, lineHeight: 1, ..._options };\n    const paths = createPaths(text, size, this.data, options);\n    for (let p = 0, pl = paths.length; p < pl; p++) {\n      Array.prototype.push.apply(shapes, paths[p].toShapes(false));\n    }\n    return shapes;\n  }\n}\n__publicField(Font, \"isFont\");\n__publicField(Font, \"type\");\nfunction createPaths(text, size, data, options) {\n  const chars = Array.from(text);\n  const scale = size / data.resolution;\n  const line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;\n  const paths = [];\n  let offsetX = 0, offsetY = 0;\n  for (let i = 0; i < chars.length; i++) {\n    const char = chars[i];\n    if (char === \"\\n\") {\n      offsetX = 0;\n      offsetY -= line_height * options.lineHeight;\n    } else {\n      const ret = createPath(char, scale, offsetX, offsetY, data);\n      if (ret) {\n        offsetX += ret.offsetX + options.letterSpacing;\n        paths.push(ret.path);\n      }\n    }\n  }\n  return paths;\n}\nfunction createPath(char, scale, offsetX, offsetY, data) {\n  const glyph = data.glyphs[char] || data.glyphs[\"?\"];\n  if (!glyph) {\n    console.error('THREE.Font: character \"' + char + '\" does not exists in font family ' + data.familyName + \".\");\n    return;\n  }\n  const path = new ShapePath();\n  let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;\n  if (glyph.o) {\n    const outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(\" \"));\n    for (let i = 0, l = outline.length; i < l; ) {\n      const action = outline[i++];\n      switch (action) {\n        case \"m\":\n          x = parseInt(outline[i++]) * scale + offsetX;\n          y = parseInt(outline[i++]) * scale + offsetY;\n          path.moveTo(x, y);\n          break;\n        case \"l\":\n          x = parseInt(outline[i++]) * scale + offsetX;\n          y = parseInt(outline[i++]) * scale + offsetY;\n          path.lineTo(x, y);\n          break;\n        case \"q\":\n          cpx = parseInt(outline[i++]) * scale + offsetX;\n          cpy = parseInt(outline[i++]) * scale + offsetY;\n          cpx1 = parseInt(outline[i++]) * scale + offsetX;\n          cpy1 = parseInt(outline[i++]) * scale + offsetY;\n          path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);\n          break;\n        case \"b\":\n          cpx = parseInt(outline[i++]) * scale + offsetX;\n          cpy = parseInt(outline[i++]) * scale + offsetY;\n          cpx1 = parseInt(outline[i++]) * scale + offsetX;\n          cpy1 = parseInt(outline[i++]) * scale + offsetY;\n          cpx2 = parseInt(outline[i++]) * scale + offsetX;\n          cpy2 = parseInt(outline[i++]) * scale + offsetY;\n          path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);\n          break;\n      }\n    }\n  }\n  return { offsetX: glyph.ha * scale, path };\n}\nexport {\n  Font,\n  FontLoader\n};\n"]},"metadata":{},"sourceType":"module"}