{"ast":null,"code":"import _classCallCheck from \"/Users/theodaguier/Repositories/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/theodaguier/Repositories/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nvar __defProp = Object.defineProperty;\n\nvar __defNormalProp = function __defNormalProp(obj, key, value) {\n  return key in obj ? __defProp(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\n\nvar __publicField = function __publicField(obj, key, value) {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n\n  return value;\n};\n\nimport { Vector3, Color, Vector2, Mesh, Line, Points, Matrix3, BufferAttribute } from \"three\";\n\nvar OBJExporter = /*#__PURE__*/function () {\n  function OBJExporter() {\n    _classCallCheck(this, OBJExporter);\n\n    __publicField(this, \"output\");\n\n    __publicField(this, \"indexVertex\");\n\n    __publicField(this, \"indexVertexUvs\");\n\n    __publicField(this, \"indexNormals\");\n\n    __publicField(this, \"vertex\");\n\n    __publicField(this, \"color\");\n\n    __publicField(this, \"normal\");\n\n    __publicField(this, \"uv\");\n\n    __publicField(this, \"face\");\n\n    this.output = \"\";\n    this.indexVertex = 0;\n    this.indexVertexUvs = 0;\n    this.indexNormals = 0;\n    this.vertex = new Vector3();\n    this.color = new Color();\n    this.normal = new Vector3();\n    this.uv = new Vector2();\n    this.face = [];\n  }\n\n  _createClass(OBJExporter, [{\n    key: \"parse\",\n    value: function parse(object) {\n      var _this = this;\n\n      object.traverse(function (child) {\n        if (child instanceof Mesh && child.isMesh) {\n          _this.parseMesh(child);\n        }\n\n        if (child instanceof Line && child.isLine) {\n          _this.parseLine(child);\n        }\n\n        if (child instanceof Points && child.isPoints) {\n          _this.parsePoints(child);\n        }\n      });\n      return this.output;\n    }\n  }, {\n    key: \"parseMesh\",\n    value: function parseMesh(mesh) {\n      var nbVertex = 0;\n      var nbNormals = 0;\n      var nbVertexUvs = 0;\n      var geometry = mesh.geometry;\n      var normalMatrixWorld = new Matrix3();\n\n      if (!geometry.isBufferGeometry) {\n        throw new Error(\"THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.\");\n      }\n\n      var vertices = geometry.getAttribute(\"position\");\n      var normals = geometry.getAttribute(\"normal\");\n      var uvs = geometry.getAttribute(\"uv\");\n      var indices = geometry.getIndex();\n      this.output += \"o \".concat(mesh.name, \"\\n\");\n\n      if (mesh.material && !Array.isArray(mesh.material) && mesh.material.name) {\n        this.output += \"usemtl \".concat(mesh.material.name, \"\\n\");\n      }\n\n      if (vertices !== void 0) {\n        for (var i = 0, l = vertices.count; i < l; i++, nbVertex++) {\n          this.vertex.x = vertices.getX(i);\n          this.vertex.y = vertices.getY(i);\n          this.vertex.z = vertices.getZ(i);\n          this.vertex.applyMatrix4(mesh.matrixWorld);\n          this.output += \"v \".concat(this.vertex.x, \" \").concat(this.vertex.y, \" \").concat(this.vertex.z, \"\\n\");\n        }\n      }\n\n      if (uvs !== void 0) {\n        for (var _i = 0, _l = uvs.count; _i < _l; _i++, nbVertexUvs++) {\n          this.uv.x = uvs.getX(_i);\n          this.uv.y = uvs.getY(_i);\n          this.output += \"vt \".concat(this.uv.x, \" \").concat(this.uv.y, \"\\n\");\n        }\n      }\n\n      if (normals !== void 0) {\n        normalMatrixWorld.getNormalMatrix(mesh.matrixWorld);\n\n        for (var _i2 = 0, _l2 = normals.count; _i2 < _l2; _i2++, nbNormals++) {\n          this.normal.x = normals.getX(_i2);\n          this.normal.y = normals.getY(_i2);\n          this.normal.z = normals.getZ(_i2);\n          this.normal.applyMatrix3(normalMatrixWorld).normalize();\n          this.output += \"vn \".concat(this.normal.x, \" \").concat(this.normal.y, \" \").concat(this.normal.z, \"\\n\");\n        }\n      }\n\n      if (indices !== null) {\n        for (var _i3 = 0, _l3 = indices.count; _i3 < _l3; _i3 += 3) {\n          for (var m = 0; m < 3; m++) {\n            var j = indices.getX(_i3 + m) + 1;\n            this.face[m] = this.indexVertex + j + (normals || uvs ? \"/\".concat(uvs ? this.indexVertexUvs + j : \"\").concat(normals ? \"/\".concat(this.indexNormals + j) : \"\") : \"\");\n          }\n\n          this.output += \"f \".concat(this.face.join(\" \"), \"\\n\");\n        }\n      } else {\n        for (var _i4 = 0, _l4 = vertices.count; _i4 < _l4; _i4 += 3) {\n          for (var _m = 0; _m < 3; _m++) {\n            var _j = _i4 + _m + 1;\n\n            this.face[_m] = this.indexVertex + _j + (normals || uvs ? \"/\".concat(uvs ? this.indexVertexUvs + _j : \"\").concat(normals ? \"/\".concat(this.indexNormals + _j) : \"\") : \"\");\n          }\n\n          this.output += \"f \".concat(this.face.join(\" \"), \"\\n\");\n        }\n      }\n\n      this.indexVertex += nbVertex;\n      this.indexVertexUvs += nbVertexUvs;\n      this.indexNormals += nbNormals;\n    }\n  }, {\n    key: \"parseLine\",\n    value: function parseLine(line) {\n      var nbVertex = 0;\n      var geometry = line.geometry;\n      var type = line.type;\n\n      if (geometry.isBufferGeometry) {\n        throw new Error(\"THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.\");\n      }\n\n      var vertices = geometry.getAttribute(\"position\");\n      this.output += \"o \".concat(line.name, \"\\n\");\n\n      if (vertices !== void 0) {\n        for (var i = 0, l = vertices.count; i < l; i++, nbVertex++) {\n          this.vertex.x = vertices.getX(i);\n          this.vertex.y = vertices.getY(i);\n          this.vertex.z = vertices.getZ(i);\n          this.vertex.applyMatrix4(line.matrixWorld);\n          this.output += \"v \".concat(this.vertex.x, \" \").concat(this.vertex.y, \" \").concat(this.vertex.z, \"\\n\");\n        }\n      }\n\n      if (type === \"Line\") {\n        this.output += \"l \";\n\n        for (var j = 1, _l5 = vertices.count; j <= _l5; j++) {\n          this.output += \"\".concat(this.indexVertex + j, \" \");\n        }\n\n        this.output += \"\\n\";\n      }\n\n      if (type === \"LineSegments\") {\n        for (var _j2 = 1, k = _j2 + 1, _l6 = vertices.count; _j2 < _l6; _j2 += 2, k = _j2 + 1) {\n          this.output += \"l \".concat(this.indexVertex + _j2, \" \").concat(this.indexVertex + k, \"\\n\");\n        }\n      }\n\n      this.indexVertex += nbVertex;\n    }\n  }, {\n    key: \"parsePoints\",\n    value: function parsePoints(points) {\n      var nbVertex = 0;\n      var geometry = points.geometry;\n\n      if (!geometry.isBufferGeometry) {\n        throw new Error(\"THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.\");\n      }\n\n      var vertices = geometry.getAttribute(\"position\");\n      var colors = geometry.getAttribute(\"color\");\n      this.output += \"o \".concat(points.name, \"\\n\");\n\n      if (vertices !== void 0) {\n        for (var i = 0, l = vertices.count; i < l; i++, nbVertex++) {\n          this.vertex.fromBufferAttribute(vertices, i);\n          this.vertex.applyMatrix4(points.matrixWorld);\n          this.output += \"v \".concat(this.vertex.x, \" \").concat(this.vertex.y, \" \").concat(this.vertex.z);\n\n          if (colors !== void 0 && colors instanceof BufferAttribute) {\n            this.color.fromBufferAttribute(colors, i);\n            this.output += \" \".concat(this.color.r, \" \").concat(this.color.g, \" \").concat(this.color.b);\n          }\n\n          this.output += \"\\n\";\n        }\n      }\n\n      this.output += \"p \";\n\n      for (var j = 1, _l7 = vertices.count; j <= _l7; j++) {\n        this.output += \"\".concat(this.indexVertex + j, \" \");\n      }\n\n      this.output += \"\\n\";\n      this.indexVertex += nbVertex;\n    }\n  }]);\n\n  return OBJExporter;\n}();\n\nexport { OBJExporter };","map":{"version":3,"sources":["/Users/theodaguier/Repositories/E-Do-Studio/node_modules/three-stdlib/exporters/OBJExporter.js"],"names":["__defProp","Object","defineProperty","__defNormalProp","obj","key","value","enumerable","configurable","writable","__publicField","Vector3","Color","Vector2","Mesh","Line","Points","Matrix3","BufferAttribute","OBJExporter","output","indexVertex","indexVertexUvs","indexNormals","vertex","color","normal","uv","face","object","traverse","child","isMesh","parseMesh","isLine","parseLine","isPoints","parsePoints","mesh","nbVertex","nbNormals","nbVertexUvs","geometry","normalMatrixWorld","isBufferGeometry","Error","vertices","getAttribute","normals","uvs","indices","getIndex","name","material","Array","isArray","i","l","count","x","getX","y","getY","z","getZ","applyMatrix4","matrixWorld","getNormalMatrix","applyMatrix3","normalize","m","j","join","line","type","k","points","colors","fromBufferAttribute","r","g","b"],"mappings":"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","sourcesContent":["var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Vector3, Color, Vector2, Mesh, Line, Points, Matrix3, BufferAttribute } from \"three\";\nclass OBJExporter {\n  constructor() {\n    __publicField(this, \"output\");\n    __publicField(this, \"indexVertex\");\n    __publicField(this, \"indexVertexUvs\");\n    __publicField(this, \"indexNormals\");\n    __publicField(this, \"vertex\");\n    __publicField(this, \"color\");\n    __publicField(this, \"normal\");\n    __publicField(this, \"uv\");\n    __publicField(this, \"face\");\n    this.output = \"\";\n    this.indexVertex = 0;\n    this.indexVertexUvs = 0;\n    this.indexNormals = 0;\n    this.vertex = new Vector3();\n    this.color = new Color();\n    this.normal = new Vector3();\n    this.uv = new Vector2();\n    this.face = [];\n  }\n  parse(object) {\n    object.traverse((child) => {\n      if (child instanceof Mesh && child.isMesh) {\n        this.parseMesh(child);\n      }\n      if (child instanceof Line && child.isLine) {\n        this.parseLine(child);\n      }\n      if (child instanceof Points && child.isPoints) {\n        this.parsePoints(child);\n      }\n    });\n    return this.output;\n  }\n  parseMesh(mesh) {\n    let nbVertex = 0;\n    let nbNormals = 0;\n    let nbVertexUvs = 0;\n    const geometry = mesh.geometry;\n    const normalMatrixWorld = new Matrix3();\n    if (!geometry.isBufferGeometry) {\n      throw new Error(\"THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.\");\n    }\n    const vertices = geometry.getAttribute(\"position\");\n    const normals = geometry.getAttribute(\"normal\");\n    const uvs = geometry.getAttribute(\"uv\");\n    const indices = geometry.getIndex();\n    this.output += `o ${mesh.name}\n`;\n    if (mesh.material && !Array.isArray(mesh.material) && mesh.material.name) {\n      this.output += `usemtl ${mesh.material.name}\n`;\n    }\n    if (vertices !== void 0) {\n      for (let i = 0, l = vertices.count; i < l; i++, nbVertex++) {\n        this.vertex.x = vertices.getX(i);\n        this.vertex.y = vertices.getY(i);\n        this.vertex.z = vertices.getZ(i);\n        this.vertex.applyMatrix4(mesh.matrixWorld);\n        this.output += `v ${this.vertex.x} ${this.vertex.y} ${this.vertex.z}\n`;\n      }\n    }\n    if (uvs !== void 0) {\n      for (let i = 0, l = uvs.count; i < l; i++, nbVertexUvs++) {\n        this.uv.x = uvs.getX(i);\n        this.uv.y = uvs.getY(i);\n        this.output += `vt ${this.uv.x} ${this.uv.y}\n`;\n      }\n    }\n    if (normals !== void 0) {\n      normalMatrixWorld.getNormalMatrix(mesh.matrixWorld);\n      for (let i = 0, l = normals.count; i < l; i++, nbNormals++) {\n        this.normal.x = normals.getX(i);\n        this.normal.y = normals.getY(i);\n        this.normal.z = normals.getZ(i);\n        this.normal.applyMatrix3(normalMatrixWorld).normalize();\n        this.output += `vn ${this.normal.x} ${this.normal.y} ${this.normal.z}\n`;\n      }\n    }\n    if (indices !== null) {\n      for (let i = 0, l = indices.count; i < l; i += 3) {\n        for (let m = 0; m < 3; m++) {\n          const j = indices.getX(i + m) + 1;\n          this.face[m] = this.indexVertex + j + (normals || uvs ? `/${uvs ? this.indexVertexUvs + j : \"\"}${normals ? `/${this.indexNormals + j}` : \"\"}` : \"\");\n        }\n        this.output += `f ${this.face.join(\" \")}\n`;\n      }\n    } else {\n      for (let i = 0, l = vertices.count; i < l; i += 3) {\n        for (let m = 0; m < 3; m++) {\n          const j = i + m + 1;\n          this.face[m] = this.indexVertex + j + (normals || uvs ? `/${uvs ? this.indexVertexUvs + j : \"\"}${normals ? `/${this.indexNormals + j}` : \"\"}` : \"\");\n        }\n        this.output += `f ${this.face.join(\" \")}\n`;\n      }\n    }\n    this.indexVertex += nbVertex;\n    this.indexVertexUvs += nbVertexUvs;\n    this.indexNormals += nbNormals;\n  }\n  parseLine(line) {\n    let nbVertex = 0;\n    const geometry = line.geometry;\n    const type = line.type;\n    if (geometry.isBufferGeometry) {\n      throw new Error(\"THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.\");\n    }\n    const vertices = geometry.getAttribute(\"position\");\n    this.output += `o ${line.name}\n`;\n    if (vertices !== void 0) {\n      for (let i = 0, l = vertices.count; i < l; i++, nbVertex++) {\n        this.vertex.x = vertices.getX(i);\n        this.vertex.y = vertices.getY(i);\n        this.vertex.z = vertices.getZ(i);\n        this.vertex.applyMatrix4(line.matrixWorld);\n        this.output += `v ${this.vertex.x} ${this.vertex.y} ${this.vertex.z}\n`;\n      }\n    }\n    if (type === \"Line\") {\n      this.output += \"l \";\n      for (let j = 1, l = vertices.count; j <= l; j++) {\n        this.output += `${this.indexVertex + j} `;\n      }\n      this.output += \"\\n\";\n    }\n    if (type === \"LineSegments\") {\n      for (let j = 1, k = j + 1, l = vertices.count; j < l; j += 2, k = j + 1) {\n        this.output += `l ${this.indexVertex + j} ${this.indexVertex + k}\n`;\n      }\n    }\n    this.indexVertex += nbVertex;\n  }\n  parsePoints(points) {\n    let nbVertex = 0;\n    const geometry = points.geometry;\n    if (!geometry.isBufferGeometry) {\n      throw new Error(\"THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.\");\n    }\n    const vertices = geometry.getAttribute(\"position\");\n    const colors = geometry.getAttribute(\"color\");\n    this.output += `o ${points.name}\n`;\n    if (vertices !== void 0) {\n      for (let i = 0, l = vertices.count; i < l; i++, nbVertex++) {\n        this.vertex.fromBufferAttribute(vertices, i);\n        this.vertex.applyMatrix4(points.matrixWorld);\n        this.output += `v ${this.vertex.x} ${this.vertex.y} ${this.vertex.z}`;\n        if (colors !== void 0 && colors instanceof BufferAttribute) {\n          this.color.fromBufferAttribute(colors, i);\n          this.output += ` ${this.color.r} ${this.color.g} ${this.color.b}`;\n        }\n        this.output += \"\\n\";\n      }\n    }\n    this.output += \"p \";\n    for (let j = 1, l = vertices.count; j <= l; j++) {\n      this.output += `${this.indexVertex + j} `;\n    }\n    this.output += \"\\n\";\n    this.indexVertex += nbVertex;\n  }\n}\nexport {\n  OBJExporter\n};\n"]},"metadata":{},"sourceType":"module"}