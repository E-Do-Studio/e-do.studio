{"ast":null,"code":"import _classCallCheck from \"/Users/theodaguier/Repositories/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _assertThisInitialized from \"/Users/theodaguier/Repositories/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"/Users/theodaguier/Repositories/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/theodaguier/Repositories/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nvar __defProp = Object.defineProperty;\n\nvar __defNormalProp = function __defNormalProp(obj, key, value) {\n  return key in obj ? __defProp(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\n\nvar __publicField = function __publicField(obj, key, value) {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n\n  return value;\n};\n\nimport { Mesh, PerspectiveCamera, Color, Plane, Matrix4, WebGLRenderTarget, HalfFloatType, ShaderMaterial, UniformsUtils, Vector3, Quaternion, Vector4, NoToneMapping } from \"three\";\n\nvar _Refractor = /*#__PURE__*/function (_Mesh) {\n  _inherits(_Refractor, _Mesh);\n\n  var _super = _createSuper(_Refractor);\n\n  function _Refractor(geometry) {\n    var _this;\n\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, _Refractor);\n\n    _this = _super.call(this, geometry);\n    _this.isRefractor = true;\n    _this.type = \"Refractor\";\n    _this.camera = new PerspectiveCamera();\n\n    var scope = _assertThisInitialized(_this);\n\n    var color = options.color !== void 0 ? new Color(options.color) : new Color(8355711);\n    var textureWidth = options.textureWidth || 512;\n    var textureHeight = options.textureHeight || 512;\n    var clipBias = options.clipBias || 0;\n    var shader = options.shader || _Refractor.RefractorShader;\n    var multisample = options.multisample !== void 0 ? options.multisample : 4;\n    var virtualCamera = _this.camera;\n    virtualCamera.matrixAutoUpdate = false;\n    virtualCamera.userData.refractor = true;\n    var refractorPlane = new Plane();\n    var textureMatrix = new Matrix4();\n    var renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, {\n      samples: multisample,\n      type: HalfFloatType\n    });\n    _this.material = new ShaderMaterial({\n      uniforms: UniformsUtils.clone(shader.uniforms),\n      vertexShader: shader.vertexShader,\n      fragmentShader: shader.fragmentShader,\n      transparent: true // ensures, refractors are drawn from farthest to closest\n\n    });\n    _this.material.uniforms[\"color\"].value = color;\n    _this.material.uniforms[\"tDiffuse\"].value = renderTarget.texture;\n    _this.material.uniforms[\"textureMatrix\"].value = textureMatrix;\n\n    var visible = function () {\n      var refractorWorldPosition = new Vector3();\n      var cameraWorldPosition = new Vector3();\n      var rotationMatrix = new Matrix4();\n      var view = new Vector3();\n      var normal = new Vector3();\n      return function visible2(camera) {\n        refractorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n        cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n        view.subVectors(refractorWorldPosition, cameraWorldPosition);\n        rotationMatrix.extractRotation(scope.matrixWorld);\n        normal.set(0, 0, 1);\n        normal.applyMatrix4(rotationMatrix);\n        return view.dot(normal) < 0;\n      };\n    }();\n\n    var updateRefractorPlane = function () {\n      var normal = new Vector3();\n      var position = new Vector3();\n      var quaternion = new Quaternion();\n      var scale = new Vector3();\n      return function updateRefractorPlane2() {\n        scope.matrixWorld.decompose(position, quaternion, scale);\n        normal.set(0, 0, 1).applyQuaternion(quaternion).normalize();\n        normal.negate();\n        refractorPlane.setFromNormalAndCoplanarPoint(normal, position);\n      };\n    }();\n\n    var updateVirtualCamera = function () {\n      var clipPlane = new Plane();\n      var clipVector = new Vector4();\n      var q = new Vector4();\n      return function updateVirtualCamera2(camera) {\n        virtualCamera.matrixWorld.copy(camera.matrixWorld);\n        virtualCamera.matrixWorldInverse.copy(virtualCamera.matrixWorld).invert();\n        virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\n        virtualCamera.far = camera.far;\n        clipPlane.copy(refractorPlane);\n        clipPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\n        clipVector.set(clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.constant);\n        var projectionMatrix = virtualCamera.projectionMatrix;\n        q.x = (Math.sign(clipVector.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n        q.y = (Math.sign(clipVector.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n        q.z = -1;\n        q.w = (1 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];\n        clipVector.multiplyScalar(2 / clipVector.dot(q));\n        projectionMatrix.elements[2] = clipVector.x;\n        projectionMatrix.elements[6] = clipVector.y;\n        projectionMatrix.elements[10] = clipVector.z + 1 - clipBias;\n        projectionMatrix.elements[14] = clipVector.w;\n      };\n    }();\n\n    function updateTextureMatrix(camera) {\n      textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);\n      textureMatrix.multiply(camera.projectionMatrix);\n      textureMatrix.multiply(camera.matrixWorldInverse);\n      textureMatrix.multiply(scope.matrixWorld);\n    }\n\n    function render(renderer, scene, camera) {\n      scope.visible = false;\n      var currentRenderTarget = renderer.getRenderTarget();\n      var currentXrEnabled = renderer.xr.enabled;\n      var currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n      var currentToneMapping = renderer.toneMapping;\n      var isSRGB = false;\n      if (\"outputColorSpace\" in renderer) isSRGB = renderer.outputColorSpace === \"srgb\";else isSRGB = renderer.outputEncoding === 3001;\n      renderer.xr.enabled = false;\n      renderer.shadowMap.autoUpdate = false;\n      if (\"outputColorSpace\" in renderer) renderer.outputColorSpace = \"linear-srgb\";else renderer.outputEncoding = 3e3;\n      renderer.toneMapping = NoToneMapping;\n      renderer.setRenderTarget(renderTarget);\n      if (renderer.autoClear === false) renderer.clear();\n      renderer.render(scene, virtualCamera);\n      renderer.xr.enabled = currentXrEnabled;\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n      renderer.toneMapping = currentToneMapping;\n      renderer.setRenderTarget(currentRenderTarget);\n      if (\"outputColorSpace\" in renderer) renderer.outputColorSpace = isSRGB ? \"srgb\" : \"srgb-linear\";else renderer.outputEncoding = isSRGB ? 3001 : 3e3;\n      var viewport = camera.viewport;\n\n      if (viewport !== void 0) {\n        renderer.state.viewport(viewport);\n      }\n\n      scope.visible = true;\n    }\n\n    _this.onBeforeRender = function (renderer, scene, camera) {\n      if (camera.userData.refractor === true) return;\n      if (!visible(camera) === true) return;\n      updateRefractorPlane();\n      updateTextureMatrix(camera);\n      updateVirtualCamera(camera);\n      render(renderer, scene, camera);\n    };\n\n    _this.getRenderTarget = function () {\n      return renderTarget;\n    };\n\n    _this.dispose = function () {\n      renderTarget.dispose();\n      scope.material.dispose();\n    };\n\n    return _this;\n  }\n\n  return _Refractor;\n}(Mesh);\n\nvar Refractor = _Refractor;\n\n__publicField(Refractor, \"RefractorShader\", {\n  uniforms: {\n    color: {\n      value: null\n    },\n    tDiffuse: {\n      value: null\n    },\n    textureMatrix: {\n      value: null\n    }\n  },\n  vertexShader:\n  /* glsl */\n  \"\\n\\n\\t\\tuniform mat4 textureMatrix;\\n\\n\\t\\tvarying vec4 vUv;\\n\\n\\t\\tvoid main() {\\n\\n\\t\\t\\tvUv = textureMatrix * vec4( position, 1.0 );\\n\\t\\t\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\n\\t\\t}\",\n  fragmentShader:\n  /* glsl */\n  \"\\n\\n\\t\\tuniform vec3 color;\\n\\t\\tuniform sampler2D tDiffuse;\\n\\n\\t\\tvarying vec4 vUv;\\n\\n\\t\\tfloat blendOverlay( float base, float blend ) {\\n\\n\\t\\t\\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\\n\\n\\t\\t}\\n\\n\\t\\tvec3 blendOverlay( vec3 base, vec3 blend ) {\\n\\n\\t\\t\\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\\n\\n\\t\\t}\\n\\n\\t\\tvoid main() {\\n\\n\\t\\t\\tvec4 base = texture2DProj( tDiffuse, vUv );\\n\\t\\t\\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\\n\\n\\t\\t\\t#include <tonemapping_fragment>\\n\\t\\t\\t#include <encodings_fragment>\\n\\n\\t\\t}\"\n});\n\nexport { Refractor };","map":{"version":3,"sources":["/Users/theodaguier/Repositories/E-Do-Studio/node_modules/three-stdlib/objects/Refractor.js"],"names":["__defProp","Object","defineProperty","__defNormalProp","obj","key","value","enumerable","configurable","writable","__publicField","Mesh","PerspectiveCamera","Color","Plane","Matrix4","WebGLRenderTarget","HalfFloatType","ShaderMaterial","UniformsUtils","Vector3","Quaternion","Vector4","NoToneMapping","_Refractor","geometry","options","isRefractor","type","camera","scope","color","textureWidth","textureHeight","clipBias","shader","RefractorShader","multisample","virtualCamera","matrixAutoUpdate","userData","refractor","refractorPlane","textureMatrix","renderTarget","samples","material","uniforms","clone","vertexShader","fragmentShader","transparent","texture","visible","refractorWorldPosition","cameraWorldPosition","rotationMatrix","view","normal","visible2","setFromMatrixPosition","matrixWorld","subVectors","extractRotation","set","applyMatrix4","dot","updateRefractorPlane","position","quaternion","scale","updateRefractorPlane2","decompose","applyQuaternion","normalize","negate","setFromNormalAndCoplanarPoint","updateVirtualCamera","clipPlane","clipVector","q","updateVirtualCamera2","copy","matrixWorldInverse","invert","projectionMatrix","far","x","y","z","constant","Math","sign","elements","w","multiplyScalar","updateTextureMatrix","multiply","render","renderer","scene","currentRenderTarget","getRenderTarget","currentXrEnabled","xr","enabled","currentShadowAutoUpdate","shadowMap","autoUpdate","currentToneMapping","toneMapping","isSRGB","outputColorSpace","outputEncoding","setRenderTarget","autoClear","clear","viewport","state","onBeforeRender","dispose","Refractor","tDiffuse"],"mappings":"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","sourcesContent":["var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Mesh, PerspectiveCamera, Color, Plane, Matrix4, WebGLRenderTarget, HalfFloatType, ShaderMaterial, UniformsUtils, Vector3, Quaternion, Vector4, NoToneMapping } from \"three\";\nconst _Refractor = class extends Mesh {\n  constructor(geometry, options = {}) {\n    super(geometry);\n    this.isRefractor = true;\n    this.type = \"Refractor\";\n    this.camera = new PerspectiveCamera();\n    const scope = this;\n    const color = options.color !== void 0 ? new Color(options.color) : new Color(8355711);\n    const textureWidth = options.textureWidth || 512;\n    const textureHeight = options.textureHeight || 512;\n    const clipBias = options.clipBias || 0;\n    const shader = options.shader || _Refractor.RefractorShader;\n    const multisample = options.multisample !== void 0 ? options.multisample : 4;\n    const virtualCamera = this.camera;\n    virtualCamera.matrixAutoUpdate = false;\n    virtualCamera.userData.refractor = true;\n    const refractorPlane = new Plane();\n    const textureMatrix = new Matrix4();\n    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, {\n      samples: multisample,\n      type: HalfFloatType\n    });\n    this.material = new ShaderMaterial({\n      uniforms: UniformsUtils.clone(shader.uniforms),\n      vertexShader: shader.vertexShader,\n      fragmentShader: shader.fragmentShader,\n      transparent: true\n      // ensures, refractors are drawn from farthest to closest\n    });\n    this.material.uniforms[\"color\"].value = color;\n    this.material.uniforms[\"tDiffuse\"].value = renderTarget.texture;\n    this.material.uniforms[\"textureMatrix\"].value = textureMatrix;\n    const visible = function() {\n      const refractorWorldPosition = new Vector3();\n      const cameraWorldPosition = new Vector3();\n      const rotationMatrix = new Matrix4();\n      const view = new Vector3();\n      const normal = new Vector3();\n      return function visible2(camera) {\n        refractorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n        cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n        view.subVectors(refractorWorldPosition, cameraWorldPosition);\n        rotationMatrix.extractRotation(scope.matrixWorld);\n        normal.set(0, 0, 1);\n        normal.applyMatrix4(rotationMatrix);\n        return view.dot(normal) < 0;\n      };\n    }();\n    const updateRefractorPlane = function() {\n      const normal = new Vector3();\n      const position = new Vector3();\n      const quaternion = new Quaternion();\n      const scale = new Vector3();\n      return function updateRefractorPlane2() {\n        scope.matrixWorld.decompose(position, quaternion, scale);\n        normal.set(0, 0, 1).applyQuaternion(quaternion).normalize();\n        normal.negate();\n        refractorPlane.setFromNormalAndCoplanarPoint(normal, position);\n      };\n    }();\n    const updateVirtualCamera = function() {\n      const clipPlane = new Plane();\n      const clipVector = new Vector4();\n      const q = new Vector4();\n      return function updateVirtualCamera2(camera) {\n        virtualCamera.matrixWorld.copy(camera.matrixWorld);\n        virtualCamera.matrixWorldInverse.copy(virtualCamera.matrixWorld).invert();\n        virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\n        virtualCamera.far = camera.far;\n        clipPlane.copy(refractorPlane);\n        clipPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\n        clipVector.set(clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.constant);\n        const projectionMatrix = virtualCamera.projectionMatrix;\n        q.x = (Math.sign(clipVector.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n        q.y = (Math.sign(clipVector.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n        q.z = -1;\n        q.w = (1 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];\n        clipVector.multiplyScalar(2 / clipVector.dot(q));\n        projectionMatrix.elements[2] = clipVector.x;\n        projectionMatrix.elements[6] = clipVector.y;\n        projectionMatrix.elements[10] = clipVector.z + 1 - clipBias;\n        projectionMatrix.elements[14] = clipVector.w;\n      };\n    }();\n    function updateTextureMatrix(camera) {\n      textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);\n      textureMatrix.multiply(camera.projectionMatrix);\n      textureMatrix.multiply(camera.matrixWorldInverse);\n      textureMatrix.multiply(scope.matrixWorld);\n    }\n    function render(renderer, scene, camera) {\n      scope.visible = false;\n      const currentRenderTarget = renderer.getRenderTarget();\n      const currentXrEnabled = renderer.xr.enabled;\n      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n      const currentToneMapping = renderer.toneMapping;\n      let isSRGB = false;\n      if (\"outputColorSpace\" in renderer)\n        isSRGB = renderer.outputColorSpace === \"srgb\";\n      else\n        isSRGB = renderer.outputEncoding === 3001;\n      renderer.xr.enabled = false;\n      renderer.shadowMap.autoUpdate = false;\n      if (\"outputColorSpace\" in renderer)\n        renderer.outputColorSpace = \"linear-srgb\";\n      else\n        renderer.outputEncoding = 3e3;\n      renderer.toneMapping = NoToneMapping;\n      renderer.setRenderTarget(renderTarget);\n      if (renderer.autoClear === false)\n        renderer.clear();\n      renderer.render(scene, virtualCamera);\n      renderer.xr.enabled = currentXrEnabled;\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n      renderer.toneMapping = currentToneMapping;\n      renderer.setRenderTarget(currentRenderTarget);\n      if (\"outputColorSpace\" in renderer)\n        renderer.outputColorSpace = isSRGB ? \"srgb\" : \"srgb-linear\";\n      else\n        renderer.outputEncoding = isSRGB ? 3001 : 3e3;\n      const viewport = camera.viewport;\n      if (viewport !== void 0) {\n        renderer.state.viewport(viewport);\n      }\n      scope.visible = true;\n    }\n    this.onBeforeRender = function(renderer, scene, camera) {\n      if (camera.userData.refractor === true)\n        return;\n      if (!visible(camera) === true)\n        return;\n      updateRefractorPlane();\n      updateTextureMatrix(camera);\n      updateVirtualCamera(camera);\n      render(renderer, scene, camera);\n    };\n    this.getRenderTarget = function() {\n      return renderTarget;\n    };\n    this.dispose = function() {\n      renderTarget.dispose();\n      scope.material.dispose();\n    };\n  }\n};\nlet Refractor = _Refractor;\n__publicField(Refractor, \"RefractorShader\", {\n  uniforms: {\n    color: {\n      value: null\n    },\n    tDiffuse: {\n      value: null\n    },\n    textureMatrix: {\n      value: null\n    }\n  },\n  vertexShader: (\n    /* glsl */\n    `\n\n\t\tuniform mat4 textureMatrix;\n\n\t\tvarying vec4 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec4 vUv;\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\n\t\t}`\n  )\n});\nexport {\n  Refractor\n};\n"]},"metadata":{},"sourceType":"module"}