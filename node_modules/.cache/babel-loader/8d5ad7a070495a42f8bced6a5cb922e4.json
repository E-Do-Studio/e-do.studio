{"ast":null,"code":"var __defProp = Object.defineProperty;\n\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\n\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n\n  return value;\n};\n\nimport { Mesh, PerspectiveCamera, Color, Plane, Matrix4, WebGLRenderTarget, HalfFloatType, ShaderMaterial, UniformsUtils, Vector3, Quaternion, Vector4, NoToneMapping } from \"three\";\n\nconst _Refractor = class extends Mesh {\n  constructor(geometry, options = {}) {\n    super(geometry);\n    this.isRefractor = true;\n    this.type = \"Refractor\";\n    this.camera = new PerspectiveCamera();\n    const scope = this;\n    const color = options.color !== void 0 ? new Color(options.color) : new Color(8355711);\n    const textureWidth = options.textureWidth || 512;\n    const textureHeight = options.textureHeight || 512;\n    const clipBias = options.clipBias || 0;\n    const shader = options.shader || _Refractor.RefractorShader;\n    const multisample = options.multisample !== void 0 ? options.multisample : 4;\n    const virtualCamera = this.camera;\n    virtualCamera.matrixAutoUpdate = false;\n    virtualCamera.userData.refractor = true;\n    const refractorPlane = new Plane();\n    const textureMatrix = new Matrix4();\n    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, {\n      samples: multisample,\n      type: HalfFloatType\n    });\n    this.material = new ShaderMaterial({\n      uniforms: UniformsUtils.clone(shader.uniforms),\n      vertexShader: shader.vertexShader,\n      fragmentShader: shader.fragmentShader,\n      transparent: true // ensures, refractors are drawn from farthest to closest\n\n    });\n    this.material.uniforms[\"color\"].value = color;\n    this.material.uniforms[\"tDiffuse\"].value = renderTarget.texture;\n    this.material.uniforms[\"textureMatrix\"].value = textureMatrix;\n\n    const visible = function () {\n      const refractorWorldPosition = new Vector3();\n      const cameraWorldPosition = new Vector3();\n      const rotationMatrix = new Matrix4();\n      const view = new Vector3();\n      const normal = new Vector3();\n      return function visible2(camera) {\n        refractorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n        cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n        view.subVectors(refractorWorldPosition, cameraWorldPosition);\n        rotationMatrix.extractRotation(scope.matrixWorld);\n        normal.set(0, 0, 1);\n        normal.applyMatrix4(rotationMatrix);\n        return view.dot(normal) < 0;\n      };\n    }();\n\n    const updateRefractorPlane = function () {\n      const normal = new Vector3();\n      const position = new Vector3();\n      const quaternion = new Quaternion();\n      const scale = new Vector3();\n      return function updateRefractorPlane2() {\n        scope.matrixWorld.decompose(position, quaternion, scale);\n        normal.set(0, 0, 1).applyQuaternion(quaternion).normalize();\n        normal.negate();\n        refractorPlane.setFromNormalAndCoplanarPoint(normal, position);\n      };\n    }();\n\n    const updateVirtualCamera = function () {\n      const clipPlane = new Plane();\n      const clipVector = new Vector4();\n      const q = new Vector4();\n      return function updateVirtualCamera2(camera) {\n        virtualCamera.matrixWorld.copy(camera.matrixWorld);\n        virtualCamera.matrixWorldInverse.copy(virtualCamera.matrixWorld).invert();\n        virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\n        virtualCamera.far = camera.far;\n        clipPlane.copy(refractorPlane);\n        clipPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\n        clipVector.set(clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.constant);\n        const projectionMatrix = virtualCamera.projectionMatrix;\n        q.x = (Math.sign(clipVector.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n        q.y = (Math.sign(clipVector.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n        q.z = -1;\n        q.w = (1 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];\n        clipVector.multiplyScalar(2 / clipVector.dot(q));\n        projectionMatrix.elements[2] = clipVector.x;\n        projectionMatrix.elements[6] = clipVector.y;\n        projectionMatrix.elements[10] = clipVector.z + 1 - clipBias;\n        projectionMatrix.elements[14] = clipVector.w;\n      };\n    }();\n\n    function updateTextureMatrix(camera) {\n      textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);\n      textureMatrix.multiply(camera.projectionMatrix);\n      textureMatrix.multiply(camera.matrixWorldInverse);\n      textureMatrix.multiply(scope.matrixWorld);\n    }\n\n    function render(renderer, scene, camera) {\n      scope.visible = false;\n      const currentRenderTarget = renderer.getRenderTarget();\n      const currentXrEnabled = renderer.xr.enabled;\n      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n      const currentToneMapping = renderer.toneMapping;\n      let isSRGB = false;\n      if (\"outputColorSpace\" in renderer) isSRGB = renderer.outputColorSpace === \"srgb\";else isSRGB = renderer.outputEncoding === 3001;\n      renderer.xr.enabled = false;\n      renderer.shadowMap.autoUpdate = false;\n      if (\"outputColorSpace\" in renderer) renderer.outputColorSpace = \"linear-srgb\";else renderer.outputEncoding = 3e3;\n      renderer.toneMapping = NoToneMapping;\n      renderer.setRenderTarget(renderTarget);\n      if (renderer.autoClear === false) renderer.clear();\n      renderer.render(scene, virtualCamera);\n      renderer.xr.enabled = currentXrEnabled;\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n      renderer.toneMapping = currentToneMapping;\n      renderer.setRenderTarget(currentRenderTarget);\n      if (\"outputColorSpace\" in renderer) renderer.outputColorSpace = isSRGB ? \"srgb\" : \"srgb-linear\";else renderer.outputEncoding = isSRGB ? 3001 : 3e3;\n      const viewport = camera.viewport;\n\n      if (viewport !== void 0) {\n        renderer.state.viewport(viewport);\n      }\n\n      scope.visible = true;\n    }\n\n    this.onBeforeRender = function (renderer, scene, camera) {\n      if (camera.userData.refractor === true) return;\n      if (!visible(camera) === true) return;\n      updateRefractorPlane();\n      updateTextureMatrix(camera);\n      updateVirtualCamera(camera);\n      render(renderer, scene, camera);\n    };\n\n    this.getRenderTarget = function () {\n      return renderTarget;\n    };\n\n    this.dispose = function () {\n      renderTarget.dispose();\n      scope.material.dispose();\n    };\n  }\n\n};\n\nlet Refractor = _Refractor;\n\n__publicField(Refractor, \"RefractorShader\", {\n  uniforms: {\n    color: {\n      value: null\n    },\n    tDiffuse: {\n      value: null\n    },\n    textureMatrix: {\n      value: null\n    }\n  },\n  vertexShader:\n  /* glsl */\n  `\n\n\t\tuniform mat4 textureMatrix;\n\n\t\tvarying vec4 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`,\n  fragmentShader:\n  /* glsl */\n  `\n\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec4 vUv;\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\n\t\t}`\n});\n\nexport { Refractor };","map":{"version":3,"sources":["/Users/theodaguier/_workdir/dev/pro/e-do/E-Do-Studio/node_modules/three-stdlib/objects/Refractor.js"],"names":["__defProp","Object","defineProperty","__defNormalProp","obj","key","value","enumerable","configurable","writable","__publicField","Mesh","PerspectiveCamera","Color","Plane","Matrix4","WebGLRenderTarget","HalfFloatType","ShaderMaterial","UniformsUtils","Vector3","Quaternion","Vector4","NoToneMapping","_Refractor","constructor","geometry","options","isRefractor","type","camera","scope","color","textureWidth","textureHeight","clipBias","shader","RefractorShader","multisample","virtualCamera","matrixAutoUpdate","userData","refractor","refractorPlane","textureMatrix","renderTarget","samples","material","uniforms","clone","vertexShader","fragmentShader","transparent","texture","visible","refractorWorldPosition","cameraWorldPosition","rotationMatrix","view","normal","visible2","setFromMatrixPosition","matrixWorld","subVectors","extractRotation","set","applyMatrix4","dot","updateRefractorPlane","position","quaternion","scale","updateRefractorPlane2","decompose","applyQuaternion","normalize","negate","setFromNormalAndCoplanarPoint","updateVirtualCamera","clipPlane","clipVector","q","updateVirtualCamera2","copy","matrixWorldInverse","invert","projectionMatrix","far","x","y","z","constant","Math","sign","elements","w","multiplyScalar","updateTextureMatrix","multiply","render","renderer","scene","currentRenderTarget","getRenderTarget","currentXrEnabled","xr","enabled","currentShadowAutoUpdate","shadowMap","autoUpdate","currentToneMapping","toneMapping","isSRGB","outputColorSpace","outputEncoding","setRenderTarget","autoClear","clear","viewport","state","onBeforeRender","dispose","Refractor","tDiffuse"],"mappings":"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","sourcesContent":["var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Mesh, PerspectiveCamera, Color, Plane, Matrix4, WebGLRenderTarget, HalfFloatType, ShaderMaterial, UniformsUtils, Vector3, Quaternion, Vector4, NoToneMapping } from \"three\";\nconst _Refractor = class extends Mesh {\n  constructor(geometry, options = {}) {\n    super(geometry);\n    this.isRefractor = true;\n    this.type = \"Refractor\";\n    this.camera = new PerspectiveCamera();\n    const scope = this;\n    const color = options.color !== void 0 ? new Color(options.color) : new Color(8355711);\n    const textureWidth = options.textureWidth || 512;\n    const textureHeight = options.textureHeight || 512;\n    const clipBias = options.clipBias || 0;\n    const shader = options.shader || _Refractor.RefractorShader;\n    const multisample = options.multisample !== void 0 ? options.multisample : 4;\n    const virtualCamera = this.camera;\n    virtualCamera.matrixAutoUpdate = false;\n    virtualCamera.userData.refractor = true;\n    const refractorPlane = new Plane();\n    const textureMatrix = new Matrix4();\n    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, {\n      samples: multisample,\n      type: HalfFloatType\n    });\n    this.material = new ShaderMaterial({\n      uniforms: UniformsUtils.clone(shader.uniforms),\n      vertexShader: shader.vertexShader,\n      fragmentShader: shader.fragmentShader,\n      transparent: true\n      // ensures, refractors are drawn from farthest to closest\n    });\n    this.material.uniforms[\"color\"].value = color;\n    this.material.uniforms[\"tDiffuse\"].value = renderTarget.texture;\n    this.material.uniforms[\"textureMatrix\"].value = textureMatrix;\n    const visible = function() {\n      const refractorWorldPosition = new Vector3();\n      const cameraWorldPosition = new Vector3();\n      const rotationMatrix = new Matrix4();\n      const view = new Vector3();\n      const normal = new Vector3();\n      return function visible2(camera) {\n        refractorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n        cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n        view.subVectors(refractorWorldPosition, cameraWorldPosition);\n        rotationMatrix.extractRotation(scope.matrixWorld);\n        normal.set(0, 0, 1);\n        normal.applyMatrix4(rotationMatrix);\n        return view.dot(normal) < 0;\n      };\n    }();\n    const updateRefractorPlane = function() {\n      const normal = new Vector3();\n      const position = new Vector3();\n      const quaternion = new Quaternion();\n      const scale = new Vector3();\n      return function updateRefractorPlane2() {\n        scope.matrixWorld.decompose(position, quaternion, scale);\n        normal.set(0, 0, 1).applyQuaternion(quaternion).normalize();\n        normal.negate();\n        refractorPlane.setFromNormalAndCoplanarPoint(normal, position);\n      };\n    }();\n    const updateVirtualCamera = function() {\n      const clipPlane = new Plane();\n      const clipVector = new Vector4();\n      const q = new Vector4();\n      return function updateVirtualCamera2(camera) {\n        virtualCamera.matrixWorld.copy(camera.matrixWorld);\n        virtualCamera.matrixWorldInverse.copy(virtualCamera.matrixWorld).invert();\n        virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\n        virtualCamera.far = camera.far;\n        clipPlane.copy(refractorPlane);\n        clipPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\n        clipVector.set(clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.constant);\n        const projectionMatrix = virtualCamera.projectionMatrix;\n        q.x = (Math.sign(clipVector.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n        q.y = (Math.sign(clipVector.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n        q.z = -1;\n        q.w = (1 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];\n        clipVector.multiplyScalar(2 / clipVector.dot(q));\n        projectionMatrix.elements[2] = clipVector.x;\n        projectionMatrix.elements[6] = clipVector.y;\n        projectionMatrix.elements[10] = clipVector.z + 1 - clipBias;\n        projectionMatrix.elements[14] = clipVector.w;\n      };\n    }();\n    function updateTextureMatrix(camera) {\n      textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);\n      textureMatrix.multiply(camera.projectionMatrix);\n      textureMatrix.multiply(camera.matrixWorldInverse);\n      textureMatrix.multiply(scope.matrixWorld);\n    }\n    function render(renderer, scene, camera) {\n      scope.visible = false;\n      const currentRenderTarget = renderer.getRenderTarget();\n      const currentXrEnabled = renderer.xr.enabled;\n      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n      const currentToneMapping = renderer.toneMapping;\n      let isSRGB = false;\n      if (\"outputColorSpace\" in renderer)\n        isSRGB = renderer.outputColorSpace === \"srgb\";\n      else\n        isSRGB = renderer.outputEncoding === 3001;\n      renderer.xr.enabled = false;\n      renderer.shadowMap.autoUpdate = false;\n      if (\"outputColorSpace\" in renderer)\n        renderer.outputColorSpace = \"linear-srgb\";\n      else\n        renderer.outputEncoding = 3e3;\n      renderer.toneMapping = NoToneMapping;\n      renderer.setRenderTarget(renderTarget);\n      if (renderer.autoClear === false)\n        renderer.clear();\n      renderer.render(scene, virtualCamera);\n      renderer.xr.enabled = currentXrEnabled;\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n      renderer.toneMapping = currentToneMapping;\n      renderer.setRenderTarget(currentRenderTarget);\n      if (\"outputColorSpace\" in renderer)\n        renderer.outputColorSpace = isSRGB ? \"srgb\" : \"srgb-linear\";\n      else\n        renderer.outputEncoding = isSRGB ? 3001 : 3e3;\n      const viewport = camera.viewport;\n      if (viewport !== void 0) {\n        renderer.state.viewport(viewport);\n      }\n      scope.visible = true;\n    }\n    this.onBeforeRender = function(renderer, scene, camera) {\n      if (camera.userData.refractor === true)\n        return;\n      if (!visible(camera) === true)\n        return;\n      updateRefractorPlane();\n      updateTextureMatrix(camera);\n      updateVirtualCamera(camera);\n      render(renderer, scene, camera);\n    };\n    this.getRenderTarget = function() {\n      return renderTarget;\n    };\n    this.dispose = function() {\n      renderTarget.dispose();\n      scope.material.dispose();\n    };\n  }\n};\nlet Refractor = _Refractor;\n__publicField(Refractor, \"RefractorShader\", {\n  uniforms: {\n    color: {\n      value: null\n    },\n    tDiffuse: {\n      value: null\n    },\n    textureMatrix: {\n      value: null\n    }\n  },\n  vertexShader: (\n    /* glsl */\n    `\n\n\t\tuniform mat4 textureMatrix;\n\n\t\tvarying vec4 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec4 vUv;\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\n\t\t}`\n  )\n});\nexport {\n  Refractor\n};\n"]},"metadata":{},"sourceType":"module"}