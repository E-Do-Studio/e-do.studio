{"ast":null,"code":"import _classCallCheck from \"/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { Loader, LoaderUtils, FileLoader, MathUtils, Vector3, Quaternion, VectorKeyframeTrack, QuaternionKeyframeTrack, AnimationClip, Matrix4, MeshBasicMaterial, MeshLambertMaterial, MeshPhongMaterial, RepeatWrapping, ClampToEdgeWrapping, Vector2, DoubleSide, FrontSide, PerspectiveCamera, OrthographicCamera, Color, AmbientLight, SpotLight, PointLight, DirectionalLight, BufferGeometry, Float32BufferAttribute, Skeleton, Bone, Group, LineBasicMaterial, SkinnedMesh, Mesh, Line, LineSegments, Scene, TextureLoader, Euler } from \"three\";\nimport { TGALoader } from \"./TGALoader.js\";\n\nvar ColladaLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(ColladaLoader, _Loader);\n\n  var _super = _createSuper(ColladaLoader);\n\n  function ColladaLoader(manager) {\n    _classCallCheck(this, ColladaLoader);\n\n    return _super.call(this, manager);\n  }\n\n  _createClass(ColladaLoader, [{\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var path = scope.path === \"\" ? LoaderUtils.extractUrlBase(url) : scope.path;\n      var loader = new FileLoader(scope.manager);\n      loader.setPath(scope.path);\n      loader.setRequestHeader(scope.requestHeader);\n      loader.setWithCredentials(scope.withCredentials);\n      loader.load(url, function (text) {\n        try {\n          onLoad(scope.parse(text, path));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(text, path) {\n      function getElementsByTagName(xml2, name) {\n        var array = [];\n        var childNodes = xml2.childNodes;\n\n        for (var i = 0, l = childNodes.length; i < l; i++) {\n          var child = childNodes[i];\n\n          if (child.nodeName === name) {\n            array.push(child);\n          }\n        }\n\n        return array;\n      }\n\n      function parseStrings(text2) {\n        if (text2.length === 0) return [];\n        var parts = text2.trim().split(/\\s+/);\n        var array = new Array(parts.length);\n\n        for (var i = 0, l = parts.length; i < l; i++) {\n          array[i] = parts[i];\n        }\n\n        return array;\n      }\n\n      function parseFloats(text2) {\n        if (text2.length === 0) return [];\n        var parts = text2.trim().split(/\\s+/);\n        var array = new Array(parts.length);\n\n        for (var i = 0, l = parts.length; i < l; i++) {\n          array[i] = parseFloat(parts[i]);\n        }\n\n        return array;\n      }\n\n      function parseInts(text2) {\n        if (text2.length === 0) return [];\n        var parts = text2.trim().split(/\\s+/);\n        var array = new Array(parts.length);\n\n        for (var i = 0, l = parts.length; i < l; i++) {\n          array[i] = parseInt(parts[i]);\n        }\n\n        return array;\n      }\n\n      function parseId(text2) {\n        return text2.substring(1);\n      }\n\n      function generateId() {\n        return \"three_default_\" + count++;\n      }\n\n      function isEmpty(object) {\n        return Object.keys(object).length === 0;\n      }\n\n      function parseAsset(xml2) {\n        return {\n          unit: parseAssetUnit(getElementsByTagName(xml2, \"unit\")[0]),\n          upAxis: parseAssetUpAxis(getElementsByTagName(xml2, \"up_axis\")[0])\n        };\n      }\n\n      function parseAssetUnit(xml2) {\n        if (xml2 !== void 0 && xml2.hasAttribute(\"meter\") === true) {\n          return parseFloat(xml2.getAttribute(\"meter\"));\n        } else {\n          return 1;\n        }\n      }\n\n      function parseAssetUpAxis(xml2) {\n        return xml2 !== void 0 ? xml2.textContent : \"Y_UP\";\n      }\n\n      function parseLibrary(xml2, libraryName, nodeName, parser) {\n        var library2 = getElementsByTagName(xml2, libraryName)[0];\n\n        if (library2 !== void 0) {\n          var elements = getElementsByTagName(library2, nodeName);\n\n          for (var i = 0; i < elements.length; i++) {\n            parser(elements[i]);\n          }\n        }\n      }\n\n      function buildLibrary(data, builder) {\n        for (var name in data) {\n          var object = data[name];\n          object.build = builder(data[name]);\n        }\n      }\n\n      function getBuild(data, builder) {\n        if (data.build !== void 0) return data.build;\n        data.build = builder(data);\n        return data.build;\n      }\n\n      function parseAnimation(xml2) {\n        var data = {\n          sources: {},\n          samplers: {},\n          channels: {}\n        };\n        var hasChildren = false;\n\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          var id = void 0;\n\n          switch (child.nodeName) {\n            case \"source\":\n              id = child.getAttribute(\"id\");\n              data.sources[id] = parseSource(child);\n              break;\n\n            case \"sampler\":\n              id = child.getAttribute(\"id\");\n              data.samplers[id] = parseAnimationSampler(child);\n              break;\n\n            case \"channel\":\n              id = child.getAttribute(\"target\");\n              data.channels[id] = parseAnimationChannel(child);\n              break;\n\n            case \"animation\":\n              parseAnimation(child);\n              hasChildren = true;\n              break;\n\n            default:\n              console.log(child);\n          }\n        }\n\n        if (hasChildren === false) {\n          library.animations[xml2.getAttribute(\"id\") || MathUtils.generateUUID()] = data;\n        }\n      }\n\n      function parseAnimationSampler(xml2) {\n        var data = {\n          inputs: {}\n        };\n\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case \"input\":\n              var id = parseId(child.getAttribute(\"source\"));\n              var semantic = child.getAttribute(\"semantic\");\n              data.inputs[semantic] = id;\n              break;\n          }\n        }\n\n        return data;\n      }\n\n      function parseAnimationChannel(xml2) {\n        var data = {};\n        var target = xml2.getAttribute(\"target\");\n        var parts = target.split(\"/\");\n        var id = parts.shift();\n        var sid = parts.shift();\n        var arraySyntax = sid.indexOf(\"(\") !== -1;\n        var memberSyntax = sid.indexOf(\".\") !== -1;\n\n        if (memberSyntax) {\n          parts = sid.split(\".\");\n          sid = parts.shift();\n          data.member = parts.shift();\n        } else if (arraySyntax) {\n          var indices = sid.split(\"(\");\n          sid = indices.shift();\n\n          for (var i = 0; i < indices.length; i++) {\n            indices[i] = parseInt(indices[i].replace(/\\)/, \"\"));\n          }\n\n          data.indices = indices;\n        }\n\n        data.id = id;\n        data.sid = sid;\n        data.arraySyntax = arraySyntax;\n        data.memberSyntax = memberSyntax;\n        data.sampler = parseId(xml2.getAttribute(\"source\"));\n        return data;\n      }\n\n      function buildAnimation(data) {\n        var tracks = [];\n        var channels = data.channels;\n        var samplers = data.samplers;\n        var sources = data.sources;\n\n        for (var target in channels) {\n          if (channels.hasOwnProperty(target)) {\n            var channel = channels[target];\n            var sampler = samplers[channel.sampler];\n            var inputId = sampler.inputs.INPUT;\n            var outputId = sampler.inputs.OUTPUT;\n            var inputSource = sources[inputId];\n            var outputSource = sources[outputId];\n            var animation = buildAnimationChannel(channel, inputSource, outputSource);\n            createKeyframeTracks(animation, tracks);\n          }\n        }\n\n        return tracks;\n      }\n\n      function getAnimation(id) {\n        return getBuild(library.animations[id], buildAnimation);\n      }\n\n      function buildAnimationChannel(channel, inputSource, outputSource) {\n        var node = library.nodes[channel.id];\n        var object3D = getNode(node.id);\n        var transform = node.transforms[channel.sid];\n        var defaultMatrix = node.matrix.clone().transpose();\n        var time, stride;\n        var i, il, j, jl;\n        var data = {};\n\n        switch (transform) {\n          case \"matrix\":\n            for (i = 0, il = inputSource.array.length; i < il; i++) {\n              time = inputSource.array[i];\n              stride = i * outputSource.stride;\n              if (data[time] === void 0) data[time] = {};\n\n              if (channel.arraySyntax === true) {\n                var value = outputSource.array[stride];\n                var index = channel.indices[0] + 4 * channel.indices[1];\n                data[time][index] = value;\n              } else {\n                for (j = 0, jl = outputSource.stride; j < jl; j++) {\n                  data[time][j] = outputSource.array[stride + j];\n                }\n              }\n            }\n\n            break;\n\n          case \"translate\":\n            console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n            break;\n\n          case \"rotate\":\n            console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n            break;\n\n          case \"scale\":\n            console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n            break;\n        }\n\n        var keyframes = prepareAnimationData(data, defaultMatrix);\n        var animation = {\n          name: object3D.uuid,\n          keyframes: keyframes\n        };\n        return animation;\n      }\n\n      function prepareAnimationData(data, defaultMatrix) {\n        var keyframes = [];\n\n        for (var time in data) {\n          keyframes.push({\n            time: parseFloat(time),\n            value: data[time]\n          });\n        }\n\n        keyframes.sort(ascending);\n\n        for (var i = 0; i < 16; i++) {\n          transformAnimationData(keyframes, i, defaultMatrix.elements[i]);\n        }\n\n        return keyframes;\n\n        function ascending(a, b) {\n          return a.time - b.time;\n        }\n      }\n\n      var position = new Vector3();\n      var scale = new Vector3();\n      var quaternion = new Quaternion();\n\n      function createKeyframeTracks(animation, tracks) {\n        var keyframes = animation.keyframes;\n        var name = animation.name;\n        var times = [];\n        var positionData = [];\n        var quaternionData = [];\n        var scaleData = [];\n\n        for (var i = 0, l = keyframes.length; i < l; i++) {\n          var keyframe = keyframes[i];\n          var time = keyframe.time;\n          var value = keyframe.value;\n          matrix.fromArray(value).transpose();\n          matrix.decompose(position, quaternion, scale);\n          times.push(time);\n          positionData.push(position.x, position.y, position.z);\n          quaternionData.push(quaternion.x, quaternion.y, quaternion.z, quaternion.w);\n          scaleData.push(scale.x, scale.y, scale.z);\n        }\n\n        if (positionData.length > 0) tracks.push(new VectorKeyframeTrack(name + \".position\", times, positionData));\n\n        if (quaternionData.length > 0) {\n          tracks.push(new QuaternionKeyframeTrack(name + \".quaternion\", times, quaternionData));\n        }\n\n        if (scaleData.length > 0) tracks.push(new VectorKeyframeTrack(name + \".scale\", times, scaleData));\n        return tracks;\n      }\n\n      function transformAnimationData(keyframes, property, defaultValue) {\n        var keyframe;\n        var empty = true;\n        var i, l;\n\n        for (i = 0, l = keyframes.length; i < l; i++) {\n          keyframe = keyframes[i];\n\n          if (keyframe.value[property] === void 0) {\n            keyframe.value[property] = null;\n          } else {\n            empty = false;\n          }\n        }\n\n        if (empty === true) {\n          for (i = 0, l = keyframes.length; i < l; i++) {\n            keyframe = keyframes[i];\n            keyframe.value[property] = defaultValue;\n          }\n        } else {\n          createMissingKeyframes(keyframes, property);\n        }\n      }\n\n      function createMissingKeyframes(keyframes, property) {\n        var prev, next;\n\n        for (var i = 0, l = keyframes.length; i < l; i++) {\n          var keyframe = keyframes[i];\n\n          if (keyframe.value[property] === null) {\n            prev = getPrev(keyframes, i, property);\n            next = getNext(keyframes, i, property);\n\n            if (prev === null) {\n              keyframe.value[property] = next.value[property];\n              continue;\n            }\n\n            if (next === null) {\n              keyframe.value[property] = prev.value[property];\n              continue;\n            }\n\n            interpolate(keyframe, prev, next, property);\n          }\n        }\n      }\n\n      function getPrev(keyframes, i, property) {\n        while (i >= 0) {\n          var keyframe = keyframes[i];\n          if (keyframe.value[property] !== null) return keyframe;\n          i--;\n        }\n\n        return null;\n      }\n\n      function getNext(keyframes, i, property) {\n        while (i < keyframes.length) {\n          var keyframe = keyframes[i];\n          if (keyframe.value[property] !== null) return keyframe;\n          i++;\n        }\n\n        return null;\n      }\n\n      function interpolate(key, prev, next, property) {\n        if (next.time - prev.time === 0) {\n          key.value[property] = prev.value[property];\n          return;\n        }\n\n        key.value[property] = (key.time - prev.time) * (next.value[property] - prev.value[property]) / (next.time - prev.time) + prev.value[property];\n      }\n\n      function parseAnimationClip(xml2) {\n        var data = {\n          name: xml2.getAttribute(\"id\") || \"default\",\n          start: parseFloat(xml2.getAttribute(\"start\") || 0),\n          end: parseFloat(xml2.getAttribute(\"end\") || 0),\n          animations: []\n        };\n\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case \"instance_animation\":\n              data.animations.push(parseId(child.getAttribute(\"url\")));\n              break;\n          }\n        }\n\n        library.clips[xml2.getAttribute(\"id\")] = data;\n      }\n\n      function buildAnimationClip(data) {\n        var tracks = [];\n        var name = data.name;\n        var duration = data.end - data.start || -1;\n        var animations2 = data.animations;\n\n        for (var i = 0, il = animations2.length; i < il; i++) {\n          var animationTracks = getAnimation(animations2[i]);\n\n          for (var j = 0, jl = animationTracks.length; j < jl; j++) {\n            tracks.push(animationTracks[j]);\n          }\n        }\n\n        return new AnimationClip(name, duration, tracks);\n      }\n\n      function getAnimationClip(id) {\n        return getBuild(library.clips[id], buildAnimationClip);\n      }\n\n      function parseController(xml2) {\n        var data = {};\n\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case \"skin\":\n              data.id = parseId(child.getAttribute(\"source\"));\n              data.skin = parseSkin(child);\n              break;\n\n            case \"morph\":\n              data.id = parseId(child.getAttribute(\"source\"));\n              console.warn(\"THREE.ColladaLoader: Morph target animation not supported yet.\");\n              break;\n          }\n        }\n\n        library.controllers[xml2.getAttribute(\"id\")] = data;\n      }\n\n      function parseSkin(xml2) {\n        var data = {\n          sources: {}\n        };\n\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case \"bind_shape_matrix\":\n              data.bindShapeMatrix = parseFloats(child.textContent);\n              break;\n\n            case \"source\":\n              var id = child.getAttribute(\"id\");\n              data.sources[id] = parseSource(child);\n              break;\n\n            case \"joints\":\n              data.joints = parseJoints(child);\n              break;\n\n            case \"vertex_weights\":\n              data.vertexWeights = parseVertexWeights(child);\n              break;\n          }\n        }\n\n        return data;\n      }\n\n      function parseJoints(xml2) {\n        var data = {\n          inputs: {}\n        };\n\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case \"input\":\n              var semantic = child.getAttribute(\"semantic\");\n              var id = parseId(child.getAttribute(\"source\"));\n              data.inputs[semantic] = id;\n              break;\n          }\n        }\n\n        return data;\n      }\n\n      function parseVertexWeights(xml2) {\n        var data = {\n          inputs: {}\n        };\n\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case \"input\":\n              var semantic = child.getAttribute(\"semantic\");\n              var id = parseId(child.getAttribute(\"source\"));\n              var offset = parseInt(child.getAttribute(\"offset\"));\n              data.inputs[semantic] = {\n                id: id,\n                offset: offset\n              };\n              break;\n\n            case \"vcount\":\n              data.vcount = parseInts(child.textContent);\n              break;\n\n            case \"v\":\n              data.v = parseInts(child.textContent);\n              break;\n          }\n        }\n\n        return data;\n      }\n\n      function buildController(data) {\n        var build = {\n          id: data.id\n        };\n        var geometry = library.geometries[build.id];\n\n        if (data.skin !== void 0) {\n          build.skin = buildSkin(data.skin);\n          geometry.sources.skinIndices = build.skin.indices;\n          geometry.sources.skinWeights = build.skin.weights;\n        }\n\n        return build;\n      }\n\n      function buildSkin(data) {\n        var BONE_LIMIT = 4;\n        var build = {\n          joints: [],\n          // this must be an array to preserve the joint order\n          indices: {\n            array: [],\n            stride: BONE_LIMIT\n          },\n          weights: {\n            array: [],\n            stride: BONE_LIMIT\n          }\n        };\n        var sources = data.sources;\n        var vertexWeights = data.vertexWeights;\n        var vcount = vertexWeights.vcount;\n        var v = vertexWeights.v;\n        var jointOffset = vertexWeights.inputs.JOINT.offset;\n        var weightOffset = vertexWeights.inputs.WEIGHT.offset;\n        var jointSource = data.sources[data.joints.inputs.JOINT];\n        var inverseSource = data.sources[data.joints.inputs.INV_BIND_MATRIX];\n        var weights = sources[vertexWeights.inputs.WEIGHT.id].array;\n        var stride = 0;\n        var i, j, l;\n\n        for (i = 0, l = vcount.length; i < l; i++) {\n          var jointCount = vcount[i];\n          var vertexSkinData = [];\n\n          for (j = 0; j < jointCount; j++) {\n            var skinIndex = v[stride + jointOffset];\n            var weightId = v[stride + weightOffset];\n            var skinWeight = weights[weightId];\n            vertexSkinData.push({\n              index: skinIndex,\n              weight: skinWeight\n            });\n            stride += 2;\n          }\n\n          vertexSkinData.sort(descending);\n\n          for (j = 0; j < BONE_LIMIT; j++) {\n            var d = vertexSkinData[j];\n\n            if (d !== void 0) {\n              build.indices.array.push(d.index);\n              build.weights.array.push(d.weight);\n            } else {\n              build.indices.array.push(0);\n              build.weights.array.push(0);\n            }\n          }\n        }\n\n        if (data.bindShapeMatrix) {\n          build.bindMatrix = new Matrix4().fromArray(data.bindShapeMatrix).transpose();\n        } else {\n          build.bindMatrix = new Matrix4().identity();\n        }\n\n        for (i = 0, l = jointSource.array.length; i < l; i++) {\n          var name = jointSource.array[i];\n          var boneInverse = new Matrix4().fromArray(inverseSource.array, i * inverseSource.stride).transpose();\n          build.joints.push({\n            name: name,\n            boneInverse: boneInverse\n          });\n        }\n\n        return build;\n\n        function descending(a, b) {\n          return b.weight - a.weight;\n        }\n      }\n\n      function getController(id) {\n        return getBuild(library.controllers[id], buildController);\n      }\n\n      function parseImage(xml2) {\n        var data = {\n          init_from: getElementsByTagName(xml2, \"init_from\")[0].textContent\n        };\n        library.images[xml2.getAttribute(\"id\")] = data;\n      }\n\n      function buildImage(data) {\n        if (data.build !== void 0) return data.build;\n        return data.init_from;\n      }\n\n      function getImage(id) {\n        var data = library.images[id];\n\n        if (data !== void 0) {\n          return getBuild(data, buildImage);\n        }\n\n        console.warn(\"THREE.ColladaLoader: Couldn't find image with ID:\", id);\n        return null;\n      }\n\n      function parseEffect(xml2) {\n        var data = {};\n\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case \"profile_COMMON\":\n              data.profile = parseEffectProfileCOMMON(child);\n              break;\n          }\n        }\n\n        library.effects[xml2.getAttribute(\"id\")] = data;\n      }\n\n      function parseEffectProfileCOMMON(xml2) {\n        var data = {\n          surfaces: {},\n          samplers: {}\n        };\n\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case \"newparam\":\n              parseEffectNewparam(child, data);\n              break;\n\n            case \"technique\":\n              data.technique = parseEffectTechnique(child);\n              break;\n\n            case \"extra\":\n              data.extra = parseEffectExtra(child);\n              break;\n          }\n        }\n\n        return data;\n      }\n\n      function parseEffectNewparam(xml2, data) {\n        var sid = xml2.getAttribute(\"sid\");\n\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case \"surface\":\n              data.surfaces[sid] = parseEffectSurface(child);\n              break;\n\n            case \"sampler2D\":\n              data.samplers[sid] = parseEffectSampler(child);\n              break;\n          }\n        }\n      }\n\n      function parseEffectSurface(xml2) {\n        var data = {};\n\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case \"init_from\":\n              data.init_from = child.textContent;\n              break;\n          }\n        }\n\n        return data;\n      }\n\n      function parseEffectSampler(xml2) {\n        var data = {};\n\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case \"source\":\n              data.source = child.textContent;\n              break;\n          }\n        }\n\n        return data;\n      }\n\n      function parseEffectTechnique(xml2) {\n        var data = {};\n\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case \"constant\":\n            case \"lambert\":\n            case \"blinn\":\n            case \"phong\":\n              data.type = child.nodeName;\n              data.parameters = parseEffectParameters(child);\n              break;\n\n            case \"extra\":\n              data.extra = parseEffectExtra(child);\n              break;\n          }\n        }\n\n        return data;\n      }\n\n      function parseEffectParameters(xml2) {\n        var data = {};\n\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case \"emission\":\n            case \"diffuse\":\n            case \"specular\":\n            case \"bump\":\n            case \"ambient\":\n            case \"shininess\":\n            case \"transparency\":\n              data[child.nodeName] = parseEffectParameter(child);\n              break;\n\n            case \"transparent\":\n              data[child.nodeName] = {\n                opaque: child.hasAttribute(\"opaque\") ? child.getAttribute(\"opaque\") : \"A_ONE\",\n                data: parseEffectParameter(child)\n              };\n              break;\n          }\n        }\n\n        return data;\n      }\n\n      function parseEffectParameter(xml2) {\n        var data = {};\n\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case \"color\":\n              data[child.nodeName] = parseFloats(child.textContent);\n              break;\n\n            case \"float\":\n              data[child.nodeName] = parseFloat(child.textContent);\n              break;\n\n            case \"texture\":\n              data[child.nodeName] = {\n                id: child.getAttribute(\"texture\"),\n                extra: parseEffectParameterTexture(child)\n              };\n              break;\n          }\n        }\n\n        return data;\n      }\n\n      function parseEffectParameterTexture(xml2) {\n        var data = {\n          technique: {}\n        };\n\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case \"extra\":\n              parseEffectParameterTextureExtra(child, data);\n              break;\n          }\n        }\n\n        return data;\n      }\n\n      function parseEffectParameterTextureExtra(xml2, data) {\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case \"technique\":\n              parseEffectParameterTextureExtraTechnique(child, data);\n              break;\n          }\n        }\n      }\n\n      function parseEffectParameterTextureExtraTechnique(xml2, data) {\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case \"repeatU\":\n            case \"repeatV\":\n            case \"offsetU\":\n            case \"offsetV\":\n              data.technique[child.nodeName] = parseFloat(child.textContent);\n              break;\n\n            case \"wrapU\":\n            case \"wrapV\":\n              if (child.textContent.toUpperCase() === \"TRUE\") {\n                data.technique[child.nodeName] = 1;\n              } else if (child.textContent.toUpperCase() === \"FALSE\") {\n                data.technique[child.nodeName] = 0;\n              } else {\n                data.technique[child.nodeName] = parseInt(child.textContent);\n              }\n\n              break;\n\n            case \"bump\":\n              data[child.nodeName] = parseEffectExtraTechniqueBump(child);\n              break;\n          }\n        }\n      }\n\n      function parseEffectExtra(xml2) {\n        var data = {};\n\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case \"technique\":\n              data.technique = parseEffectExtraTechnique(child);\n              break;\n          }\n        }\n\n        return data;\n      }\n\n      function parseEffectExtraTechnique(xml2) {\n        var data = {};\n\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case \"double_sided\":\n              data[child.nodeName] = parseInt(child.textContent);\n              break;\n\n            case \"bump\":\n              data[child.nodeName] = parseEffectExtraTechniqueBump(child);\n              break;\n          }\n        }\n\n        return data;\n      }\n\n      function parseEffectExtraTechniqueBump(xml2) {\n        var data = {};\n\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case \"texture\":\n              data[child.nodeName] = {\n                id: child.getAttribute(\"texture\"),\n                texcoord: child.getAttribute(\"texcoord\"),\n                extra: parseEffectParameterTexture(child)\n              };\n              break;\n          }\n        }\n\n        return data;\n      }\n\n      function buildEffect(data) {\n        return data;\n      }\n\n      function getEffect(id) {\n        return getBuild(library.effects[id], buildEffect);\n      }\n\n      function parseMaterial(xml2) {\n        var data = {\n          name: xml2.getAttribute(\"name\")\n        };\n\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case \"instance_effect\":\n              data.url = parseId(child.getAttribute(\"url\"));\n              break;\n          }\n        }\n\n        library.materials[xml2.getAttribute(\"id\")] = data;\n      }\n\n      function getTextureLoader(image) {\n        var loader;\n        var extension = image.slice((image.lastIndexOf(\".\") - 1 >>> 0) + 2);\n        extension = extension.toLowerCase();\n\n        switch (extension) {\n          case \"tga\":\n            loader = tgaLoader;\n            break;\n\n          default:\n            loader = textureLoader;\n        }\n\n        return loader;\n      }\n\n      function buildMaterial(data) {\n        var effect = getEffect(data.url);\n        var technique = effect.profile.technique;\n        var material;\n\n        switch (technique.type) {\n          case \"phong\":\n          case \"blinn\":\n            material = new MeshPhongMaterial();\n            break;\n\n          case \"lambert\":\n            material = new MeshLambertMaterial();\n            break;\n\n          default:\n            material = new MeshBasicMaterial();\n            break;\n        }\n\n        material.name = data.name || \"\";\n\n        function getTexture(textureObject) {\n          var sampler = effect.profile.samplers[textureObject.id];\n          var image = null;\n\n          if (sampler !== void 0) {\n            var surface = effect.profile.surfaces[sampler.source];\n            image = getImage(surface.init_from);\n          } else {\n            console.warn(\"THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530).\");\n            image = getImage(textureObject.id);\n          }\n\n          if (image !== null) {\n            var loader = getTextureLoader(image);\n\n            if (loader !== void 0) {\n              var texture = loader.load(image);\n              var extra = textureObject.extra;\n\n              if (extra !== void 0 && extra.technique !== void 0 && isEmpty(extra.technique) === false) {\n                var technique2 = extra.technique;\n                texture.wrapS = technique2.wrapU ? RepeatWrapping : ClampToEdgeWrapping;\n                texture.wrapT = technique2.wrapV ? RepeatWrapping : ClampToEdgeWrapping;\n                texture.offset.set(technique2.offsetU || 0, technique2.offsetV || 0);\n                texture.repeat.set(technique2.repeatU || 1, technique2.repeatV || 1);\n              } else {\n                texture.wrapS = RepeatWrapping;\n                texture.wrapT = RepeatWrapping;\n              }\n\n              return texture;\n            } else {\n              console.warn(\"THREE.ColladaLoader: Loader for texture %s not found.\", image);\n              return null;\n            }\n          } else {\n            console.warn(\"THREE.ColladaLoader: Couldn't create texture with ID:\", textureObject.id);\n            return null;\n          }\n        }\n\n        var parameters = technique.parameters;\n\n        for (var key in parameters) {\n          var parameter = parameters[key];\n\n          switch (key) {\n            case \"diffuse\":\n              if (parameter.color) material.color.fromArray(parameter.color);\n              if (parameter.texture) material.map = getTexture(parameter.texture);\n              break;\n\n            case \"specular\":\n              if (parameter.color && material.specular) material.specular.fromArray(parameter.color);\n              if (parameter.texture) material.specularMap = getTexture(parameter.texture);\n              break;\n\n            case \"bump\":\n              if (parameter.texture) material.normalMap = getTexture(parameter.texture);\n              break;\n\n            case \"ambient\":\n              if (parameter.texture) material.lightMap = getTexture(parameter.texture);\n              break;\n\n            case \"shininess\":\n              if (parameter.float && material.shininess) material.shininess = parameter.float;\n              break;\n\n            case \"emission\":\n              if (parameter.color && material.emissive) material.emissive.fromArray(parameter.color);\n              if (parameter.texture) material.emissiveMap = getTexture(parameter.texture);\n              break;\n          }\n        }\n\n        var transparent = parameters[\"transparent\"];\n        var transparency = parameters[\"transparency\"];\n\n        if (transparency === void 0 && transparent) {\n          transparency = {\n            float: 1\n          };\n        }\n\n        if (transparent === void 0 && transparency) {\n          transparent = {\n            opaque: \"A_ONE\",\n            data: {\n              color: [1, 1, 1, 1]\n            }\n          };\n        }\n\n        if (transparent && transparency) {\n          if (transparent.data.texture) {\n            material.transparent = true;\n          } else {\n            var color = transparent.data.color;\n\n            switch (transparent.opaque) {\n              case \"A_ONE\":\n                material.opacity = color[3] * transparency.float;\n                break;\n\n              case \"RGB_ZERO\":\n                material.opacity = 1 - color[0] * transparency.float;\n                break;\n\n              case \"A_ZERO\":\n                material.opacity = 1 - color[3] * transparency.float;\n                break;\n\n              case \"RGB_ONE\":\n                material.opacity = color[0] * transparency.float;\n                break;\n\n              default:\n                console.warn('THREE.ColladaLoader: Invalid opaque type \"%s\" of transparent tag.', transparent.opaque);\n            }\n\n            if (material.opacity < 1) material.transparent = true;\n          }\n        }\n\n        if (technique.extra !== void 0 && technique.extra.technique !== void 0) {\n          var techniques = technique.extra.technique;\n\n          for (var k in techniques) {\n            var v = techniques[k];\n\n            switch (k) {\n              case \"double_sided\":\n                material.side = v === 1 ? DoubleSide : FrontSide;\n                break;\n\n              case \"bump\":\n                material.normalMap = getTexture(v.texture);\n                material.normalScale = new Vector2(1, 1);\n                break;\n            }\n          }\n        }\n\n        return material;\n      }\n\n      function getMaterial(id) {\n        return getBuild(library.materials[id], buildMaterial);\n      }\n\n      function parseCamera(xml2) {\n        var data = {\n          name: xml2.getAttribute(\"name\")\n        };\n\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case \"optics\":\n              data.optics = parseCameraOptics(child);\n              break;\n          }\n        }\n\n        library.cameras[xml2.getAttribute(\"id\")] = data;\n      }\n\n      function parseCameraOptics(xml2) {\n        for (var i = 0; i < xml2.childNodes.length; i++) {\n          var child = xml2.childNodes[i];\n\n          switch (child.nodeName) {\n            case \"technique_common\":\n              return parseCameraTechnique(child);\n          }\n        }\n\n        return {};\n      }\n\n      function parseCameraTechnique(xml2) {\n        var data = {};\n\n        for (var i = 0; i < xml2.childNodes.length; i++) {\n          var child = xml2.childNodes[i];\n\n          switch (child.nodeName) {\n            case \"perspective\":\n            case \"orthographic\":\n              data.technique = child.nodeName;\n              data.parameters = parseCameraParameters(child);\n              break;\n          }\n        }\n\n        return data;\n      }\n\n      function parseCameraParameters(xml2) {\n        var data = {};\n\n        for (var i = 0; i < xml2.childNodes.length; i++) {\n          var child = xml2.childNodes[i];\n\n          switch (child.nodeName) {\n            case \"xfov\":\n            case \"yfov\":\n            case \"xmag\":\n            case \"ymag\":\n            case \"znear\":\n            case \"zfar\":\n            case \"aspect_ratio\":\n              data[child.nodeName] = parseFloat(child.textContent);\n              break;\n          }\n        }\n\n        return data;\n      }\n\n      function buildCamera(data) {\n        var camera;\n\n        switch (data.optics.technique) {\n          case \"perspective\":\n            camera = new PerspectiveCamera(data.optics.parameters.yfov, data.optics.parameters.aspect_ratio, data.optics.parameters.znear, data.optics.parameters.zfar);\n            break;\n\n          case \"orthographic\":\n            var ymag = data.optics.parameters.ymag;\n            var xmag = data.optics.parameters.xmag;\n            var aspectRatio = data.optics.parameters.aspect_ratio;\n            xmag = xmag === void 0 ? ymag * aspectRatio : xmag;\n            ymag = ymag === void 0 ? xmag / aspectRatio : ymag;\n            xmag *= 0.5;\n            ymag *= 0.5;\n            camera = new OrthographicCamera(-xmag, xmag, ymag, -ymag, // left, right, top, bottom\n            data.optics.parameters.znear, data.optics.parameters.zfar);\n            break;\n\n          default:\n            camera = new PerspectiveCamera();\n            break;\n        }\n\n        camera.name = data.name || \"\";\n        return camera;\n      }\n\n      function getCamera(id) {\n        var data = library.cameras[id];\n\n        if (data !== void 0) {\n          return getBuild(data, buildCamera);\n        }\n\n        console.warn(\"THREE.ColladaLoader: Couldn't find camera with ID:\", id);\n        return null;\n      }\n\n      function parseLight(xml2) {\n        var data = {};\n\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case \"technique_common\":\n              data = parseLightTechnique(child);\n              break;\n          }\n        }\n\n        library.lights[xml2.getAttribute(\"id\")] = data;\n      }\n\n      function parseLightTechnique(xml2) {\n        var data = {};\n\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case \"directional\":\n            case \"point\":\n            case \"spot\":\n            case \"ambient\":\n              data.technique = child.nodeName;\n              data.parameters = parseLightParameters(child);\n          }\n        }\n\n        return data;\n      }\n\n      function parseLightParameters(xml2) {\n        var data = {};\n\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case \"color\":\n              var array = parseFloats(child.textContent);\n              data.color = new Color().fromArray(array);\n              break;\n\n            case \"falloff_angle\":\n              data.falloffAngle = parseFloat(child.textContent);\n              break;\n\n            case \"quadratic_attenuation\":\n              var f = parseFloat(child.textContent);\n              data.distance = f ? Math.sqrt(1 / f) : 0;\n              break;\n          }\n        }\n\n        return data;\n      }\n\n      function buildLight(data) {\n        var light;\n\n        switch (data.technique) {\n          case \"directional\":\n            light = new DirectionalLight();\n            break;\n\n          case \"point\":\n            light = new PointLight();\n            break;\n\n          case \"spot\":\n            light = new SpotLight();\n            break;\n\n          case \"ambient\":\n            light = new AmbientLight();\n            break;\n        }\n\n        if (data.parameters.color) light.color.copy(data.parameters.color);\n        if (data.parameters.distance) light.distance = data.parameters.distance;\n        return light;\n      }\n\n      function getLight(id) {\n        var data = library.lights[id];\n\n        if (data !== void 0) {\n          return getBuild(data, buildLight);\n        }\n\n        console.warn(\"THREE.ColladaLoader: Couldn't find light with ID:\", id);\n        return null;\n      }\n\n      function parseGeometry(xml2) {\n        var data = {\n          name: xml2.getAttribute(\"name\"),\n          sources: {},\n          vertices: {},\n          primitives: []\n        };\n        var mesh = getElementsByTagName(xml2, \"mesh\")[0];\n        if (mesh === void 0) return;\n\n        for (var i = 0; i < mesh.childNodes.length; i++) {\n          var child = mesh.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          var id = child.getAttribute(\"id\");\n\n          switch (child.nodeName) {\n            case \"source\":\n              data.sources[id] = parseSource(child);\n              break;\n\n            case \"vertices\":\n              data.vertices = parseGeometryVertices(child);\n              break;\n\n            case \"polygons\":\n              console.warn(\"THREE.ColladaLoader: Unsupported primitive type: \", child.nodeName);\n              break;\n\n            case \"lines\":\n            case \"linestrips\":\n            case \"polylist\":\n            case \"triangles\":\n              data.primitives.push(parseGeometryPrimitive(child));\n              break;\n\n            default:\n              console.log(child);\n          }\n        }\n\n        library.geometries[xml2.getAttribute(\"id\")] = data;\n      }\n\n      function parseSource(xml2) {\n        var data = {\n          array: [],\n          stride: 3\n        };\n\n        for (var i = 0; i < xml2.childNodes.length; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case \"float_array\":\n              data.array = parseFloats(child.textContent);\n              break;\n\n            case \"Name_array\":\n              data.array = parseStrings(child.textContent);\n              break;\n\n            case \"technique_common\":\n              var accessor = getElementsByTagName(child, \"accessor\")[0];\n\n              if (accessor !== void 0) {\n                data.stride = parseInt(accessor.getAttribute(\"stride\"));\n              }\n\n              break;\n          }\n        }\n\n        return data;\n      }\n\n      function parseGeometryVertices(xml2) {\n        var data = {};\n\n        for (var i = 0; i < xml2.childNodes.length; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          data[child.getAttribute(\"semantic\")] = parseId(child.getAttribute(\"source\"));\n        }\n\n        return data;\n      }\n\n      function parseGeometryPrimitive(xml2) {\n        var primitive = {\n          type: xml2.nodeName,\n          material: xml2.getAttribute(\"material\"),\n          count: parseInt(xml2.getAttribute(\"count\")),\n          inputs: {},\n          stride: 0,\n          hasUV: false\n        };\n\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case \"input\":\n              var id = parseId(child.getAttribute(\"source\"));\n              var semantic = child.getAttribute(\"semantic\");\n              var offset = parseInt(child.getAttribute(\"offset\"));\n              var set = parseInt(child.getAttribute(\"set\"));\n              var inputname = set > 0 ? semantic + set : semantic;\n              primitive.inputs[inputname] = {\n                id: id,\n                offset: offset\n              };\n              primitive.stride = Math.max(primitive.stride, offset + 1);\n              if (semantic === \"TEXCOORD\") primitive.hasUV = true;\n              break;\n\n            case \"vcount\":\n              primitive.vcount = parseInts(child.textContent);\n              break;\n\n            case \"p\":\n              primitive.p = parseInts(child.textContent);\n              break;\n          }\n        }\n\n        return primitive;\n      }\n\n      function groupPrimitives(primitives) {\n        var build = {};\n\n        for (var i = 0; i < primitives.length; i++) {\n          var primitive = primitives[i];\n          if (build[primitive.type] === void 0) build[primitive.type] = [];\n          build[primitive.type].push(primitive);\n        }\n\n        return build;\n      }\n\n      function checkUVCoordinates(primitives) {\n        var count2 = 0;\n\n        for (var i = 0, l = primitives.length; i < l; i++) {\n          var primitive = primitives[i];\n\n          if (primitive.hasUV === true) {\n            count2++;\n          }\n        }\n\n        if (count2 > 0 && count2 < primitives.length) {\n          primitives.uvsNeedsFix = true;\n        }\n      }\n\n      function buildGeometry(data) {\n        var build = {};\n        var sources = data.sources;\n        var vertices = data.vertices;\n        var primitives = data.primitives;\n        if (primitives.length === 0) return {};\n        var groupedPrimitives = groupPrimitives(primitives);\n\n        for (var type in groupedPrimitives) {\n          var primitiveType = groupedPrimitives[type];\n          checkUVCoordinates(primitiveType);\n          build[type] = buildGeometryType(primitiveType, sources, vertices);\n        }\n\n        return build;\n      }\n\n      function buildGeometryType(primitives, sources, vertices) {\n        var build = {};\n        var position2 = {\n          array: [],\n          stride: 0\n        };\n        var normal = {\n          array: [],\n          stride: 0\n        };\n        var uv = {\n          array: [],\n          stride: 0\n        };\n        var uv2 = {\n          array: [],\n          stride: 0\n        };\n        var color = {\n          array: [],\n          stride: 0\n        };\n        var skinIndex = {\n          array: [],\n          stride: 4\n        };\n        var skinWeight = {\n          array: [],\n          stride: 4\n        };\n        var geometry = new BufferGeometry();\n        var materialKeys = [];\n        var start = 0;\n\n        for (var p = 0; p < primitives.length; p++) {\n          var primitive = primitives[p];\n          var inputs = primitive.inputs;\n          var count2 = 0;\n\n          switch (primitive.type) {\n            case \"lines\":\n            case \"linestrips\":\n              count2 = primitive.count * 2;\n              break;\n\n            case \"triangles\":\n              count2 = primitive.count * 3;\n              break;\n\n            case \"polylist\":\n              for (var g = 0; g < primitive.count; g++) {\n                var vc = primitive.vcount[g];\n\n                switch (vc) {\n                  case 3:\n                    count2 += 3;\n                    break;\n\n                  case 4:\n                    count2 += 6;\n                    break;\n\n                  default:\n                    count2 += (vc - 2) * 3;\n                    break;\n                }\n              }\n\n              break;\n\n            default:\n              console.warn(\"THREE.ColladaLoader: Unknow primitive type:\", primitive.type);\n          }\n\n          geometry.addGroup(start, count2, p);\n          start += count2;\n\n          if (primitive.material) {\n            materialKeys.push(primitive.material);\n          }\n\n          for (var name in inputs) {\n            var input = inputs[name];\n\n            switch (name) {\n              case \"VERTEX\":\n                for (var key in vertices) {\n                  var id = vertices[key];\n\n                  switch (key) {\n                    case \"POSITION\":\n                      var prevLength = position2.array.length;\n                      buildGeometryData(primitive, sources[id], input.offset, position2.array);\n                      position2.stride = sources[id].stride;\n\n                      if (sources.skinWeights && sources.skinIndices) {\n                        buildGeometryData(primitive, sources.skinIndices, input.offset, skinIndex.array);\n                        buildGeometryData(primitive, sources.skinWeights, input.offset, skinWeight.array);\n                      }\n\n                      if (primitive.hasUV === false && primitives.uvsNeedsFix === true) {\n                        var count3 = (position2.array.length - prevLength) / position2.stride;\n\n                        for (var i = 0; i < count3; i++) {\n                          uv.array.push(0, 0);\n                        }\n                      }\n\n                      break;\n\n                    case \"NORMAL\":\n                      buildGeometryData(primitive, sources[id], input.offset, normal.array);\n                      normal.stride = sources[id].stride;\n                      break;\n\n                    case \"COLOR\":\n                      buildGeometryData(primitive, sources[id], input.offset, color.array);\n                      color.stride = sources[id].stride;\n                      break;\n\n                    case \"TEXCOORD\":\n                      buildGeometryData(primitive, sources[id], input.offset, uv.array);\n                      uv.stride = sources[id].stride;\n                      break;\n\n                    case \"TEXCOORD1\":\n                      buildGeometryData(primitive, sources[id], input.offset, uv2.array);\n                      uv.stride = sources[id].stride;\n                      break;\n\n                    default:\n                      console.warn('THREE.ColladaLoader: Semantic \"%s\" not handled in geometry build process.', key);\n                  }\n                }\n\n                break;\n\n              case \"NORMAL\":\n                buildGeometryData(primitive, sources[input.id], input.offset, normal.array);\n                normal.stride = sources[input.id].stride;\n                break;\n\n              case \"COLOR\":\n                buildGeometryData(primitive, sources[input.id], input.offset, color.array);\n                color.stride = sources[input.id].stride;\n                break;\n\n              case \"TEXCOORD\":\n                buildGeometryData(primitive, sources[input.id], input.offset, uv.array);\n                uv.stride = sources[input.id].stride;\n                break;\n\n              case \"TEXCOORD1\":\n                buildGeometryData(primitive, sources[input.id], input.offset, uv2.array);\n                uv2.stride = sources[input.id].stride;\n                break;\n            }\n          }\n        }\n\n        if (position2.array.length > 0) {\n          geometry.setAttribute(\"position\", new Float32BufferAttribute(position2.array, position2.stride));\n        }\n\n        if (normal.array.length > 0) {\n          geometry.setAttribute(\"normal\", new Float32BufferAttribute(normal.array, normal.stride));\n        }\n\n        if (color.array.length > 0) geometry.setAttribute(\"color\", new Float32BufferAttribute(color.array, color.stride));\n        if (uv.array.length > 0) geometry.setAttribute(\"uv\", new Float32BufferAttribute(uv.array, uv.stride));\n        if (uv2.array.length > 0) geometry.setAttribute(\"uv2\", new Float32BufferAttribute(uv2.array, uv2.stride));\n\n        if (skinIndex.array.length > 0) {\n          geometry.setAttribute(\"skinIndex\", new Float32BufferAttribute(skinIndex.array, skinIndex.stride));\n        }\n\n        if (skinWeight.array.length > 0) {\n          geometry.setAttribute(\"skinWeight\", new Float32BufferAttribute(skinWeight.array, skinWeight.stride));\n        }\n\n        build.data = geometry;\n        build.type = primitives[0].type;\n        build.materialKeys = materialKeys;\n        return build;\n      }\n\n      function buildGeometryData(primitive, source, offset, array) {\n        var indices = primitive.p;\n        var stride = primitive.stride;\n        var vcount = primitive.vcount;\n\n        function pushVector(i) {\n          var index = indices[i + offset] * sourceStride;\n          var length = index + sourceStride;\n\n          for (; index < length; index++) {\n            array.push(sourceArray[index]);\n          }\n        }\n\n        var sourceArray = source.array;\n        var sourceStride = source.stride;\n\n        if (primitive.vcount !== void 0) {\n          var index = 0;\n\n          for (var i = 0, l = vcount.length; i < l; i++) {\n            var count2 = vcount[i];\n\n            if (count2 === 4) {\n              var a = index + stride * 0;\n              var b = index + stride * 1;\n              var c = index + stride * 2;\n              var d = index + stride * 3;\n              pushVector(a);\n              pushVector(b);\n              pushVector(d);\n              pushVector(b);\n              pushVector(c);\n              pushVector(d);\n            } else if (count2 === 3) {\n              var _a = index + stride * 0;\n\n              var _b = index + stride * 1;\n\n              var _c = index + stride * 2;\n\n              pushVector(_a);\n              pushVector(_b);\n              pushVector(_c);\n            } else if (count2 > 4) {\n              for (var k = 1, kl = count2 - 2; k <= kl; k++) {\n                var _a2 = index + stride * 0;\n\n                var _b2 = index + stride * k;\n\n                var _c2 = index + stride * (k + 1);\n\n                pushVector(_a2);\n                pushVector(_b2);\n                pushVector(_c2);\n              }\n            }\n\n            index += stride * count2;\n          }\n        } else {\n          for (var _i = 0, _l = indices.length; _i < _l; _i += stride) {\n            pushVector(_i);\n          }\n        }\n      }\n\n      function getGeometry(id) {\n        return getBuild(library.geometries[id], buildGeometry);\n      }\n\n      function parseKinematicsModel(xml2) {\n        var data = {\n          name: xml2.getAttribute(\"name\") || \"\",\n          joints: {},\n          links: []\n        };\n\n        for (var i = 0; i < xml2.childNodes.length; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case \"technique_common\":\n              parseKinematicsTechniqueCommon(child, data);\n              break;\n          }\n        }\n\n        library.kinematicsModels[xml2.getAttribute(\"id\")] = data;\n      }\n\n      function buildKinematicsModel(data) {\n        if (data.build !== void 0) return data.build;\n        return data;\n      }\n\n      function getKinematicsModel(id) {\n        return getBuild(library.kinematicsModels[id], buildKinematicsModel);\n      }\n\n      function parseKinematicsTechniqueCommon(xml2, data) {\n        for (var i = 0; i < xml2.childNodes.length; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case \"joint\":\n              data.joints[child.getAttribute(\"sid\")] = parseKinematicsJoint(child);\n              break;\n\n            case \"link\":\n              data.links.push(parseKinematicsLink(child));\n              break;\n          }\n        }\n      }\n\n      function parseKinematicsJoint(xml2) {\n        var data;\n\n        for (var i = 0; i < xml2.childNodes.length; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case \"prismatic\":\n            case \"revolute\":\n              data = parseKinematicsJointParameter(child);\n              break;\n          }\n        }\n\n        return data;\n      }\n\n      function parseKinematicsJointParameter(xml2) {\n        var data = {\n          sid: xml2.getAttribute(\"sid\"),\n          name: xml2.getAttribute(\"name\") || \"\",\n          axis: new Vector3(),\n          limits: {\n            min: 0,\n            max: 0\n          },\n          type: xml2.nodeName,\n          static: false,\n          zeroPosition: 0,\n          middlePosition: 0\n        };\n\n        for (var i = 0; i < xml2.childNodes.length; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case \"axis\":\n              var array = parseFloats(child.textContent);\n              data.axis.fromArray(array);\n              break;\n\n            case \"limits\":\n              var max = child.getElementsByTagName(\"max\")[0];\n              var min = child.getElementsByTagName(\"min\")[0];\n              data.limits.max = parseFloat(max.textContent);\n              data.limits.min = parseFloat(min.textContent);\n              break;\n          }\n        }\n\n        if (data.limits.min >= data.limits.max) {\n          data.static = true;\n        }\n\n        data.middlePosition = (data.limits.min + data.limits.max) / 2;\n        return data;\n      }\n\n      function parseKinematicsLink(xml2) {\n        var data = {\n          sid: xml2.getAttribute(\"sid\"),\n          name: xml2.getAttribute(\"name\") || \"\",\n          attachments: [],\n          transforms: []\n        };\n\n        for (var i = 0; i < xml2.childNodes.length; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case \"attachment_full\":\n              data.attachments.push(parseKinematicsAttachment(child));\n              break;\n\n            case \"matrix\":\n            case \"translate\":\n            case \"rotate\":\n              data.transforms.push(parseKinematicsTransform(child));\n              break;\n          }\n        }\n\n        return data;\n      }\n\n      function parseKinematicsAttachment(xml2) {\n        var data = {\n          joint: xml2.getAttribute(\"joint\").split(\"/\").pop(),\n          transforms: [],\n          links: []\n        };\n\n        for (var i = 0; i < xml2.childNodes.length; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case \"link\":\n              data.links.push(parseKinematicsLink(child));\n              break;\n\n            case \"matrix\":\n            case \"translate\":\n            case \"rotate\":\n              data.transforms.push(parseKinematicsTransform(child));\n              break;\n          }\n        }\n\n        return data;\n      }\n\n      function parseKinematicsTransform(xml2) {\n        var data = {\n          type: xml2.nodeName\n        };\n        var array = parseFloats(xml2.textContent);\n\n        switch (data.type) {\n          case \"matrix\":\n            data.obj = new Matrix4();\n            data.obj.fromArray(array).transpose();\n            break;\n\n          case \"translate\":\n            data.obj = new Vector3();\n            data.obj.fromArray(array);\n            break;\n\n          case \"rotate\":\n            data.obj = new Vector3();\n            data.obj.fromArray(array);\n            data.angle = MathUtils.degToRad(array[3]);\n            break;\n        }\n\n        return data;\n      }\n\n      function parsePhysicsModel(xml2) {\n        var data = {\n          name: xml2.getAttribute(\"name\") || \"\",\n          rigidBodies: {}\n        };\n\n        for (var i = 0; i < xml2.childNodes.length; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case \"rigid_body\":\n              data.rigidBodies[child.getAttribute(\"name\")] = {};\n              parsePhysicsRigidBody(child, data.rigidBodies[child.getAttribute(\"name\")]);\n              break;\n          }\n        }\n\n        library.physicsModels[xml2.getAttribute(\"id\")] = data;\n      }\n\n      function parsePhysicsRigidBody(xml2, data) {\n        for (var i = 0; i < xml2.childNodes.length; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case \"technique_common\":\n              parsePhysicsTechniqueCommon(child, data);\n              break;\n          }\n        }\n      }\n\n      function parsePhysicsTechniqueCommon(xml2, data) {\n        for (var i = 0; i < xml2.childNodes.length; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case \"inertia\":\n              data.inertia = parseFloats(child.textContent);\n              break;\n\n            case \"mass\":\n              data.mass = parseFloats(child.textContent)[0];\n              break;\n          }\n        }\n      }\n\n      function parseKinematicsScene(xml2) {\n        var data = {\n          bindJointAxis: []\n        };\n\n        for (var i = 0; i < xml2.childNodes.length; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case \"bind_joint_axis\":\n              data.bindJointAxis.push(parseKinematicsBindJointAxis(child));\n              break;\n          }\n        }\n\n        library.kinematicsScenes[parseId(xml2.getAttribute(\"url\"))] = data;\n      }\n\n      function parseKinematicsBindJointAxis(xml2) {\n        var data = {\n          target: xml2.getAttribute(\"target\").split(\"/\").pop()\n        };\n\n        for (var i = 0; i < xml2.childNodes.length; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case \"axis\":\n              var param = child.getElementsByTagName(\"param\")[0];\n              data.axis = param.textContent;\n              var tmpJointIndex = data.axis.split(\"inst_\").pop().split(\"axis\")[0];\n              data.jointIndex = tmpJointIndex.substr(0, tmpJointIndex.length - 1);\n              break;\n          }\n        }\n\n        return data;\n      }\n\n      function buildKinematicsScene(data) {\n        if (data.build !== void 0) return data.build;\n        return data;\n      }\n\n      function getKinematicsScene(id) {\n        return getBuild(library.kinematicsScenes[id], buildKinematicsScene);\n      }\n\n      function setupKinematics() {\n        var kinematicsModelId = Object.keys(library.kinematicsModels)[0];\n        var kinematicsSceneId = Object.keys(library.kinematicsScenes)[0];\n        var visualSceneId = Object.keys(library.visualScenes)[0];\n        if (kinematicsModelId === void 0 || kinematicsSceneId === void 0) return;\n        var kinematicsModel = getKinematicsModel(kinematicsModelId);\n        var kinematicsScene = getKinematicsScene(kinematicsSceneId);\n        var visualScene = getVisualScene(visualSceneId);\n        var bindJointAxis = kinematicsScene.bindJointAxis;\n        var jointMap = {};\n\n        for (var i = 0, l = bindJointAxis.length; i < l; i++) {\n          var axis = bindJointAxis[i];\n          var targetElement = collada.querySelector('[sid=\"' + axis.target + '\"]');\n\n          if (targetElement) {\n            var parentVisualElement = targetElement.parentElement;\n            connect(axis.jointIndex, parentVisualElement);\n          }\n        }\n\n        function connect(jointIndex, visualElement) {\n          var visualElementName = visualElement.getAttribute(\"name\");\n          var joint = kinematicsModel.joints[jointIndex];\n          visualScene.traverse(function (object) {\n            if (object.name === visualElementName) {\n              jointMap[jointIndex] = {\n                object: object,\n                transforms: buildTransformList(visualElement),\n                joint: joint,\n                position: joint.zeroPosition\n              };\n            }\n          });\n        }\n\n        var m0 = new Matrix4();\n        kinematics = {\n          joints: kinematicsModel && kinematicsModel.joints,\n          getJointValue: function getJointValue(jointIndex) {\n            var jointData = jointMap[jointIndex];\n\n            if (jointData) {\n              return jointData.position;\n            } else {\n              console.warn(\"THREE.ColladaLoader: Joint \" + jointIndex + \" doesn't exist.\");\n            }\n          },\n          setJointValue: function setJointValue(jointIndex, value) {\n            var jointData = jointMap[jointIndex];\n\n            if (jointData) {\n              var joint = jointData.joint;\n\n              if (value > joint.limits.max || value < joint.limits.min) {\n                console.warn(\"THREE.ColladaLoader: Joint \" + jointIndex + \" value \" + value + \" outside of limits (min: \" + joint.limits.min + \", max: \" + joint.limits.max + \").\");\n              } else if (joint.static) {\n                console.warn(\"THREE.ColladaLoader: Joint \" + jointIndex + \" is static.\");\n              } else {\n                var object = jointData.object;\n                var _axis = joint.axis;\n                var transforms = jointData.transforms;\n                matrix.identity();\n\n                for (var _i2 = 0; _i2 < transforms.length; _i2++) {\n                  var transform = transforms[_i2];\n\n                  if (transform.sid && transform.sid.indexOf(jointIndex) !== -1) {\n                    switch (joint.type) {\n                      case \"revolute\":\n                        matrix.multiply(m0.makeRotationAxis(_axis, MathUtils.degToRad(value)));\n                        break;\n\n                      case \"prismatic\":\n                        matrix.multiply(m0.makeTranslation(_axis.x * value, _axis.y * value, _axis.z * value));\n                        break;\n\n                      default:\n                        console.warn(\"THREE.ColladaLoader: Unknown joint type: \" + joint.type);\n                        break;\n                    }\n                  } else {\n                    switch (transform.type) {\n                      case \"matrix\":\n                        matrix.multiply(transform.obj);\n                        break;\n\n                      case \"translate\":\n                        matrix.multiply(m0.makeTranslation(transform.obj.x, transform.obj.y, transform.obj.z));\n                        break;\n\n                      case \"scale\":\n                        matrix.scale(transform.obj);\n                        break;\n\n                      case \"rotate\":\n                        matrix.multiply(m0.makeRotationAxis(transform.obj, transform.angle));\n                        break;\n                    }\n                  }\n                }\n\n                object.matrix.copy(matrix);\n                object.matrix.decompose(object.position, object.quaternion, object.scale);\n                jointMap[jointIndex].position = value;\n              }\n            } else {\n              console.log(\"THREE.ColladaLoader: \" + jointIndex + \" does not exist.\");\n            }\n          }\n        };\n      }\n\n      function buildTransformList(node) {\n        var transforms = [];\n        var xml2 = collada.querySelector('[id=\"' + node.id + '\"]');\n\n        for (var i = 0; i < xml2.childNodes.length; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          var array = void 0,\n              vector2 = void 0;\n\n          switch (child.nodeName) {\n            case \"matrix\":\n              array = parseFloats(child.textContent);\n              var matrix2 = new Matrix4().fromArray(array).transpose();\n              transforms.push({\n                sid: child.getAttribute(\"sid\"),\n                type: child.nodeName,\n                obj: matrix2\n              });\n              break;\n\n            case \"translate\":\n            case \"scale\":\n              array = parseFloats(child.textContent);\n              vector2 = new Vector3().fromArray(array);\n              transforms.push({\n                sid: child.getAttribute(\"sid\"),\n                type: child.nodeName,\n                obj: vector2\n              });\n              break;\n\n            case \"rotate\":\n              array = parseFloats(child.textContent);\n              vector2 = new Vector3().fromArray(array);\n              var angle = MathUtils.degToRad(array[3]);\n              transforms.push({\n                sid: child.getAttribute(\"sid\"),\n                type: child.nodeName,\n                obj: vector2,\n                angle: angle\n              });\n              break;\n          }\n        }\n\n        return transforms;\n      }\n\n      function prepareNodes(xml2) {\n        var elements = xml2.getElementsByTagName(\"node\");\n\n        for (var i = 0; i < elements.length; i++) {\n          var element = elements[i];\n\n          if (element.hasAttribute(\"id\") === false) {\n            element.setAttribute(\"id\", generateId());\n          }\n        }\n      }\n\n      var matrix = new Matrix4();\n      var vector = new Vector3();\n\n      function parseNode(xml2) {\n        var data = {\n          name: xml2.getAttribute(\"name\") || \"\",\n          type: xml2.getAttribute(\"type\"),\n          id: xml2.getAttribute(\"id\"),\n          sid: xml2.getAttribute(\"sid\"),\n          matrix: new Matrix4(),\n          nodes: [],\n          instanceCameras: [],\n          instanceControllers: [],\n          instanceLights: [],\n          instanceGeometries: [],\n          instanceNodes: [],\n          transforms: {}\n        };\n\n        for (var i = 0; i < xml2.childNodes.length; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          var array = void 0;\n\n          switch (child.nodeName) {\n            case \"node\":\n              data.nodes.push(child.getAttribute(\"id\"));\n              parseNode(child);\n              break;\n\n            case \"instance_camera\":\n              data.instanceCameras.push(parseId(child.getAttribute(\"url\")));\n              break;\n\n            case \"instance_controller\":\n              data.instanceControllers.push(parseNodeInstance(child));\n              break;\n\n            case \"instance_light\":\n              data.instanceLights.push(parseId(child.getAttribute(\"url\")));\n              break;\n\n            case \"instance_geometry\":\n              data.instanceGeometries.push(parseNodeInstance(child));\n              break;\n\n            case \"instance_node\":\n              data.instanceNodes.push(parseId(child.getAttribute(\"url\")));\n              break;\n\n            case \"matrix\":\n              array = parseFloats(child.textContent);\n              data.matrix.multiply(matrix.fromArray(array).transpose());\n              data.transforms[child.getAttribute(\"sid\")] = child.nodeName;\n              break;\n\n            case \"translate\":\n              array = parseFloats(child.textContent);\n              vector.fromArray(array);\n              data.matrix.multiply(matrix.makeTranslation(vector.x, vector.y, vector.z));\n              data.transforms[child.getAttribute(\"sid\")] = child.nodeName;\n              break;\n\n            case \"rotate\":\n              array = parseFloats(child.textContent);\n              var angle = MathUtils.degToRad(array[3]);\n              data.matrix.multiply(matrix.makeRotationAxis(vector.fromArray(array), angle));\n              data.transforms[child.getAttribute(\"sid\")] = child.nodeName;\n              break;\n\n            case \"scale\":\n              array = parseFloats(child.textContent);\n              data.matrix.scale(vector.fromArray(array));\n              data.transforms[child.getAttribute(\"sid\")] = child.nodeName;\n              break;\n\n            case \"extra\":\n              break;\n\n            default:\n              console.log(child);\n          }\n        }\n\n        if (hasNode(data.id)) {\n          console.warn(\"THREE.ColladaLoader: There is already a node with ID %s. Exclude current node from further processing.\", data.id);\n        } else {\n          library.nodes[data.id] = data;\n        }\n\n        return data;\n      }\n\n      function parseNodeInstance(xml2) {\n        var data = {\n          id: parseId(xml2.getAttribute(\"url\")),\n          materials: {},\n          skeletons: []\n        };\n\n        for (var i = 0; i < xml2.childNodes.length; i++) {\n          var child = xml2.childNodes[i];\n\n          switch (child.nodeName) {\n            case \"bind_material\":\n              var instances = child.getElementsByTagName(\"instance_material\");\n\n              for (var j = 0; j < instances.length; j++) {\n                var instance = instances[j];\n                var symbol = instance.getAttribute(\"symbol\");\n                var target = instance.getAttribute(\"target\");\n                data.materials[symbol] = parseId(target);\n              }\n\n              break;\n\n            case \"skeleton\":\n              data.skeletons.push(parseId(child.textContent));\n              break;\n\n            default:\n              break;\n          }\n        }\n\n        return data;\n      }\n\n      function buildSkeleton(skeletons, joints) {\n        var boneData = [];\n        var sortedBoneData = [];\n        var i, j, data;\n\n        for (i = 0; i < skeletons.length; i++) {\n          var skeleton = skeletons[i];\n          var root = void 0;\n\n          if (hasNode(skeleton)) {\n            root = getNode(skeleton);\n            buildBoneHierarchy(root, joints, boneData);\n          } else if (hasVisualScene(skeleton)) {\n            var visualScene = library.visualScenes[skeleton];\n            var children = visualScene.children;\n\n            for (var j2 = 0; j2 < children.length; j2++) {\n              var child = children[j2];\n\n              if (child.type === \"JOINT\") {\n                var root2 = getNode(child.id);\n                buildBoneHierarchy(root2, joints, boneData);\n              }\n            }\n          } else {\n            console.error(\"THREE.ColladaLoader: Unable to find root bone of skeleton with ID:\", skeleton);\n          }\n        }\n\n        for (i = 0; i < joints.length; i++) {\n          for (j = 0; j < boneData.length; j++) {\n            data = boneData[j];\n\n            if (data.bone.name === joints[i].name) {\n              sortedBoneData[i] = data;\n              data.processed = true;\n              break;\n            }\n          }\n        }\n\n        for (i = 0; i < boneData.length; i++) {\n          data = boneData[i];\n\n          if (data.processed === false) {\n            sortedBoneData.push(data);\n            data.processed = true;\n          }\n        }\n\n        var bones = [];\n        var boneInverses = [];\n\n        for (i = 0; i < sortedBoneData.length; i++) {\n          data = sortedBoneData[i];\n          bones.push(data.bone);\n          boneInverses.push(data.boneInverse);\n        }\n\n        return new Skeleton(bones, boneInverses);\n      }\n\n      function buildBoneHierarchy(root, joints, boneData) {\n        root.traverse(function (object) {\n          if (object.isBone === true) {\n            var boneInverse;\n\n            for (var i = 0; i < joints.length; i++) {\n              var joint = joints[i];\n\n              if (joint.name === object.name) {\n                boneInverse = joint.boneInverse;\n                break;\n              }\n            }\n\n            if (boneInverse === void 0) {\n              boneInverse = new Matrix4();\n            }\n\n            boneData.push({\n              bone: object,\n              boneInverse: boneInverse,\n              processed: false\n            });\n          }\n        });\n      }\n\n      function buildNode(data) {\n        var objects = [];\n        var matrix2 = data.matrix;\n        var nodes = data.nodes;\n        var type = data.type;\n        var instanceCameras = data.instanceCameras;\n        var instanceControllers = data.instanceControllers;\n        var instanceLights = data.instanceLights;\n        var instanceGeometries = data.instanceGeometries;\n        var instanceNodes = data.instanceNodes;\n\n        for (var i = 0, l = nodes.length; i < l; i++) {\n          objects.push(getNode(nodes[i]));\n        }\n\n        for (var _i3 = 0, _l2 = instanceCameras.length; _i3 < _l2; _i3++) {\n          var instanceCamera = getCamera(instanceCameras[_i3]);\n\n          if (instanceCamera !== null) {\n            objects.push(instanceCamera.clone());\n          }\n        }\n\n        for (var _i4 = 0, _l3 = instanceControllers.length; _i4 < _l3; _i4++) {\n          var instance = instanceControllers[_i4];\n          var controller = getController(instance.id);\n          var geometries = getGeometry(controller.id);\n          var newObjects = buildObjects(geometries, instance.materials);\n          var skeletons = instance.skeletons;\n          var joints = controller.skin.joints;\n          var skeleton = buildSkeleton(skeletons, joints);\n\n          for (var j = 0, jl = newObjects.length; j < jl; j++) {\n            var object2 = newObjects[j];\n\n            if (object2.isSkinnedMesh) {\n              object2.bind(skeleton, controller.skin.bindMatrix);\n              object2.normalizeSkinWeights();\n            }\n\n            objects.push(object2);\n          }\n        }\n\n        for (var _i5 = 0, _l4 = instanceLights.length; _i5 < _l4; _i5++) {\n          var instanceLight = getLight(instanceLights[_i5]);\n\n          if (instanceLight !== null) {\n            objects.push(instanceLight.clone());\n          }\n        }\n\n        for (var _i6 = 0, _l5 = instanceGeometries.length; _i6 < _l5; _i6++) {\n          var _instance = instanceGeometries[_i6];\n\n          var _geometries = getGeometry(_instance.id);\n\n          var _newObjects = buildObjects(_geometries, _instance.materials);\n\n          for (var _j = 0, _jl = _newObjects.length; _j < _jl; _j++) {\n            objects.push(_newObjects[_j]);\n          }\n        }\n\n        for (var _i7 = 0, _l6 = instanceNodes.length; _i7 < _l6; _i7++) {\n          objects.push(getNode(instanceNodes[_i7]).clone());\n        }\n\n        var object;\n\n        if (nodes.length === 0 && objects.length === 1) {\n          object = objects[0];\n        } else {\n          object = type === \"JOINT\" ? new Bone() : new Group();\n\n          for (var _i8 = 0; _i8 < objects.length; _i8++) {\n            object.add(objects[_i8]);\n          }\n        }\n\n        object.name = type === \"JOINT\" ? data.sid : data.name;\n        object.matrix.copy(matrix2);\n        object.matrix.decompose(object.position, object.quaternion, object.scale);\n        return object;\n      }\n\n      var fallbackMaterial = new MeshBasicMaterial({\n        color: 16711935\n      });\n\n      function resolveMaterialBinding(keys, instanceMaterials) {\n        var materials = [];\n\n        for (var i = 0, l = keys.length; i < l; i++) {\n          var id = instanceMaterials[keys[i]];\n\n          if (id === void 0) {\n            console.warn(\"THREE.ColladaLoader: Material with key %s not found. Apply fallback material.\", keys[i]);\n            materials.push(fallbackMaterial);\n          } else {\n            materials.push(getMaterial(id));\n          }\n        }\n\n        return materials;\n      }\n\n      function buildObjects(geometries, instanceMaterials) {\n        var objects = [];\n\n        for (var type in geometries) {\n          var geometry = geometries[type];\n          var materials = resolveMaterialBinding(geometry.materialKeys, instanceMaterials);\n\n          if (materials.length === 0) {\n            if (type === \"lines\" || type === \"linestrips\") {\n              materials.push(new LineBasicMaterial());\n            } else {\n              materials.push(new MeshPhongMaterial());\n            }\n          }\n\n          var skinning = geometry.data.attributes.skinIndex !== void 0;\n          var material = materials.length === 1 ? materials[0] : materials;\n          var object = void 0;\n\n          switch (type) {\n            case \"lines\":\n              object = new LineSegments(geometry.data, material);\n              break;\n\n            case \"linestrips\":\n              object = new Line(geometry.data, material);\n              break;\n\n            case \"triangles\":\n            case \"polylist\":\n              if (skinning) {\n                object = new SkinnedMesh(geometry.data, material);\n              } else {\n                object = new Mesh(geometry.data, material);\n              }\n\n              break;\n          }\n\n          objects.push(object);\n        }\n\n        return objects;\n      }\n\n      function hasNode(id) {\n        return library.nodes[id] !== void 0;\n      }\n\n      function getNode(id) {\n        return getBuild(library.nodes[id], buildNode);\n      }\n\n      function parseVisualScene(xml2) {\n        var data = {\n          name: xml2.getAttribute(\"name\"),\n          children: []\n        };\n        prepareNodes(xml2);\n        var elements = getElementsByTagName(xml2, \"node\");\n\n        for (var i = 0; i < elements.length; i++) {\n          data.children.push(parseNode(elements[i]));\n        }\n\n        library.visualScenes[xml2.getAttribute(\"id\")] = data;\n      }\n\n      function buildVisualScene(data) {\n        var group = new Group();\n        group.name = data.name;\n        var children = data.children;\n\n        for (var i = 0; i < children.length; i++) {\n          var child = children[i];\n          group.add(getNode(child.id));\n        }\n\n        return group;\n      }\n\n      function hasVisualScene(id) {\n        return library.visualScenes[id] !== void 0;\n      }\n\n      function getVisualScene(id) {\n        return getBuild(library.visualScenes[id], buildVisualScene);\n      }\n\n      function parseScene(xml2) {\n        var instance = getElementsByTagName(xml2, \"instance_visual_scene\")[0];\n        return getVisualScene(parseId(instance.getAttribute(\"url\")));\n      }\n\n      function setupAnimations() {\n        var clips = library.clips;\n\n        if (isEmpty(clips) === true) {\n          if (isEmpty(library.animations) === false) {\n            var tracks = [];\n\n            for (var id in library.animations) {\n              var animationTracks = getAnimation(id);\n\n              for (var i = 0, l = animationTracks.length; i < l; i++) {\n                tracks.push(animationTracks[i]);\n              }\n            }\n\n            animations.push(new AnimationClip(\"default\", -1, tracks));\n          }\n        } else {\n          for (var _id in clips) {\n            animations.push(getAnimationClip(_id));\n          }\n        }\n      }\n\n      function parserErrorToText(parserError2) {\n        var result = \"\";\n        var stack = [parserError2];\n\n        while (stack.length) {\n          var node = stack.shift();\n\n          if (node.nodeType === Node.TEXT_NODE) {\n            result += node.textContent;\n          } else {\n            result += \"\\n\";\n            stack.push.apply(stack, node.childNodes);\n          }\n        }\n\n        return result.trim();\n      }\n\n      if (text.length === 0) {\n        return {\n          scene: new Scene()\n        };\n      }\n\n      var xml = new DOMParser().parseFromString(text, \"application/xml\");\n      var collada = getElementsByTagName(xml, \"COLLADA\")[0];\n      var parserError = xml.getElementsByTagName(\"parsererror\")[0];\n\n      if (parserError !== void 0) {\n        var errorElement = getElementsByTagName(parserError, \"div\")[0];\n        var errorText;\n\n        if (errorElement) {\n          errorText = errorElement.textContent;\n        } else {\n          errorText = parserErrorToText(parserError);\n        }\n\n        console.error(\"THREE.ColladaLoader: Failed to parse collada file.\\n\", errorText);\n        return null;\n      }\n\n      var version = collada.getAttribute(\"version\");\n      console.log(\"THREE.ColladaLoader: File version\", version);\n      var asset = parseAsset(getElementsByTagName(collada, \"asset\")[0]);\n      var textureLoader = new TextureLoader(this.manager);\n      textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n      var tgaLoader;\n\n      if (TGALoader) {\n        tgaLoader = new TGALoader(this.manager);\n        tgaLoader.setPath(this.resourcePath || path);\n      }\n\n      var animations = [];\n      var kinematics = {};\n      var count = 0;\n      var library = {\n        animations: {},\n        clips: {},\n        controllers: {},\n        images: {},\n        effects: {},\n        materials: {},\n        cameras: {},\n        lights: {},\n        geometries: {},\n        nodes: {},\n        visualScenes: {},\n        kinematicsModels: {},\n        physicsModels: {},\n        kinematicsScenes: {}\n      };\n      parseLibrary(collada, \"library_animations\", \"animation\", parseAnimation);\n      parseLibrary(collada, \"library_animation_clips\", \"animation_clip\", parseAnimationClip);\n      parseLibrary(collada, \"library_controllers\", \"controller\", parseController);\n      parseLibrary(collada, \"library_images\", \"image\", parseImage);\n      parseLibrary(collada, \"library_effects\", \"effect\", parseEffect);\n      parseLibrary(collada, \"library_materials\", \"material\", parseMaterial);\n      parseLibrary(collada, \"library_cameras\", \"camera\", parseCamera);\n      parseLibrary(collada, \"library_lights\", \"light\", parseLight);\n      parseLibrary(collada, \"library_geometries\", \"geometry\", parseGeometry);\n      parseLibrary(collada, \"library_nodes\", \"node\", parseNode);\n      parseLibrary(collada, \"library_visual_scenes\", \"visual_scene\", parseVisualScene);\n      parseLibrary(collada, \"library_kinematics_models\", \"kinematics_model\", parseKinematicsModel);\n      parseLibrary(collada, \"library_physics_models\", \"physics_model\", parsePhysicsModel);\n      parseLibrary(collada, \"scene\", \"instance_kinematics_scene\", parseKinematicsScene);\n      buildLibrary(library.animations, buildAnimation);\n      buildLibrary(library.clips, buildAnimationClip);\n      buildLibrary(library.controllers, buildController);\n      buildLibrary(library.images, buildImage);\n      buildLibrary(library.effects, buildEffect);\n      buildLibrary(library.materials, buildMaterial);\n      buildLibrary(library.cameras, buildCamera);\n      buildLibrary(library.lights, buildLight);\n      buildLibrary(library.geometries, buildGeometry);\n      buildLibrary(library.visualScenes, buildVisualScene);\n      setupAnimations();\n      setupKinematics();\n      var scene = parseScene(getElementsByTagName(collada, \"scene\")[0]);\n      scene.animations = animations;\n\n      if (asset.upAxis === \"Z_UP\") {\n        scene.quaternion.setFromEuler(new Euler(-Math.PI / 2, 0, 0));\n      }\n\n      scene.scale.multiplyScalar(asset.unit);\n      return {\n        get animations() {\n          console.warn(\"THREE.ColladaLoader: Please access animations over scene.animations now.\");\n          return animations;\n        },\n\n        kinematics: kinematics,\n        library: library,\n        scene: scene\n      };\n    }\n  }]);\n\n  return ColladaLoader;\n}(Loader);\n\nexport { ColladaLoader };","map":{"version":3,"sources":["/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/three-stdlib/loaders/ColladaLoader.js"],"names":["Loader","LoaderUtils","FileLoader","MathUtils","Vector3","Quaternion","VectorKeyframeTrack","QuaternionKeyframeTrack","AnimationClip","Matrix4","MeshBasicMaterial","MeshLambertMaterial","MeshPhongMaterial","RepeatWrapping","ClampToEdgeWrapping","Vector2","DoubleSide","FrontSide","PerspectiveCamera","OrthographicCamera","Color","AmbientLight","SpotLight","PointLight","DirectionalLight","BufferGeometry","Float32BufferAttribute","Skeleton","Bone","Group","LineBasicMaterial","SkinnedMesh","Mesh","Line","LineSegments","Scene","TextureLoader","Euler","TGALoader","ColladaLoader","manager","url","onLoad","onProgress","onError","scope","path","extractUrlBase","loader","setPath","setRequestHeader","requestHeader","setWithCredentials","withCredentials","load","text","parse","e","console","error","itemError","getElementsByTagName","xml2","name","array","childNodes","i","l","length","child","nodeName","push","parseStrings","text2","parts","trim","split","Array","parseFloats","parseFloat","parseInts","parseInt","parseId","substring","generateId","count","isEmpty","object","Object","keys","parseAsset","unit","parseAssetUnit","upAxis","parseAssetUpAxis","hasAttribute","getAttribute","textContent","parseLibrary","libraryName","parser","library2","elements","buildLibrary","data","builder","build","getBuild","parseAnimation","sources","samplers","channels","hasChildren","nodeType","id","parseSource","parseAnimationSampler","parseAnimationChannel","log","library","animations","generateUUID","inputs","semantic","target","shift","sid","arraySyntax","indexOf","memberSyntax","member","indices","replace","sampler","buildAnimation","tracks","hasOwnProperty","channel","inputId","INPUT","outputId","OUTPUT","inputSource","outputSource","animation","buildAnimationChannel","createKeyframeTracks","getAnimation","node","nodes","object3D","getNode","transform","transforms","defaultMatrix","matrix","clone","transpose","time","stride","il","j","jl","value","index","warn","keyframes","prepareAnimationData","uuid","sort","ascending","transformAnimationData","a","b","position","scale","quaternion","times","positionData","quaternionData","scaleData","keyframe","fromArray","decompose","x","y","z","w","property","defaultValue","empty","createMissingKeyframes","prev","next","getPrev","getNext","interpolate","key","parseAnimationClip","start","end","clips","buildAnimationClip","duration","animations2","animationTracks","getAnimationClip","parseController","skin","parseSkin","controllers","bindShapeMatrix","joints","parseJoints","vertexWeights","parseVertexWeights","offset","vcount","v","buildController","geometry","geometries","buildSkin","skinIndices","skinWeights","weights","BONE_LIMIT","jointOffset","JOINT","weightOffset","WEIGHT","jointSource","inverseSource","INV_BIND_MATRIX","jointCount","vertexSkinData","skinIndex","weightId","skinWeight","weight","descending","d","bindMatrix","identity","boneInverse","getController","parseImage","init_from","images","buildImage","getImage","parseEffect","profile","parseEffectProfileCOMMON","effects","surfaces","parseEffectNewparam","technique","parseEffectTechnique","extra","parseEffectExtra","parseEffectSurface","parseEffectSampler","source","type","parameters","parseEffectParameters","parseEffectParameter","opaque","parseEffectParameterTexture","parseEffectParameterTextureExtra","parseEffectParameterTextureExtraTechnique","toUpperCase","parseEffectExtraTechniqueBump","parseEffectExtraTechnique","texcoord","buildEffect","getEffect","parseMaterial","materials","getTextureLoader","image","extension","slice","lastIndexOf","toLowerCase","tgaLoader","textureLoader","buildMaterial","effect","material","getTexture","textureObject","surface","texture","technique2","wrapS","wrapU","wrapT","wrapV","set","offsetU","offsetV","repeat","repeatU","repeatV","parameter","color","map","specular","specularMap","normalMap","lightMap","float","shininess","emissive","emissiveMap","transparent","transparency","opacity","techniques","k","side","normalScale","getMaterial","parseCamera","optics","parseCameraOptics","cameras","parseCameraTechnique","parseCameraParameters","buildCamera","camera","yfov","aspect_ratio","znear","zfar","ymag","xmag","aspectRatio","getCamera","parseLight","parseLightTechnique","lights","parseLightParameters","falloffAngle","f","distance","Math","sqrt","buildLight","light","copy","getLight","parseGeometry","vertices","primitives","mesh","parseGeometryVertices","parseGeometryPrimitive","accessor","primitive","hasUV","inputname","max","p","groupPrimitives","checkUVCoordinates","count2","uvsNeedsFix","buildGeometry","groupedPrimitives","primitiveType","buildGeometryType","position2","normal","uv","uv2","materialKeys","g","vc","addGroup","input","prevLength","buildGeometryData","count3","setAttribute","pushVector","sourceStride","sourceArray","c","kl","getGeometry","parseKinematicsModel","links","parseKinematicsTechniqueCommon","kinematicsModels","buildKinematicsModel","getKinematicsModel","parseKinematicsJoint","parseKinematicsLink","parseKinematicsJointParameter","axis","limits","min","static","zeroPosition","middlePosition","attachments","parseKinematicsAttachment","parseKinematicsTransform","joint","pop","obj","angle","degToRad","parsePhysicsModel","rigidBodies","parsePhysicsRigidBody","physicsModels","parsePhysicsTechniqueCommon","inertia","mass","parseKinematicsScene","bindJointAxis","parseKinematicsBindJointAxis","kinematicsScenes","param","tmpJointIndex","jointIndex","substr","buildKinematicsScene","getKinematicsScene","setupKinematics","kinematicsModelId","kinematicsSceneId","visualSceneId","visualScenes","kinematicsModel","kinematicsScene","visualScene","getVisualScene","jointMap","targetElement","collada","querySelector","parentVisualElement","parentElement","connect","visualElement","visualElementName","traverse","buildTransformList","m0","kinematics","getJointValue","jointData","setJointValue","multiply","makeRotationAxis","makeTranslation","vector2","matrix2","prepareNodes","element","vector","parseNode","instanceCameras","instanceControllers","instanceLights","instanceGeometries","instanceNodes","parseNodeInstance","hasNode","skeletons","instances","instance","symbol","buildSkeleton","boneData","sortedBoneData","skeleton","root","buildBoneHierarchy","hasVisualScene","children","j2","root2","bone","processed","bones","boneInverses","isBone","buildNode","objects","instanceCamera","controller","newObjects","buildObjects","object2","isSkinnedMesh","bind","normalizeSkinWeights","instanceLight","add","fallbackMaterial","resolveMaterialBinding","instanceMaterials","skinning","attributes","parseVisualScene","buildVisualScene","group","parseScene","setupAnimations","parserErrorToText","parserError2","result","stack","Node","TEXT_NODE","apply","scene","xml","DOMParser","parseFromString","parserError","errorElement","errorText","version","asset","resourcePath","setCrossOrigin","crossOrigin","setFromEuler","PI","multiplyScalar"],"mappings":"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","sourcesContent":["import { Loader, LoaderUtils, FileLoader, MathUtils, Vector3, Quaternion, VectorKeyframeTrack, QuaternionKeyframeTrack, AnimationClip, Matrix4, MeshBasicMaterial, MeshLambertMaterial, MeshPhongMaterial, RepeatWrapping, ClampToEdgeWrapping, Vector2, DoubleSide, FrontSide, PerspectiveCamera, OrthographicCamera, Color, AmbientLight, SpotLight, PointLight, DirectionalLight, BufferGeometry, Float32BufferAttribute, Skeleton, Bone, Group, LineBasicMaterial, SkinnedMesh, Mesh, Line, LineSegments, Scene, TextureLoader, Euler } from \"three\";\nimport { TGALoader } from \"./TGALoader.js\";\nclass ColladaLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const path = scope.path === \"\" ? LoaderUtils.extractUrlBase(url) : scope.path;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(\n      url,\n      function(text) {\n        try {\n          onLoad(scope.parse(text, path));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n          scope.manager.itemError(url);\n        }\n      },\n      onProgress,\n      onError\n    );\n  }\n  parse(text, path) {\n    function getElementsByTagName(xml2, name) {\n      const array = [];\n      const childNodes = xml2.childNodes;\n      for (let i = 0, l = childNodes.length; i < l; i++) {\n        const child = childNodes[i];\n        if (child.nodeName === name) {\n          array.push(child);\n        }\n      }\n      return array;\n    }\n    function parseStrings(text2) {\n      if (text2.length === 0)\n        return [];\n      const parts = text2.trim().split(/\\s+/);\n      const array = new Array(parts.length);\n      for (let i = 0, l = parts.length; i < l; i++) {\n        array[i] = parts[i];\n      }\n      return array;\n    }\n    function parseFloats(text2) {\n      if (text2.length === 0)\n        return [];\n      const parts = text2.trim().split(/\\s+/);\n      const array = new Array(parts.length);\n      for (let i = 0, l = parts.length; i < l; i++) {\n        array[i] = parseFloat(parts[i]);\n      }\n      return array;\n    }\n    function parseInts(text2) {\n      if (text2.length === 0)\n        return [];\n      const parts = text2.trim().split(/\\s+/);\n      const array = new Array(parts.length);\n      for (let i = 0, l = parts.length; i < l; i++) {\n        array[i] = parseInt(parts[i]);\n      }\n      return array;\n    }\n    function parseId(text2) {\n      return text2.substring(1);\n    }\n    function generateId() {\n      return \"three_default_\" + count++;\n    }\n    function isEmpty(object) {\n      return Object.keys(object).length === 0;\n    }\n    function parseAsset(xml2) {\n      return {\n        unit: parseAssetUnit(getElementsByTagName(xml2, \"unit\")[0]),\n        upAxis: parseAssetUpAxis(getElementsByTagName(xml2, \"up_axis\")[0])\n      };\n    }\n    function parseAssetUnit(xml2) {\n      if (xml2 !== void 0 && xml2.hasAttribute(\"meter\") === true) {\n        return parseFloat(xml2.getAttribute(\"meter\"));\n      } else {\n        return 1;\n      }\n    }\n    function parseAssetUpAxis(xml2) {\n      return xml2 !== void 0 ? xml2.textContent : \"Y_UP\";\n    }\n    function parseLibrary(xml2, libraryName, nodeName, parser) {\n      const library2 = getElementsByTagName(xml2, libraryName)[0];\n      if (library2 !== void 0) {\n        const elements = getElementsByTagName(library2, nodeName);\n        for (let i = 0; i < elements.length; i++) {\n          parser(elements[i]);\n        }\n      }\n    }\n    function buildLibrary(data, builder) {\n      for (const name in data) {\n        const object = data[name];\n        object.build = builder(data[name]);\n      }\n    }\n    function getBuild(data, builder) {\n      if (data.build !== void 0)\n        return data.build;\n      data.build = builder(data);\n      return data.build;\n    }\n    function parseAnimation(xml2) {\n      const data = {\n        sources: {},\n        samplers: {},\n        channels: {}\n      };\n      let hasChildren = false;\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        let id;\n        switch (child.nodeName) {\n          case \"source\":\n            id = child.getAttribute(\"id\");\n            data.sources[id] = parseSource(child);\n            break;\n          case \"sampler\":\n            id = child.getAttribute(\"id\");\n            data.samplers[id] = parseAnimationSampler(child);\n            break;\n          case \"channel\":\n            id = child.getAttribute(\"target\");\n            data.channels[id] = parseAnimationChannel(child);\n            break;\n          case \"animation\":\n            parseAnimation(child);\n            hasChildren = true;\n            break;\n          default:\n            console.log(child);\n        }\n      }\n      if (hasChildren === false) {\n        library.animations[xml2.getAttribute(\"id\") || MathUtils.generateUUID()] = data;\n      }\n    }\n    function parseAnimationSampler(xml2) {\n      const data = {\n        inputs: {}\n      };\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"input\":\n            const id = parseId(child.getAttribute(\"source\"));\n            const semantic = child.getAttribute(\"semantic\");\n            data.inputs[semantic] = id;\n            break;\n        }\n      }\n      return data;\n    }\n    function parseAnimationChannel(xml2) {\n      const data = {};\n      const target = xml2.getAttribute(\"target\");\n      let parts = target.split(\"/\");\n      const id = parts.shift();\n      let sid = parts.shift();\n      const arraySyntax = sid.indexOf(\"(\") !== -1;\n      const memberSyntax = sid.indexOf(\".\") !== -1;\n      if (memberSyntax) {\n        parts = sid.split(\".\");\n        sid = parts.shift();\n        data.member = parts.shift();\n      } else if (arraySyntax) {\n        const indices = sid.split(\"(\");\n        sid = indices.shift();\n        for (let i = 0; i < indices.length; i++) {\n          indices[i] = parseInt(indices[i].replace(/\\)/, \"\"));\n        }\n        data.indices = indices;\n      }\n      data.id = id;\n      data.sid = sid;\n      data.arraySyntax = arraySyntax;\n      data.memberSyntax = memberSyntax;\n      data.sampler = parseId(xml2.getAttribute(\"source\"));\n      return data;\n    }\n    function buildAnimation(data) {\n      const tracks = [];\n      const channels = data.channels;\n      const samplers = data.samplers;\n      const sources = data.sources;\n      for (const target in channels) {\n        if (channels.hasOwnProperty(target)) {\n          const channel = channels[target];\n          const sampler = samplers[channel.sampler];\n          const inputId = sampler.inputs.INPUT;\n          const outputId = sampler.inputs.OUTPUT;\n          const inputSource = sources[inputId];\n          const outputSource = sources[outputId];\n          const animation = buildAnimationChannel(channel, inputSource, outputSource);\n          createKeyframeTracks(animation, tracks);\n        }\n      }\n      return tracks;\n    }\n    function getAnimation(id) {\n      return getBuild(library.animations[id], buildAnimation);\n    }\n    function buildAnimationChannel(channel, inputSource, outputSource) {\n      const node = library.nodes[channel.id];\n      const object3D = getNode(node.id);\n      const transform = node.transforms[channel.sid];\n      const defaultMatrix = node.matrix.clone().transpose();\n      let time, stride;\n      let i, il, j, jl;\n      const data = {};\n      switch (transform) {\n        case \"matrix\":\n          for (i = 0, il = inputSource.array.length; i < il; i++) {\n            time = inputSource.array[i];\n            stride = i * outputSource.stride;\n            if (data[time] === void 0)\n              data[time] = {};\n            if (channel.arraySyntax === true) {\n              const value = outputSource.array[stride];\n              const index = channel.indices[0] + 4 * channel.indices[1];\n              data[time][index] = value;\n            } else {\n              for (j = 0, jl = outputSource.stride; j < jl; j++) {\n                data[time][j] = outputSource.array[stride + j];\n              }\n            }\n          }\n          break;\n        case \"translate\":\n          console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n          break;\n        case \"rotate\":\n          console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n          break;\n        case \"scale\":\n          console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n          break;\n      }\n      const keyframes = prepareAnimationData(data, defaultMatrix);\n      const animation = {\n        name: object3D.uuid,\n        keyframes\n      };\n      return animation;\n    }\n    function prepareAnimationData(data, defaultMatrix) {\n      const keyframes = [];\n      for (const time in data) {\n        keyframes.push({ time: parseFloat(time), value: data[time] });\n      }\n      keyframes.sort(ascending);\n      for (let i = 0; i < 16; i++) {\n        transformAnimationData(keyframes, i, defaultMatrix.elements[i]);\n      }\n      return keyframes;\n      function ascending(a, b) {\n        return a.time - b.time;\n      }\n    }\n    const position = new Vector3();\n    const scale = new Vector3();\n    const quaternion = new Quaternion();\n    function createKeyframeTracks(animation, tracks) {\n      const keyframes = animation.keyframes;\n      const name = animation.name;\n      const times = [];\n      const positionData = [];\n      const quaternionData = [];\n      const scaleData = [];\n      for (let i = 0, l = keyframes.length; i < l; i++) {\n        const keyframe = keyframes[i];\n        const time = keyframe.time;\n        const value = keyframe.value;\n        matrix.fromArray(value).transpose();\n        matrix.decompose(position, quaternion, scale);\n        times.push(time);\n        positionData.push(position.x, position.y, position.z);\n        quaternionData.push(quaternion.x, quaternion.y, quaternion.z, quaternion.w);\n        scaleData.push(scale.x, scale.y, scale.z);\n      }\n      if (positionData.length > 0)\n        tracks.push(new VectorKeyframeTrack(name + \".position\", times, positionData));\n      if (quaternionData.length > 0) {\n        tracks.push(new QuaternionKeyframeTrack(name + \".quaternion\", times, quaternionData));\n      }\n      if (scaleData.length > 0)\n        tracks.push(new VectorKeyframeTrack(name + \".scale\", times, scaleData));\n      return tracks;\n    }\n    function transformAnimationData(keyframes, property, defaultValue) {\n      let keyframe;\n      let empty = true;\n      let i, l;\n      for (i = 0, l = keyframes.length; i < l; i++) {\n        keyframe = keyframes[i];\n        if (keyframe.value[property] === void 0) {\n          keyframe.value[property] = null;\n        } else {\n          empty = false;\n        }\n      }\n      if (empty === true) {\n        for (i = 0, l = keyframes.length; i < l; i++) {\n          keyframe = keyframes[i];\n          keyframe.value[property] = defaultValue;\n        }\n      } else {\n        createMissingKeyframes(keyframes, property);\n      }\n    }\n    function createMissingKeyframes(keyframes, property) {\n      let prev, next;\n      for (let i = 0, l = keyframes.length; i < l; i++) {\n        const keyframe = keyframes[i];\n        if (keyframe.value[property] === null) {\n          prev = getPrev(keyframes, i, property);\n          next = getNext(keyframes, i, property);\n          if (prev === null) {\n            keyframe.value[property] = next.value[property];\n            continue;\n          }\n          if (next === null) {\n            keyframe.value[property] = prev.value[property];\n            continue;\n          }\n          interpolate(keyframe, prev, next, property);\n        }\n      }\n    }\n    function getPrev(keyframes, i, property) {\n      while (i >= 0) {\n        const keyframe = keyframes[i];\n        if (keyframe.value[property] !== null)\n          return keyframe;\n        i--;\n      }\n      return null;\n    }\n    function getNext(keyframes, i, property) {\n      while (i < keyframes.length) {\n        const keyframe = keyframes[i];\n        if (keyframe.value[property] !== null)\n          return keyframe;\n        i++;\n      }\n      return null;\n    }\n    function interpolate(key, prev, next, property) {\n      if (next.time - prev.time === 0) {\n        key.value[property] = prev.value[property];\n        return;\n      }\n      key.value[property] = (key.time - prev.time) * (next.value[property] - prev.value[property]) / (next.time - prev.time) + prev.value[property];\n    }\n    function parseAnimationClip(xml2) {\n      const data = {\n        name: xml2.getAttribute(\"id\") || \"default\",\n        start: parseFloat(xml2.getAttribute(\"start\") || 0),\n        end: parseFloat(xml2.getAttribute(\"end\") || 0),\n        animations: []\n      };\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"instance_animation\":\n            data.animations.push(parseId(child.getAttribute(\"url\")));\n            break;\n        }\n      }\n      library.clips[xml2.getAttribute(\"id\")] = data;\n    }\n    function buildAnimationClip(data) {\n      const tracks = [];\n      const name = data.name;\n      const duration = data.end - data.start || -1;\n      const animations2 = data.animations;\n      for (let i = 0, il = animations2.length; i < il; i++) {\n        const animationTracks = getAnimation(animations2[i]);\n        for (let j = 0, jl = animationTracks.length; j < jl; j++) {\n          tracks.push(animationTracks[j]);\n        }\n      }\n      return new AnimationClip(name, duration, tracks);\n    }\n    function getAnimationClip(id) {\n      return getBuild(library.clips[id], buildAnimationClip);\n    }\n    function parseController(xml2) {\n      const data = {};\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"skin\":\n            data.id = parseId(child.getAttribute(\"source\"));\n            data.skin = parseSkin(child);\n            break;\n          case \"morph\":\n            data.id = parseId(child.getAttribute(\"source\"));\n            console.warn(\"THREE.ColladaLoader: Morph target animation not supported yet.\");\n            break;\n        }\n      }\n      library.controllers[xml2.getAttribute(\"id\")] = data;\n    }\n    function parseSkin(xml2) {\n      const data = {\n        sources: {}\n      };\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"bind_shape_matrix\":\n            data.bindShapeMatrix = parseFloats(child.textContent);\n            break;\n          case \"source\":\n            const id = child.getAttribute(\"id\");\n            data.sources[id] = parseSource(child);\n            break;\n          case \"joints\":\n            data.joints = parseJoints(child);\n            break;\n          case \"vertex_weights\":\n            data.vertexWeights = parseVertexWeights(child);\n            break;\n        }\n      }\n      return data;\n    }\n    function parseJoints(xml2) {\n      const data = {\n        inputs: {}\n      };\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"input\":\n            const semantic = child.getAttribute(\"semantic\");\n            const id = parseId(child.getAttribute(\"source\"));\n            data.inputs[semantic] = id;\n            break;\n        }\n      }\n      return data;\n    }\n    function parseVertexWeights(xml2) {\n      const data = {\n        inputs: {}\n      };\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"input\":\n            const semantic = child.getAttribute(\"semantic\");\n            const id = parseId(child.getAttribute(\"source\"));\n            const offset = parseInt(child.getAttribute(\"offset\"));\n            data.inputs[semantic] = { id, offset };\n            break;\n          case \"vcount\":\n            data.vcount = parseInts(child.textContent);\n            break;\n          case \"v\":\n            data.v = parseInts(child.textContent);\n            break;\n        }\n      }\n      return data;\n    }\n    function buildController(data) {\n      const build = {\n        id: data.id\n      };\n      const geometry = library.geometries[build.id];\n      if (data.skin !== void 0) {\n        build.skin = buildSkin(data.skin);\n        geometry.sources.skinIndices = build.skin.indices;\n        geometry.sources.skinWeights = build.skin.weights;\n      }\n      return build;\n    }\n    function buildSkin(data) {\n      const BONE_LIMIT = 4;\n      const build = {\n        joints: [],\n        // this must be an array to preserve the joint order\n        indices: {\n          array: [],\n          stride: BONE_LIMIT\n        },\n        weights: {\n          array: [],\n          stride: BONE_LIMIT\n        }\n      };\n      const sources = data.sources;\n      const vertexWeights = data.vertexWeights;\n      const vcount = vertexWeights.vcount;\n      const v = vertexWeights.v;\n      const jointOffset = vertexWeights.inputs.JOINT.offset;\n      const weightOffset = vertexWeights.inputs.WEIGHT.offset;\n      const jointSource = data.sources[data.joints.inputs.JOINT];\n      const inverseSource = data.sources[data.joints.inputs.INV_BIND_MATRIX];\n      const weights = sources[vertexWeights.inputs.WEIGHT.id].array;\n      let stride = 0;\n      let i, j, l;\n      for (i = 0, l = vcount.length; i < l; i++) {\n        const jointCount = vcount[i];\n        const vertexSkinData = [];\n        for (j = 0; j < jointCount; j++) {\n          const skinIndex = v[stride + jointOffset];\n          const weightId = v[stride + weightOffset];\n          const skinWeight = weights[weightId];\n          vertexSkinData.push({ index: skinIndex, weight: skinWeight });\n          stride += 2;\n        }\n        vertexSkinData.sort(descending);\n        for (j = 0; j < BONE_LIMIT; j++) {\n          const d = vertexSkinData[j];\n          if (d !== void 0) {\n            build.indices.array.push(d.index);\n            build.weights.array.push(d.weight);\n          } else {\n            build.indices.array.push(0);\n            build.weights.array.push(0);\n          }\n        }\n      }\n      if (data.bindShapeMatrix) {\n        build.bindMatrix = new Matrix4().fromArray(data.bindShapeMatrix).transpose();\n      } else {\n        build.bindMatrix = new Matrix4().identity();\n      }\n      for (i = 0, l = jointSource.array.length; i < l; i++) {\n        const name = jointSource.array[i];\n        const boneInverse = new Matrix4().fromArray(inverseSource.array, i * inverseSource.stride).transpose();\n        build.joints.push({ name, boneInverse });\n      }\n      return build;\n      function descending(a, b) {\n        return b.weight - a.weight;\n      }\n    }\n    function getController(id) {\n      return getBuild(library.controllers[id], buildController);\n    }\n    function parseImage(xml2) {\n      const data = {\n        init_from: getElementsByTagName(xml2, \"init_from\")[0].textContent\n      };\n      library.images[xml2.getAttribute(\"id\")] = data;\n    }\n    function buildImage(data) {\n      if (data.build !== void 0)\n        return data.build;\n      return data.init_from;\n    }\n    function getImage(id) {\n      const data = library.images[id];\n      if (data !== void 0) {\n        return getBuild(data, buildImage);\n      }\n      console.warn(\"THREE.ColladaLoader: Couldn't find image with ID:\", id);\n      return null;\n    }\n    function parseEffect(xml2) {\n      const data = {};\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"profile_COMMON\":\n            data.profile = parseEffectProfileCOMMON(child);\n            break;\n        }\n      }\n      library.effects[xml2.getAttribute(\"id\")] = data;\n    }\n    function parseEffectProfileCOMMON(xml2) {\n      const data = {\n        surfaces: {},\n        samplers: {}\n      };\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"newparam\":\n            parseEffectNewparam(child, data);\n            break;\n          case \"technique\":\n            data.technique = parseEffectTechnique(child);\n            break;\n          case \"extra\":\n            data.extra = parseEffectExtra(child);\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectNewparam(xml2, data) {\n      const sid = xml2.getAttribute(\"sid\");\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"surface\":\n            data.surfaces[sid] = parseEffectSurface(child);\n            break;\n          case \"sampler2D\":\n            data.samplers[sid] = parseEffectSampler(child);\n            break;\n        }\n      }\n    }\n    function parseEffectSurface(xml2) {\n      const data = {};\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"init_from\":\n            data.init_from = child.textContent;\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectSampler(xml2) {\n      const data = {};\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"source\":\n            data.source = child.textContent;\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectTechnique(xml2) {\n      const data = {};\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"constant\":\n          case \"lambert\":\n          case \"blinn\":\n          case \"phong\":\n            data.type = child.nodeName;\n            data.parameters = parseEffectParameters(child);\n            break;\n          case \"extra\":\n            data.extra = parseEffectExtra(child);\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectParameters(xml2) {\n      const data = {};\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"emission\":\n          case \"diffuse\":\n          case \"specular\":\n          case \"bump\":\n          case \"ambient\":\n          case \"shininess\":\n          case \"transparency\":\n            data[child.nodeName] = parseEffectParameter(child);\n            break;\n          case \"transparent\":\n            data[child.nodeName] = {\n              opaque: child.hasAttribute(\"opaque\") ? child.getAttribute(\"opaque\") : \"A_ONE\",\n              data: parseEffectParameter(child)\n            };\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectParameter(xml2) {\n      const data = {};\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"color\":\n            data[child.nodeName] = parseFloats(child.textContent);\n            break;\n          case \"float\":\n            data[child.nodeName] = parseFloat(child.textContent);\n            break;\n          case \"texture\":\n            data[child.nodeName] = { id: child.getAttribute(\"texture\"), extra: parseEffectParameterTexture(child) };\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectParameterTexture(xml2) {\n      const data = {\n        technique: {}\n      };\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"extra\":\n            parseEffectParameterTextureExtra(child, data);\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectParameterTextureExtra(xml2, data) {\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"technique\":\n            parseEffectParameterTextureExtraTechnique(child, data);\n            break;\n        }\n      }\n    }\n    function parseEffectParameterTextureExtraTechnique(xml2, data) {\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"repeatU\":\n          case \"repeatV\":\n          case \"offsetU\":\n          case \"offsetV\":\n            data.technique[child.nodeName] = parseFloat(child.textContent);\n            break;\n          case \"wrapU\":\n          case \"wrapV\":\n            if (child.textContent.toUpperCase() === \"TRUE\") {\n              data.technique[child.nodeName] = 1;\n            } else if (child.textContent.toUpperCase() === \"FALSE\") {\n              data.technique[child.nodeName] = 0;\n            } else {\n              data.technique[child.nodeName] = parseInt(child.textContent);\n            }\n            break;\n          case \"bump\":\n            data[child.nodeName] = parseEffectExtraTechniqueBump(child);\n            break;\n        }\n      }\n    }\n    function parseEffectExtra(xml2) {\n      const data = {};\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"technique\":\n            data.technique = parseEffectExtraTechnique(child);\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectExtraTechnique(xml2) {\n      const data = {};\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"double_sided\":\n            data[child.nodeName] = parseInt(child.textContent);\n            break;\n          case \"bump\":\n            data[child.nodeName] = parseEffectExtraTechniqueBump(child);\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectExtraTechniqueBump(xml2) {\n      var data = {};\n      for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n        var child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"texture\":\n            data[child.nodeName] = {\n              id: child.getAttribute(\"texture\"),\n              texcoord: child.getAttribute(\"texcoord\"),\n              extra: parseEffectParameterTexture(child)\n            };\n            break;\n        }\n      }\n      return data;\n    }\n    function buildEffect(data) {\n      return data;\n    }\n    function getEffect(id) {\n      return getBuild(library.effects[id], buildEffect);\n    }\n    function parseMaterial(xml2) {\n      const data = {\n        name: xml2.getAttribute(\"name\")\n      };\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"instance_effect\":\n            data.url = parseId(child.getAttribute(\"url\"));\n            break;\n        }\n      }\n      library.materials[xml2.getAttribute(\"id\")] = data;\n    }\n    function getTextureLoader(image) {\n      let loader;\n      let extension = image.slice((image.lastIndexOf(\".\") - 1 >>> 0) + 2);\n      extension = extension.toLowerCase();\n      switch (extension) {\n        case \"tga\":\n          loader = tgaLoader;\n          break;\n        default:\n          loader = textureLoader;\n      }\n      return loader;\n    }\n    function buildMaterial(data) {\n      const effect = getEffect(data.url);\n      const technique = effect.profile.technique;\n      let material;\n      switch (technique.type) {\n        case \"phong\":\n        case \"blinn\":\n          material = new MeshPhongMaterial();\n          break;\n        case \"lambert\":\n          material = new MeshLambertMaterial();\n          break;\n        default:\n          material = new MeshBasicMaterial();\n          break;\n      }\n      material.name = data.name || \"\";\n      function getTexture(textureObject) {\n        const sampler = effect.profile.samplers[textureObject.id];\n        let image = null;\n        if (sampler !== void 0) {\n          const surface = effect.profile.surfaces[sampler.source];\n          image = getImage(surface.init_from);\n        } else {\n          console.warn(\"THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530).\");\n          image = getImage(textureObject.id);\n        }\n        if (image !== null) {\n          const loader = getTextureLoader(image);\n          if (loader !== void 0) {\n            const texture = loader.load(image);\n            const extra = textureObject.extra;\n            if (extra !== void 0 && extra.technique !== void 0 && isEmpty(extra.technique) === false) {\n              const technique2 = extra.technique;\n              texture.wrapS = technique2.wrapU ? RepeatWrapping : ClampToEdgeWrapping;\n              texture.wrapT = technique2.wrapV ? RepeatWrapping : ClampToEdgeWrapping;\n              texture.offset.set(technique2.offsetU || 0, technique2.offsetV || 0);\n              texture.repeat.set(technique2.repeatU || 1, technique2.repeatV || 1);\n            } else {\n              texture.wrapS = RepeatWrapping;\n              texture.wrapT = RepeatWrapping;\n            }\n            return texture;\n          } else {\n            console.warn(\"THREE.ColladaLoader: Loader for texture %s not found.\", image);\n            return null;\n          }\n        } else {\n          console.warn(\"THREE.ColladaLoader: Couldn't create texture with ID:\", textureObject.id);\n          return null;\n        }\n      }\n      const parameters = technique.parameters;\n      for (const key in parameters) {\n        const parameter = parameters[key];\n        switch (key) {\n          case \"diffuse\":\n            if (parameter.color)\n              material.color.fromArray(parameter.color);\n            if (parameter.texture)\n              material.map = getTexture(parameter.texture);\n            break;\n          case \"specular\":\n            if (parameter.color && material.specular)\n              material.specular.fromArray(parameter.color);\n            if (parameter.texture)\n              material.specularMap = getTexture(parameter.texture);\n            break;\n          case \"bump\":\n            if (parameter.texture)\n              material.normalMap = getTexture(parameter.texture);\n            break;\n          case \"ambient\":\n            if (parameter.texture)\n              material.lightMap = getTexture(parameter.texture);\n            break;\n          case \"shininess\":\n            if (parameter.float && material.shininess)\n              material.shininess = parameter.float;\n            break;\n          case \"emission\":\n            if (parameter.color && material.emissive)\n              material.emissive.fromArray(parameter.color);\n            if (parameter.texture)\n              material.emissiveMap = getTexture(parameter.texture);\n            break;\n        }\n      }\n      let transparent = parameters[\"transparent\"];\n      let transparency = parameters[\"transparency\"];\n      if (transparency === void 0 && transparent) {\n        transparency = {\n          float: 1\n        };\n      }\n      if (transparent === void 0 && transparency) {\n        transparent = {\n          opaque: \"A_ONE\",\n          data: {\n            color: [1, 1, 1, 1]\n          }\n        };\n      }\n      if (transparent && transparency) {\n        if (transparent.data.texture) {\n          material.transparent = true;\n        } else {\n          const color = transparent.data.color;\n          switch (transparent.opaque) {\n            case \"A_ONE\":\n              material.opacity = color[3] * transparency.float;\n              break;\n            case \"RGB_ZERO\":\n              material.opacity = 1 - color[0] * transparency.float;\n              break;\n            case \"A_ZERO\":\n              material.opacity = 1 - color[3] * transparency.float;\n              break;\n            case \"RGB_ONE\":\n              material.opacity = color[0] * transparency.float;\n              break;\n            default:\n              console.warn('THREE.ColladaLoader: Invalid opaque type \"%s\" of transparent tag.', transparent.opaque);\n          }\n          if (material.opacity < 1)\n            material.transparent = true;\n        }\n      }\n      if (technique.extra !== void 0 && technique.extra.technique !== void 0) {\n        const techniques = technique.extra.technique;\n        for (const k in techniques) {\n          const v = techniques[k];\n          switch (k) {\n            case \"double_sided\":\n              material.side = v === 1 ? DoubleSide : FrontSide;\n              break;\n            case \"bump\":\n              material.normalMap = getTexture(v.texture);\n              material.normalScale = new Vector2(1, 1);\n              break;\n          }\n        }\n      }\n      return material;\n    }\n    function getMaterial(id) {\n      return getBuild(library.materials[id], buildMaterial);\n    }\n    function parseCamera(xml2) {\n      const data = {\n        name: xml2.getAttribute(\"name\")\n      };\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"optics\":\n            data.optics = parseCameraOptics(child);\n            break;\n        }\n      }\n      library.cameras[xml2.getAttribute(\"id\")] = data;\n    }\n    function parseCameraOptics(xml2) {\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        switch (child.nodeName) {\n          case \"technique_common\":\n            return parseCameraTechnique(child);\n        }\n      }\n      return {};\n    }\n    function parseCameraTechnique(xml2) {\n      const data = {};\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        switch (child.nodeName) {\n          case \"perspective\":\n          case \"orthographic\":\n            data.technique = child.nodeName;\n            data.parameters = parseCameraParameters(child);\n            break;\n        }\n      }\n      return data;\n    }\n    function parseCameraParameters(xml2) {\n      const data = {};\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        switch (child.nodeName) {\n          case \"xfov\":\n          case \"yfov\":\n          case \"xmag\":\n          case \"ymag\":\n          case \"znear\":\n          case \"zfar\":\n          case \"aspect_ratio\":\n            data[child.nodeName] = parseFloat(child.textContent);\n            break;\n        }\n      }\n      return data;\n    }\n    function buildCamera(data) {\n      let camera;\n      switch (data.optics.technique) {\n        case \"perspective\":\n          camera = new PerspectiveCamera(\n            data.optics.parameters.yfov,\n            data.optics.parameters.aspect_ratio,\n            data.optics.parameters.znear,\n            data.optics.parameters.zfar\n          );\n          break;\n        case \"orthographic\":\n          let ymag = data.optics.parameters.ymag;\n          let xmag = data.optics.parameters.xmag;\n          const aspectRatio = data.optics.parameters.aspect_ratio;\n          xmag = xmag === void 0 ? ymag * aspectRatio : xmag;\n          ymag = ymag === void 0 ? xmag / aspectRatio : ymag;\n          xmag *= 0.5;\n          ymag *= 0.5;\n          camera = new OrthographicCamera(\n            -xmag,\n            xmag,\n            ymag,\n            -ymag,\n            // left, right, top, bottom\n            data.optics.parameters.znear,\n            data.optics.parameters.zfar\n          );\n          break;\n        default:\n          camera = new PerspectiveCamera();\n          break;\n      }\n      camera.name = data.name || \"\";\n      return camera;\n    }\n    function getCamera(id) {\n      const data = library.cameras[id];\n      if (data !== void 0) {\n        return getBuild(data, buildCamera);\n      }\n      console.warn(\"THREE.ColladaLoader: Couldn't find camera with ID:\", id);\n      return null;\n    }\n    function parseLight(xml2) {\n      let data = {};\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"technique_common\":\n            data = parseLightTechnique(child);\n            break;\n        }\n      }\n      library.lights[xml2.getAttribute(\"id\")] = data;\n    }\n    function parseLightTechnique(xml2) {\n      const data = {};\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"directional\":\n          case \"point\":\n          case \"spot\":\n          case \"ambient\":\n            data.technique = child.nodeName;\n            data.parameters = parseLightParameters(child);\n        }\n      }\n      return data;\n    }\n    function parseLightParameters(xml2) {\n      const data = {};\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"color\":\n            const array = parseFloats(child.textContent);\n            data.color = new Color().fromArray(array);\n            break;\n          case \"falloff_angle\":\n            data.falloffAngle = parseFloat(child.textContent);\n            break;\n          case \"quadratic_attenuation\":\n            const f = parseFloat(child.textContent);\n            data.distance = f ? Math.sqrt(1 / f) : 0;\n            break;\n        }\n      }\n      return data;\n    }\n    function buildLight(data) {\n      let light;\n      switch (data.technique) {\n        case \"directional\":\n          light = new DirectionalLight();\n          break;\n        case \"point\":\n          light = new PointLight();\n          break;\n        case \"spot\":\n          light = new SpotLight();\n          break;\n        case \"ambient\":\n          light = new AmbientLight();\n          break;\n      }\n      if (data.parameters.color)\n        light.color.copy(data.parameters.color);\n      if (data.parameters.distance)\n        light.distance = data.parameters.distance;\n      return light;\n    }\n    function getLight(id) {\n      const data = library.lights[id];\n      if (data !== void 0) {\n        return getBuild(data, buildLight);\n      }\n      console.warn(\"THREE.ColladaLoader: Couldn't find light with ID:\", id);\n      return null;\n    }\n    function parseGeometry(xml2) {\n      const data = {\n        name: xml2.getAttribute(\"name\"),\n        sources: {},\n        vertices: {},\n        primitives: []\n      };\n      const mesh = getElementsByTagName(xml2, \"mesh\")[0];\n      if (mesh === void 0)\n        return;\n      for (let i = 0; i < mesh.childNodes.length; i++) {\n        const child = mesh.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        const id = child.getAttribute(\"id\");\n        switch (child.nodeName) {\n          case \"source\":\n            data.sources[id] = parseSource(child);\n            break;\n          case \"vertices\":\n            data.vertices = parseGeometryVertices(child);\n            break;\n          case \"polygons\":\n            console.warn(\"THREE.ColladaLoader: Unsupported primitive type: \", child.nodeName);\n            break;\n          case \"lines\":\n          case \"linestrips\":\n          case \"polylist\":\n          case \"triangles\":\n            data.primitives.push(parseGeometryPrimitive(child));\n            break;\n          default:\n            console.log(child);\n        }\n      }\n      library.geometries[xml2.getAttribute(\"id\")] = data;\n    }\n    function parseSource(xml2) {\n      const data = {\n        array: [],\n        stride: 3\n      };\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"float_array\":\n            data.array = parseFloats(child.textContent);\n            break;\n          case \"Name_array\":\n            data.array = parseStrings(child.textContent);\n            break;\n          case \"technique_common\":\n            const accessor = getElementsByTagName(child, \"accessor\")[0];\n            if (accessor !== void 0) {\n              data.stride = parseInt(accessor.getAttribute(\"stride\"));\n            }\n            break;\n        }\n      }\n      return data;\n    }\n    function parseGeometryVertices(xml2) {\n      const data = {};\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        data[child.getAttribute(\"semantic\")] = parseId(child.getAttribute(\"source\"));\n      }\n      return data;\n    }\n    function parseGeometryPrimitive(xml2) {\n      const primitive = {\n        type: xml2.nodeName,\n        material: xml2.getAttribute(\"material\"),\n        count: parseInt(xml2.getAttribute(\"count\")),\n        inputs: {},\n        stride: 0,\n        hasUV: false\n      };\n      for (let i = 0, l = xml2.childNodes.length; i < l; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"input\":\n            const id = parseId(child.getAttribute(\"source\"));\n            const semantic = child.getAttribute(\"semantic\");\n            const offset = parseInt(child.getAttribute(\"offset\"));\n            const set = parseInt(child.getAttribute(\"set\"));\n            const inputname = set > 0 ? semantic + set : semantic;\n            primitive.inputs[inputname] = { id, offset };\n            primitive.stride = Math.max(primitive.stride, offset + 1);\n            if (semantic === \"TEXCOORD\")\n              primitive.hasUV = true;\n            break;\n          case \"vcount\":\n            primitive.vcount = parseInts(child.textContent);\n            break;\n          case \"p\":\n            primitive.p = parseInts(child.textContent);\n            break;\n        }\n      }\n      return primitive;\n    }\n    function groupPrimitives(primitives) {\n      const build = {};\n      for (let i = 0; i < primitives.length; i++) {\n        const primitive = primitives[i];\n        if (build[primitive.type] === void 0)\n          build[primitive.type] = [];\n        build[primitive.type].push(primitive);\n      }\n      return build;\n    }\n    function checkUVCoordinates(primitives) {\n      let count2 = 0;\n      for (let i = 0, l = primitives.length; i < l; i++) {\n        const primitive = primitives[i];\n        if (primitive.hasUV === true) {\n          count2++;\n        }\n      }\n      if (count2 > 0 && count2 < primitives.length) {\n        primitives.uvsNeedsFix = true;\n      }\n    }\n    function buildGeometry(data) {\n      const build = {};\n      const sources = data.sources;\n      const vertices = data.vertices;\n      const primitives = data.primitives;\n      if (primitives.length === 0)\n        return {};\n      const groupedPrimitives = groupPrimitives(primitives);\n      for (const type in groupedPrimitives) {\n        const primitiveType = groupedPrimitives[type];\n        checkUVCoordinates(primitiveType);\n        build[type] = buildGeometryType(primitiveType, sources, vertices);\n      }\n      return build;\n    }\n    function buildGeometryType(primitives, sources, vertices) {\n      const build = {};\n      const position2 = { array: [], stride: 0 };\n      const normal = { array: [], stride: 0 };\n      const uv = { array: [], stride: 0 };\n      const uv2 = { array: [], stride: 0 };\n      const color = { array: [], stride: 0 };\n      const skinIndex = { array: [], stride: 4 };\n      const skinWeight = { array: [], stride: 4 };\n      const geometry = new BufferGeometry();\n      const materialKeys = [];\n      let start = 0;\n      for (let p = 0; p < primitives.length; p++) {\n        const primitive = primitives[p];\n        const inputs = primitive.inputs;\n        let count2 = 0;\n        switch (primitive.type) {\n          case \"lines\":\n          case \"linestrips\":\n            count2 = primitive.count * 2;\n            break;\n          case \"triangles\":\n            count2 = primitive.count * 3;\n            break;\n          case \"polylist\":\n            for (let g = 0; g < primitive.count; g++) {\n              const vc = primitive.vcount[g];\n              switch (vc) {\n                case 3:\n                  count2 += 3;\n                  break;\n                case 4:\n                  count2 += 6;\n                  break;\n                default:\n                  count2 += (vc - 2) * 3;\n                  break;\n              }\n            }\n            break;\n          default:\n            console.warn(\"THREE.ColladaLoader: Unknow primitive type:\", primitive.type);\n        }\n        geometry.addGroup(start, count2, p);\n        start += count2;\n        if (primitive.material) {\n          materialKeys.push(primitive.material);\n        }\n        for (const name in inputs) {\n          const input = inputs[name];\n          switch (name) {\n            case \"VERTEX\":\n              for (const key in vertices) {\n                const id = vertices[key];\n                switch (key) {\n                  case \"POSITION\":\n                    const prevLength = position2.array.length;\n                    buildGeometryData(primitive, sources[id], input.offset, position2.array);\n                    position2.stride = sources[id].stride;\n                    if (sources.skinWeights && sources.skinIndices) {\n                      buildGeometryData(primitive, sources.skinIndices, input.offset, skinIndex.array);\n                      buildGeometryData(primitive, sources.skinWeights, input.offset, skinWeight.array);\n                    }\n                    if (primitive.hasUV === false && primitives.uvsNeedsFix === true) {\n                      const count3 = (position2.array.length - prevLength) / position2.stride;\n                      for (let i = 0; i < count3; i++) {\n                        uv.array.push(0, 0);\n                      }\n                    }\n                    break;\n                  case \"NORMAL\":\n                    buildGeometryData(primitive, sources[id], input.offset, normal.array);\n                    normal.stride = sources[id].stride;\n                    break;\n                  case \"COLOR\":\n                    buildGeometryData(primitive, sources[id], input.offset, color.array);\n                    color.stride = sources[id].stride;\n                    break;\n                  case \"TEXCOORD\":\n                    buildGeometryData(primitive, sources[id], input.offset, uv.array);\n                    uv.stride = sources[id].stride;\n                    break;\n                  case \"TEXCOORD1\":\n                    buildGeometryData(primitive, sources[id], input.offset, uv2.array);\n                    uv.stride = sources[id].stride;\n                    break;\n                  default:\n                    console.warn('THREE.ColladaLoader: Semantic \"%s\" not handled in geometry build process.', key);\n                }\n              }\n              break;\n            case \"NORMAL\":\n              buildGeometryData(primitive, sources[input.id], input.offset, normal.array);\n              normal.stride = sources[input.id].stride;\n              break;\n            case \"COLOR\":\n              buildGeometryData(primitive, sources[input.id], input.offset, color.array);\n              color.stride = sources[input.id].stride;\n              break;\n            case \"TEXCOORD\":\n              buildGeometryData(primitive, sources[input.id], input.offset, uv.array);\n              uv.stride = sources[input.id].stride;\n              break;\n            case \"TEXCOORD1\":\n              buildGeometryData(primitive, sources[input.id], input.offset, uv2.array);\n              uv2.stride = sources[input.id].stride;\n              break;\n          }\n        }\n      }\n      if (position2.array.length > 0) {\n        geometry.setAttribute(\"position\", new Float32BufferAttribute(position2.array, position2.stride));\n      }\n      if (normal.array.length > 0) {\n        geometry.setAttribute(\"normal\", new Float32BufferAttribute(normal.array, normal.stride));\n      }\n      if (color.array.length > 0)\n        geometry.setAttribute(\"color\", new Float32BufferAttribute(color.array, color.stride));\n      if (uv.array.length > 0)\n        geometry.setAttribute(\"uv\", new Float32BufferAttribute(uv.array, uv.stride));\n      if (uv2.array.length > 0)\n        geometry.setAttribute(\"uv2\", new Float32BufferAttribute(uv2.array, uv2.stride));\n      if (skinIndex.array.length > 0) {\n        geometry.setAttribute(\"skinIndex\", new Float32BufferAttribute(skinIndex.array, skinIndex.stride));\n      }\n      if (skinWeight.array.length > 0) {\n        geometry.setAttribute(\"skinWeight\", new Float32BufferAttribute(skinWeight.array, skinWeight.stride));\n      }\n      build.data = geometry;\n      build.type = primitives[0].type;\n      build.materialKeys = materialKeys;\n      return build;\n    }\n    function buildGeometryData(primitive, source, offset, array) {\n      const indices = primitive.p;\n      const stride = primitive.stride;\n      const vcount = primitive.vcount;\n      function pushVector(i) {\n        let index = indices[i + offset] * sourceStride;\n        const length = index + sourceStride;\n        for (; index < length; index++) {\n          array.push(sourceArray[index]);\n        }\n      }\n      const sourceArray = source.array;\n      const sourceStride = source.stride;\n      if (primitive.vcount !== void 0) {\n        let index = 0;\n        for (let i = 0, l = vcount.length; i < l; i++) {\n          const count2 = vcount[i];\n          if (count2 === 4) {\n            const a = index + stride * 0;\n            const b = index + stride * 1;\n            const c = index + stride * 2;\n            const d = index + stride * 3;\n            pushVector(a);\n            pushVector(b);\n            pushVector(d);\n            pushVector(b);\n            pushVector(c);\n            pushVector(d);\n          } else if (count2 === 3) {\n            const a = index + stride * 0;\n            const b = index + stride * 1;\n            const c = index + stride * 2;\n            pushVector(a);\n            pushVector(b);\n            pushVector(c);\n          } else if (count2 > 4) {\n            for (let k = 1, kl = count2 - 2; k <= kl; k++) {\n              const a = index + stride * 0;\n              const b = index + stride * k;\n              const c = index + stride * (k + 1);\n              pushVector(a);\n              pushVector(b);\n              pushVector(c);\n            }\n          }\n          index += stride * count2;\n        }\n      } else {\n        for (let i = 0, l = indices.length; i < l; i += stride) {\n          pushVector(i);\n        }\n      }\n    }\n    function getGeometry(id) {\n      return getBuild(library.geometries[id], buildGeometry);\n    }\n    function parseKinematicsModel(xml2) {\n      const data = {\n        name: xml2.getAttribute(\"name\") || \"\",\n        joints: {},\n        links: []\n      };\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"technique_common\":\n            parseKinematicsTechniqueCommon(child, data);\n            break;\n        }\n      }\n      library.kinematicsModels[xml2.getAttribute(\"id\")] = data;\n    }\n    function buildKinematicsModel(data) {\n      if (data.build !== void 0)\n        return data.build;\n      return data;\n    }\n    function getKinematicsModel(id) {\n      return getBuild(library.kinematicsModels[id], buildKinematicsModel);\n    }\n    function parseKinematicsTechniqueCommon(xml2, data) {\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"joint\":\n            data.joints[child.getAttribute(\"sid\")] = parseKinematicsJoint(child);\n            break;\n          case \"link\":\n            data.links.push(parseKinematicsLink(child));\n            break;\n        }\n      }\n    }\n    function parseKinematicsJoint(xml2) {\n      let data;\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"prismatic\":\n          case \"revolute\":\n            data = parseKinematicsJointParameter(child);\n            break;\n        }\n      }\n      return data;\n    }\n    function parseKinematicsJointParameter(xml2) {\n      const data = {\n        sid: xml2.getAttribute(\"sid\"),\n        name: xml2.getAttribute(\"name\") || \"\",\n        axis: new Vector3(),\n        limits: {\n          min: 0,\n          max: 0\n        },\n        type: xml2.nodeName,\n        static: false,\n        zeroPosition: 0,\n        middlePosition: 0\n      };\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"axis\":\n            const array = parseFloats(child.textContent);\n            data.axis.fromArray(array);\n            break;\n          case \"limits\":\n            const max = child.getElementsByTagName(\"max\")[0];\n            const min = child.getElementsByTagName(\"min\")[0];\n            data.limits.max = parseFloat(max.textContent);\n            data.limits.min = parseFloat(min.textContent);\n            break;\n        }\n      }\n      if (data.limits.min >= data.limits.max) {\n        data.static = true;\n      }\n      data.middlePosition = (data.limits.min + data.limits.max) / 2;\n      return data;\n    }\n    function parseKinematicsLink(xml2) {\n      const data = {\n        sid: xml2.getAttribute(\"sid\"),\n        name: xml2.getAttribute(\"name\") || \"\",\n        attachments: [],\n        transforms: []\n      };\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"attachment_full\":\n            data.attachments.push(parseKinematicsAttachment(child));\n            break;\n          case \"matrix\":\n          case \"translate\":\n          case \"rotate\":\n            data.transforms.push(parseKinematicsTransform(child));\n            break;\n        }\n      }\n      return data;\n    }\n    function parseKinematicsAttachment(xml2) {\n      const data = {\n        joint: xml2.getAttribute(\"joint\").split(\"/\").pop(),\n        transforms: [],\n        links: []\n      };\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"link\":\n            data.links.push(parseKinematicsLink(child));\n            break;\n          case \"matrix\":\n          case \"translate\":\n          case \"rotate\":\n            data.transforms.push(parseKinematicsTransform(child));\n            break;\n        }\n      }\n      return data;\n    }\n    function parseKinematicsTransform(xml2) {\n      const data = {\n        type: xml2.nodeName\n      };\n      const array = parseFloats(xml2.textContent);\n      switch (data.type) {\n        case \"matrix\":\n          data.obj = new Matrix4();\n          data.obj.fromArray(array).transpose();\n          break;\n        case \"translate\":\n          data.obj = new Vector3();\n          data.obj.fromArray(array);\n          break;\n        case \"rotate\":\n          data.obj = new Vector3();\n          data.obj.fromArray(array);\n          data.angle = MathUtils.degToRad(array[3]);\n          break;\n      }\n      return data;\n    }\n    function parsePhysicsModel(xml2) {\n      const data = {\n        name: xml2.getAttribute(\"name\") || \"\",\n        rigidBodies: {}\n      };\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"rigid_body\":\n            data.rigidBodies[child.getAttribute(\"name\")] = {};\n            parsePhysicsRigidBody(child, data.rigidBodies[child.getAttribute(\"name\")]);\n            break;\n        }\n      }\n      library.physicsModels[xml2.getAttribute(\"id\")] = data;\n    }\n    function parsePhysicsRigidBody(xml2, data) {\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"technique_common\":\n            parsePhysicsTechniqueCommon(child, data);\n            break;\n        }\n      }\n    }\n    function parsePhysicsTechniqueCommon(xml2, data) {\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"inertia\":\n            data.inertia = parseFloats(child.textContent);\n            break;\n          case \"mass\":\n            data.mass = parseFloats(child.textContent)[0];\n            break;\n        }\n      }\n    }\n    function parseKinematicsScene(xml2) {\n      const data = {\n        bindJointAxis: []\n      };\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"bind_joint_axis\":\n            data.bindJointAxis.push(parseKinematicsBindJointAxis(child));\n            break;\n        }\n      }\n      library.kinematicsScenes[parseId(xml2.getAttribute(\"url\"))] = data;\n    }\n    function parseKinematicsBindJointAxis(xml2) {\n      const data = {\n        target: xml2.getAttribute(\"target\").split(\"/\").pop()\n      };\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        switch (child.nodeName) {\n          case \"axis\":\n            const param = child.getElementsByTagName(\"param\")[0];\n            data.axis = param.textContent;\n            const tmpJointIndex = data.axis.split(\"inst_\").pop().split(\"axis\")[0];\n            data.jointIndex = tmpJointIndex.substr(0, tmpJointIndex.length - 1);\n            break;\n        }\n      }\n      return data;\n    }\n    function buildKinematicsScene(data) {\n      if (data.build !== void 0)\n        return data.build;\n      return data;\n    }\n    function getKinematicsScene(id) {\n      return getBuild(library.kinematicsScenes[id], buildKinematicsScene);\n    }\n    function setupKinematics() {\n      const kinematicsModelId = Object.keys(library.kinematicsModels)[0];\n      const kinematicsSceneId = Object.keys(library.kinematicsScenes)[0];\n      const visualSceneId = Object.keys(library.visualScenes)[0];\n      if (kinematicsModelId === void 0 || kinematicsSceneId === void 0)\n        return;\n      const kinematicsModel = getKinematicsModel(kinematicsModelId);\n      const kinematicsScene = getKinematicsScene(kinematicsSceneId);\n      const visualScene = getVisualScene(visualSceneId);\n      const bindJointAxis = kinematicsScene.bindJointAxis;\n      const jointMap = {};\n      for (let i = 0, l = bindJointAxis.length; i < l; i++) {\n        const axis = bindJointAxis[i];\n        const targetElement = collada.querySelector('[sid=\"' + axis.target + '\"]');\n        if (targetElement) {\n          const parentVisualElement = targetElement.parentElement;\n          connect(axis.jointIndex, parentVisualElement);\n        }\n      }\n      function connect(jointIndex, visualElement) {\n        const visualElementName = visualElement.getAttribute(\"name\");\n        const joint = kinematicsModel.joints[jointIndex];\n        visualScene.traverse(function(object) {\n          if (object.name === visualElementName) {\n            jointMap[jointIndex] = {\n              object,\n              transforms: buildTransformList(visualElement),\n              joint,\n              position: joint.zeroPosition\n            };\n          }\n        });\n      }\n      const m0 = new Matrix4();\n      kinematics = {\n        joints: kinematicsModel && kinematicsModel.joints,\n        getJointValue: function(jointIndex) {\n          const jointData = jointMap[jointIndex];\n          if (jointData) {\n            return jointData.position;\n          } else {\n            console.warn(\"THREE.ColladaLoader: Joint \" + jointIndex + \" doesn't exist.\");\n          }\n        },\n        setJointValue: function(jointIndex, value) {\n          const jointData = jointMap[jointIndex];\n          if (jointData) {\n            const joint = jointData.joint;\n            if (value > joint.limits.max || value < joint.limits.min) {\n              console.warn(\n                \"THREE.ColladaLoader: Joint \" + jointIndex + \" value \" + value + \" outside of limits (min: \" + joint.limits.min + \", max: \" + joint.limits.max + \").\"\n              );\n            } else if (joint.static) {\n              console.warn(\"THREE.ColladaLoader: Joint \" + jointIndex + \" is static.\");\n            } else {\n              const object = jointData.object;\n              const axis = joint.axis;\n              const transforms = jointData.transforms;\n              matrix.identity();\n              for (let i = 0; i < transforms.length; i++) {\n                const transform = transforms[i];\n                if (transform.sid && transform.sid.indexOf(jointIndex) !== -1) {\n                  switch (joint.type) {\n                    case \"revolute\":\n                      matrix.multiply(m0.makeRotationAxis(axis, MathUtils.degToRad(value)));\n                      break;\n                    case \"prismatic\":\n                      matrix.multiply(m0.makeTranslation(axis.x * value, axis.y * value, axis.z * value));\n                      break;\n                    default:\n                      console.warn(\"THREE.ColladaLoader: Unknown joint type: \" + joint.type);\n                      break;\n                  }\n                } else {\n                  switch (transform.type) {\n                    case \"matrix\":\n                      matrix.multiply(transform.obj);\n                      break;\n                    case \"translate\":\n                      matrix.multiply(m0.makeTranslation(transform.obj.x, transform.obj.y, transform.obj.z));\n                      break;\n                    case \"scale\":\n                      matrix.scale(transform.obj);\n                      break;\n                    case \"rotate\":\n                      matrix.multiply(m0.makeRotationAxis(transform.obj, transform.angle));\n                      break;\n                  }\n                }\n              }\n              object.matrix.copy(matrix);\n              object.matrix.decompose(object.position, object.quaternion, object.scale);\n              jointMap[jointIndex].position = value;\n            }\n          } else {\n            console.log(\"THREE.ColladaLoader: \" + jointIndex + \" does not exist.\");\n          }\n        }\n      };\n    }\n    function buildTransformList(node) {\n      const transforms = [];\n      const xml2 = collada.querySelector('[id=\"' + node.id + '\"]');\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        let array, vector2;\n        switch (child.nodeName) {\n          case \"matrix\":\n            array = parseFloats(child.textContent);\n            const matrix2 = new Matrix4().fromArray(array).transpose();\n            transforms.push({\n              sid: child.getAttribute(\"sid\"),\n              type: child.nodeName,\n              obj: matrix2\n            });\n            break;\n          case \"translate\":\n          case \"scale\":\n            array = parseFloats(child.textContent);\n            vector2 = new Vector3().fromArray(array);\n            transforms.push({\n              sid: child.getAttribute(\"sid\"),\n              type: child.nodeName,\n              obj: vector2\n            });\n            break;\n          case \"rotate\":\n            array = parseFloats(child.textContent);\n            vector2 = new Vector3().fromArray(array);\n            const angle = MathUtils.degToRad(array[3]);\n            transforms.push({\n              sid: child.getAttribute(\"sid\"),\n              type: child.nodeName,\n              obj: vector2,\n              angle\n            });\n            break;\n        }\n      }\n      return transforms;\n    }\n    function prepareNodes(xml2) {\n      const elements = xml2.getElementsByTagName(\"node\");\n      for (let i = 0; i < elements.length; i++) {\n        const element = elements[i];\n        if (element.hasAttribute(\"id\") === false) {\n          element.setAttribute(\"id\", generateId());\n        }\n      }\n    }\n    const matrix = new Matrix4();\n    const vector = new Vector3();\n    function parseNode(xml2) {\n      const data = {\n        name: xml2.getAttribute(\"name\") || \"\",\n        type: xml2.getAttribute(\"type\"),\n        id: xml2.getAttribute(\"id\"),\n        sid: xml2.getAttribute(\"sid\"),\n        matrix: new Matrix4(),\n        nodes: [],\n        instanceCameras: [],\n        instanceControllers: [],\n        instanceLights: [],\n        instanceGeometries: [],\n        instanceNodes: [],\n        transforms: {}\n      };\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        if (child.nodeType !== 1)\n          continue;\n        let array;\n        switch (child.nodeName) {\n          case \"node\":\n            data.nodes.push(child.getAttribute(\"id\"));\n            parseNode(child);\n            break;\n          case \"instance_camera\":\n            data.instanceCameras.push(parseId(child.getAttribute(\"url\")));\n            break;\n          case \"instance_controller\":\n            data.instanceControllers.push(parseNodeInstance(child));\n            break;\n          case \"instance_light\":\n            data.instanceLights.push(parseId(child.getAttribute(\"url\")));\n            break;\n          case \"instance_geometry\":\n            data.instanceGeometries.push(parseNodeInstance(child));\n            break;\n          case \"instance_node\":\n            data.instanceNodes.push(parseId(child.getAttribute(\"url\")));\n            break;\n          case \"matrix\":\n            array = parseFloats(child.textContent);\n            data.matrix.multiply(matrix.fromArray(array).transpose());\n            data.transforms[child.getAttribute(\"sid\")] = child.nodeName;\n            break;\n          case \"translate\":\n            array = parseFloats(child.textContent);\n            vector.fromArray(array);\n            data.matrix.multiply(matrix.makeTranslation(vector.x, vector.y, vector.z));\n            data.transforms[child.getAttribute(\"sid\")] = child.nodeName;\n            break;\n          case \"rotate\":\n            array = parseFloats(child.textContent);\n            const angle = MathUtils.degToRad(array[3]);\n            data.matrix.multiply(matrix.makeRotationAxis(vector.fromArray(array), angle));\n            data.transforms[child.getAttribute(\"sid\")] = child.nodeName;\n            break;\n          case \"scale\":\n            array = parseFloats(child.textContent);\n            data.matrix.scale(vector.fromArray(array));\n            data.transforms[child.getAttribute(\"sid\")] = child.nodeName;\n            break;\n          case \"extra\":\n            break;\n          default:\n            console.log(child);\n        }\n      }\n      if (hasNode(data.id)) {\n        console.warn(\n          \"THREE.ColladaLoader: There is already a node with ID %s. Exclude current node from further processing.\",\n          data.id\n        );\n      } else {\n        library.nodes[data.id] = data;\n      }\n      return data;\n    }\n    function parseNodeInstance(xml2) {\n      const data = {\n        id: parseId(xml2.getAttribute(\"url\")),\n        materials: {},\n        skeletons: []\n      };\n      for (let i = 0; i < xml2.childNodes.length; i++) {\n        const child = xml2.childNodes[i];\n        switch (child.nodeName) {\n          case \"bind_material\":\n            const instances = child.getElementsByTagName(\"instance_material\");\n            for (let j = 0; j < instances.length; j++) {\n              const instance = instances[j];\n              const symbol = instance.getAttribute(\"symbol\");\n              const target = instance.getAttribute(\"target\");\n              data.materials[symbol] = parseId(target);\n            }\n            break;\n          case \"skeleton\":\n            data.skeletons.push(parseId(child.textContent));\n            break;\n          default:\n            break;\n        }\n      }\n      return data;\n    }\n    function buildSkeleton(skeletons, joints) {\n      const boneData = [];\n      const sortedBoneData = [];\n      let i, j, data;\n      for (i = 0; i < skeletons.length; i++) {\n        const skeleton = skeletons[i];\n        let root;\n        if (hasNode(skeleton)) {\n          root = getNode(skeleton);\n          buildBoneHierarchy(root, joints, boneData);\n        } else if (hasVisualScene(skeleton)) {\n          const visualScene = library.visualScenes[skeleton];\n          const children = visualScene.children;\n          for (let j2 = 0; j2 < children.length; j2++) {\n            const child = children[j2];\n            if (child.type === \"JOINT\") {\n              const root2 = getNode(child.id);\n              buildBoneHierarchy(root2, joints, boneData);\n            }\n          }\n        } else {\n          console.error(\"THREE.ColladaLoader: Unable to find root bone of skeleton with ID:\", skeleton);\n        }\n      }\n      for (i = 0; i < joints.length; i++) {\n        for (j = 0; j < boneData.length; j++) {\n          data = boneData[j];\n          if (data.bone.name === joints[i].name) {\n            sortedBoneData[i] = data;\n            data.processed = true;\n            break;\n          }\n        }\n      }\n      for (i = 0; i < boneData.length; i++) {\n        data = boneData[i];\n        if (data.processed === false) {\n          sortedBoneData.push(data);\n          data.processed = true;\n        }\n      }\n      const bones = [];\n      const boneInverses = [];\n      for (i = 0; i < sortedBoneData.length; i++) {\n        data = sortedBoneData[i];\n        bones.push(data.bone);\n        boneInverses.push(data.boneInverse);\n      }\n      return new Skeleton(bones, boneInverses);\n    }\n    function buildBoneHierarchy(root, joints, boneData) {\n      root.traverse(function(object) {\n        if (object.isBone === true) {\n          let boneInverse;\n          for (let i = 0; i < joints.length; i++) {\n            const joint = joints[i];\n            if (joint.name === object.name) {\n              boneInverse = joint.boneInverse;\n              break;\n            }\n          }\n          if (boneInverse === void 0) {\n            boneInverse = new Matrix4();\n          }\n          boneData.push({ bone: object, boneInverse, processed: false });\n        }\n      });\n    }\n    function buildNode(data) {\n      const objects = [];\n      const matrix2 = data.matrix;\n      const nodes = data.nodes;\n      const type = data.type;\n      const instanceCameras = data.instanceCameras;\n      const instanceControllers = data.instanceControllers;\n      const instanceLights = data.instanceLights;\n      const instanceGeometries = data.instanceGeometries;\n      const instanceNodes = data.instanceNodes;\n      for (let i = 0, l = nodes.length; i < l; i++) {\n        objects.push(getNode(nodes[i]));\n      }\n      for (let i = 0, l = instanceCameras.length; i < l; i++) {\n        const instanceCamera = getCamera(instanceCameras[i]);\n        if (instanceCamera !== null) {\n          objects.push(instanceCamera.clone());\n        }\n      }\n      for (let i = 0, l = instanceControllers.length; i < l; i++) {\n        const instance = instanceControllers[i];\n        const controller = getController(instance.id);\n        const geometries = getGeometry(controller.id);\n        const newObjects = buildObjects(geometries, instance.materials);\n        const skeletons = instance.skeletons;\n        const joints = controller.skin.joints;\n        const skeleton = buildSkeleton(skeletons, joints);\n        for (let j = 0, jl = newObjects.length; j < jl; j++) {\n          const object2 = newObjects[j];\n          if (object2.isSkinnedMesh) {\n            object2.bind(skeleton, controller.skin.bindMatrix);\n            object2.normalizeSkinWeights();\n          }\n          objects.push(object2);\n        }\n      }\n      for (let i = 0, l = instanceLights.length; i < l; i++) {\n        const instanceLight = getLight(instanceLights[i]);\n        if (instanceLight !== null) {\n          objects.push(instanceLight.clone());\n        }\n      }\n      for (let i = 0, l = instanceGeometries.length; i < l; i++) {\n        const instance = instanceGeometries[i];\n        const geometries = getGeometry(instance.id);\n        const newObjects = buildObjects(geometries, instance.materials);\n        for (let j = 0, jl = newObjects.length; j < jl; j++) {\n          objects.push(newObjects[j]);\n        }\n      }\n      for (let i = 0, l = instanceNodes.length; i < l; i++) {\n        objects.push(getNode(instanceNodes[i]).clone());\n      }\n      let object;\n      if (nodes.length === 0 && objects.length === 1) {\n        object = objects[0];\n      } else {\n        object = type === \"JOINT\" ? new Bone() : new Group();\n        for (let i = 0; i < objects.length; i++) {\n          object.add(objects[i]);\n        }\n      }\n      object.name = type === \"JOINT\" ? data.sid : data.name;\n      object.matrix.copy(matrix2);\n      object.matrix.decompose(object.position, object.quaternion, object.scale);\n      return object;\n    }\n    const fallbackMaterial = new MeshBasicMaterial({ color: 16711935 });\n    function resolveMaterialBinding(keys, instanceMaterials) {\n      const materials = [];\n      for (let i = 0, l = keys.length; i < l; i++) {\n        const id = instanceMaterials[keys[i]];\n        if (id === void 0) {\n          console.warn(\"THREE.ColladaLoader: Material with key %s not found. Apply fallback material.\", keys[i]);\n          materials.push(fallbackMaterial);\n        } else {\n          materials.push(getMaterial(id));\n        }\n      }\n      return materials;\n    }\n    function buildObjects(geometries, instanceMaterials) {\n      const objects = [];\n      for (const type in geometries) {\n        const geometry = geometries[type];\n        const materials = resolveMaterialBinding(geometry.materialKeys, instanceMaterials);\n        if (materials.length === 0) {\n          if (type === \"lines\" || type === \"linestrips\") {\n            materials.push(new LineBasicMaterial());\n          } else {\n            materials.push(new MeshPhongMaterial());\n          }\n        }\n        const skinning = geometry.data.attributes.skinIndex !== void 0;\n        const material = materials.length === 1 ? materials[0] : materials;\n        let object;\n        switch (type) {\n          case \"lines\":\n            object = new LineSegments(geometry.data, material);\n            break;\n          case \"linestrips\":\n            object = new Line(geometry.data, material);\n            break;\n          case \"triangles\":\n          case \"polylist\":\n            if (skinning) {\n              object = new SkinnedMesh(geometry.data, material);\n            } else {\n              object = new Mesh(geometry.data, material);\n            }\n            break;\n        }\n        objects.push(object);\n      }\n      return objects;\n    }\n    function hasNode(id) {\n      return library.nodes[id] !== void 0;\n    }\n    function getNode(id) {\n      return getBuild(library.nodes[id], buildNode);\n    }\n    function parseVisualScene(xml2) {\n      const data = {\n        name: xml2.getAttribute(\"name\"),\n        children: []\n      };\n      prepareNodes(xml2);\n      const elements = getElementsByTagName(xml2, \"node\");\n      for (let i = 0; i < elements.length; i++) {\n        data.children.push(parseNode(elements[i]));\n      }\n      library.visualScenes[xml2.getAttribute(\"id\")] = data;\n    }\n    function buildVisualScene(data) {\n      const group = new Group();\n      group.name = data.name;\n      const children = data.children;\n      for (let i = 0; i < children.length; i++) {\n        const child = children[i];\n        group.add(getNode(child.id));\n      }\n      return group;\n    }\n    function hasVisualScene(id) {\n      return library.visualScenes[id] !== void 0;\n    }\n    function getVisualScene(id) {\n      return getBuild(library.visualScenes[id], buildVisualScene);\n    }\n    function parseScene(xml2) {\n      const instance = getElementsByTagName(xml2, \"instance_visual_scene\")[0];\n      return getVisualScene(parseId(instance.getAttribute(\"url\")));\n    }\n    function setupAnimations() {\n      const clips = library.clips;\n      if (isEmpty(clips) === true) {\n        if (isEmpty(library.animations) === false) {\n          const tracks = [];\n          for (const id in library.animations) {\n            const animationTracks = getAnimation(id);\n            for (let i = 0, l = animationTracks.length; i < l; i++) {\n              tracks.push(animationTracks[i]);\n            }\n          }\n          animations.push(new AnimationClip(\"default\", -1, tracks));\n        }\n      } else {\n        for (const id in clips) {\n          animations.push(getAnimationClip(id));\n        }\n      }\n    }\n    function parserErrorToText(parserError2) {\n      let result = \"\";\n      const stack = [parserError2];\n      while (stack.length) {\n        const node = stack.shift();\n        if (node.nodeType === Node.TEXT_NODE) {\n          result += node.textContent;\n        } else {\n          result += \"\\n\";\n          stack.push.apply(stack, node.childNodes);\n        }\n      }\n      return result.trim();\n    }\n    if (text.length === 0) {\n      return { scene: new Scene() };\n    }\n    const xml = new DOMParser().parseFromString(text, \"application/xml\");\n    const collada = getElementsByTagName(xml, \"COLLADA\")[0];\n    const parserError = xml.getElementsByTagName(\"parsererror\")[0];\n    if (parserError !== void 0) {\n      const errorElement = getElementsByTagName(parserError, \"div\")[0];\n      let errorText;\n      if (errorElement) {\n        errorText = errorElement.textContent;\n      } else {\n        errorText = parserErrorToText(parserError);\n      }\n      console.error(\"THREE.ColladaLoader: Failed to parse collada file.\\n\", errorText);\n      return null;\n    }\n    const version = collada.getAttribute(\"version\");\n    console.log(\"THREE.ColladaLoader: File version\", version);\n    const asset = parseAsset(getElementsByTagName(collada, \"asset\")[0]);\n    const textureLoader = new TextureLoader(this.manager);\n    textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n    let tgaLoader;\n    if (TGALoader) {\n      tgaLoader = new TGALoader(this.manager);\n      tgaLoader.setPath(this.resourcePath || path);\n    }\n    const animations = [];\n    let kinematics = {};\n    let count = 0;\n    const library = {\n      animations: {},\n      clips: {},\n      controllers: {},\n      images: {},\n      effects: {},\n      materials: {},\n      cameras: {},\n      lights: {},\n      geometries: {},\n      nodes: {},\n      visualScenes: {},\n      kinematicsModels: {},\n      physicsModels: {},\n      kinematicsScenes: {}\n    };\n    parseLibrary(collada, \"library_animations\", \"animation\", parseAnimation);\n    parseLibrary(collada, \"library_animation_clips\", \"animation_clip\", parseAnimationClip);\n    parseLibrary(collada, \"library_controllers\", \"controller\", parseController);\n    parseLibrary(collada, \"library_images\", \"image\", parseImage);\n    parseLibrary(collada, \"library_effects\", \"effect\", parseEffect);\n    parseLibrary(collada, \"library_materials\", \"material\", parseMaterial);\n    parseLibrary(collada, \"library_cameras\", \"camera\", parseCamera);\n    parseLibrary(collada, \"library_lights\", \"light\", parseLight);\n    parseLibrary(collada, \"library_geometries\", \"geometry\", parseGeometry);\n    parseLibrary(collada, \"library_nodes\", \"node\", parseNode);\n    parseLibrary(collada, \"library_visual_scenes\", \"visual_scene\", parseVisualScene);\n    parseLibrary(collada, \"library_kinematics_models\", \"kinematics_model\", parseKinematicsModel);\n    parseLibrary(collada, \"library_physics_models\", \"physics_model\", parsePhysicsModel);\n    parseLibrary(collada, \"scene\", \"instance_kinematics_scene\", parseKinematicsScene);\n    buildLibrary(library.animations, buildAnimation);\n    buildLibrary(library.clips, buildAnimationClip);\n    buildLibrary(library.controllers, buildController);\n    buildLibrary(library.images, buildImage);\n    buildLibrary(library.effects, buildEffect);\n    buildLibrary(library.materials, buildMaterial);\n    buildLibrary(library.cameras, buildCamera);\n    buildLibrary(library.lights, buildLight);\n    buildLibrary(library.geometries, buildGeometry);\n    buildLibrary(library.visualScenes, buildVisualScene);\n    setupAnimations();\n    setupKinematics();\n    const scene = parseScene(getElementsByTagName(collada, \"scene\")[0]);\n    scene.animations = animations;\n    if (asset.upAxis === \"Z_UP\") {\n      scene.quaternion.setFromEuler(new Euler(-Math.PI / 2, 0, 0));\n    }\n    scene.scale.multiplyScalar(asset.unit);\n    return {\n      get animations() {\n        console.warn(\"THREE.ColladaLoader: Please access animations over scene.animations now.\");\n        return animations;\n      },\n      kinematics,\n      library,\n      scene\n    };\n  }\n}\nexport {\n  ColladaLoader\n};\n"]},"metadata":{},"sourceType":"module"}