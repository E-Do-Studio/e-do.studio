{"ast":null,"code":"import { FloatType, Scene, Camera, Mesh, PlaneGeometry, NearestFilter, ShaderMaterial, ClampToEdgeWrapping, WebGLRenderTarget, RGBAFormat, DataTexture, NoToneMapping } from \"three\";\n\nclass GPUComputationRenderer {\n  constructor(sizeX, sizeY, renderer) {\n    this.variables = [];\n    this.currentTextureIndex = 0;\n    let dataType = FloatType;\n    const scene = new Scene();\n    const camera = new Camera();\n    camera.position.z = 1;\n    const passThruUniforms = {\n      passThruTexture: {\n        value: null\n      }\n    };\n    const passThruShader = createShaderMaterial(getPassThroughFragmentShader(), passThruUniforms);\n    const mesh = new Mesh(new PlaneGeometry(2, 2), passThruShader);\n    scene.add(mesh);\n\n    this.setDataType = function (type) {\n      dataType = type;\n      return this;\n    };\n\n    this.addVariable = function (variableName, computeFragmentShader, initialValueTexture) {\n      const material = this.createShaderMaterial(computeFragmentShader);\n      const variable = {\n        name: variableName,\n        initialValueTexture,\n        material,\n        dependencies: null,\n        renderTargets: [],\n        wrapS: null,\n        wrapT: null,\n        minFilter: NearestFilter,\n        magFilter: NearestFilter\n      };\n      this.variables.push(variable);\n      return variable;\n    };\n\n    this.setVariableDependencies = function (variable, dependencies) {\n      variable.dependencies = dependencies;\n    };\n\n    this.init = function () {\n      if (renderer.capabilities.isWebGL2 === false && renderer.extensions.has(\"OES_texture_float\") === false) {\n        return \"No OES_texture_float support for float textures.\";\n      }\n\n      if (renderer.capabilities.maxVertexTextures === 0) {\n        return \"No support for vertex shader textures.\";\n      }\n\n      for (let i = 0; i < this.variables.length; i++) {\n        const variable = this.variables[i];\n        variable.renderTargets[0] = this.createRenderTarget(sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter);\n        variable.renderTargets[1] = this.createRenderTarget(sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter);\n        this.renderTexture(variable.initialValueTexture, variable.renderTargets[0]);\n        this.renderTexture(variable.initialValueTexture, variable.renderTargets[1]);\n        const material = variable.material;\n        const uniforms = material.uniforms;\n\n        if (variable.dependencies !== null) {\n          for (let d = 0; d < variable.dependencies.length; d++) {\n            const depVar = variable.dependencies[d];\n\n            if (depVar.name !== variable.name) {\n              let found = false;\n\n              for (let j = 0; j < this.variables.length; j++) {\n                if (depVar.name === this.variables[j].name) {\n                  found = true;\n                  break;\n                }\n              }\n\n              if (!found) {\n                return \"Variable dependency not found. Variable=\" + variable.name + \", dependency=\" + depVar.name;\n              }\n            }\n\n            uniforms[depVar.name] = {\n              value: null\n            };\n            material.fragmentShader = \"\\nuniform sampler2D \" + depVar.name + \";\\n\" + material.fragmentShader;\n          }\n        }\n      }\n\n      this.currentTextureIndex = 0;\n      return null;\n    };\n\n    this.compute = function () {\n      const currentTextureIndex = this.currentTextureIndex;\n      const nextTextureIndex = this.currentTextureIndex === 0 ? 1 : 0;\n\n      for (let i = 0, il = this.variables.length; i < il; i++) {\n        const variable = this.variables[i];\n\n        if (variable.dependencies !== null) {\n          const uniforms = variable.material.uniforms;\n\n          for (let d = 0, dl = variable.dependencies.length; d < dl; d++) {\n            const depVar = variable.dependencies[d];\n            uniforms[depVar.name].value = depVar.renderTargets[currentTextureIndex].texture;\n          }\n        }\n\n        this.doRenderTarget(variable.material, variable.renderTargets[nextTextureIndex]);\n      }\n\n      this.currentTextureIndex = nextTextureIndex;\n    };\n\n    this.getCurrentRenderTarget = function (variable) {\n      return variable.renderTargets[this.currentTextureIndex];\n    };\n\n    this.getAlternateRenderTarget = function (variable) {\n      return variable.renderTargets[this.currentTextureIndex === 0 ? 1 : 0];\n    };\n\n    this.dispose = function () {\n      mesh.geometry.dispose();\n      mesh.material.dispose();\n      const variables = this.variables;\n\n      for (let i = 0; i < variables.length; i++) {\n        const variable = variables[i];\n        if (variable.initialValueTexture) variable.initialValueTexture.dispose();\n        const renderTargets = variable.renderTargets;\n\n        for (let j = 0; j < renderTargets.length; j++) {\n          const renderTarget = renderTargets[j];\n          renderTarget.dispose();\n        }\n      }\n    };\n\n    function addResolutionDefine(materialShader) {\n      materialShader.defines.resolution = \"vec2( \" + sizeX.toFixed(1) + \", \" + sizeY.toFixed(1) + \" )\";\n    }\n\n    this.addResolutionDefine = addResolutionDefine;\n\n    function createShaderMaterial(computeFragmentShader, uniforms) {\n      uniforms = uniforms || {};\n      const material = new ShaderMaterial({\n        uniforms,\n        vertexShader: getPassThroughVertexShader(),\n        fragmentShader: computeFragmentShader\n      });\n      addResolutionDefine(material);\n      return material;\n    }\n\n    this.createShaderMaterial = createShaderMaterial;\n\n    this.createRenderTarget = function (sizeXTexture, sizeYTexture, wrapS, wrapT, minFilter, magFilter) {\n      sizeXTexture = sizeXTexture || sizeX;\n      sizeYTexture = sizeYTexture || sizeY;\n      wrapS = wrapS || ClampToEdgeWrapping;\n      wrapT = wrapT || ClampToEdgeWrapping;\n      minFilter = minFilter || NearestFilter;\n      magFilter = magFilter || NearestFilter;\n      const renderTarget = new WebGLRenderTarget(sizeXTexture, sizeYTexture, {\n        wrapS,\n        wrapT,\n        minFilter,\n        magFilter,\n        format: RGBAFormat,\n        type: dataType,\n        depthBuffer: false\n      });\n      return renderTarget;\n    };\n\n    this.createTexture = function () {\n      const data = new Float32Array(sizeX * sizeY * 4);\n      const texture = new DataTexture(data, sizeX, sizeY, RGBAFormat, FloatType);\n      texture.needsUpdate = true;\n      return texture;\n    };\n\n    this.renderTexture = function (input, output) {\n      passThruUniforms.passThruTexture.value = input;\n      this.doRenderTarget(passThruShader, output);\n      passThruUniforms.passThruTexture.value = null;\n    };\n\n    this.doRenderTarget = function (material, output) {\n      const currentRenderTarget = renderer.getRenderTarget();\n      const currentXrEnabled = renderer.xr.enabled;\n      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n      const currentOutputColorSpace = renderer.outputColorSpace;\n      const currentToneMapping = renderer.toneMapping;\n      renderer.xr.enabled = false;\n      renderer.shadowMap.autoUpdate = false;\n      if (\"outputColorSpace\" in renderer) renderer.outputColorSpace = \"srgb-linear\";else renderer.encoding = 3e3;\n      renderer.toneMapping = NoToneMapping;\n      mesh.material = material;\n      renderer.setRenderTarget(output);\n      renderer.render(scene, camera);\n      mesh.material = passThruShader;\n      renderer.xr.enabled = currentXrEnabled;\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n      renderer.outputColorSpace = currentOutputColorSpace;\n      renderer.toneMapping = currentToneMapping;\n      renderer.setRenderTarget(currentRenderTarget);\n    };\n\n    function getPassThroughVertexShader() {\n      return \"void main()\t{\\n\\n\tgl_Position = vec4( position, 1.0 );\\n\\n}\\n\";\n    }\n\n    function getPassThroughFragmentShader() {\n      return \"uniform sampler2D passThruTexture;\\n\\nvoid main() {\\n\\n\tvec2 uv = gl_FragCoord.xy / resolution.xy;\\n\\n\tgl_FragColor = texture2D( passThruTexture, uv );\\n\\n}\\n\";\n    }\n  }\n\n}\n\nexport { GPUComputationRenderer };","map":{"version":3,"sources":["/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/three-stdlib/misc/GPUComputationRenderer.js"],"names":["FloatType","Scene","Camera","Mesh","PlaneGeometry","NearestFilter","ShaderMaterial","ClampToEdgeWrapping","WebGLRenderTarget","RGBAFormat","DataTexture","NoToneMapping","GPUComputationRenderer","constructor","sizeX","sizeY","renderer","variables","currentTextureIndex","dataType","scene","camera","position","z","passThruUniforms","passThruTexture","value","passThruShader","createShaderMaterial","getPassThroughFragmentShader","mesh","add","setDataType","type","addVariable","variableName","computeFragmentShader","initialValueTexture","material","variable","name","dependencies","renderTargets","wrapS","wrapT","minFilter","magFilter","push","setVariableDependencies","init","capabilities","isWebGL2","extensions","has","maxVertexTextures","i","length","createRenderTarget","renderTexture","uniforms","d","depVar","found","j","fragmentShader","compute","nextTextureIndex","il","dl","texture","doRenderTarget","getCurrentRenderTarget","getAlternateRenderTarget","dispose","geometry","renderTarget","addResolutionDefine","materialShader","defines","resolution","toFixed","vertexShader","getPassThroughVertexShader","sizeXTexture","sizeYTexture","format","depthBuffer","createTexture","data","Float32Array","needsUpdate","input","output","currentRenderTarget","getRenderTarget","currentXrEnabled","xr","enabled","currentShadowAutoUpdate","shadowMap","autoUpdate","currentOutputColorSpace","outputColorSpace","currentToneMapping","toneMapping","encoding","setRenderTarget","render"],"mappings":"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","sourcesContent":["import { FloatType, Scene, Camera, Mesh, PlaneGeometry, NearestFilter, ShaderMaterial, ClampToEdgeWrapping, WebGLRenderTarget, RGBAFormat, DataTexture, NoToneMapping } from \"three\";\nclass GPUComputationRenderer {\n  constructor(sizeX, sizeY, renderer) {\n    this.variables = [];\n    this.currentTextureIndex = 0;\n    let dataType = FloatType;\n    const scene = new Scene();\n    const camera = new Camera();\n    camera.position.z = 1;\n    const passThruUniforms = {\n      passThruTexture: { value: null }\n    };\n    const passThruShader = createShaderMaterial(getPassThroughFragmentShader(), passThruUniforms);\n    const mesh = new Mesh(new PlaneGeometry(2, 2), passThruShader);\n    scene.add(mesh);\n    this.setDataType = function(type) {\n      dataType = type;\n      return this;\n    };\n    this.addVariable = function(variableName, computeFragmentShader, initialValueTexture) {\n      const material = this.createShaderMaterial(computeFragmentShader);\n      const variable = {\n        name: variableName,\n        initialValueTexture,\n        material,\n        dependencies: null,\n        renderTargets: [],\n        wrapS: null,\n        wrapT: null,\n        minFilter: NearestFilter,\n        magFilter: NearestFilter\n      };\n      this.variables.push(variable);\n      return variable;\n    };\n    this.setVariableDependencies = function(variable, dependencies) {\n      variable.dependencies = dependencies;\n    };\n    this.init = function() {\n      if (renderer.capabilities.isWebGL2 === false && renderer.extensions.has(\"OES_texture_float\") === false) {\n        return \"No OES_texture_float support for float textures.\";\n      }\n      if (renderer.capabilities.maxVertexTextures === 0) {\n        return \"No support for vertex shader textures.\";\n      }\n      for (let i = 0; i < this.variables.length; i++) {\n        const variable = this.variables[i];\n        variable.renderTargets[0] = this.createRenderTarget(\n          sizeX,\n          sizeY,\n          variable.wrapS,\n          variable.wrapT,\n          variable.minFilter,\n          variable.magFilter\n        );\n        variable.renderTargets[1] = this.createRenderTarget(\n          sizeX,\n          sizeY,\n          variable.wrapS,\n          variable.wrapT,\n          variable.minFilter,\n          variable.magFilter\n        );\n        this.renderTexture(variable.initialValueTexture, variable.renderTargets[0]);\n        this.renderTexture(variable.initialValueTexture, variable.renderTargets[1]);\n        const material = variable.material;\n        const uniforms = material.uniforms;\n        if (variable.dependencies !== null) {\n          for (let d = 0; d < variable.dependencies.length; d++) {\n            const depVar = variable.dependencies[d];\n            if (depVar.name !== variable.name) {\n              let found = false;\n              for (let j = 0; j < this.variables.length; j++) {\n                if (depVar.name === this.variables[j].name) {\n                  found = true;\n                  break;\n                }\n              }\n              if (!found) {\n                return \"Variable dependency not found. Variable=\" + variable.name + \", dependency=\" + depVar.name;\n              }\n            }\n            uniforms[depVar.name] = { value: null };\n            material.fragmentShader = \"\\nuniform sampler2D \" + depVar.name + \";\\n\" + material.fragmentShader;\n          }\n        }\n      }\n      this.currentTextureIndex = 0;\n      return null;\n    };\n    this.compute = function() {\n      const currentTextureIndex = this.currentTextureIndex;\n      const nextTextureIndex = this.currentTextureIndex === 0 ? 1 : 0;\n      for (let i = 0, il = this.variables.length; i < il; i++) {\n        const variable = this.variables[i];\n        if (variable.dependencies !== null) {\n          const uniforms = variable.material.uniforms;\n          for (let d = 0, dl = variable.dependencies.length; d < dl; d++) {\n            const depVar = variable.dependencies[d];\n            uniforms[depVar.name].value = depVar.renderTargets[currentTextureIndex].texture;\n          }\n        }\n        this.doRenderTarget(variable.material, variable.renderTargets[nextTextureIndex]);\n      }\n      this.currentTextureIndex = nextTextureIndex;\n    };\n    this.getCurrentRenderTarget = function(variable) {\n      return variable.renderTargets[this.currentTextureIndex];\n    };\n    this.getAlternateRenderTarget = function(variable) {\n      return variable.renderTargets[this.currentTextureIndex === 0 ? 1 : 0];\n    };\n    this.dispose = function() {\n      mesh.geometry.dispose();\n      mesh.material.dispose();\n      const variables = this.variables;\n      for (let i = 0; i < variables.length; i++) {\n        const variable = variables[i];\n        if (variable.initialValueTexture)\n          variable.initialValueTexture.dispose();\n        const renderTargets = variable.renderTargets;\n        for (let j = 0; j < renderTargets.length; j++) {\n          const renderTarget = renderTargets[j];\n          renderTarget.dispose();\n        }\n      }\n    };\n    function addResolutionDefine(materialShader) {\n      materialShader.defines.resolution = \"vec2( \" + sizeX.toFixed(1) + \", \" + sizeY.toFixed(1) + \" )\";\n    }\n    this.addResolutionDefine = addResolutionDefine;\n    function createShaderMaterial(computeFragmentShader, uniforms) {\n      uniforms = uniforms || {};\n      const material = new ShaderMaterial({\n        uniforms,\n        vertexShader: getPassThroughVertexShader(),\n        fragmentShader: computeFragmentShader\n      });\n      addResolutionDefine(material);\n      return material;\n    }\n    this.createShaderMaterial = createShaderMaterial;\n    this.createRenderTarget = function(sizeXTexture, sizeYTexture, wrapS, wrapT, minFilter, magFilter) {\n      sizeXTexture = sizeXTexture || sizeX;\n      sizeYTexture = sizeYTexture || sizeY;\n      wrapS = wrapS || ClampToEdgeWrapping;\n      wrapT = wrapT || ClampToEdgeWrapping;\n      minFilter = minFilter || NearestFilter;\n      magFilter = magFilter || NearestFilter;\n      const renderTarget = new WebGLRenderTarget(sizeXTexture, sizeYTexture, {\n        wrapS,\n        wrapT,\n        minFilter,\n        magFilter,\n        format: RGBAFormat,\n        type: dataType,\n        depthBuffer: false\n      });\n      return renderTarget;\n    };\n    this.createTexture = function() {\n      const data = new Float32Array(sizeX * sizeY * 4);\n      const texture = new DataTexture(data, sizeX, sizeY, RGBAFormat, FloatType);\n      texture.needsUpdate = true;\n      return texture;\n    };\n    this.renderTexture = function(input, output) {\n      passThruUniforms.passThruTexture.value = input;\n      this.doRenderTarget(passThruShader, output);\n      passThruUniforms.passThruTexture.value = null;\n    };\n    this.doRenderTarget = function(material, output) {\n      const currentRenderTarget = renderer.getRenderTarget();\n      const currentXrEnabled = renderer.xr.enabled;\n      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n      const currentOutputColorSpace = renderer.outputColorSpace;\n      const currentToneMapping = renderer.toneMapping;\n      renderer.xr.enabled = false;\n      renderer.shadowMap.autoUpdate = false;\n      if (\"outputColorSpace\" in renderer)\n        renderer.outputColorSpace = \"srgb-linear\";\n      else\n        renderer.encoding = 3e3;\n      renderer.toneMapping = NoToneMapping;\n      mesh.material = material;\n      renderer.setRenderTarget(output);\n      renderer.render(scene, camera);\n      mesh.material = passThruShader;\n      renderer.xr.enabled = currentXrEnabled;\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n      renderer.outputColorSpace = currentOutputColorSpace;\n      renderer.toneMapping = currentToneMapping;\n      renderer.setRenderTarget(currentRenderTarget);\n    };\n    function getPassThroughVertexShader() {\n      return \"void main()\t{\\n\\n\tgl_Position = vec4( position, 1.0 );\\n\\n}\\n\";\n    }\n    function getPassThroughFragmentShader() {\n      return \"uniform sampler2D passThruTexture;\\n\\nvoid main() {\\n\\n\tvec2 uv = gl_FragCoord.xy / resolution.xy;\\n\\n\tgl_FragColor = texture2D( passThruTexture, uv );\\n\\n}\\n\";\n    }\n  }\n}\nexport {\n  GPUComputationRenderer\n};\n"]},"metadata":{},"sourceType":"module"}