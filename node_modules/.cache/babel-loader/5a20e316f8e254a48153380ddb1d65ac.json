{"ast":null,"code":"import { CompressedTextureLoader, RGBAFormat, RGB_ETC1_Format, RGBA_S3TC_DXT5_Format, RGBA_S3TC_DXT3_Format, RGB_S3TC_DXT1_Format } from \"three\";\n\nclass DDSLoader extends CompressedTextureLoader {\n  constructor(manager) {\n    super(manager);\n  }\n\n  parse(buffer, loadMipmaps) {\n    const dds = {\n      mipmaps: [],\n      width: 0,\n      height: 0,\n      format: null,\n      mipmapCount: 1\n    };\n    const DDS_MAGIC = 542327876;\n    const DDSD_MIPMAPCOUNT = 131072;\n    const DDSCAPS2_CUBEMAP = 512;\n    const DDSCAPS2_CUBEMAP_POSITIVEX = 1024;\n    const DDSCAPS2_CUBEMAP_NEGATIVEX = 2048;\n    const DDSCAPS2_CUBEMAP_POSITIVEY = 4096;\n    const DDSCAPS2_CUBEMAP_NEGATIVEY = 8192;\n    const DDSCAPS2_CUBEMAP_POSITIVEZ = 16384;\n    const DDSCAPS2_CUBEMAP_NEGATIVEZ = 32768;\n    const DDPF_FOURCC = 4;\n\n    function fourCCToInt32(value) {\n      return value.charCodeAt(0) + (value.charCodeAt(1) << 8) + (value.charCodeAt(2) << 16) + (value.charCodeAt(3) << 24);\n    }\n\n    function int32ToFourCC(value) {\n      return String.fromCharCode(value & 255, value >> 8 & 255, value >> 16 & 255, value >> 24 & 255);\n    }\n\n    function loadARGBMip(buffer2, dataOffset2, width, height) {\n      const dataLength = width * height * 4;\n      const srcBuffer = new Uint8Array(buffer2, dataOffset2, dataLength);\n      const byteArray = new Uint8Array(dataLength);\n      let dst = 0;\n      let src = 0;\n\n      for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n          const b = srcBuffer[src];\n          src++;\n          const g = srcBuffer[src];\n          src++;\n          const r = srcBuffer[src];\n          src++;\n          const a = srcBuffer[src];\n          src++;\n          byteArray[dst] = r;\n          dst++;\n          byteArray[dst] = g;\n          dst++;\n          byteArray[dst] = b;\n          dst++;\n          byteArray[dst] = a;\n          dst++;\n        }\n      }\n\n      return byteArray;\n    }\n\n    const FOURCC_DXT1 = fourCCToInt32(\"DXT1\");\n    const FOURCC_DXT3 = fourCCToInt32(\"DXT3\");\n    const FOURCC_DXT5 = fourCCToInt32(\"DXT5\");\n    const FOURCC_ETC1 = fourCCToInt32(\"ETC1\");\n    const headerLengthInt = 31;\n    const off_magic = 0;\n    const off_size = 1;\n    const off_flags = 2;\n    const off_height = 3;\n    const off_width = 4;\n    const off_mipmapCount = 7;\n    const off_pfFlags = 20;\n    const off_pfFourCC = 21;\n    const off_RGBBitCount = 22;\n    const off_RBitMask = 23;\n    const off_GBitMask = 24;\n    const off_BBitMask = 25;\n    const off_ABitMask = 26;\n    const off_caps2 = 28;\n    const header = new Int32Array(buffer, 0, headerLengthInt);\n\n    if (header[off_magic] !== DDS_MAGIC) {\n      console.error(\"THREE.DDSLoader.parse: Invalid magic number in DDS header.\");\n      return dds;\n    }\n\n    if (!header[off_pfFlags] & DDPF_FOURCC) {\n      console.error(\"THREE.DDSLoader.parse: Unsupported format, must contain a FourCC code.\");\n      return dds;\n    }\n\n    let blockBytes;\n    const fourCC = header[off_pfFourCC];\n    let isRGBAUncompressed = false;\n\n    switch (fourCC) {\n      case FOURCC_DXT1:\n        blockBytes = 8;\n        dds.format = RGB_S3TC_DXT1_Format;\n        break;\n\n      case FOURCC_DXT3:\n        blockBytes = 16;\n        dds.format = RGBA_S3TC_DXT3_Format;\n        break;\n\n      case FOURCC_DXT5:\n        blockBytes = 16;\n        dds.format = RGBA_S3TC_DXT5_Format;\n        break;\n\n      case FOURCC_ETC1:\n        blockBytes = 8;\n        dds.format = RGB_ETC1_Format;\n        break;\n\n      default:\n        if (header[off_RGBBitCount] === 32 && header[off_RBitMask] & 16711680 && header[off_GBitMask] & 65280 && header[off_BBitMask] & 255 && header[off_ABitMask] & 4278190080) {\n          isRGBAUncompressed = true;\n          blockBytes = 64;\n          dds.format = RGBAFormat;\n        } else {\n          console.error(\"THREE.DDSLoader.parse: Unsupported FourCC code \", int32ToFourCC(fourCC));\n          return dds;\n        }\n\n    }\n\n    dds.mipmapCount = 1;\n\n    if (header[off_flags] & DDSD_MIPMAPCOUNT && loadMipmaps !== false) {\n      dds.mipmapCount = Math.max(1, header[off_mipmapCount]);\n    }\n\n    const caps2 = header[off_caps2];\n    dds.isCubemap = caps2 & DDSCAPS2_CUBEMAP ? true : false;\n\n    if (dds.isCubemap && (!(caps2 & DDSCAPS2_CUBEMAP_POSITIVEX) || !(caps2 & DDSCAPS2_CUBEMAP_NEGATIVEX) || !(caps2 & DDSCAPS2_CUBEMAP_POSITIVEY) || !(caps2 & DDSCAPS2_CUBEMAP_NEGATIVEY) || !(caps2 & DDSCAPS2_CUBEMAP_POSITIVEZ) || !(caps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ))) {\n      console.error(\"THREE.DDSLoader.parse: Incomplete cubemap faces\");\n      return dds;\n    }\n\n    dds.width = header[off_width];\n    dds.height = header[off_height];\n    let dataOffset = header[off_size] + 4;\n    const faces = dds.isCubemap ? 6 : 1;\n\n    for (let face = 0; face < faces; face++) {\n      let width = dds.width;\n      let height = dds.height;\n\n      for (let i = 0; i < dds.mipmapCount; i++) {\n        let byteArray, dataLength;\n\n        if (isRGBAUncompressed) {\n          byteArray = loadARGBMip(buffer, dataOffset, width, height);\n          dataLength = byteArray.length;\n        } else {\n          dataLength = Math.max(4, width) / 4 * Math.max(4, height) / 4 * blockBytes;\n          byteArray = new Uint8Array(buffer, dataOffset, dataLength);\n        }\n\n        const mipmap = {\n          data: byteArray,\n          width,\n          height\n        };\n        dds.mipmaps.push(mipmap);\n        dataOffset += dataLength;\n        width = Math.max(width >> 1, 1);\n        height = Math.max(height >> 1, 1);\n      }\n    }\n\n    return dds;\n  }\n\n}\n\nexport { DDSLoader };","map":{"version":3,"sources":["/Users/theodaguier/_workdir/dev/pro/e-do/E-Do-Studio/node_modules/three-stdlib/loaders/DDSLoader.js"],"names":["CompressedTextureLoader","RGBAFormat","RGB_ETC1_Format","RGBA_S3TC_DXT5_Format","RGBA_S3TC_DXT3_Format","RGB_S3TC_DXT1_Format","DDSLoader","constructor","manager","parse","buffer","loadMipmaps","dds","mipmaps","width","height","format","mipmapCount","DDS_MAGIC","DDSD_MIPMAPCOUNT","DDSCAPS2_CUBEMAP","DDSCAPS2_CUBEMAP_POSITIVEX","DDSCAPS2_CUBEMAP_NEGATIVEX","DDSCAPS2_CUBEMAP_POSITIVEY","DDSCAPS2_CUBEMAP_NEGATIVEY","DDSCAPS2_CUBEMAP_POSITIVEZ","DDSCAPS2_CUBEMAP_NEGATIVEZ","DDPF_FOURCC","fourCCToInt32","value","charCodeAt","int32ToFourCC","String","fromCharCode","loadARGBMip","buffer2","dataOffset2","dataLength","srcBuffer","Uint8Array","byteArray","dst","src","y","x","b","g","r","a","FOURCC_DXT1","FOURCC_DXT3","FOURCC_DXT5","FOURCC_ETC1","headerLengthInt","off_magic","off_size","off_flags","off_height","off_width","off_mipmapCount","off_pfFlags","off_pfFourCC","off_RGBBitCount","off_RBitMask","off_GBitMask","off_BBitMask","off_ABitMask","off_caps2","header","Int32Array","console","error","blockBytes","fourCC","isRGBAUncompressed","Math","max","caps2","isCubemap","dataOffset","faces","face","i","length","mipmap","data","push"],"mappings":"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","sourcesContent":["import { CompressedTextureLoader, RGBAFormat, RGB_ETC1_Format, RGBA_S3TC_DXT5_Format, RGBA_S3TC_DXT3_Format, RGB_S3TC_DXT1_Format } from \"three\";\nclass DDSLoader extends CompressedTextureLoader {\n  constructor(manager) {\n    super(manager);\n  }\n  parse(buffer, loadMipmaps) {\n    const dds = { mipmaps: [], width: 0, height: 0, format: null, mipmapCount: 1 };\n    const DDS_MAGIC = 542327876;\n    const DDSD_MIPMAPCOUNT = 131072;\n    const DDSCAPS2_CUBEMAP = 512;\n    const DDSCAPS2_CUBEMAP_POSITIVEX = 1024;\n    const DDSCAPS2_CUBEMAP_NEGATIVEX = 2048;\n    const DDSCAPS2_CUBEMAP_POSITIVEY = 4096;\n    const DDSCAPS2_CUBEMAP_NEGATIVEY = 8192;\n    const DDSCAPS2_CUBEMAP_POSITIVEZ = 16384;\n    const DDSCAPS2_CUBEMAP_NEGATIVEZ = 32768;\n    const DDPF_FOURCC = 4;\n    function fourCCToInt32(value) {\n      return value.charCodeAt(0) + (value.charCodeAt(1) << 8) + (value.charCodeAt(2) << 16) + (value.charCodeAt(3) << 24);\n    }\n    function int32ToFourCC(value) {\n      return String.fromCharCode(value & 255, value >> 8 & 255, value >> 16 & 255, value >> 24 & 255);\n    }\n    function loadARGBMip(buffer2, dataOffset2, width, height) {\n      const dataLength = width * height * 4;\n      const srcBuffer = new Uint8Array(buffer2, dataOffset2, dataLength);\n      const byteArray = new Uint8Array(dataLength);\n      let dst = 0;\n      let src = 0;\n      for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n          const b = srcBuffer[src];\n          src++;\n          const g = srcBuffer[src];\n          src++;\n          const r = srcBuffer[src];\n          src++;\n          const a = srcBuffer[src];\n          src++;\n          byteArray[dst] = r;\n          dst++;\n          byteArray[dst] = g;\n          dst++;\n          byteArray[dst] = b;\n          dst++;\n          byteArray[dst] = a;\n          dst++;\n        }\n      }\n      return byteArray;\n    }\n    const FOURCC_DXT1 = fourCCToInt32(\"DXT1\");\n    const FOURCC_DXT3 = fourCCToInt32(\"DXT3\");\n    const FOURCC_DXT5 = fourCCToInt32(\"DXT5\");\n    const FOURCC_ETC1 = fourCCToInt32(\"ETC1\");\n    const headerLengthInt = 31;\n    const off_magic = 0;\n    const off_size = 1;\n    const off_flags = 2;\n    const off_height = 3;\n    const off_width = 4;\n    const off_mipmapCount = 7;\n    const off_pfFlags = 20;\n    const off_pfFourCC = 21;\n    const off_RGBBitCount = 22;\n    const off_RBitMask = 23;\n    const off_GBitMask = 24;\n    const off_BBitMask = 25;\n    const off_ABitMask = 26;\n    const off_caps2 = 28;\n    const header = new Int32Array(buffer, 0, headerLengthInt);\n    if (header[off_magic] !== DDS_MAGIC) {\n      console.error(\"THREE.DDSLoader.parse: Invalid magic number in DDS header.\");\n      return dds;\n    }\n    if (!header[off_pfFlags] & DDPF_FOURCC) {\n      console.error(\"THREE.DDSLoader.parse: Unsupported format, must contain a FourCC code.\");\n      return dds;\n    }\n    let blockBytes;\n    const fourCC = header[off_pfFourCC];\n    let isRGBAUncompressed = false;\n    switch (fourCC) {\n      case FOURCC_DXT1:\n        blockBytes = 8;\n        dds.format = RGB_S3TC_DXT1_Format;\n        break;\n      case FOURCC_DXT3:\n        blockBytes = 16;\n        dds.format = RGBA_S3TC_DXT3_Format;\n        break;\n      case FOURCC_DXT5:\n        blockBytes = 16;\n        dds.format = RGBA_S3TC_DXT5_Format;\n        break;\n      case FOURCC_ETC1:\n        blockBytes = 8;\n        dds.format = RGB_ETC1_Format;\n        break;\n      default:\n        if (header[off_RGBBitCount] === 32 && header[off_RBitMask] & 16711680 && header[off_GBitMask] & 65280 && header[off_BBitMask] & 255 && header[off_ABitMask] & 4278190080) {\n          isRGBAUncompressed = true;\n          blockBytes = 64;\n          dds.format = RGBAFormat;\n        } else {\n          console.error(\"THREE.DDSLoader.parse: Unsupported FourCC code \", int32ToFourCC(fourCC));\n          return dds;\n        }\n    }\n    dds.mipmapCount = 1;\n    if (header[off_flags] & DDSD_MIPMAPCOUNT && loadMipmaps !== false) {\n      dds.mipmapCount = Math.max(1, header[off_mipmapCount]);\n    }\n    const caps2 = header[off_caps2];\n    dds.isCubemap = caps2 & DDSCAPS2_CUBEMAP ? true : false;\n    if (dds.isCubemap && (!(caps2 & DDSCAPS2_CUBEMAP_POSITIVEX) || !(caps2 & DDSCAPS2_CUBEMAP_NEGATIVEX) || !(caps2 & DDSCAPS2_CUBEMAP_POSITIVEY) || !(caps2 & DDSCAPS2_CUBEMAP_NEGATIVEY) || !(caps2 & DDSCAPS2_CUBEMAP_POSITIVEZ) || !(caps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ))) {\n      console.error(\"THREE.DDSLoader.parse: Incomplete cubemap faces\");\n      return dds;\n    }\n    dds.width = header[off_width];\n    dds.height = header[off_height];\n    let dataOffset = header[off_size] + 4;\n    const faces = dds.isCubemap ? 6 : 1;\n    for (let face = 0; face < faces; face++) {\n      let width = dds.width;\n      let height = dds.height;\n      for (let i = 0; i < dds.mipmapCount; i++) {\n        let byteArray, dataLength;\n        if (isRGBAUncompressed) {\n          byteArray = loadARGBMip(buffer, dataOffset, width, height);\n          dataLength = byteArray.length;\n        } else {\n          dataLength = Math.max(4, width) / 4 * Math.max(4, height) / 4 * blockBytes;\n          byteArray = new Uint8Array(buffer, dataOffset, dataLength);\n        }\n        const mipmap = { data: byteArray, width, height };\n        dds.mipmaps.push(mipmap);\n        dataOffset += dataLength;\n        width = Math.max(width >> 1, 1);\n        height = Math.max(height >> 1, 1);\n      }\n    }\n    return dds;\n  }\n}\nexport {\n  DDSLoader\n};\n"]},"metadata":{},"sourceType":"module"}