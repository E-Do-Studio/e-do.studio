{"ast":null,"code":"import { Object3D, Vector3, Quaternion, AnimationMixer } from \"three\";\nimport { CCDIKSolver } from \"./CCDIKSolver.js\";\nimport { MMDPhysics } from \"./MMDPhysics.js\";\n\nclass MMDAnimationHelper {\n  /**\n   * @param {Object} params - (optional)\n   * @param {boolean} params.sync - Whether animation durations of added objects are synched. Default is true.\n   * @param {Number} params.afterglow - Default is 0.0.\n   * @param {boolean} params.resetPhysicsOnLoop - Default is true.\n   */\n  constructor(params = {}) {\n    this.meshes = [];\n    this.camera = null;\n    this.cameraTarget = new Object3D();\n    this.cameraTarget.name = \"target\";\n    this.audio = null;\n    this.audioManager = null;\n    this.objects = /* @__PURE__ */new WeakMap();\n    this.configuration = {\n      sync: params.sync !== void 0 ? params.sync : true,\n      afterglow: params.afterglow !== void 0 ? params.afterglow : 0,\n      resetPhysicsOnLoop: params.resetPhysicsOnLoop !== void 0 ? params.resetPhysicsOnLoop : true,\n      pmxAnimation: params.pmxAnimation !== void 0 ? params.pmxAnimation : false\n    };\n    this.enabled = {\n      animation: true,\n      ik: true,\n      grant: true,\n      physics: true,\n      cameraAnimation: true\n    };\n\n    this.onBeforePhysics = function () {};\n\n    this.sharedPhysics = false;\n    this.masterPhysics = null;\n  }\n  /**\n   * Adds an Three.js Object to helper and setups animation.\n   * The anmation durations of added objects are synched\n   * if this.configuration.sync is true.\n   *\n   * @param {THREE.SkinnedMesh|THREE.Camera|THREE.Audio} object\n   * @param {Object} params - (optional)\n   * @param {THREE.AnimationClip|Array<THREE.AnimationClip>} params.animation - Only for THREE.SkinnedMesh and THREE.Camera. Default is undefined.\n   * @param {boolean} params.physics - Only for THREE.SkinnedMesh. Default is true.\n   * @param {Integer} params.warmup - Only for THREE.SkinnedMesh and physics is true. Default is 60.\n   * @param {Number} params.unitStep - Only for THREE.SkinnedMesh and physics is true. Default is 1 / 65.\n   * @param {Integer} params.maxStepNum - Only for THREE.SkinnedMesh and physics is true. Default is 3.\n   * @param {Vector3} params.gravity - Only for THREE.SkinnedMesh and physics is true. Default ( 0, - 9.8 * 10, 0 ).\n   * @param {Number} params.delayTime - Only for THREE.Audio. Default is 0.0.\n   * @return {MMDAnimationHelper}\n   */\n\n\n  add(object, params = {}) {\n    if (object.isSkinnedMesh) {\n      this._addMesh(object, params);\n    } else if (object.isCamera) {\n      this._setupCamera(object, params);\n    } else if (object.type === \"Audio\") {\n      this._setupAudio(object, params);\n    } else {\n      throw new Error(\"THREE.MMDAnimationHelper.add: accepts only THREE.SkinnedMesh or THREE.Camera or THREE.Audio instance.\");\n    }\n\n    if (this.configuration.sync) this._syncDuration();\n    return this;\n  }\n  /**\n   * Removes an Three.js Object from helper.\n   *\n   * @param {THREE.SkinnedMesh|THREE.Camera|THREE.Audio} object\n   * @return {MMDAnimationHelper}\n   */\n\n\n  remove(object) {\n    if (object.isSkinnedMesh) {\n      this._removeMesh(object);\n    } else if (object.isCamera) {\n      this._clearCamera(object);\n    } else if (object.type === \"Audio\") {\n      this._clearAudio(object);\n    } else {\n      throw new Error(\"THREE.MMDAnimationHelper.remove: accepts only THREE.SkinnedMesh or THREE.Camera or THREE.Audio instance.\");\n    }\n\n    if (this.configuration.sync) this._syncDuration();\n    return this;\n  }\n  /**\n   * Updates the animation.\n   *\n   * @param {Number} delta\n   * @return {MMDAnimationHelper}\n   */\n\n\n  update(delta) {\n    if (this.audioManager !== null) this.audioManager.control(delta);\n\n    for (let i = 0; i < this.meshes.length; i++) {\n      this._animateMesh(this.meshes[i], delta);\n    }\n\n    if (this.sharedPhysics) this._updateSharedPhysics(delta);\n    if (this.camera !== null) this._animateCamera(this.camera, delta);\n    return this;\n  }\n  /**\n   * Changes the pose of SkinnedMesh as VPD specifies.\n   *\n   * @param {THREE.SkinnedMesh} mesh\n   * @param {Object} vpd - VPD content parsed MMDParser\n   * @param {Object} params - (optional)\n   * @param {boolean} params.resetPose - Default is true.\n   * @param {boolean} params.ik - Default is true.\n   * @param {boolean} params.grant - Default is true.\n   * @return {MMDAnimationHelper}\n   */\n\n\n  pose(mesh, vpd, params = {}) {\n    if (params.resetPose !== false) mesh.pose();\n    const bones = mesh.skeleton.bones;\n    const boneParams = vpd.bones;\n    const boneNameDictionary = {};\n\n    for (let i = 0, il = bones.length; i < il; i++) {\n      boneNameDictionary[bones[i].name] = i;\n    }\n\n    const vector = new Vector3();\n    const quaternion = new Quaternion();\n\n    for (let i = 0, il = boneParams.length; i < il; i++) {\n      const boneParam = boneParams[i];\n      const boneIndex = boneNameDictionary[boneParam.name];\n      if (boneIndex === void 0) continue;\n      const bone = bones[boneIndex];\n      bone.position.add(vector.fromArray(boneParam.translation));\n      bone.quaternion.multiply(quaternion.fromArray(boneParam.quaternion));\n    }\n\n    mesh.updateMatrixWorld(true);\n\n    if (this.configuration.pmxAnimation && mesh.geometry.userData.MMD && mesh.geometry.userData.MMD.format === \"pmx\") {\n      const sortedBonesData = this._sortBoneDataArray(mesh.geometry.userData.MMD.bones.slice());\n\n      const ikSolver = params.ik !== false ? this._createCCDIKSolver(mesh) : null;\n      const grantSolver = params.grant !== false ? this.createGrantSolver(mesh) : null;\n\n      this._animatePMXMesh(mesh, sortedBonesData, ikSolver, grantSolver);\n    } else {\n      if (params.ik !== false) {\n        this._createCCDIKSolver(mesh).update();\n      }\n\n      if (params.grant !== false) {\n        this.createGrantSolver(mesh).update();\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Enabes/Disables an animation feature.\n   *\n   * @param {string} key\n   * @param {boolean} enabled\n   * @return {MMDAnimationHelper}\n   */\n\n\n  enable(key, enabled) {\n    if (this.enabled[key] === void 0) {\n      throw new Error(\"THREE.MMDAnimationHelper.enable: unknown key \" + key);\n    }\n\n    this.enabled[key] = enabled;\n\n    if (key === \"physics\") {\n      for (let i = 0, il = this.meshes.length; i < il; i++) {\n        this._optimizeIK(this.meshes[i], enabled);\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Creates an GrantSolver instance.\n   *\n   * @param {THREE.SkinnedMesh} mesh\n   * @return {GrantSolver}\n   */\n\n\n  createGrantSolver(mesh) {\n    return new GrantSolver(mesh, mesh.geometry.userData.MMD.grants);\n  } // private methods\n\n\n  _addMesh(mesh, params) {\n    if (this.meshes.indexOf(mesh) >= 0) {\n      throw new Error(\"THREE.MMDAnimationHelper._addMesh: SkinnedMesh '\" + mesh.name + \"' has already been added.\");\n    }\n\n    this.meshes.push(mesh);\n    this.objects.set(mesh, {\n      looped: false\n    });\n\n    this._setupMeshAnimation(mesh, params.animation);\n\n    if (params.physics !== false) {\n      this._setupMeshPhysics(mesh, params);\n    }\n\n    return this;\n  }\n\n  _setupCamera(camera, params) {\n    if (this.camera === camera) {\n      throw new Error(\"THREE.MMDAnimationHelper._setupCamera: Camera '\" + camera.name + \"' has already been set.\");\n    }\n\n    if (this.camera) this.clearCamera(this.camera);\n    this.camera = camera;\n    camera.add(this.cameraTarget);\n    this.objects.set(camera, {});\n\n    if (params.animation !== void 0) {\n      this._setupCameraAnimation(camera, params.animation);\n    }\n\n    return this;\n  }\n\n  _setupAudio(audio, params) {\n    if (this.audio === audio) {\n      throw new Error(\"THREE.MMDAnimationHelper._setupAudio: Audio '\" + audio.name + \"' has already been set.\");\n    }\n\n    if (this.audio) this.clearAudio(this.audio);\n    this.audio = audio;\n    this.audioManager = new AudioManager(audio, params);\n    this.objects.set(this.audioManager, {\n      duration: this.audioManager.duration\n    });\n    return this;\n  }\n\n  _removeMesh(mesh) {\n    let found = false;\n    let writeIndex = 0;\n\n    for (let i = 0, il = this.meshes.length; i < il; i++) {\n      if (this.meshes[i] === mesh) {\n        this.objects.delete(mesh);\n        found = true;\n        continue;\n      }\n\n      this.meshes[writeIndex++] = this.meshes[i];\n    }\n\n    if (!found) {\n      throw new Error(\"THREE.MMDAnimationHelper._removeMesh: SkinnedMesh '\" + mesh.name + \"' has not been added yet.\");\n    }\n\n    this.meshes.length = writeIndex;\n    return this;\n  }\n\n  _clearCamera(camera) {\n    if (camera !== this.camera) {\n      throw new Error(\"THREE.MMDAnimationHelper._clearCamera: Camera '\" + camera.name + \"' has not been set yet.\");\n    }\n\n    this.camera.remove(this.cameraTarget);\n    this.objects.delete(this.camera);\n    this.camera = null;\n    return this;\n  }\n\n  _clearAudio(audio) {\n    if (audio !== this.audio) {\n      throw new Error(\"THREE.MMDAnimationHelper._clearAudio: Audio '\" + audio.name + \"' has not been set yet.\");\n    }\n\n    this.objects.delete(this.audioManager);\n    this.audio = null;\n    this.audioManager = null;\n    return this;\n  }\n\n  _setupMeshAnimation(mesh, animation) {\n    const objects = this.objects.get(mesh);\n\n    if (animation !== void 0) {\n      const animations = Array.isArray(animation) ? animation : [animation];\n      objects.mixer = new AnimationMixer(mesh);\n\n      for (let i = 0, il = animations.length; i < il; i++) {\n        objects.mixer.clipAction(animations[i]).play();\n      }\n\n      objects.mixer.addEventListener(\"loop\", function (event) {\n        const tracks = event.action._clip.tracks;\n        if (tracks.length > 0 && tracks[0].name.slice(0, 6) !== \".bones\") return;\n        objects.looped = true;\n      });\n    }\n\n    objects.ikSolver = this._createCCDIKSolver(mesh);\n    objects.grantSolver = this.createGrantSolver(mesh);\n    return this;\n  }\n\n  _setupCameraAnimation(camera, animation) {\n    const animations = Array.isArray(animation) ? animation : [animation];\n    const objects = this.objects.get(camera);\n    objects.mixer = new AnimationMixer(camera);\n\n    for (let i = 0, il = animations.length; i < il; i++) {\n      objects.mixer.clipAction(animations[i]).play();\n    }\n  }\n\n  _setupMeshPhysics(mesh, params) {\n    const objects = this.objects.get(mesh);\n\n    if (params.world === void 0 && this.sharedPhysics) {\n      const masterPhysics = this._getMasterPhysics();\n\n      if (masterPhysics !== null) world = masterPhysics.world;\n    }\n\n    objects.physics = this._createMMDPhysics(mesh, params);\n\n    if (objects.mixer && params.animationWarmup !== false) {\n      this._animateMesh(mesh, 0);\n\n      objects.physics.reset();\n    }\n\n    objects.physics.warmup(params.warmup !== void 0 ? params.warmup : 60);\n\n    this._optimizeIK(mesh, true);\n  }\n\n  _animateMesh(mesh, delta) {\n    const objects = this.objects.get(mesh);\n    const mixer = objects.mixer;\n    const ikSolver = objects.ikSolver;\n    const grantSolver = objects.grantSolver;\n    const physics = objects.physics;\n    const looped = objects.looped;\n\n    if (mixer && this.enabled.animation) {\n      this._restoreBones(mesh);\n\n      mixer.update(delta);\n\n      this._saveBones(mesh);\n\n      if (this.configuration.pmxAnimation && mesh.geometry.userData.MMD && mesh.geometry.userData.MMD.format === \"pmx\") {\n        if (!objects.sortedBonesData) objects.sortedBonesData = this._sortBoneDataArray(mesh.geometry.userData.MMD.bones.slice());\n\n        this._animatePMXMesh(mesh, objects.sortedBonesData, ikSolver && this.enabled.ik ? ikSolver : null, grantSolver && this.enabled.grant ? grantSolver : null);\n      } else {\n        if (ikSolver && this.enabled.ik) {\n          mesh.updateMatrixWorld(true);\n          ikSolver.update();\n        }\n\n        if (grantSolver && this.enabled.grant) {\n          grantSolver.update();\n        }\n      }\n    }\n\n    if (looped === true && this.enabled.physics) {\n      if (physics && this.configuration.resetPhysicsOnLoop) physics.reset();\n      objects.looped = false;\n    }\n\n    if (physics && this.enabled.physics && !this.sharedPhysics) {\n      this.onBeforePhysics(mesh);\n      physics.update(delta);\n    }\n  } // Sort bones in order by 1. transformationClass and 2. bone index.\n  // In PMX animation system, bone transformations should be processed\n  // in this order.\n\n\n  _sortBoneDataArray(boneDataArray) {\n    return boneDataArray.sort(function (a, b) {\n      if (a.transformationClass !== b.transformationClass) {\n        return a.transformationClass - b.transformationClass;\n      } else {\n        return a.index - b.index;\n      }\n    });\n  } // PMX Animation system is a bit too complex and doesn't great match to\n  // Three.js Animation system. This method attempts to simulate it as much as\n  // possible but doesn't perfectly simulate.\n  // This method is more costly than the regular one so\n  // you are recommended to set constructor parameter \"pmxAnimation: true\"\n  // only if your PMX model animation doesn't work well.\n  // If you need better method you would be required to write your own.\n\n\n  _animatePMXMesh(mesh, sortedBonesData, ikSolver, grantSolver) {\n    _quaternionIndex = 0;\n\n    _grantResultMap.clear();\n\n    for (let i = 0, il = sortedBonesData.length; i < il; i++) {\n      updateOne(mesh, sortedBonesData[i].index, ikSolver, grantSolver);\n    }\n\n    mesh.updateMatrixWorld(true);\n    return this;\n  }\n\n  _animateCamera(camera, delta) {\n    const mixer = this.objects.get(camera).mixer;\n\n    if (mixer && this.enabled.cameraAnimation) {\n      mixer.update(delta);\n      camera.updateProjectionMatrix();\n      camera.up.set(0, 1, 0);\n      camera.up.applyQuaternion(camera.quaternion);\n      camera.lookAt(this.cameraTarget.position);\n    }\n  }\n\n  _optimizeIK(mesh, physicsEnabled) {\n    const iks = mesh.geometry.userData.MMD.iks;\n    const bones = mesh.geometry.userData.MMD.bones;\n\n    for (let i = 0, il = iks.length; i < il; i++) {\n      const ik = iks[i];\n      const links = ik.links;\n\n      for (let j = 0, jl = links.length; j < jl; j++) {\n        const link = links[j];\n\n        if (physicsEnabled === true) {\n          link.enabled = bones[link.index].rigidBodyType > 0 ? false : true;\n        } else {\n          link.enabled = true;\n        }\n      }\n    }\n  }\n\n  _createCCDIKSolver(mesh) {\n    if (CCDIKSolver === void 0) {\n      throw new Error(\"THREE.MMDAnimationHelper: Import CCDIKSolver.\");\n    }\n\n    return new CCDIKSolver(mesh, mesh.geometry.userData.MMD.iks);\n  }\n\n  _createMMDPhysics(mesh, params) {\n    if (MMDPhysics === void 0) {\n      throw new Error(\"THREE.MMDPhysics: Import MMDPhysics.\");\n    }\n\n    return new MMDPhysics(mesh, mesh.geometry.userData.MMD.rigidBodies, mesh.geometry.userData.MMD.constraints, params);\n  }\n  /*\n   * Detects the longest duration and then sets it to them to sync.\n   * TODO: Not to access private properties ( ._actions and ._clip )\n   */\n\n\n  _syncDuration() {\n    let max = 0;\n    const objects = this.objects;\n    const meshes = this.meshes;\n    const camera = this.camera;\n    const audioManager = this.audioManager;\n\n    for (let i = 0, il = meshes.length; i < il; i++) {\n      const mixer = this.objects.get(meshes[i]).mixer;\n      if (mixer === void 0) continue;\n\n      for (let j = 0; j < mixer._actions.length; j++) {\n        const clip = mixer._actions[j]._clip;\n\n        if (!objects.has(clip)) {\n          objects.set(clip, {\n            duration: clip.duration\n          });\n        }\n\n        max = Math.max(max, objects.get(clip).duration);\n      }\n    }\n\n    if (camera !== null) {\n      const mixer = this.objects.get(camera).mixer;\n\n      if (mixer !== void 0) {\n        for (let i = 0, il = mixer._actions.length; i < il; i++) {\n          const clip = mixer._actions[i]._clip;\n\n          if (!objects.has(clip)) {\n            objects.set(clip, {\n              duration: clip.duration\n            });\n          }\n\n          max = Math.max(max, objects.get(clip).duration);\n        }\n      }\n    }\n\n    if (audioManager !== null) {\n      max = Math.max(max, objects.get(audioManager).duration);\n    }\n\n    max += this.configuration.afterglow;\n\n    for (let i = 0, il = this.meshes.length; i < il; i++) {\n      const mixer = this.objects.get(this.meshes[i]).mixer;\n      if (mixer === void 0) continue;\n\n      for (let j = 0, jl = mixer._actions.length; j < jl; j++) {\n        mixer._actions[j]._clip.duration = max;\n      }\n    }\n\n    if (camera !== null) {\n      const mixer = this.objects.get(camera).mixer;\n\n      if (mixer !== void 0) {\n        for (let i = 0, il = mixer._actions.length; i < il; i++) {\n          mixer._actions[i]._clip.duration = max;\n        }\n      }\n    }\n\n    if (audioManager !== null) {\n      audioManager.duration = max;\n    }\n  } // workaround\n\n\n  _updatePropertyMixersBuffer(mesh) {\n    const mixer = this.objects.get(mesh).mixer;\n    const propertyMixers = mixer._bindings;\n    const accuIndex = mixer._accuIndex;\n\n    for (let i = 0, il = propertyMixers.length; i < il; i++) {\n      const propertyMixer = propertyMixers[i];\n      const buffer = propertyMixer.buffer;\n      const stride = propertyMixer.valueSize;\n      const offset = (accuIndex + 1) * stride;\n      propertyMixer.binding.getValue(buffer, offset);\n    }\n  }\n  /*\n   * Avoiding these two issues by restore/save bones before/after mixer animation.\n   *\n   * 1. PropertyMixer used by AnimationMixer holds cache value in .buffer.\n   *    Calculating IK, Grant, and Physics after mixer animation can break\n   *    the cache coherency.\n   *\n   * 2. Applying Grant two or more times without reset the posing breaks model.\n   */\n\n\n  _saveBones(mesh) {\n    const objects = this.objects.get(mesh);\n    const bones = mesh.skeleton.bones;\n    let backupBones = objects.backupBones;\n\n    if (backupBones === void 0) {\n      backupBones = new Float32Array(bones.length * 7);\n      objects.backupBones = backupBones;\n    }\n\n    for (let i = 0, il = bones.length; i < il; i++) {\n      const bone = bones[i];\n      bone.position.toArray(backupBones, i * 7);\n      bone.quaternion.toArray(backupBones, i * 7 + 3);\n    }\n  }\n\n  _restoreBones(mesh) {\n    const objects = this.objects.get(mesh);\n    const backupBones = objects.backupBones;\n    if (backupBones === void 0) return;\n    const bones = mesh.skeleton.bones;\n\n    for (let i = 0, il = bones.length; i < il; i++) {\n      const bone = bones[i];\n      bone.position.fromArray(backupBones, i * 7);\n      bone.quaternion.fromArray(backupBones, i * 7 + 3);\n    }\n  } // experimental\n\n\n  _getMasterPhysics() {\n    if (this.masterPhysics !== null) return this.masterPhysics;\n\n    for (let i = 0, il = this.meshes.length; i < il; i++) {\n      const physics = this.meshes[i].physics;\n\n      if (physics !== void 0 && physics !== null) {\n        this.masterPhysics = physics;\n        return this.masterPhysics;\n      }\n    }\n\n    return null;\n  }\n\n  _updateSharedPhysics(delta) {\n    if (this.meshes.length === 0 || !this.enabled.physics || !this.sharedPhysics) return;\n\n    const physics = this._getMasterPhysics();\n\n    if (physics === null) return;\n\n    for (let i = 0, il = this.meshes.length; i < il; i++) {\n      const p = this.meshes[i].physics;\n\n      if (p !== null && p !== void 0) {\n        p.updateRigidBodies();\n      }\n    }\n\n    physics.stepSimulation(delta);\n\n    for (let i = 0, il = this.meshes.length; i < il; i++) {\n      const p = this.meshes[i].physics;\n\n      if (p !== null && p !== void 0) {\n        p.updateBones();\n      }\n    }\n  }\n\n}\n\nconst _quaternions = [];\nlet _quaternionIndex = 0;\n\nfunction getQuaternion() {\n  if (_quaternionIndex >= _quaternions.length) {\n    _quaternions.push(new Quaternion());\n  }\n\n  return _quaternions[_quaternionIndex++];\n}\n\nconst _grantResultMap = /* @__PURE__ */new Map();\n\nfunction updateOne(mesh, boneIndex, ikSolver, grantSolver) {\n  const bones = mesh.skeleton.bones;\n  const bonesData = mesh.geometry.userData.MMD.bones;\n  const boneData = bonesData[boneIndex];\n  const bone = bones[boneIndex];\n  if (_grantResultMap.has(boneIndex)) return;\n  const quaternion = getQuaternion();\n\n  _grantResultMap.set(boneIndex, quaternion.copy(bone.quaternion));\n\n  if (grantSolver && boneData.grant && !boneData.grant.isLocal && boneData.grant.affectRotation) {\n    const parentIndex = boneData.grant.parentIndex;\n    const ratio = boneData.grant.ratio;\n\n    if (!_grantResultMap.has(parentIndex)) {\n      updateOne(mesh, parentIndex, ikSolver, grantSolver);\n    }\n\n    grantSolver.addGrantRotation(bone, _grantResultMap.get(parentIndex), ratio);\n  }\n\n  if (ikSolver && boneData.ik) {\n    mesh.updateMatrixWorld(true);\n    ikSolver.updateOne(boneData.ik);\n    const links = boneData.ik.links;\n\n    for (let i = 0, il = links.length; i < il; i++) {\n      const link = links[i];\n      if (link.enabled === false) continue;\n      const linkIndex = link.index;\n\n      if (_grantResultMap.has(linkIndex)) {\n        _grantResultMap.set(linkIndex, _grantResultMap.get(linkIndex).copy(bones[linkIndex].quaternion));\n      }\n    }\n  }\n\n  quaternion.copy(bone.quaternion);\n}\n\nclass AudioManager {\n  /**\n   * @param {THREE.Audio} audio\n   * @param {Object} params - (optional)\n   * @param {Nuumber} params.delayTime\n   */\n  constructor(audio, params = {}) {\n    this.audio = audio;\n    this.elapsedTime = 0;\n    this.currentTime = 0;\n    this.delayTime = params.delayTime !== void 0 ? params.delayTime : 0;\n    this.audioDuration = this.audio.buffer.duration;\n    this.duration = this.audioDuration + this.delayTime;\n  }\n  /**\n   * @param {Number} delta\n   * @return {AudioManager}\n   */\n\n\n  control(delta) {\n    this.elapsed += delta;\n    this.currentTime += delta;\n    if (this._shouldStopAudio()) this.audio.stop();\n    if (this._shouldStartAudio()) this.audio.play();\n    return this;\n  } // private methods\n\n\n  _shouldStartAudio() {\n    if (this.audio.isPlaying) return false;\n\n    while (this.currentTime >= this.duration) {\n      this.currentTime -= this.duration;\n    }\n\n    if (this.currentTime < this.delayTime) return false;\n    if (this.currentTime - this.delayTime > this.audioDuration) return false;\n    return true;\n  }\n\n  _shouldStopAudio() {\n    return this.audio.isPlaying && this.currentTime >= this.duration;\n  }\n\n}\n\nconst _q = /* @__PURE__ */new Quaternion();\n\nclass GrantSolver {\n  constructor(mesh, grants = []) {\n    this.mesh = mesh;\n    this.grants = grants;\n  }\n  /**\n   * Solve all the grant bones\n   * @return {GrantSolver}\n   */\n\n\n  update() {\n    const grants = this.grants;\n\n    for (let i = 0, il = grants.length; i < il; i++) {\n      this.updateOne(grants[i]);\n    }\n\n    return this;\n  }\n  /**\n   * Solve a grant bone\n   * @param {Object} grant - grant parameter\n   * @return {GrantSolver}\n   */\n\n\n  updateOne(grant) {\n    const bones = this.mesh.skeleton.bones;\n    const bone = bones[grant.index];\n    const parentBone = bones[grant.parentIndex];\n\n    if (grant.isLocal) {\n      if (grant.affectPosition) {}\n\n      if (grant.affectRotation) {}\n    } else {\n      if (grant.affectPosition) {}\n\n      if (grant.affectRotation) {\n        this.addGrantRotation(bone, parentBone.quaternion, grant.ratio);\n      }\n    }\n\n    return this;\n  }\n\n  addGrantRotation(bone, q, ratio) {\n    _q.set(0, 0, 0, 1);\n\n    _q.slerp(q, ratio);\n\n    bone.quaternion.multiply(_q);\n    return this;\n  }\n\n}\n\nexport { MMDAnimationHelper };","map":{"version":3,"sources":["/Users/theodaguier/_workdir/dev/pro/e-do/E-Do-Studio/node_modules/three-stdlib/animation/MMDAnimationHelper.js"],"names":["Object3D","Vector3","Quaternion","AnimationMixer","CCDIKSolver","MMDPhysics","MMDAnimationHelper","constructor","params","meshes","camera","cameraTarget","name","audio","audioManager","objects","WeakMap","configuration","sync","afterglow","resetPhysicsOnLoop","pmxAnimation","enabled","animation","ik","grant","physics","cameraAnimation","onBeforePhysics","sharedPhysics","masterPhysics","add","object","isSkinnedMesh","_addMesh","isCamera","_setupCamera","type","_setupAudio","Error","_syncDuration","remove","_removeMesh","_clearCamera","_clearAudio","update","delta","control","i","length","_animateMesh","_updateSharedPhysics","_animateCamera","pose","mesh","vpd","resetPose","bones","skeleton","boneParams","boneNameDictionary","il","vector","quaternion","boneParam","boneIndex","bone","position","fromArray","translation","multiply","updateMatrixWorld","geometry","userData","MMD","format","sortedBonesData","_sortBoneDataArray","slice","ikSolver","_createCCDIKSolver","grantSolver","createGrantSolver","_animatePMXMesh","enable","key","_optimizeIK","GrantSolver","grants","indexOf","push","set","looped","_setupMeshAnimation","_setupMeshPhysics","clearCamera","_setupCameraAnimation","clearAudio","AudioManager","duration","found","writeIndex","delete","get","animations","Array","isArray","mixer","clipAction","play","addEventListener","event","tracks","action","_clip","world","_getMasterPhysics","_createMMDPhysics","animationWarmup","reset","warmup","_restoreBones","_saveBones","boneDataArray","sort","a","b","transformationClass","index","_quaternionIndex","_grantResultMap","clear","updateOne","updateProjectionMatrix","up","applyQuaternion","lookAt","physicsEnabled","iks","links","j","jl","link","rigidBodyType","rigidBodies","constraints","max","_actions","clip","has","Math","_updatePropertyMixersBuffer","propertyMixers","_bindings","accuIndex","_accuIndex","propertyMixer","buffer","stride","valueSize","offset","binding","getValue","backupBones","Float32Array","toArray","p","updateRigidBodies","stepSimulation","updateBones","_quaternions","getQuaternion","Map","bonesData","boneData","copy","isLocal","affectRotation","parentIndex","ratio","addGrantRotation","linkIndex","elapsedTime","currentTime","delayTime","audioDuration","elapsed","_shouldStopAudio","stop","_shouldStartAudio","isPlaying","_q","parentBone","affectPosition","q","slerp"],"mappings":"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","sourcesContent":["import { Object3D, Vector3, Quaternion, AnimationMixer } from \"three\";\nimport { CCDIKSolver } from \"./CCDIKSolver.js\";\nimport { MMDPhysics } from \"./MMDPhysics.js\";\nclass MMDAnimationHelper {\n  /**\n   * @param {Object} params - (optional)\n   * @param {boolean} params.sync - Whether animation durations of added objects are synched. Default is true.\n   * @param {Number} params.afterglow - Default is 0.0.\n   * @param {boolean} params.resetPhysicsOnLoop - Default is true.\n   */\n  constructor(params = {}) {\n    this.meshes = [];\n    this.camera = null;\n    this.cameraTarget = new Object3D();\n    this.cameraTarget.name = \"target\";\n    this.audio = null;\n    this.audioManager = null;\n    this.objects = /* @__PURE__ */ new WeakMap();\n    this.configuration = {\n      sync: params.sync !== void 0 ? params.sync : true,\n      afterglow: params.afterglow !== void 0 ? params.afterglow : 0,\n      resetPhysicsOnLoop: params.resetPhysicsOnLoop !== void 0 ? params.resetPhysicsOnLoop : true,\n      pmxAnimation: params.pmxAnimation !== void 0 ? params.pmxAnimation : false\n    };\n    this.enabled = {\n      animation: true,\n      ik: true,\n      grant: true,\n      physics: true,\n      cameraAnimation: true\n    };\n    this.onBeforePhysics = function() {\n    };\n    this.sharedPhysics = false;\n    this.masterPhysics = null;\n  }\n  /**\n   * Adds an Three.js Object to helper and setups animation.\n   * The anmation durations of added objects are synched\n   * if this.configuration.sync is true.\n   *\n   * @param {THREE.SkinnedMesh|THREE.Camera|THREE.Audio} object\n   * @param {Object} params - (optional)\n   * @param {THREE.AnimationClip|Array<THREE.AnimationClip>} params.animation - Only for THREE.SkinnedMesh and THREE.Camera. Default is undefined.\n   * @param {boolean} params.physics - Only for THREE.SkinnedMesh. Default is true.\n   * @param {Integer} params.warmup - Only for THREE.SkinnedMesh and physics is true. Default is 60.\n   * @param {Number} params.unitStep - Only for THREE.SkinnedMesh and physics is true. Default is 1 / 65.\n   * @param {Integer} params.maxStepNum - Only for THREE.SkinnedMesh and physics is true. Default is 3.\n   * @param {Vector3} params.gravity - Only for THREE.SkinnedMesh and physics is true. Default ( 0, - 9.8 * 10, 0 ).\n   * @param {Number} params.delayTime - Only for THREE.Audio. Default is 0.0.\n   * @return {MMDAnimationHelper}\n   */\n  add(object, params = {}) {\n    if (object.isSkinnedMesh) {\n      this._addMesh(object, params);\n    } else if (object.isCamera) {\n      this._setupCamera(object, params);\n    } else if (object.type === \"Audio\") {\n      this._setupAudio(object, params);\n    } else {\n      throw new Error(\n        \"THREE.MMDAnimationHelper.add: accepts only THREE.SkinnedMesh or THREE.Camera or THREE.Audio instance.\"\n      );\n    }\n    if (this.configuration.sync)\n      this._syncDuration();\n    return this;\n  }\n  /**\n   * Removes an Three.js Object from helper.\n   *\n   * @param {THREE.SkinnedMesh|THREE.Camera|THREE.Audio} object\n   * @return {MMDAnimationHelper}\n   */\n  remove(object) {\n    if (object.isSkinnedMesh) {\n      this._removeMesh(object);\n    } else if (object.isCamera) {\n      this._clearCamera(object);\n    } else if (object.type === \"Audio\") {\n      this._clearAudio(object);\n    } else {\n      throw new Error(\n        \"THREE.MMDAnimationHelper.remove: accepts only THREE.SkinnedMesh or THREE.Camera or THREE.Audio instance.\"\n      );\n    }\n    if (this.configuration.sync)\n      this._syncDuration();\n    return this;\n  }\n  /**\n   * Updates the animation.\n   *\n   * @param {Number} delta\n   * @return {MMDAnimationHelper}\n   */\n  update(delta) {\n    if (this.audioManager !== null)\n      this.audioManager.control(delta);\n    for (let i = 0; i < this.meshes.length; i++) {\n      this._animateMesh(this.meshes[i], delta);\n    }\n    if (this.sharedPhysics)\n      this._updateSharedPhysics(delta);\n    if (this.camera !== null)\n      this._animateCamera(this.camera, delta);\n    return this;\n  }\n  /**\n   * Changes the pose of SkinnedMesh as VPD specifies.\n   *\n   * @param {THREE.SkinnedMesh} mesh\n   * @param {Object} vpd - VPD content parsed MMDParser\n   * @param {Object} params - (optional)\n   * @param {boolean} params.resetPose - Default is true.\n   * @param {boolean} params.ik - Default is true.\n   * @param {boolean} params.grant - Default is true.\n   * @return {MMDAnimationHelper}\n   */\n  pose(mesh, vpd, params = {}) {\n    if (params.resetPose !== false)\n      mesh.pose();\n    const bones = mesh.skeleton.bones;\n    const boneParams = vpd.bones;\n    const boneNameDictionary = {};\n    for (let i = 0, il = bones.length; i < il; i++) {\n      boneNameDictionary[bones[i].name] = i;\n    }\n    const vector = new Vector3();\n    const quaternion = new Quaternion();\n    for (let i = 0, il = boneParams.length; i < il; i++) {\n      const boneParam = boneParams[i];\n      const boneIndex = boneNameDictionary[boneParam.name];\n      if (boneIndex === void 0)\n        continue;\n      const bone = bones[boneIndex];\n      bone.position.add(vector.fromArray(boneParam.translation));\n      bone.quaternion.multiply(quaternion.fromArray(boneParam.quaternion));\n    }\n    mesh.updateMatrixWorld(true);\n    if (this.configuration.pmxAnimation && mesh.geometry.userData.MMD && mesh.geometry.userData.MMD.format === \"pmx\") {\n      const sortedBonesData = this._sortBoneDataArray(mesh.geometry.userData.MMD.bones.slice());\n      const ikSolver = params.ik !== false ? this._createCCDIKSolver(mesh) : null;\n      const grantSolver = params.grant !== false ? this.createGrantSolver(mesh) : null;\n      this._animatePMXMesh(mesh, sortedBonesData, ikSolver, grantSolver);\n    } else {\n      if (params.ik !== false) {\n        this._createCCDIKSolver(mesh).update();\n      }\n      if (params.grant !== false) {\n        this.createGrantSolver(mesh).update();\n      }\n    }\n    return this;\n  }\n  /**\n   * Enabes/Disables an animation feature.\n   *\n   * @param {string} key\n   * @param {boolean} enabled\n   * @return {MMDAnimationHelper}\n   */\n  enable(key, enabled) {\n    if (this.enabled[key] === void 0) {\n      throw new Error(\"THREE.MMDAnimationHelper.enable: unknown key \" + key);\n    }\n    this.enabled[key] = enabled;\n    if (key === \"physics\") {\n      for (let i = 0, il = this.meshes.length; i < il; i++) {\n        this._optimizeIK(this.meshes[i], enabled);\n      }\n    }\n    return this;\n  }\n  /**\n   * Creates an GrantSolver instance.\n   *\n   * @param {THREE.SkinnedMesh} mesh\n   * @return {GrantSolver}\n   */\n  createGrantSolver(mesh) {\n    return new GrantSolver(mesh, mesh.geometry.userData.MMD.grants);\n  }\n  // private methods\n  _addMesh(mesh, params) {\n    if (this.meshes.indexOf(mesh) >= 0) {\n      throw new Error(\"THREE.MMDAnimationHelper._addMesh: SkinnedMesh '\" + mesh.name + \"' has already been added.\");\n    }\n    this.meshes.push(mesh);\n    this.objects.set(mesh, { looped: false });\n    this._setupMeshAnimation(mesh, params.animation);\n    if (params.physics !== false) {\n      this._setupMeshPhysics(mesh, params);\n    }\n    return this;\n  }\n  _setupCamera(camera, params) {\n    if (this.camera === camera) {\n      throw new Error(\"THREE.MMDAnimationHelper._setupCamera: Camera '\" + camera.name + \"' has already been set.\");\n    }\n    if (this.camera)\n      this.clearCamera(this.camera);\n    this.camera = camera;\n    camera.add(this.cameraTarget);\n    this.objects.set(camera, {});\n    if (params.animation !== void 0) {\n      this._setupCameraAnimation(camera, params.animation);\n    }\n    return this;\n  }\n  _setupAudio(audio, params) {\n    if (this.audio === audio) {\n      throw new Error(\"THREE.MMDAnimationHelper._setupAudio: Audio '\" + audio.name + \"' has already been set.\");\n    }\n    if (this.audio)\n      this.clearAudio(this.audio);\n    this.audio = audio;\n    this.audioManager = new AudioManager(audio, params);\n    this.objects.set(this.audioManager, {\n      duration: this.audioManager.duration\n    });\n    return this;\n  }\n  _removeMesh(mesh) {\n    let found = false;\n    let writeIndex = 0;\n    for (let i = 0, il = this.meshes.length; i < il; i++) {\n      if (this.meshes[i] === mesh) {\n        this.objects.delete(mesh);\n        found = true;\n        continue;\n      }\n      this.meshes[writeIndex++] = this.meshes[i];\n    }\n    if (!found) {\n      throw new Error(\n        \"THREE.MMDAnimationHelper._removeMesh: SkinnedMesh '\" + mesh.name + \"' has not been added yet.\"\n      );\n    }\n    this.meshes.length = writeIndex;\n    return this;\n  }\n  _clearCamera(camera) {\n    if (camera !== this.camera) {\n      throw new Error(\"THREE.MMDAnimationHelper._clearCamera: Camera '\" + camera.name + \"' has not been set yet.\");\n    }\n    this.camera.remove(this.cameraTarget);\n    this.objects.delete(this.camera);\n    this.camera = null;\n    return this;\n  }\n  _clearAudio(audio) {\n    if (audio !== this.audio) {\n      throw new Error(\"THREE.MMDAnimationHelper._clearAudio: Audio '\" + audio.name + \"' has not been set yet.\");\n    }\n    this.objects.delete(this.audioManager);\n    this.audio = null;\n    this.audioManager = null;\n    return this;\n  }\n  _setupMeshAnimation(mesh, animation) {\n    const objects = this.objects.get(mesh);\n    if (animation !== void 0) {\n      const animations = Array.isArray(animation) ? animation : [animation];\n      objects.mixer = new AnimationMixer(mesh);\n      for (let i = 0, il = animations.length; i < il; i++) {\n        objects.mixer.clipAction(animations[i]).play();\n      }\n      objects.mixer.addEventListener(\"loop\", function(event) {\n        const tracks = event.action._clip.tracks;\n        if (tracks.length > 0 && tracks[0].name.slice(0, 6) !== \".bones\")\n          return;\n        objects.looped = true;\n      });\n    }\n    objects.ikSolver = this._createCCDIKSolver(mesh);\n    objects.grantSolver = this.createGrantSolver(mesh);\n    return this;\n  }\n  _setupCameraAnimation(camera, animation) {\n    const animations = Array.isArray(animation) ? animation : [animation];\n    const objects = this.objects.get(camera);\n    objects.mixer = new AnimationMixer(camera);\n    for (let i = 0, il = animations.length; i < il; i++) {\n      objects.mixer.clipAction(animations[i]).play();\n    }\n  }\n  _setupMeshPhysics(mesh, params) {\n    const objects = this.objects.get(mesh);\n    if (params.world === void 0 && this.sharedPhysics) {\n      const masterPhysics = this._getMasterPhysics();\n      if (masterPhysics !== null)\n        world = masterPhysics.world;\n    }\n    objects.physics = this._createMMDPhysics(mesh, params);\n    if (objects.mixer && params.animationWarmup !== false) {\n      this._animateMesh(mesh, 0);\n      objects.physics.reset();\n    }\n    objects.physics.warmup(params.warmup !== void 0 ? params.warmup : 60);\n    this._optimizeIK(mesh, true);\n  }\n  _animateMesh(mesh, delta) {\n    const objects = this.objects.get(mesh);\n    const mixer = objects.mixer;\n    const ikSolver = objects.ikSolver;\n    const grantSolver = objects.grantSolver;\n    const physics = objects.physics;\n    const looped = objects.looped;\n    if (mixer && this.enabled.animation) {\n      this._restoreBones(mesh);\n      mixer.update(delta);\n      this._saveBones(mesh);\n      if (this.configuration.pmxAnimation && mesh.geometry.userData.MMD && mesh.geometry.userData.MMD.format === \"pmx\") {\n        if (!objects.sortedBonesData)\n          objects.sortedBonesData = this._sortBoneDataArray(mesh.geometry.userData.MMD.bones.slice());\n        this._animatePMXMesh(\n          mesh,\n          objects.sortedBonesData,\n          ikSolver && this.enabled.ik ? ikSolver : null,\n          grantSolver && this.enabled.grant ? grantSolver : null\n        );\n      } else {\n        if (ikSolver && this.enabled.ik) {\n          mesh.updateMatrixWorld(true);\n          ikSolver.update();\n        }\n        if (grantSolver && this.enabled.grant) {\n          grantSolver.update();\n        }\n      }\n    }\n    if (looped === true && this.enabled.physics) {\n      if (physics && this.configuration.resetPhysicsOnLoop)\n        physics.reset();\n      objects.looped = false;\n    }\n    if (physics && this.enabled.physics && !this.sharedPhysics) {\n      this.onBeforePhysics(mesh);\n      physics.update(delta);\n    }\n  }\n  // Sort bones in order by 1. transformationClass and 2. bone index.\n  // In PMX animation system, bone transformations should be processed\n  // in this order.\n  _sortBoneDataArray(boneDataArray) {\n    return boneDataArray.sort(function(a, b) {\n      if (a.transformationClass !== b.transformationClass) {\n        return a.transformationClass - b.transformationClass;\n      } else {\n        return a.index - b.index;\n      }\n    });\n  }\n  // PMX Animation system is a bit too complex and doesn't great match to\n  // Three.js Animation system. This method attempts to simulate it as much as\n  // possible but doesn't perfectly simulate.\n  // This method is more costly than the regular one so\n  // you are recommended to set constructor parameter \"pmxAnimation: true\"\n  // only if your PMX model animation doesn't work well.\n  // If you need better method you would be required to write your own.\n  _animatePMXMesh(mesh, sortedBonesData, ikSolver, grantSolver) {\n    _quaternionIndex = 0;\n    _grantResultMap.clear();\n    for (let i = 0, il = sortedBonesData.length; i < il; i++) {\n      updateOne(mesh, sortedBonesData[i].index, ikSolver, grantSolver);\n    }\n    mesh.updateMatrixWorld(true);\n    return this;\n  }\n  _animateCamera(camera, delta) {\n    const mixer = this.objects.get(camera).mixer;\n    if (mixer && this.enabled.cameraAnimation) {\n      mixer.update(delta);\n      camera.updateProjectionMatrix();\n      camera.up.set(0, 1, 0);\n      camera.up.applyQuaternion(camera.quaternion);\n      camera.lookAt(this.cameraTarget.position);\n    }\n  }\n  _optimizeIK(mesh, physicsEnabled) {\n    const iks = mesh.geometry.userData.MMD.iks;\n    const bones = mesh.geometry.userData.MMD.bones;\n    for (let i = 0, il = iks.length; i < il; i++) {\n      const ik = iks[i];\n      const links = ik.links;\n      for (let j = 0, jl = links.length; j < jl; j++) {\n        const link = links[j];\n        if (physicsEnabled === true) {\n          link.enabled = bones[link.index].rigidBodyType > 0 ? false : true;\n        } else {\n          link.enabled = true;\n        }\n      }\n    }\n  }\n  _createCCDIKSolver(mesh) {\n    if (CCDIKSolver === void 0) {\n      throw new Error(\"THREE.MMDAnimationHelper: Import CCDIKSolver.\");\n    }\n    return new CCDIKSolver(mesh, mesh.geometry.userData.MMD.iks);\n  }\n  _createMMDPhysics(mesh, params) {\n    if (MMDPhysics === void 0) {\n      throw new Error(\"THREE.MMDPhysics: Import MMDPhysics.\");\n    }\n    return new MMDPhysics(mesh, mesh.geometry.userData.MMD.rigidBodies, mesh.geometry.userData.MMD.constraints, params);\n  }\n  /*\n   * Detects the longest duration and then sets it to them to sync.\n   * TODO: Not to access private properties ( ._actions and ._clip )\n   */\n  _syncDuration() {\n    let max = 0;\n    const objects = this.objects;\n    const meshes = this.meshes;\n    const camera = this.camera;\n    const audioManager = this.audioManager;\n    for (let i = 0, il = meshes.length; i < il; i++) {\n      const mixer = this.objects.get(meshes[i]).mixer;\n      if (mixer === void 0)\n        continue;\n      for (let j = 0; j < mixer._actions.length; j++) {\n        const clip = mixer._actions[j]._clip;\n        if (!objects.has(clip)) {\n          objects.set(clip, {\n            duration: clip.duration\n          });\n        }\n        max = Math.max(max, objects.get(clip).duration);\n      }\n    }\n    if (camera !== null) {\n      const mixer = this.objects.get(camera).mixer;\n      if (mixer !== void 0) {\n        for (let i = 0, il = mixer._actions.length; i < il; i++) {\n          const clip = mixer._actions[i]._clip;\n          if (!objects.has(clip)) {\n            objects.set(clip, {\n              duration: clip.duration\n            });\n          }\n          max = Math.max(max, objects.get(clip).duration);\n        }\n      }\n    }\n    if (audioManager !== null) {\n      max = Math.max(max, objects.get(audioManager).duration);\n    }\n    max += this.configuration.afterglow;\n    for (let i = 0, il = this.meshes.length; i < il; i++) {\n      const mixer = this.objects.get(this.meshes[i]).mixer;\n      if (mixer === void 0)\n        continue;\n      for (let j = 0, jl = mixer._actions.length; j < jl; j++) {\n        mixer._actions[j]._clip.duration = max;\n      }\n    }\n    if (camera !== null) {\n      const mixer = this.objects.get(camera).mixer;\n      if (mixer !== void 0) {\n        for (let i = 0, il = mixer._actions.length; i < il; i++) {\n          mixer._actions[i]._clip.duration = max;\n        }\n      }\n    }\n    if (audioManager !== null) {\n      audioManager.duration = max;\n    }\n  }\n  // workaround\n  _updatePropertyMixersBuffer(mesh) {\n    const mixer = this.objects.get(mesh).mixer;\n    const propertyMixers = mixer._bindings;\n    const accuIndex = mixer._accuIndex;\n    for (let i = 0, il = propertyMixers.length; i < il; i++) {\n      const propertyMixer = propertyMixers[i];\n      const buffer = propertyMixer.buffer;\n      const stride = propertyMixer.valueSize;\n      const offset = (accuIndex + 1) * stride;\n      propertyMixer.binding.getValue(buffer, offset);\n    }\n  }\n  /*\n   * Avoiding these two issues by restore/save bones before/after mixer animation.\n   *\n   * 1. PropertyMixer used by AnimationMixer holds cache value in .buffer.\n   *    Calculating IK, Grant, and Physics after mixer animation can break\n   *    the cache coherency.\n   *\n   * 2. Applying Grant two or more times without reset the posing breaks model.\n   */\n  _saveBones(mesh) {\n    const objects = this.objects.get(mesh);\n    const bones = mesh.skeleton.bones;\n    let backupBones = objects.backupBones;\n    if (backupBones === void 0) {\n      backupBones = new Float32Array(bones.length * 7);\n      objects.backupBones = backupBones;\n    }\n    for (let i = 0, il = bones.length; i < il; i++) {\n      const bone = bones[i];\n      bone.position.toArray(backupBones, i * 7);\n      bone.quaternion.toArray(backupBones, i * 7 + 3);\n    }\n  }\n  _restoreBones(mesh) {\n    const objects = this.objects.get(mesh);\n    const backupBones = objects.backupBones;\n    if (backupBones === void 0)\n      return;\n    const bones = mesh.skeleton.bones;\n    for (let i = 0, il = bones.length; i < il; i++) {\n      const bone = bones[i];\n      bone.position.fromArray(backupBones, i * 7);\n      bone.quaternion.fromArray(backupBones, i * 7 + 3);\n    }\n  }\n  // experimental\n  _getMasterPhysics() {\n    if (this.masterPhysics !== null)\n      return this.masterPhysics;\n    for (let i = 0, il = this.meshes.length; i < il; i++) {\n      const physics = this.meshes[i].physics;\n      if (physics !== void 0 && physics !== null) {\n        this.masterPhysics = physics;\n        return this.masterPhysics;\n      }\n    }\n    return null;\n  }\n  _updateSharedPhysics(delta) {\n    if (this.meshes.length === 0 || !this.enabled.physics || !this.sharedPhysics)\n      return;\n    const physics = this._getMasterPhysics();\n    if (physics === null)\n      return;\n    for (let i = 0, il = this.meshes.length; i < il; i++) {\n      const p = this.meshes[i].physics;\n      if (p !== null && p !== void 0) {\n        p.updateRigidBodies();\n      }\n    }\n    physics.stepSimulation(delta);\n    for (let i = 0, il = this.meshes.length; i < il; i++) {\n      const p = this.meshes[i].physics;\n      if (p !== null && p !== void 0) {\n        p.updateBones();\n      }\n    }\n  }\n}\nconst _quaternions = [];\nlet _quaternionIndex = 0;\nfunction getQuaternion() {\n  if (_quaternionIndex >= _quaternions.length) {\n    _quaternions.push(new Quaternion());\n  }\n  return _quaternions[_quaternionIndex++];\n}\nconst _grantResultMap = /* @__PURE__ */ new Map();\nfunction updateOne(mesh, boneIndex, ikSolver, grantSolver) {\n  const bones = mesh.skeleton.bones;\n  const bonesData = mesh.geometry.userData.MMD.bones;\n  const boneData = bonesData[boneIndex];\n  const bone = bones[boneIndex];\n  if (_grantResultMap.has(boneIndex))\n    return;\n  const quaternion = getQuaternion();\n  _grantResultMap.set(boneIndex, quaternion.copy(bone.quaternion));\n  if (grantSolver && boneData.grant && !boneData.grant.isLocal && boneData.grant.affectRotation) {\n    const parentIndex = boneData.grant.parentIndex;\n    const ratio = boneData.grant.ratio;\n    if (!_grantResultMap.has(parentIndex)) {\n      updateOne(mesh, parentIndex, ikSolver, grantSolver);\n    }\n    grantSolver.addGrantRotation(bone, _grantResultMap.get(parentIndex), ratio);\n  }\n  if (ikSolver && boneData.ik) {\n    mesh.updateMatrixWorld(true);\n    ikSolver.updateOne(boneData.ik);\n    const links = boneData.ik.links;\n    for (let i = 0, il = links.length; i < il; i++) {\n      const link = links[i];\n      if (link.enabled === false)\n        continue;\n      const linkIndex = link.index;\n      if (_grantResultMap.has(linkIndex)) {\n        _grantResultMap.set(linkIndex, _grantResultMap.get(linkIndex).copy(bones[linkIndex].quaternion));\n      }\n    }\n  }\n  quaternion.copy(bone.quaternion);\n}\nclass AudioManager {\n  /**\n   * @param {THREE.Audio} audio\n   * @param {Object} params - (optional)\n   * @param {Nuumber} params.delayTime\n   */\n  constructor(audio, params = {}) {\n    this.audio = audio;\n    this.elapsedTime = 0;\n    this.currentTime = 0;\n    this.delayTime = params.delayTime !== void 0 ? params.delayTime : 0;\n    this.audioDuration = this.audio.buffer.duration;\n    this.duration = this.audioDuration + this.delayTime;\n  }\n  /**\n   * @param {Number} delta\n   * @return {AudioManager}\n   */\n  control(delta) {\n    this.elapsed += delta;\n    this.currentTime += delta;\n    if (this._shouldStopAudio())\n      this.audio.stop();\n    if (this._shouldStartAudio())\n      this.audio.play();\n    return this;\n  }\n  // private methods\n  _shouldStartAudio() {\n    if (this.audio.isPlaying)\n      return false;\n    while (this.currentTime >= this.duration) {\n      this.currentTime -= this.duration;\n    }\n    if (this.currentTime < this.delayTime)\n      return false;\n    if (this.currentTime - this.delayTime > this.audioDuration)\n      return false;\n    return true;\n  }\n  _shouldStopAudio() {\n    return this.audio.isPlaying && this.currentTime >= this.duration;\n  }\n}\nconst _q = /* @__PURE__ */ new Quaternion();\nclass GrantSolver {\n  constructor(mesh, grants = []) {\n    this.mesh = mesh;\n    this.grants = grants;\n  }\n  /**\n   * Solve all the grant bones\n   * @return {GrantSolver}\n   */\n  update() {\n    const grants = this.grants;\n    for (let i = 0, il = grants.length; i < il; i++) {\n      this.updateOne(grants[i]);\n    }\n    return this;\n  }\n  /**\n   * Solve a grant bone\n   * @param {Object} grant - grant parameter\n   * @return {GrantSolver}\n   */\n  updateOne(grant) {\n    const bones = this.mesh.skeleton.bones;\n    const bone = bones[grant.index];\n    const parentBone = bones[grant.parentIndex];\n    if (grant.isLocal) {\n      if (grant.affectPosition) {\n      }\n      if (grant.affectRotation) {\n      }\n    } else {\n      if (grant.affectPosition) {\n      }\n      if (grant.affectRotation) {\n        this.addGrantRotation(bone, parentBone.quaternion, grant.ratio);\n      }\n    }\n    return this;\n  }\n  addGrantRotation(bone, q, ratio) {\n    _q.set(0, 0, 0, 1);\n    _q.slerp(q, ratio);\n    bone.quaternion.multiply(_q);\n    return this;\n  }\n}\nexport {\n  MMDAnimationHelper\n};\n"]},"metadata":{},"sourceType":"module"}