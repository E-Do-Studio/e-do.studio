{"ast":null,"code":"import _defineProperty from \"/Users/theodaguier/Repositories/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _regeneratorRuntime from \"/Users/theodaguier/Repositories/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/theodaguier/Repositories/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/theodaguier/Repositories/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/theodaguier/Repositories/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { PlaneGeometry, ShaderMaterial, Uniform, Mesh, PerspectiveCamera, Scene, WebGLRenderer, Texture, NearestFilter, NearestMipmapNearestFilter, NearestMipmapLinearFilter, LinearFilter, LinearMipmapNearestFilter, LinearMipmapLinearFilter, ClampToEdgeWrapping, RepeatWrapping, MirroredRepeatWrapping, Color, MathUtils, Vector3, CompressedTexture, RGBAFormat, DoubleSide, REVISION, BufferAttribute, PropertyBinding, InterpolateDiscrete, Matrix4, InterpolateLinear } from \"three\";\n\nvar _renderer;\n\nvar fullscreenQuadGeometry;\nvar fullscreenQuadMaterial;\nvar fullscreenQuad;\n\nfunction decompress(texture) {\n  var maxTextureSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;\n  var renderer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  if (!fullscreenQuadGeometry) fullscreenQuadGeometry = new PlaneGeometry(2, 2, 1, 1);\n  if (!fullscreenQuadMaterial) fullscreenQuadMaterial = new ShaderMaterial({\n    uniforms: {\n      blitTexture: new Uniform(texture)\n    },\n    vertexShader:\n    /* glsl */\n    \"\\n        varying vec2 vUv;\\n        void main(){\\n            vUv = uv;\\n            gl_Position = vec4(position.xy * 1.0,0.,.999999);\\n        }\\n      \",\n    fragmentShader:\n    /* glsl */\n    \"\\n          uniform sampler2D blitTexture; \\n          varying vec2 vUv;\\n\\n          void main(){ \\n              gl_FragColor = vec4(vUv.xy, 0, 1);\\n              \\n              #ifdef IS_SRGB\\n              gl_FragColor = LinearTosRGB( texture2D( blitTexture, vUv) );\\n              #else\\n              gl_FragColor = texture2D( blitTexture, vUv);\\n              #endif\\n          }\\n      \"\n  });\n  fullscreenQuadMaterial.uniforms.blitTexture.value = texture;\n  fullscreenQuadMaterial.defines.IS_SRGB = \"colorSpace\" in texture ? texture.colorSpace === \"srgb\" : texture.encoding === 3001;\n  fullscreenQuadMaterial.needsUpdate = true;\n\n  if (!fullscreenQuad) {\n    fullscreenQuad = new Mesh(fullscreenQuadGeometry, fullscreenQuadMaterial);\n    fullscreenQuad.frustrumCulled = false;\n  }\n\n  var _camera = new PerspectiveCamera();\n\n  var _scene = new Scene();\n\n  _scene.add(fullscreenQuad);\n\n  if (!renderer) {\n    renderer = _renderer = new WebGLRenderer({\n      antialias: false\n    });\n  }\n\n  renderer.setSize(Math.min(texture.image.width, maxTextureSize), Math.min(texture.image.height, maxTextureSize));\n  renderer.clear();\n  renderer.render(_scene, _camera);\n  var readableTexture = new Texture(renderer.domElement);\n  readableTexture.minFilter = texture.minFilter;\n  readableTexture.magFilter = texture.magFilter;\n  readableTexture.wrapS = texture.wrapS;\n  readableTexture.wrapT = texture.wrapT;\n  readableTexture.name = texture.name;\n\n  if (_renderer) {\n    _renderer.dispose();\n\n    _renderer = null;\n  }\n\n  return readableTexture;\n}\n\nvar KHR_mesh_quantization_ExtraAttrTypes = {\n  POSITION: [\"byte\", \"byte normalized\", \"unsigned byte\", \"unsigned byte normalized\", \"short\", \"short normalized\", \"unsigned short\", \"unsigned short normalized\"],\n  NORMAL: [\"byte normalized\", \"short normalized\"],\n  TANGENT: [\"byte normalized\", \"short normalized\"],\n  TEXCOORD: [\"byte\", \"byte normalized\", \"unsigned byte\", \"short\", \"short normalized\", \"unsigned short\"]\n};\n\nvar GLTFExporter = /*#__PURE__*/function () {\n  function GLTFExporter() {\n    _classCallCheck(this, GLTFExporter);\n\n    this.pluginCallbacks = [];\n    this.register(function (writer) {\n      return new GLTFLightExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsUnlitExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsTransmissionExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsVolumeExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsIorExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsSpecularExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsClearcoatExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsIridescenceExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsSheenExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsAnisotropyExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsEmissiveStrengthExtension(writer);\n    });\n  }\n\n  _createClass(GLTFExporter, [{\n    key: \"register\",\n    value: function register(callback) {\n      if (this.pluginCallbacks.indexOf(callback) === -1) {\n        this.pluginCallbacks.push(callback);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"unregister\",\n    value: function unregister(callback) {\n      if (this.pluginCallbacks.indexOf(callback) !== -1) {\n        this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);\n      }\n\n      return this;\n    }\n    /**\n     * Parse scenes and generate GLTF output\n     * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n     * @param  {Function} onDone  Callback on completed\n     * @param  {Function} onError  Callback on errors\n     * @param  {Object} options options\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(input, onDone, onError, options) {\n      var writer = new GLTFWriter();\n      var plugins = [];\n\n      for (var i = 0, il = this.pluginCallbacks.length; i < il; i++) {\n        plugins.push(this.pluginCallbacks[i](writer));\n      }\n\n      writer.setPlugins(plugins);\n      writer.write(input, onDone, options).catch(onError);\n    }\n  }, {\n    key: \"parseAsync\",\n    value: function parseAsync(input, options) {\n      var scope = this;\n      return new Promise(function (resolve, reject) {\n        scope.parse(input, resolve, reject, options);\n      });\n    }\n  }]);\n\n  return GLTFExporter;\n}();\n\nvar WEBGL_CONSTANTS = {\n  POINTS: 0,\n  LINES: 1,\n  LINE_LOOP: 2,\n  LINE_STRIP: 3,\n  TRIANGLES: 4,\n  TRIANGLE_STRIP: 5,\n  TRIANGLE_FAN: 6,\n  BYTE: 5120,\n  UNSIGNED_BYTE: 5121,\n  SHORT: 5122,\n  UNSIGNED_SHORT: 5123,\n  INT: 5124,\n  UNSIGNED_INT: 5125,\n  FLOAT: 5126,\n  ARRAY_BUFFER: 34962,\n  ELEMENT_ARRAY_BUFFER: 34963,\n  NEAREST: 9728,\n  LINEAR: 9729,\n  NEAREST_MIPMAP_NEAREST: 9984,\n  LINEAR_MIPMAP_NEAREST: 9985,\n  NEAREST_MIPMAP_LINEAR: 9986,\n  LINEAR_MIPMAP_LINEAR: 9987,\n  CLAMP_TO_EDGE: 33071,\n  MIRRORED_REPEAT: 33648,\n  REPEAT: 10497\n};\nvar KHR_MESH_QUANTIZATION = \"KHR_mesh_quantization\";\nvar THREE_TO_WEBGL = {};\nTHREE_TO_WEBGL[NearestFilter] = WEBGL_CONSTANTS.NEAREST;\nTHREE_TO_WEBGL[NearestMipmapNearestFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[NearestMipmapLinearFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR;\nTHREE_TO_WEBGL[LinearFilter] = WEBGL_CONSTANTS.LINEAR;\nTHREE_TO_WEBGL[LinearMipmapNearestFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[LinearMipmapLinearFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR;\nTHREE_TO_WEBGL[ClampToEdgeWrapping] = WEBGL_CONSTANTS.CLAMP_TO_EDGE;\nTHREE_TO_WEBGL[RepeatWrapping] = WEBGL_CONSTANTS.REPEAT;\nTHREE_TO_WEBGL[MirroredRepeatWrapping] = WEBGL_CONSTANTS.MIRRORED_REPEAT;\nvar PATH_PROPERTIES = {\n  scale: \"scale\",\n  position: \"translation\",\n  quaternion: \"rotation\",\n  morphTargetInfluences: \"weights\"\n};\nvar DEFAULT_SPECULAR_COLOR = new Color();\nvar GLB_HEADER_BYTES = 12;\nvar GLB_HEADER_MAGIC = 1179937895;\nvar GLB_VERSION = 2;\nvar GLB_CHUNK_PREFIX_BYTES = 8;\nvar GLB_CHUNK_TYPE_JSON = 1313821514;\nvar GLB_CHUNK_TYPE_BIN = 5130562;\n\nfunction equalArray(array1, array2) {\n  return array1.length === array2.length && array1.every(function (element, index) {\n    return element === array2[index];\n  });\n}\n\nfunction stringToArrayBuffer(text) {\n  return new TextEncoder().encode(text).buffer;\n}\n\nfunction isIdentityMatrix(matrix) {\n  return equalArray(matrix.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\n}\n\nfunction getMinMax(attribute, start, count) {\n  var output = {\n    min: new Array(attribute.itemSize).fill(Number.POSITIVE_INFINITY),\n    max: new Array(attribute.itemSize).fill(Number.NEGATIVE_INFINITY)\n  };\n\n  for (var i = start; i < start + count; i++) {\n    for (var a = 0; a < attribute.itemSize; a++) {\n      var value = void 0;\n\n      if (attribute.itemSize > 4) {\n        value = attribute.array[i * attribute.itemSize + a];\n      } else {\n        if (a === 0) value = attribute.getX(i);else if (a === 1) value = attribute.getY(i);else if (a === 2) value = attribute.getZ(i);else if (a === 3) value = attribute.getW(i);\n\n        if (attribute.normalized === true) {\n          value = MathUtils.normalize(value, attribute.array);\n        }\n      }\n\n      output.min[a] = Math.min(output.min[a], value);\n      output.max[a] = Math.max(output.max[a], value);\n    }\n  }\n\n  return output;\n}\n\nfunction getPaddedBufferSize(bufferSize) {\n  return Math.ceil(bufferSize / 4) * 4;\n}\n\nfunction getPaddedArrayBuffer(arrayBuffer) {\n  var paddingByte = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var paddedLength = getPaddedBufferSize(arrayBuffer.byteLength);\n\n  if (paddedLength !== arrayBuffer.byteLength) {\n    var array = new Uint8Array(paddedLength);\n    array.set(new Uint8Array(arrayBuffer));\n\n    if (paddingByte !== 0) {\n      for (var i = arrayBuffer.byteLength; i < paddedLength; i++) {\n        array[i] = paddingByte;\n      }\n    }\n\n    return array.buffer;\n  }\n\n  return arrayBuffer;\n}\n\nfunction getCanvas() {\n  if (typeof document === \"undefined\" && typeof OffscreenCanvas !== \"undefined\") {\n    return new OffscreenCanvas(1, 1);\n  }\n\n  return document.createElement(\"canvas\");\n}\n\nfunction getToBlobPromise(canvas, mimeType) {\n  if (canvas.toBlob !== void 0) {\n    return new Promise(function (resolve) {\n      return canvas.toBlob(resolve, mimeType);\n    });\n  }\n\n  var quality;\n\n  if (mimeType === \"image/jpeg\") {\n    quality = 0.92;\n  } else if (mimeType === \"image/webp\") {\n    quality = 0.8;\n  }\n\n  return canvas.convertToBlob({\n    type: mimeType,\n    quality: quality\n  });\n}\n\nvar GLTFWriter = /*#__PURE__*/function () {\n  function GLTFWriter() {\n    _classCallCheck(this, GLTFWriter);\n\n    this.plugins = [];\n    this.options = {};\n    this.pending = [];\n    this.buffers = [];\n    this.byteOffset = 0;\n    this.buffers = [];\n    this.nodeMap = /* @__PURE__ */new Map();\n    this.skins = [];\n    this.extensionsUsed = {};\n    this.extensionsRequired = {};\n    this.uids = /* @__PURE__ */new Map();\n    this.uid = 0;\n    this.json = {\n      asset: {\n        version: \"2.0\",\n        generator: \"THREE.GLTFExporter\"\n      }\n    };\n    this.cache = {\n      meshes: /* @__PURE__ */new Map(),\n      attributes: /* @__PURE__ */new Map(),\n      attributesNormalized: /* @__PURE__ */new Map(),\n      materials: /* @__PURE__ */new Map(),\n      textures: /* @__PURE__ */new Map(),\n      images: /* @__PURE__ */new Map()\n    };\n  }\n\n  _createClass(GLTFWriter, [{\n    key: \"setPlugins\",\n    value: function setPlugins(plugins) {\n      this.plugins = plugins;\n    }\n    /**\n     * Parse scenes and generate GLTF output\n     * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n     * @param  {Function} onDone  Callback on completed\n     * @param  {Object} options options\n     */\n\n  }, {\n    key: \"write\",\n    value: function () {\n      var _write = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(input, onDone) {\n        var options,\n            writer,\n            buffers,\n            json,\n            extensionsUsed,\n            extensionsRequired,\n            blob,\n            extensionsUsedList,\n            extensionsRequiredList,\n            reader,\n            _reader,\n            _args = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                options = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};\n                this.options = Object.assign({\n                  // default options\n                  binary: false,\n                  trs: false,\n                  onlyVisible: true,\n                  maxTextureSize: Infinity,\n                  animations: [],\n                  includeCustomExtensions: false\n                }, options);\n\n                if (this.options.animations.length > 0) {\n                  this.options.trs = true;\n                }\n\n                this.processInput(input);\n                _context.next = 6;\n                return Promise.all(this.pending);\n\n              case 6:\n                writer = this;\n                buffers = writer.buffers;\n                json = writer.json;\n                options = writer.options;\n                extensionsUsed = writer.extensionsUsed;\n                extensionsRequired = writer.extensionsRequired;\n                blob = new Blob(buffers, {\n                  type: \"application/octet-stream\"\n                });\n                extensionsUsedList = Object.keys(extensionsUsed);\n                extensionsRequiredList = Object.keys(extensionsRequired);\n                if (extensionsUsedList.length > 0) json.extensionsUsed = extensionsUsedList;\n                if (extensionsRequiredList.length > 0) json.extensionsRequired = extensionsRequiredList;\n                if (json.buffers && json.buffers.length > 0) json.buffers[0].byteLength = blob.size;\n\n                if (options.binary === true) {\n                  reader = new FileReader();\n                  reader.readAsArrayBuffer(blob);\n\n                  reader.onloadend = function () {\n                    var binaryChunk = getPaddedArrayBuffer(reader.result);\n                    var binaryChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\n                    binaryChunkPrefix.setUint32(0, binaryChunk.byteLength, true);\n                    binaryChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_BIN, true);\n                    var jsonChunk = getPaddedArrayBuffer(stringToArrayBuffer(JSON.stringify(json)), 32);\n                    var jsonChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\n                    jsonChunkPrefix.setUint32(0, jsonChunk.byteLength, true);\n                    jsonChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_JSON, true);\n                    var header = new ArrayBuffer(GLB_HEADER_BYTES);\n                    var headerView = new DataView(header);\n                    headerView.setUint32(0, GLB_HEADER_MAGIC, true);\n                    headerView.setUint32(4, GLB_VERSION, true);\n                    var totalByteLength = GLB_HEADER_BYTES + jsonChunkPrefix.byteLength + jsonChunk.byteLength + binaryChunkPrefix.byteLength + binaryChunk.byteLength;\n                    headerView.setUint32(8, totalByteLength, true);\n                    var glbBlob = new Blob([header, jsonChunkPrefix, jsonChunk, binaryChunkPrefix, binaryChunk], {\n                      type: \"application/octet-stream\"\n                    });\n                    var glbReader = new FileReader();\n                    glbReader.readAsArrayBuffer(glbBlob);\n\n                    glbReader.onloadend = function () {\n                      onDone(glbReader.result);\n                    };\n                  };\n                } else {\n                  if (json.buffers && json.buffers.length > 0) {\n                    _reader = new FileReader();\n\n                    _reader.readAsDataURL(blob);\n\n                    _reader.onloadend = function () {\n                      var base64data = _reader.result;\n                      json.buffers[0].uri = base64data;\n                      onDone(json);\n                    };\n                  } else {\n                    onDone(json);\n                  }\n                }\n\n              case 19:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function write(_x, _x2) {\n        return _write.apply(this, arguments);\n      }\n\n      return write;\n    }()\n    /**\n     * Serializes a userData.\n     *\n     * @param {THREE.Object3D|THREE.Material} object\n     * @param {Object} objectDef\n     */\n\n  }, {\n    key: \"serializeUserData\",\n    value: function serializeUserData(object, objectDef) {\n      if (Object.keys(object.userData).length === 0) return;\n      var options = this.options;\n      var extensionsUsed = this.extensionsUsed;\n\n      try {\n        var json = JSON.parse(JSON.stringify(object.userData));\n\n        if (options.includeCustomExtensions && json.gltfExtensions) {\n          if (objectDef.extensions === void 0) objectDef.extensions = {};\n\n          for (var extensionName in json.gltfExtensions) {\n            objectDef.extensions[extensionName] = json.gltfExtensions[extensionName];\n            extensionsUsed[extensionName] = true;\n          }\n\n          delete json.gltfExtensions;\n        }\n\n        if (Object.keys(json).length > 0) objectDef.extras = json;\n      } catch (error) {\n        console.warn(\"THREE.GLTFExporter: userData of '\" + object.name + \"' won't be serialized because of JSON.stringify error - \" + error.message);\n      }\n    }\n    /**\n     * Returns ids for buffer attributes.\n     * @param  {Object} object\n     * @return {Integer}\n     */\n\n  }, {\n    key: \"getUID\",\n    value: function getUID(attribute) {\n      var isRelativeCopy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      if (this.uids.has(attribute) === false) {\n        var uids2 = /* @__PURE__ */new Map();\n        uids2.set(true, this.uid++);\n        uids2.set(false, this.uid++);\n        this.uids.set(attribute, uids2);\n      }\n\n      var uids = this.uids.get(attribute);\n      return uids.get(isRelativeCopy);\n    }\n    /**\n     * Checks if normal attribute values are normalized.\n     *\n     * @param {BufferAttribute} normal\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isNormalizedNormalAttribute\",\n    value: function isNormalizedNormalAttribute(normal) {\n      var cache = this.cache;\n      if (cache.attributesNormalized.has(normal)) return false;\n      var v = new Vector3();\n\n      for (var i = 0, il = normal.count; i < il; i++) {\n        if (Math.abs(v.fromBufferAttribute(normal, i).length() - 1) > 5e-4) return false;\n      }\n\n      return true;\n    }\n    /**\n     * Creates normalized normal buffer attribute.\n     *\n     * @param {BufferAttribute} normal\n     * @returns {BufferAttribute}\n     *\n     */\n\n  }, {\n    key: \"createNormalizedNormalAttribute\",\n    value: function createNormalizedNormalAttribute(normal) {\n      var cache = this.cache;\n      if (cache.attributesNormalized.has(normal)) return cache.attributesNormalized.get(normal);\n      var attribute = normal.clone();\n      var v = new Vector3();\n\n      for (var i = 0, il = attribute.count; i < il; i++) {\n        v.fromBufferAttribute(attribute, i);\n\n        if (v.x === 0 && v.y === 0 && v.z === 0) {\n          v.setX(1);\n        } else {\n          v.normalize();\n        }\n\n        attribute.setXYZ(i, v.x, v.y, v.z);\n      }\n\n      cache.attributesNormalized.set(normal, attribute);\n      return attribute;\n    }\n    /**\n     * Applies a texture transform, if present, to the map definition. Requires\n     * the KHR_texture_transform extension.\n     *\n     * @param {Object} mapDef\n     * @param {THREE.Texture} texture\n     */\n\n  }, {\n    key: \"applyTextureTransform\",\n    value: function applyTextureTransform(mapDef, texture) {\n      var didTransform = false;\n      var transformDef = {};\n\n      if (texture.offset.x !== 0 || texture.offset.y !== 0) {\n        transformDef.offset = texture.offset.toArray();\n        didTransform = true;\n      }\n\n      if (texture.rotation !== 0) {\n        transformDef.rotation = texture.rotation;\n        didTransform = true;\n      }\n\n      if (texture.repeat.x !== 1 || texture.repeat.y !== 1) {\n        transformDef.scale = texture.repeat.toArray();\n        didTransform = true;\n      }\n\n      if (didTransform) {\n        mapDef.extensions = mapDef.extensions || {};\n        mapDef.extensions[\"KHR_texture_transform\"] = transformDef;\n        this.extensionsUsed[\"KHR_texture_transform\"] = true;\n      }\n    }\n  }, {\n    key: \"buildMetalRoughTexture\",\n    value: function buildMetalRoughTexture(metalnessMap, roughnessMap) {\n      if (metalnessMap === roughnessMap) return metalnessMap;\n\n      function getEncodingConversion(map) {\n        if (\"colorSpace\" in map ? map.colorSpace === \"srgb\" : map.encoding === 3001) {\n          return function SRGBToLinear(c) {\n            return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);\n          };\n        }\n\n        return function LinearToLinear(c) {\n          return c;\n        };\n      }\n\n      console.warn(\"THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures.\");\n\n      if (metalnessMap instanceof CompressedTexture) {\n        metalnessMap = decompress(metalnessMap);\n      }\n\n      if (roughnessMap instanceof CompressedTexture) {\n        roughnessMap = decompress(roughnessMap);\n      }\n\n      var metalness = metalnessMap ? metalnessMap.image : null;\n      var roughness = roughnessMap ? roughnessMap.image : null;\n      var width = Math.max(metalness ? metalness.width : 0, roughness ? roughness.width : 0);\n      var height = Math.max(metalness ? metalness.height : 0, roughness ? roughness.height : 0);\n      var canvas = getCanvas();\n      canvas.width = width;\n      canvas.height = height;\n      var context = canvas.getContext(\"2d\");\n      context.fillStyle = \"#00ffff\";\n      context.fillRect(0, 0, width, height);\n      var composite = context.getImageData(0, 0, width, height);\n\n      if (metalness) {\n        context.drawImage(metalness, 0, 0, width, height);\n        var convert = getEncodingConversion(metalnessMap);\n        var data = context.getImageData(0, 0, width, height).data;\n\n        for (var i = 2; i < data.length; i += 4) {\n          composite.data[i] = convert(data[i] / 256) * 256;\n        }\n      }\n\n      if (roughness) {\n        context.drawImage(roughness, 0, 0, width, height);\n\n        var _convert = getEncodingConversion(roughnessMap);\n\n        var _data = context.getImageData(0, 0, width, height).data;\n\n        for (var _i = 1; _i < _data.length; _i += 4) {\n          composite.data[_i] = _convert(_data[_i] / 256) * 256;\n        }\n      }\n\n      context.putImageData(composite, 0, 0);\n      var reference = metalnessMap || roughnessMap;\n      var texture = reference.clone();\n      texture.source = new Texture(canvas).source;\n      if (\"colorSpace\" in texture) texture.colorSpace = \"\";else texture.encoding = 3e3;\n      texture.channel = (metalnessMap || roughnessMap).channel;\n\n      if (metalnessMap && roughnessMap && metalnessMap.channel !== roughnessMap.channel) {\n        console.warn(\"THREE.GLTFExporter: UV channels for metalnessMap and roughnessMap textures must match.\");\n      }\n\n      return texture;\n    }\n    /**\n     * Process a buffer to append to the default one.\n     * @param  {ArrayBuffer} buffer\n     * @return {Integer}\n     */\n\n  }, {\n    key: \"processBuffer\",\n    value: function processBuffer(buffer) {\n      var json = this.json;\n      var buffers = this.buffers;\n      if (!json.buffers) json.buffers = [{\n        byteLength: 0\n      }];\n      buffers.push(buffer);\n      return 0;\n    }\n    /**\n     * Process and generate a BufferView\n     * @param  {BufferAttribute} attribute\n     * @param  {number} componentType\n     * @param  {number} start\n     * @param  {number} count\n     * @param  {number} target (Optional) Target usage of the BufferView\n     * @return {Object}\n     */\n\n  }, {\n    key: \"processBufferView\",\n    value: function processBufferView(attribute, componentType, start, count, target) {\n      var json = this.json;\n      if (!json.bufferViews) json.bufferViews = [];\n      var componentSize;\n\n      switch (componentType) {\n        case WEBGL_CONSTANTS.BYTE:\n        case WEBGL_CONSTANTS.UNSIGNED_BYTE:\n          componentSize = 1;\n          break;\n\n        case WEBGL_CONSTANTS.SHORT:\n        case WEBGL_CONSTANTS.UNSIGNED_SHORT:\n          componentSize = 2;\n          break;\n\n        default:\n          componentSize = 4;\n      }\n\n      var byteLength = getPaddedBufferSize(count * attribute.itemSize * componentSize);\n      var dataView = new DataView(new ArrayBuffer(byteLength));\n      var offset = 0;\n\n      for (var i = start; i < start + count; i++) {\n        for (var a = 0; a < attribute.itemSize; a++) {\n          var value = void 0;\n\n          if (attribute.itemSize > 4) {\n            value = attribute.array[i * attribute.itemSize + a];\n          } else {\n            if (a === 0) value = attribute.getX(i);else if (a === 1) value = attribute.getY(i);else if (a === 2) value = attribute.getZ(i);else if (a === 3) value = attribute.getW(i);\n\n            if (attribute.normalized === true) {\n              value = MathUtils.normalize(value, attribute.array);\n            }\n          }\n\n          if (componentType === WEBGL_CONSTANTS.FLOAT) {\n            dataView.setFloat32(offset, value, true);\n          } else if (componentType === WEBGL_CONSTANTS.INT) {\n            dataView.setInt32(offset, value, true);\n          } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_INT) {\n            dataView.setUint32(offset, value, true);\n          } else if (componentType === WEBGL_CONSTANTS.SHORT) {\n            dataView.setInt16(offset, value, true);\n          } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {\n            dataView.setUint16(offset, value, true);\n          } else if (componentType === WEBGL_CONSTANTS.BYTE) {\n            dataView.setInt8(offset, value);\n          } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {\n            dataView.setUint8(offset, value);\n          }\n\n          offset += componentSize;\n        }\n      }\n\n      var bufferViewDef = {\n        buffer: this.processBuffer(dataView.buffer),\n        byteOffset: this.byteOffset,\n        byteLength: byteLength\n      };\n      if (target !== void 0) bufferViewDef.target = target;\n\n      if (target === WEBGL_CONSTANTS.ARRAY_BUFFER) {\n        bufferViewDef.byteStride = attribute.itemSize * componentSize;\n      }\n\n      this.byteOffset += byteLength;\n      json.bufferViews.push(bufferViewDef);\n      var output = {\n        id: json.bufferViews.length - 1,\n        byteLength: 0\n      };\n      return output;\n    }\n    /**\n     * Process and generate a BufferView from an image Blob.\n     * @param {Blob} blob\n     * @return {Promise<Integer>}\n     */\n\n  }, {\n    key: \"processBufferViewImage\",\n    value: function processBufferViewImage(blob) {\n      var writer = this;\n      var json = writer.json;\n      if (!json.bufferViews) json.bufferViews = [];\n      return new Promise(function (resolve) {\n        var reader = new FileReader();\n        reader.readAsArrayBuffer(blob);\n\n        reader.onloadend = function () {\n          var buffer = getPaddedArrayBuffer(reader.result);\n          var bufferViewDef = {\n            buffer: writer.processBuffer(buffer),\n            byteOffset: writer.byteOffset,\n            byteLength: buffer.byteLength\n          };\n          writer.byteOffset += buffer.byteLength;\n          resolve(json.bufferViews.push(bufferViewDef) - 1);\n        };\n      });\n    }\n    /**\n     * Process attribute to generate an accessor\n     * @param  {BufferAttribute} attribute Attribute to process\n     * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range\n     * @param  {Integer} start (Optional)\n     * @param  {Integer} count (Optional)\n     * @return {Integer|null} Index of the processed accessor on the \"accessors\" array\n     */\n\n  }, {\n    key: \"processAccessor\",\n    value: function processAccessor(attribute, geometry, start, count) {\n      var json = this.json;\n      var types = {\n        1: \"SCALAR\",\n        2: \"VEC2\",\n        3: \"VEC3\",\n        4: \"VEC4\",\n        9: \"MAT3\",\n        16: \"MAT4\"\n      };\n      var componentType;\n\n      if (attribute.array.constructor === Float32Array) {\n        componentType = WEBGL_CONSTANTS.FLOAT;\n      } else if (attribute.array.constructor === Int32Array) {\n        componentType = WEBGL_CONSTANTS.INT;\n      } else if (attribute.array.constructor === Uint32Array) {\n        componentType = WEBGL_CONSTANTS.UNSIGNED_INT;\n      } else if (attribute.array.constructor === Int16Array) {\n        componentType = WEBGL_CONSTANTS.SHORT;\n      } else if (attribute.array.constructor === Uint16Array) {\n        componentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;\n      } else if (attribute.array.constructor === Int8Array) {\n        componentType = WEBGL_CONSTANTS.BYTE;\n      } else if (attribute.array.constructor === Uint8Array) {\n        componentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;\n      } else {\n        throw new Error(\"THREE.GLTFExporter: Unsupported bufferAttribute component type: \" + attribute.array.constructor.name);\n      }\n\n      if (start === void 0) start = 0;\n      if (count === void 0) count = attribute.count;\n      if (count === 0) return null;\n      var minMax = getMinMax(attribute, start, count);\n      var bufferViewTarget;\n\n      if (geometry !== void 0) {\n        bufferViewTarget = attribute === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER;\n      }\n\n      var bufferView = this.processBufferView(attribute, componentType, start, count, bufferViewTarget);\n      var accessorDef = {\n        bufferView: bufferView.id,\n        byteOffset: bufferView.byteOffset,\n        componentType: componentType,\n        count: count,\n        max: minMax.max,\n        min: minMax.min,\n        type: types[attribute.itemSize]\n      };\n      if (attribute.normalized === true) accessorDef.normalized = true;\n      if (!json.accessors) json.accessors = [];\n      return json.accessors.push(accessorDef) - 1;\n    }\n    /**\n     * Process image\n     * @param  {Image} image to process\n     * @param  {Integer} format of the image (RGBAFormat)\n     * @param  {Boolean} flipY before writing out the image\n     * @param  {String} mimeType export format\n     * @return {Integer}     Index of the processed texture in the \"images\" array\n     */\n\n  }, {\n    key: \"processImage\",\n    value: function processImage(image, format, flipY) {\n      var mimeType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"image/png\";\n\n      if (image !== null) {\n        var writer = this;\n        var cache = writer.cache;\n        var json = writer.json;\n        var options = writer.options;\n        var pending = writer.pending;\n        if (!cache.images.has(image)) cache.images.set(image, {});\n        var cachedImages = cache.images.get(image);\n        var key = mimeType + \":flipY/\" + flipY.toString();\n        if (cachedImages[key] !== void 0) return cachedImages[key];\n        if (!json.images) json.images = [];\n        var imageDef = {\n          mimeType: mimeType\n        };\n        var canvas = getCanvas();\n        canvas.width = Math.min(image.width, options.maxTextureSize);\n        canvas.height = Math.min(image.height, options.maxTextureSize);\n        var ctx = canvas.getContext(\"2d\");\n\n        if (flipY === true) {\n          ctx.translate(0, canvas.height);\n          ctx.scale(1, -1);\n        }\n\n        if (image.data !== void 0) {\n          if (format !== RGBAFormat) {\n            console.error(\"GLTFExporter: Only RGBAFormat is supported.\", format);\n          }\n\n          if (image.width > options.maxTextureSize || image.height > options.maxTextureSize) {\n            console.warn(\"GLTFExporter: Image size is bigger than maxTextureSize\", image);\n          }\n\n          var data = new Uint8ClampedArray(image.height * image.width * 4);\n\n          for (var i = 0; i < data.length; i += 4) {\n            data[i + 0] = image.data[i + 0];\n            data[i + 1] = image.data[i + 1];\n            data[i + 2] = image.data[i + 2];\n            data[i + 3] = image.data[i + 3];\n          }\n\n          ctx.putImageData(new ImageData(data, image.width, image.height), 0, 0);\n        } else {\n          ctx.drawImage(image, 0, 0, canvas.width, canvas.height);\n        }\n\n        if (options.binary === true) {\n          pending.push(getToBlobPromise(canvas, mimeType).then(function (blob) {\n            return writer.processBufferViewImage(blob);\n          }).then(function (bufferViewIndex) {\n            imageDef.bufferView = bufferViewIndex;\n          }));\n        } else {\n          if (canvas.toDataURL !== void 0) {\n            imageDef.uri = canvas.toDataURL(mimeType);\n          } else {\n            pending.push(getToBlobPromise(canvas, mimeType).then(function (blob) {\n              return new FileReader().readAsDataURL(blob);\n            }).then(function (dataURL) {\n              imageDef.uri = dataURL;\n            }));\n          }\n        }\n\n        var index = json.images.push(imageDef) - 1;\n        cachedImages[key] = index;\n        return index;\n      } else {\n        throw new Error(\"THREE.GLTFExporter: No valid image data found. Unable to process texture.\");\n      }\n    }\n    /**\n     * Process sampler\n     * @param  {Texture} map Texture to process\n     * @return {Integer}     Index of the processed texture in the \"samplers\" array\n     */\n\n  }, {\n    key: \"processSampler\",\n    value: function processSampler(map) {\n      var json = this.json;\n      if (!json.samplers) json.samplers = [];\n      var samplerDef = {\n        magFilter: THREE_TO_WEBGL[map.magFilter],\n        minFilter: THREE_TO_WEBGL[map.minFilter],\n        wrapS: THREE_TO_WEBGL[map.wrapS],\n        wrapT: THREE_TO_WEBGL[map.wrapT]\n      };\n      return json.samplers.push(samplerDef) - 1;\n    }\n    /**\n     * Process texture\n     * @param  {Texture} map Map to process\n     * @return {Integer} Index of the processed texture in the \"textures\" array\n     */\n\n  }, {\n    key: \"processTexture\",\n    value: function processTexture(map) {\n      var writer = this;\n      var options = writer.options;\n      var cache = this.cache;\n      var json = this.json;\n      if (cache.textures.has(map)) return cache.textures.get(map);\n      if (!json.textures) json.textures = [];\n\n      if (map instanceof CompressedTexture) {\n        map = decompress(map, options.maxTextureSize);\n      }\n\n      var mimeType = map.userData.mimeType;\n      if (mimeType === \"image/webp\") mimeType = \"image/png\";\n      var textureDef = {\n        sampler: this.processSampler(map),\n        source: this.processImage(map.image, map.format, map.flipY, mimeType)\n      };\n      if (map.name) textureDef.name = map.name;\n\n      this._invokeAll(function (ext) {\n        ext.writeTexture && ext.writeTexture(map, textureDef);\n      });\n\n      var index = json.textures.push(textureDef) - 1;\n      cache.textures.set(map, index);\n      return index;\n    }\n    /**\n     * Process material\n     * @param  {THREE.Material} material Material to process\n     * @return {Integer|null} Index of the processed material in the \"materials\" array\n     */\n\n  }, {\n    key: \"processMaterial\",\n    value: function processMaterial(material) {\n      var cache = this.cache;\n      var json = this.json;\n      if (cache.materials.has(material)) return cache.materials.get(material);\n\n      if (material.isShaderMaterial) {\n        console.warn(\"GLTFExporter: THREE.ShaderMaterial not supported.\");\n        return null;\n      }\n\n      if (!json.materials) json.materials = [];\n      var materialDef = {\n        pbrMetallicRoughness: {}\n      };\n\n      if (material.isMeshStandardMaterial !== true && material.isMeshBasicMaterial !== true) {\n        console.warn(\"GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.\");\n      }\n\n      var color = material.color.toArray().concat([material.opacity]);\n\n      if (!equalArray(color, [1, 1, 1, 1])) {\n        materialDef.pbrMetallicRoughness.baseColorFactor = color;\n      }\n\n      if (material.isMeshStandardMaterial) {\n        materialDef.pbrMetallicRoughness.metallicFactor = material.metalness;\n        materialDef.pbrMetallicRoughness.roughnessFactor = material.roughness;\n      } else {\n        materialDef.pbrMetallicRoughness.metallicFactor = 0.5;\n        materialDef.pbrMetallicRoughness.roughnessFactor = 0.5;\n      }\n\n      if (material.metalnessMap || material.roughnessMap) {\n        var metalRoughTexture = this.buildMetalRoughTexture(material.metalnessMap, material.roughnessMap);\n        var metalRoughMapDef = {\n          index: this.processTexture(metalRoughTexture),\n          channel: metalRoughTexture.channel\n        };\n        this.applyTextureTransform(metalRoughMapDef, metalRoughTexture);\n        materialDef.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef;\n      }\n\n      if (material.map) {\n        var baseColorMapDef = {\n          index: this.processTexture(material.map),\n          texCoord: material.map.channel\n        };\n        this.applyTextureTransform(baseColorMapDef, material.map);\n        materialDef.pbrMetallicRoughness.baseColorTexture = baseColorMapDef;\n      }\n\n      if (material.emissive) {\n        var emissive = material.emissive;\n        var maxEmissiveComponent = Math.max(emissive.r, emissive.g, emissive.b);\n\n        if (maxEmissiveComponent > 0) {\n          materialDef.emissiveFactor = material.emissive.toArray();\n        }\n\n        if (material.emissiveMap) {\n          var emissiveMapDef = {\n            index: this.processTexture(material.emissiveMap),\n            texCoord: material.emissiveMap.channel\n          };\n          this.applyTextureTransform(emissiveMapDef, material.emissiveMap);\n          materialDef.emissiveTexture = emissiveMapDef;\n        }\n      }\n\n      if (material.normalMap) {\n        var normalMapDef = {\n          index: this.processTexture(material.normalMap),\n          texCoord: material.normalMap.channel\n        };\n\n        if (material.normalScale && material.normalScale.x !== 1) {\n          normalMapDef.scale = material.normalScale.x;\n        }\n\n        this.applyTextureTransform(normalMapDef, material.normalMap);\n        materialDef.normalTexture = normalMapDef;\n      }\n\n      if (material.aoMap) {\n        var occlusionMapDef = {\n          index: this.processTexture(material.aoMap),\n          texCoord: material.aoMap.channel\n        };\n\n        if (material.aoMapIntensity !== 1) {\n          occlusionMapDef.strength = material.aoMapIntensity;\n        }\n\n        this.applyTextureTransform(occlusionMapDef, material.aoMap);\n        materialDef.occlusionTexture = occlusionMapDef;\n      }\n\n      if (material.transparent) {\n        materialDef.alphaMode = \"BLEND\";\n      } else {\n        if (material.alphaTest > 0) {\n          materialDef.alphaMode = \"MASK\";\n          materialDef.alphaCutoff = material.alphaTest;\n        }\n      }\n\n      if (material.side === DoubleSide) materialDef.doubleSided = true;\n      if (material.name !== \"\") materialDef.name = material.name;\n      this.serializeUserData(material, materialDef);\n\n      this._invokeAll(function (ext) {\n        ext.writeMaterial && ext.writeMaterial(material, materialDef);\n      });\n\n      var index = json.materials.push(materialDef) - 1;\n      cache.materials.set(material, index);\n      return index;\n    }\n    /**\n     * Process mesh\n     * @param  {THREE.Mesh} mesh Mesh to process\n     * @return {Integer|null} Index of the processed mesh in the \"meshes\" array\n     */\n\n  }, {\n    key: \"processMesh\",\n    value: function processMesh(mesh) {\n      var _nameConversion;\n\n      var cache = this.cache;\n      var json = this.json;\n      var meshCacheKeyParts = [mesh.geometry.uuid];\n\n      if (Array.isArray(mesh.material)) {\n        for (var i = 0, l = mesh.material.length; i < l; i++) {\n          meshCacheKeyParts.push(mesh.material[i].uuid);\n        }\n      } else {\n        meshCacheKeyParts.push(mesh.material.uuid);\n      }\n\n      var meshCacheKey = meshCacheKeyParts.join(\":\");\n      if (cache.meshes.has(meshCacheKey)) return cache.meshes.get(meshCacheKey);\n      var geometry = mesh.geometry;\n      var mode;\n\n      if (mesh.isLineSegments) {\n        mode = WEBGL_CONSTANTS.LINES;\n      } else if (mesh.isLineLoop) {\n        mode = WEBGL_CONSTANTS.LINE_LOOP;\n      } else if (mesh.isLine) {\n        mode = WEBGL_CONSTANTS.LINE_STRIP;\n      } else if (mesh.isPoints) {\n        mode = WEBGL_CONSTANTS.POINTS;\n      } else {\n        mode = mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;\n      }\n\n      var meshDef = {};\n      var attributes = {};\n      var primitives = [];\n      var targets = [];\n      var nameConversion = (_nameConversion = {\n        uv: \"TEXCOORD_0\"\n      }, _defineProperty(_nameConversion, REVISION.replace(/\\D+/g, \"\") >= 152 ? \"uv1\" : \"uv2\", \"TEXCOORD_1\"), _defineProperty(_nameConversion, \"color\", \"COLOR_0\"), _defineProperty(_nameConversion, \"skinWeight\", \"WEIGHTS_0\"), _defineProperty(_nameConversion, \"skinIndex\", \"JOINTS_0\"), _nameConversion);\n      var originalNormal = geometry.getAttribute(\"normal\");\n\n      if (originalNormal !== void 0 && !this.isNormalizedNormalAttribute(originalNormal)) {\n        console.warn(\"THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.\");\n        geometry.setAttribute(\"normal\", this.createNormalizedNormalAttribute(originalNormal));\n      }\n\n      var modifiedAttribute = null;\n\n      for (var attributeName in geometry.attributes) {\n        if (attributeName.slice(0, 5) === \"morph\") continue;\n        var attribute = geometry.attributes[attributeName];\n        attributeName = nameConversion[attributeName] || attributeName.toUpperCase();\n        var validVertexAttributes = /^(POSITION|NORMAL|TANGENT|TEXCOORD_\\d+|COLOR_\\d+|JOINTS_\\d+|WEIGHTS_\\d+)$/;\n        if (!validVertexAttributes.test(attributeName)) attributeName = \"_\" + attributeName;\n\n        if (cache.attributes.has(this.getUID(attribute))) {\n          attributes[attributeName] = cache.attributes.get(this.getUID(attribute));\n          continue;\n        }\n\n        modifiedAttribute = null;\n        var array = attribute.array;\n\n        if (attributeName === \"JOINTS_0\" && !(array instanceof Uint16Array) && !(array instanceof Uint8Array)) {\n          console.warn('GLTFExporter: Attribute \"skinIndex\" converted to type UNSIGNED_SHORT.');\n          modifiedAttribute = new BufferAttribute(new Uint16Array(array), attribute.itemSize, attribute.normalized);\n        }\n\n        var accessor = this.processAccessor(modifiedAttribute || attribute, geometry);\n\n        if (accessor !== null) {\n          if (!attributeName.startsWith(\"_\")) {\n            this.detectMeshQuantization(attributeName, attribute);\n          }\n\n          attributes[attributeName] = accessor;\n          cache.attributes.set(this.getUID(attribute), accessor);\n        }\n      }\n\n      if (originalNormal !== void 0) geometry.setAttribute(\"normal\", originalNormal);\n      if (Object.keys(attributes).length === 0) return null;\n\n      if (mesh.morphTargetInfluences !== void 0 && mesh.morphTargetInfluences.length > 0) {\n        var weights = [];\n        var targetNames = [];\n        var reverseDictionary = {};\n\n        if (mesh.morphTargetDictionary !== void 0) {\n          for (var key in mesh.morphTargetDictionary) {\n            reverseDictionary[mesh.morphTargetDictionary[key]] = key;\n          }\n        }\n\n        for (var _i2 = 0; _i2 < mesh.morphTargetInfluences.length; ++_i2) {\n          var target = {};\n          var warned = false;\n\n          for (var _attributeName in geometry.morphAttributes) {\n            if (_attributeName !== \"position\" && _attributeName !== \"normal\") {\n              if (!warned) {\n                console.warn(\"GLTFExporter: Only POSITION and NORMAL morph are supported.\");\n                warned = true;\n              }\n\n              continue;\n            }\n\n            var _attribute = geometry.morphAttributes[_attributeName][_i2];\n\n            var gltfAttributeName = _attributeName.toUpperCase();\n\n            var baseAttribute = geometry.attributes[_attributeName];\n\n            if (cache.attributes.has(this.getUID(_attribute, true))) {\n              target[gltfAttributeName] = cache.attributes.get(this.getUID(_attribute, true));\n              continue;\n            }\n\n            var relativeAttribute = _attribute.clone();\n\n            if (!geometry.morphTargetsRelative) {\n              for (var j = 0, jl = _attribute.count; j < jl; j++) {\n                for (var a = 0; a < _attribute.itemSize; a++) {\n                  if (a === 0) relativeAttribute.setX(j, _attribute.getX(j) - baseAttribute.getX(j));\n                  if (a === 1) relativeAttribute.setY(j, _attribute.getY(j) - baseAttribute.getY(j));\n                  if (a === 2) relativeAttribute.setZ(j, _attribute.getZ(j) - baseAttribute.getZ(j));\n                  if (a === 3) relativeAttribute.setW(j, _attribute.getW(j) - baseAttribute.getW(j));\n                }\n              }\n            }\n\n            target[gltfAttributeName] = this.processAccessor(relativeAttribute, geometry);\n            cache.attributes.set(this.getUID(baseAttribute, true), target[gltfAttributeName]);\n          }\n\n          targets.push(target);\n          weights.push(mesh.morphTargetInfluences[_i2]);\n          if (mesh.morphTargetDictionary !== void 0) targetNames.push(reverseDictionary[_i2]);\n        }\n\n        meshDef.weights = weights;\n\n        if (targetNames.length > 0) {\n          meshDef.extras = {};\n          meshDef.extras.targetNames = targetNames;\n        }\n      }\n\n      var isMultiMaterial = Array.isArray(mesh.material);\n      if (isMultiMaterial && geometry.groups.length === 0) return null;\n      var materials = isMultiMaterial ? mesh.material : [mesh.material];\n      var groups = isMultiMaterial ? geometry.groups : [{\n        materialIndex: 0,\n        start: void 0,\n        count: void 0\n      }];\n\n      for (var _i3 = 0, il = groups.length; _i3 < il; _i3++) {\n        var primitive = {\n          mode: mode,\n          attributes: attributes\n        };\n        this.serializeUserData(geometry, primitive);\n        if (targets.length > 0) primitive.targets = targets;\n\n        if (geometry.index !== null) {\n          var cacheKey = this.getUID(geometry.index);\n\n          if (groups[_i3].start !== void 0 || groups[_i3].count !== void 0) {\n            cacheKey += \":\" + groups[_i3].start + \":\" + groups[_i3].count;\n          }\n\n          if (cache.attributes.has(cacheKey)) {\n            primitive.indices = cache.attributes.get(cacheKey);\n          } else {\n            primitive.indices = this.processAccessor(geometry.index, geometry, groups[_i3].start, groups[_i3].count);\n            cache.attributes.set(cacheKey, primitive.indices);\n          }\n\n          if (primitive.indices === null) delete primitive.indices;\n        }\n\n        var material = this.processMaterial(materials[groups[_i3].materialIndex]);\n        if (material !== null) primitive.material = material;\n        primitives.push(primitive);\n      }\n\n      meshDef.primitives = primitives;\n      if (!json.meshes) json.meshes = [];\n\n      this._invokeAll(function (ext) {\n        ext.writeMesh && ext.writeMesh(mesh, meshDef);\n      });\n\n      var index = json.meshes.push(meshDef) - 1;\n      cache.meshes.set(meshCacheKey, index);\n      return index;\n    }\n    /**\n     * If a vertex attribute with a\n     * [non-standard data type](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#meshes-overview)\n     * is used, it is checked whether it is a valid data type according to the\n     * [KHR_mesh_quantization](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md)\n     * extension.\n     * In this case the extension is automatically added to the list of used extensions.\n     *\n     * @param {string} attributeName\n     * @param {THREE.BufferAttribute} attribute\n     */\n\n  }, {\n    key: \"detectMeshQuantization\",\n    value: function detectMeshQuantization(attributeName, attribute) {\n      if (this.extensionsUsed[KHR_MESH_QUANTIZATION]) return;\n      var attrType = void 0;\n\n      switch (attribute.array.constructor) {\n        case Int8Array:\n          attrType = \"byte\";\n          break;\n\n        case Uint8Array:\n          attrType = \"unsigned byte\";\n          break;\n\n        case Int16Array:\n          attrType = \"short\";\n          break;\n\n        case Uint16Array:\n          attrType = \"unsigned short\";\n          break;\n\n        default:\n          return;\n      }\n\n      if (attribute.normalized) attrType += \" normalized\";\n      var attrNamePrefix = attributeName.split(\"_\", 1)[0];\n\n      if (KHR_mesh_quantization_ExtraAttrTypes[attrNamePrefix] && KHR_mesh_quantization_ExtraAttrTypes[attrNamePrefix].includes(attrType)) {\n        this.extensionsUsed[KHR_MESH_QUANTIZATION] = true;\n        this.extensionsRequired[KHR_MESH_QUANTIZATION] = true;\n      }\n    }\n    /**\n     * Process camera\n     * @param  {THREE.Camera} camera Camera to process\n     * @return {Integer}      Index of the processed mesh in the \"camera\" array\n     */\n\n  }, {\n    key: \"processCamera\",\n    value: function processCamera(camera) {\n      var json = this.json;\n      if (!json.cameras) json.cameras = [];\n      var isOrtho = camera.isOrthographicCamera;\n      var cameraDef = {\n        type: isOrtho ? \"orthographic\" : \"perspective\"\n      };\n\n      if (isOrtho) {\n        cameraDef.orthographic = {\n          xmag: camera.right * 2,\n          ymag: camera.top * 2,\n          zfar: camera.far <= 0 ? 1e-3 : camera.far,\n          znear: camera.near < 0 ? 0 : camera.near\n        };\n      } else {\n        cameraDef.perspective = {\n          aspectRatio: camera.aspect,\n          yfov: MathUtils.degToRad(camera.fov),\n          zfar: camera.far <= 0 ? 1e-3 : camera.far,\n          znear: camera.near < 0 ? 0 : camera.near\n        };\n      }\n\n      if (camera.name !== \"\") cameraDef.name = camera.type;\n      return json.cameras.push(cameraDef) - 1;\n    }\n    /**\n     * Creates glTF animation entry from AnimationClip object.\n     *\n     * Status:\n     * - Only properties listed in PATH_PROPERTIES may be animated.\n     *\n     * @param {THREE.AnimationClip} clip\n     * @param {THREE.Object3D} root\n     * @return {number|null}\n     */\n\n  }, {\n    key: \"processAnimation\",\n    value: function processAnimation(clip, root) {\n      var json = this.json;\n      var nodeMap = this.nodeMap;\n      if (!json.animations) json.animations = [];\n      clip = GLTFExporter.Utils.mergeMorphTargetTracks(clip.clone(), root);\n      var tracks = clip.tracks;\n      var channels = [];\n      var samplers = [];\n\n      for (var i = 0; i < tracks.length; ++i) {\n        var track = tracks[i];\n        var trackBinding = PropertyBinding.parseTrackName(track.name);\n        var trackNode = PropertyBinding.findNode(root, trackBinding.nodeName);\n        var trackProperty = PATH_PROPERTIES[trackBinding.propertyName];\n\n        if (trackBinding.objectName === \"bones\") {\n          if (trackNode.isSkinnedMesh === true) {\n            trackNode = trackNode.skeleton.getBoneByName(trackBinding.objectIndex);\n          } else {\n            trackNode = void 0;\n          }\n        }\n\n        if (!trackNode || !trackProperty) {\n          console.warn('THREE.GLTFExporter: Could not export animation track \"%s\".', track.name);\n          return null;\n        }\n\n        var inputItemSize = 1;\n        var outputItemSize = track.values.length / track.times.length;\n\n        if (trackProperty === PATH_PROPERTIES.morphTargetInfluences) {\n          outputItemSize /= trackNode.morphTargetInfluences.length;\n        }\n\n        var interpolation = void 0;\n\n        if (track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === true) {\n          interpolation = \"CUBICSPLINE\";\n          outputItemSize /= 3;\n        } else if (track.getInterpolation() === InterpolateDiscrete) {\n          interpolation = \"STEP\";\n        } else {\n          interpolation = \"LINEAR\";\n        }\n\n        samplers.push({\n          input: this.processAccessor(new BufferAttribute(track.times, inputItemSize)),\n          output: this.processAccessor(new BufferAttribute(track.values, outputItemSize)),\n          interpolation: interpolation\n        });\n        channels.push({\n          sampler: samplers.length - 1,\n          target: {\n            node: nodeMap.get(trackNode),\n            path: trackProperty\n          }\n        });\n      }\n\n      json.animations.push({\n        name: clip.name || \"clip_\" + json.animations.length,\n        samplers: samplers,\n        channels: channels\n      });\n      return json.animations.length - 1;\n    }\n    /**\n     * @param {THREE.Object3D} object\n     * @return {number|null}\n     */\n\n  }, {\n    key: \"processSkin\",\n    value: function processSkin(object) {\n      var json = this.json;\n      var nodeMap = this.nodeMap;\n      var node = json.nodes[nodeMap.get(object)];\n      var skeleton = object.skeleton;\n      if (skeleton === void 0) return null;\n      var rootJoint = object.skeleton.bones[0];\n      if (rootJoint === void 0) return null;\n      var joints = [];\n      var inverseBindMatrices = new Float32Array(skeleton.bones.length * 16);\n      var temporaryBoneInverse = new Matrix4();\n\n      for (var i = 0; i < skeleton.bones.length; ++i) {\n        joints.push(nodeMap.get(skeleton.bones[i]));\n        temporaryBoneInverse.copy(skeleton.boneInverses[i]);\n        temporaryBoneInverse.multiply(object.bindMatrix).toArray(inverseBindMatrices, i * 16);\n      }\n\n      if (json.skins === void 0) json.skins = [];\n      json.skins.push({\n        inverseBindMatrices: this.processAccessor(new BufferAttribute(inverseBindMatrices, 16)),\n        joints: joints,\n        skeleton: nodeMap.get(rootJoint)\n      });\n      var skinIndex = node.skin = json.skins.length - 1;\n      return skinIndex;\n    }\n    /**\n     * Process Object3D node\n     * @param  {THREE.Object3D} node Object3D to processNode\n     * @return {Integer} Index of the node in the nodes list\n     */\n\n  }, {\n    key: \"processNode\",\n    value: function processNode(object) {\n      var json = this.json;\n      var options = this.options;\n      var nodeMap = this.nodeMap;\n      if (!json.nodes) json.nodes = [];\n      var nodeDef = {};\n\n      if (options.trs) {\n        var rotation = object.quaternion.toArray();\n        var position = object.position.toArray();\n        var scale = object.scale.toArray();\n\n        if (!equalArray(rotation, [0, 0, 0, 1])) {\n          nodeDef.rotation = rotation;\n        }\n\n        if (!equalArray(position, [0, 0, 0])) {\n          nodeDef.translation = position;\n        }\n\n        if (!equalArray(scale, [1, 1, 1])) {\n          nodeDef.scale = scale;\n        }\n      } else {\n        if (object.matrixAutoUpdate) {\n          object.updateMatrix();\n        }\n\n        if (isIdentityMatrix(object.matrix) === false) {\n          nodeDef.matrix = object.matrix.elements;\n        }\n      }\n\n      if (object.name !== \"\") nodeDef.name = String(object.name);\n      this.serializeUserData(object, nodeDef);\n\n      if (object.isMesh || object.isLine || object.isPoints) {\n        var meshIndex = this.processMesh(object);\n        if (meshIndex !== null) nodeDef.mesh = meshIndex;\n      } else if (object.isCamera) {\n        nodeDef.camera = this.processCamera(object);\n      }\n\n      if (object.isSkinnedMesh) this.skins.push(object);\n\n      if (object.children.length > 0) {\n        var children = [];\n\n        for (var i = 0, l = object.children.length; i < l; i++) {\n          var child = object.children[i];\n\n          if (child.visible || options.onlyVisible === false) {\n            var nodeIndex2 = this.processNode(child);\n            if (nodeIndex2 !== null) children.push(nodeIndex2);\n          }\n        }\n\n        if (children.length > 0) nodeDef.children = children;\n      }\n\n      this._invokeAll(function (ext) {\n        ext.writeNode && ext.writeNode(object, nodeDef);\n      });\n\n      var nodeIndex = json.nodes.push(nodeDef) - 1;\n      nodeMap.set(object, nodeIndex);\n      return nodeIndex;\n    }\n    /**\n     * Process Scene\n     * @param  {Scene} node Scene to process\n     */\n\n  }, {\n    key: \"processScene\",\n    value: function processScene(scene) {\n      var json = this.json;\n      var options = this.options;\n\n      if (!json.scenes) {\n        json.scenes = [];\n        json.scene = 0;\n      }\n\n      var sceneDef = {};\n      if (scene.name !== \"\") sceneDef.name = scene.name;\n      json.scenes.push(sceneDef);\n      var nodes = [];\n\n      for (var i = 0, l = scene.children.length; i < l; i++) {\n        var child = scene.children[i];\n\n        if (child.visible || options.onlyVisible === false) {\n          var nodeIndex = this.processNode(child);\n          if (nodeIndex !== null) nodes.push(nodeIndex);\n        }\n      }\n\n      if (nodes.length > 0) sceneDef.nodes = nodes;\n      this.serializeUserData(scene, sceneDef);\n    }\n    /**\n     * Creates a Scene to hold a list of objects and parse it\n     * @param  {Array} objects List of objects to process\n     */\n\n  }, {\n    key: \"processObjects\",\n    value: function processObjects(objects) {\n      var scene = new Scene();\n      scene.name = \"AuxScene\";\n\n      for (var i = 0; i < objects.length; i++) {\n        scene.children.push(objects[i]);\n      }\n\n      this.processScene(scene);\n    }\n    /**\n     * @param {THREE.Object3D|Array<THREE.Object3D>} input\n     */\n\n  }, {\n    key: \"processInput\",\n    value: function processInput(input) {\n      var options = this.options;\n      input = input instanceof Array ? input : [input];\n\n      this._invokeAll(function (ext) {\n        ext.beforeParse && ext.beforeParse(input);\n      });\n\n      var objectsWithoutScene = [];\n\n      for (var i = 0; i < input.length; i++) {\n        if (input[i] instanceof Scene) {\n          this.processScene(input[i]);\n        } else {\n          objectsWithoutScene.push(input[i]);\n        }\n      }\n\n      if (objectsWithoutScene.length > 0) this.processObjects(objectsWithoutScene);\n\n      for (var _i4 = 0; _i4 < this.skins.length; ++_i4) {\n        this.processSkin(this.skins[_i4]);\n      }\n\n      for (var _i5 = 0; _i5 < options.animations.length; ++_i5) {\n        this.processAnimation(options.animations[_i5], input[0]);\n      }\n\n      this._invokeAll(function (ext) {\n        ext.afterParse && ext.afterParse(input);\n      });\n    }\n  }, {\n    key: \"_invokeAll\",\n    value: function _invokeAll(func) {\n      for (var i = 0, il = this.plugins.length; i < il; i++) {\n        func(this.plugins[i]);\n      }\n    }\n  }]);\n\n  return GLTFWriter;\n}();\n\nvar GLTFLightExtension = /*#__PURE__*/function () {\n  function GLTFLightExtension(writer) {\n    _classCallCheck(this, GLTFLightExtension);\n\n    this.writer = writer;\n    this.name = \"KHR_lights_punctual\";\n  }\n\n  _createClass(GLTFLightExtension, [{\n    key: \"writeNode\",\n    value: function writeNode(light, nodeDef) {\n      if (!light.isLight) return;\n\n      if (!light.isDirectionalLight && !light.isPointLight && !light.isSpotLight) {\n        console.warn(\"THREE.GLTFExporter: Only directional, point, and spot lights are supported.\", light);\n        return;\n      }\n\n      var writer = this.writer;\n      var json = writer.json;\n      var extensionsUsed = writer.extensionsUsed;\n      var lightDef = {};\n      if (light.name) lightDef.name = light.name;\n      lightDef.color = light.color.toArray();\n      lightDef.intensity = light.intensity;\n\n      if (light.isDirectionalLight) {\n        lightDef.type = \"directional\";\n      } else if (light.isPointLight) {\n        lightDef.type = \"point\";\n        if (light.distance > 0) lightDef.range = light.distance;\n      } else if (light.isSpotLight) {\n        lightDef.type = \"spot\";\n        if (light.distance > 0) lightDef.range = light.distance;\n        lightDef.spot = {};\n        lightDef.spot.innerConeAngle = (light.penumbra - 1) * light.angle * -1;\n        lightDef.spot.outerConeAngle = light.angle;\n      }\n\n      if (light.decay !== void 0 && light.decay !== 2) {\n        console.warn(\"THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2.\");\n      }\n\n      if (light.target && (light.target.parent !== light || light.target.position.x !== 0 || light.target.position.y !== 0 || light.target.position.z !== -1)) {\n        console.warn(\"THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1.\");\n      }\n\n      if (!extensionsUsed[this.name]) {\n        json.extensions = json.extensions || {};\n        json.extensions[this.name] = {\n          lights: []\n        };\n        extensionsUsed[this.name] = true;\n      }\n\n      var lights = json.extensions[this.name].lights;\n      lights.push(lightDef);\n      nodeDef.extensions = nodeDef.extensions || {};\n      nodeDef.extensions[this.name] = {\n        light: lights.length - 1\n      };\n    }\n  }]);\n\n  return GLTFLightExtension;\n}();\n\nvar GLTFMaterialsUnlitExtension = /*#__PURE__*/function () {\n  function GLTFMaterialsUnlitExtension(writer) {\n    _classCallCheck(this, GLTFMaterialsUnlitExtension);\n\n    this.writer = writer;\n    this.name = \"KHR_materials_unlit\";\n  }\n\n  _createClass(GLTFMaterialsUnlitExtension, [{\n    key: \"writeMaterial\",\n    value: function writeMaterial(material, materialDef) {\n      if (!material.isMeshBasicMaterial) return;\n      var writer = this.writer;\n      var extensionsUsed = writer.extensionsUsed;\n      materialDef.extensions = materialDef.extensions || {};\n      materialDef.extensions[this.name] = {};\n      extensionsUsed[this.name] = true;\n      materialDef.pbrMetallicRoughness.metallicFactor = 0;\n      materialDef.pbrMetallicRoughness.roughnessFactor = 0.9;\n    }\n  }]);\n\n  return GLTFMaterialsUnlitExtension;\n}();\n\nvar GLTFMaterialsClearcoatExtension = /*#__PURE__*/function () {\n  function GLTFMaterialsClearcoatExtension(writer) {\n    _classCallCheck(this, GLTFMaterialsClearcoatExtension);\n\n    this.writer = writer;\n    this.name = \"KHR_materials_clearcoat\";\n  }\n\n  _createClass(GLTFMaterialsClearcoatExtension, [{\n    key: \"writeMaterial\",\n    value: function writeMaterial(material, materialDef) {\n      if (!material.isMeshPhysicalMaterial || material.clearcoat === 0) return;\n      var writer = this.writer;\n      var extensionsUsed = writer.extensionsUsed;\n      var extensionDef = {};\n      extensionDef.clearcoatFactor = material.clearcoat;\n\n      if (material.clearcoatMap) {\n        var clearcoatMapDef = {\n          index: writer.processTexture(material.clearcoatMap),\n          texCoord: material.clearcoatMap.channel\n        };\n        writer.applyTextureTransform(clearcoatMapDef, material.clearcoatMap);\n        extensionDef.clearcoatTexture = clearcoatMapDef;\n      }\n\n      extensionDef.clearcoatRoughnessFactor = material.clearcoatRoughness;\n\n      if (material.clearcoatRoughnessMap) {\n        var clearcoatRoughnessMapDef = {\n          index: writer.processTexture(material.clearcoatRoughnessMap),\n          texCoord: material.clearcoatRoughnessMap.channel\n        };\n        writer.applyTextureTransform(clearcoatRoughnessMapDef, material.clearcoatRoughnessMap);\n        extensionDef.clearcoatRoughnessTexture = clearcoatRoughnessMapDef;\n      }\n\n      if (material.clearcoatNormalMap) {\n        var clearcoatNormalMapDef = {\n          index: writer.processTexture(material.clearcoatNormalMap),\n          texCoord: material.clearcoatNormalMap.channel\n        };\n        writer.applyTextureTransform(clearcoatNormalMapDef, material.clearcoatNormalMap);\n        extensionDef.clearcoatNormalTexture = clearcoatNormalMapDef;\n      }\n\n      materialDef.extensions = materialDef.extensions || {};\n      materialDef.extensions[this.name] = extensionDef;\n      extensionsUsed[this.name] = true;\n    }\n  }]);\n\n  return GLTFMaterialsClearcoatExtension;\n}();\n\nvar GLTFMaterialsIridescenceExtension = /*#__PURE__*/function () {\n  function GLTFMaterialsIridescenceExtension(writer) {\n    _classCallCheck(this, GLTFMaterialsIridescenceExtension);\n\n    this.writer = writer;\n    this.name = \"KHR_materials_iridescence\";\n  }\n\n  _createClass(GLTFMaterialsIridescenceExtension, [{\n    key: \"writeMaterial\",\n    value: function writeMaterial(material, materialDef) {\n      if (!material.isMeshPhysicalMaterial || material.iridescence === 0) return;\n      var writer = this.writer;\n      var extensionsUsed = writer.extensionsUsed;\n      var extensionDef = {};\n      extensionDef.iridescenceFactor = material.iridescence;\n\n      if (material.iridescenceMap) {\n        var iridescenceMapDef = {\n          index: writer.processTexture(material.iridescenceMap),\n          texCoord: material.iridescenceMap.channel\n        };\n        writer.applyTextureTransform(iridescenceMapDef, material.iridescenceMap);\n        extensionDef.iridescenceTexture = iridescenceMapDef;\n      }\n\n      extensionDef.iridescenceIor = material.iridescenceIOR;\n      extensionDef.iridescenceThicknessMinimum = material.iridescenceThicknessRange[0];\n      extensionDef.iridescenceThicknessMaximum = material.iridescenceThicknessRange[1];\n\n      if (material.iridescenceThicknessMap) {\n        var iridescenceThicknessMapDef = {\n          index: writer.processTexture(material.iridescenceThicknessMap),\n          texCoord: material.iridescenceThicknessMap.channel\n        };\n        writer.applyTextureTransform(iridescenceThicknessMapDef, material.iridescenceThicknessMap);\n        extensionDef.iridescenceThicknessTexture = iridescenceThicknessMapDef;\n      }\n\n      materialDef.extensions = materialDef.extensions || {};\n      materialDef.extensions[this.name] = extensionDef;\n      extensionsUsed[this.name] = true;\n    }\n  }]);\n\n  return GLTFMaterialsIridescenceExtension;\n}();\n\nvar GLTFMaterialsTransmissionExtension = /*#__PURE__*/function () {\n  function GLTFMaterialsTransmissionExtension(writer) {\n    _classCallCheck(this, GLTFMaterialsTransmissionExtension);\n\n    this.writer = writer;\n    this.name = \"KHR_materials_transmission\";\n  }\n\n  _createClass(GLTFMaterialsTransmissionExtension, [{\n    key: \"writeMaterial\",\n    value: function writeMaterial(material, materialDef) {\n      if (!material.isMeshPhysicalMaterial || material.transmission === 0) return;\n      var writer = this.writer;\n      var extensionsUsed = writer.extensionsUsed;\n      var extensionDef = {};\n      extensionDef.transmissionFactor = material.transmission;\n\n      if (material.transmissionMap) {\n        var transmissionMapDef = {\n          index: writer.processTexture(material.transmissionMap),\n          texCoord: material.transmissionMap.channel\n        };\n        writer.applyTextureTransform(transmissionMapDef, material.transmissionMap);\n        extensionDef.transmissionTexture = transmissionMapDef;\n      }\n\n      materialDef.extensions = materialDef.extensions || {};\n      materialDef.extensions[this.name] = extensionDef;\n      extensionsUsed[this.name] = true;\n    }\n  }]);\n\n  return GLTFMaterialsTransmissionExtension;\n}();\n\nvar GLTFMaterialsVolumeExtension = /*#__PURE__*/function () {\n  function GLTFMaterialsVolumeExtension(writer) {\n    _classCallCheck(this, GLTFMaterialsVolumeExtension);\n\n    this.writer = writer;\n    this.name = \"KHR_materials_volume\";\n  }\n\n  _createClass(GLTFMaterialsVolumeExtension, [{\n    key: \"writeMaterial\",\n    value: function writeMaterial(material, materialDef) {\n      if (!material.isMeshPhysicalMaterial || material.transmission === 0) return;\n      var writer = this.writer;\n      var extensionsUsed = writer.extensionsUsed;\n      var extensionDef = {};\n      extensionDef.thicknessFactor = material.thickness;\n\n      if (material.thicknessMap) {\n        var thicknessMapDef = {\n          index: writer.processTexture(material.thicknessMap),\n          texCoord: material.thicknessMap.channel\n        };\n        writer.applyTextureTransform(thicknessMapDef, material.thicknessMap);\n        extensionDef.thicknessTexture = thicknessMapDef;\n      }\n\n      extensionDef.attenuationDistance = material.attenuationDistance;\n      extensionDef.attenuationColor = material.attenuationColor.toArray();\n      materialDef.extensions = materialDef.extensions || {};\n      materialDef.extensions[this.name] = extensionDef;\n      extensionsUsed[this.name] = true;\n    }\n  }]);\n\n  return GLTFMaterialsVolumeExtension;\n}();\n\nvar GLTFMaterialsIorExtension = /*#__PURE__*/function () {\n  function GLTFMaterialsIorExtension(writer) {\n    _classCallCheck(this, GLTFMaterialsIorExtension);\n\n    this.writer = writer;\n    this.name = \"KHR_materials_ior\";\n  }\n\n  _createClass(GLTFMaterialsIorExtension, [{\n    key: \"writeMaterial\",\n    value: function writeMaterial(material, materialDef) {\n      if (!material.isMeshPhysicalMaterial || material.ior === 1.5) return;\n      var writer = this.writer;\n      var extensionsUsed = writer.extensionsUsed;\n      var extensionDef = {};\n      extensionDef.ior = material.ior;\n      materialDef.extensions = materialDef.extensions || {};\n      materialDef.extensions[this.name] = extensionDef;\n      extensionsUsed[this.name] = true;\n    }\n  }]);\n\n  return GLTFMaterialsIorExtension;\n}();\n\nvar GLTFMaterialsSpecularExtension = /*#__PURE__*/function () {\n  function GLTFMaterialsSpecularExtension(writer) {\n    _classCallCheck(this, GLTFMaterialsSpecularExtension);\n\n    this.writer = writer;\n    this.name = \"KHR_materials_specular\";\n  }\n\n  _createClass(GLTFMaterialsSpecularExtension, [{\n    key: \"writeMaterial\",\n    value: function writeMaterial(material, materialDef) {\n      if (!material.isMeshPhysicalMaterial || material.specularIntensity === 1 && material.specularColor.equals(DEFAULT_SPECULAR_COLOR) && !material.specularIntensityMap && !material.specularColorTexture) return;\n      var writer = this.writer;\n      var extensionsUsed = writer.extensionsUsed;\n      var extensionDef = {};\n\n      if (material.specularIntensityMap) {\n        var specularIntensityMapDef = {\n          index: writer.processTexture(material.specularIntensityMap),\n          texCoord: material.specularIntensityMap.channel\n        };\n        writer.applyTextureTransform(specularIntensityMapDef, material.specularIntensityMap);\n        extensionDef.specularTexture = specularIntensityMapDef;\n      }\n\n      if (material.specularColorMap) {\n        var specularColorMapDef = {\n          index: writer.processTexture(material.specularColorMap),\n          texCoord: material.specularColorMap.channel\n        };\n        writer.applyTextureTransform(specularColorMapDef, material.specularColorMap);\n        extensionDef.specularColorTexture = specularColorMapDef;\n      }\n\n      extensionDef.specularFactor = material.specularIntensity;\n      extensionDef.specularColorFactor = material.specularColor.toArray();\n      materialDef.extensions = materialDef.extensions || {};\n      materialDef.extensions[this.name] = extensionDef;\n      extensionsUsed[this.name] = true;\n    }\n  }]);\n\n  return GLTFMaterialsSpecularExtension;\n}();\n\nvar GLTFMaterialsSheenExtension = /*#__PURE__*/function () {\n  function GLTFMaterialsSheenExtension(writer) {\n    _classCallCheck(this, GLTFMaterialsSheenExtension);\n\n    this.writer = writer;\n    this.name = \"KHR_materials_sheen\";\n  }\n\n  _createClass(GLTFMaterialsSheenExtension, [{\n    key: \"writeMaterial\",\n    value: function writeMaterial(material, materialDef) {\n      if (!material.isMeshPhysicalMaterial || material.sheen == 0) return;\n      var writer = this.writer;\n      var extensionsUsed = writer.extensionsUsed;\n      var extensionDef = {};\n\n      if (material.sheenRoughnessMap) {\n        var sheenRoughnessMapDef = {\n          index: writer.processTexture(material.sheenRoughnessMap),\n          texCoord: material.sheenRoughnessMap.channel\n        };\n        writer.applyTextureTransform(sheenRoughnessMapDef, material.sheenRoughnessMap);\n        extensionDef.sheenRoughnessTexture = sheenRoughnessMapDef;\n      }\n\n      if (material.sheenColorMap) {\n        var sheenColorMapDef = {\n          index: writer.processTexture(material.sheenColorMap),\n          texCoord: material.sheenColorMap.channel\n        };\n        writer.applyTextureTransform(sheenColorMapDef, material.sheenColorMap);\n        extensionDef.sheenColorTexture = sheenColorMapDef;\n      }\n\n      extensionDef.sheenRoughnessFactor = material.sheenRoughness;\n      extensionDef.sheenColorFactor = material.sheenColor.toArray();\n      materialDef.extensions = materialDef.extensions || {};\n      materialDef.extensions[this.name] = extensionDef;\n      extensionsUsed[this.name] = true;\n    }\n  }]);\n\n  return GLTFMaterialsSheenExtension;\n}();\n\nvar GLTFMaterialsAnisotropyExtension = /*#__PURE__*/function () {\n  function GLTFMaterialsAnisotropyExtension(writer) {\n    _classCallCheck(this, GLTFMaterialsAnisotropyExtension);\n\n    this.writer = writer;\n    this.name = \"KHR_materials_anisotropy\";\n  }\n\n  _createClass(GLTFMaterialsAnisotropyExtension, [{\n    key: \"writeMaterial\",\n    value: function writeMaterial(material, materialDef) {\n      if (!material.isMeshPhysicalMaterial || material.anisotropy == 0) return;\n      var writer = this.writer;\n      var extensionsUsed = writer.extensionsUsed;\n      var extensionDef = {};\n\n      if (material.anisotropyMap) {\n        var anisotropyMapDef = {\n          index: writer.processTexture(material.anisotropyMap)\n        };\n        writer.applyTextureTransform(anisotropyMapDef, material.anisotropyMap);\n        extensionDef.anisotropyTexture = anisotropyMapDef;\n      }\n\n      extensionDef.anisotropyStrength = material.anisotropy;\n      extensionDef.anisotropyRotation = material.anisotropyRotation;\n      materialDef.extensions = materialDef.extensions || {};\n      materialDef.extensions[this.name] = extensionDef;\n      extensionsUsed[this.name] = true;\n    }\n  }]);\n\n  return GLTFMaterialsAnisotropyExtension;\n}();\n\nvar GLTFMaterialsEmissiveStrengthExtension = /*#__PURE__*/function () {\n  function GLTFMaterialsEmissiveStrengthExtension(writer) {\n    _classCallCheck(this, GLTFMaterialsEmissiveStrengthExtension);\n\n    this.writer = writer;\n    this.name = \"KHR_materials_emissive_strength\";\n  }\n\n  _createClass(GLTFMaterialsEmissiveStrengthExtension, [{\n    key: \"writeMaterial\",\n    value: function writeMaterial(material, materialDef) {\n      if (!material.isMeshStandardMaterial || material.emissiveIntensity === 1) return;\n      var writer = this.writer;\n      var extensionsUsed = writer.extensionsUsed;\n      var extensionDef = {};\n      extensionDef.emissiveStrength = material.emissiveIntensity;\n      materialDef.extensions = materialDef.extensions || {};\n      materialDef.extensions[this.name] = extensionDef;\n      extensionsUsed[this.name] = true;\n    }\n  }]);\n\n  return GLTFMaterialsEmissiveStrengthExtension;\n}();\n\nGLTFExporter.Utils = {\n  insertKeyframe: function insertKeyframe(track, time) {\n    var tolerance = 1e-3;\n    var valueSize = track.getValueSize();\n    var times = new track.TimeBufferType(track.times.length + 1);\n    var values = new track.ValueBufferType(track.values.length + valueSize);\n    var interpolant = track.createInterpolant(new track.ValueBufferType(valueSize));\n    var index;\n\n    if (track.times.length === 0) {\n      times[0] = time;\n\n      for (var i = 0; i < valueSize; i++) {\n        values[i] = 0;\n      }\n\n      index = 0;\n    } else if (time < track.times[0]) {\n      if (Math.abs(track.times[0] - time) < tolerance) return 0;\n      times[0] = time;\n      times.set(track.times, 1);\n      values.set(interpolant.evaluate(time), 0);\n      values.set(track.values, valueSize);\n      index = 0;\n    } else if (time > track.times[track.times.length - 1]) {\n      if (Math.abs(track.times[track.times.length - 1] - time) < tolerance) {\n        return track.times.length - 1;\n      }\n\n      times[times.length - 1] = time;\n      times.set(track.times, 0);\n      values.set(track.values, 0);\n      values.set(interpolant.evaluate(time), track.values.length);\n      index = times.length - 1;\n    } else {\n      for (var _i6 = 0; _i6 < track.times.length; _i6++) {\n        if (Math.abs(track.times[_i6] - time) < tolerance) return _i6;\n\n        if (track.times[_i6] < time && track.times[_i6 + 1] > time) {\n          times.set(track.times.slice(0, _i6 + 1), 0);\n          times[_i6 + 1] = time;\n          times.set(track.times.slice(_i6 + 1), _i6 + 2);\n          values.set(track.values.slice(0, (_i6 + 1) * valueSize), 0);\n          values.set(interpolant.evaluate(time), (_i6 + 1) * valueSize);\n          values.set(track.values.slice((_i6 + 1) * valueSize), (_i6 + 2) * valueSize);\n          index = _i6 + 1;\n          break;\n        }\n      }\n    }\n\n    track.times = times;\n    track.values = values;\n    return index;\n  },\n  mergeMorphTargetTracks: function mergeMorphTargetTracks(clip, root) {\n    var tracks = [];\n    var mergedTracks = {};\n    var sourceTracks = clip.tracks;\n\n    for (var i = 0; i < sourceTracks.length; ++i) {\n      var sourceTrack = sourceTracks[i];\n      var sourceTrackBinding = PropertyBinding.parseTrackName(sourceTrack.name);\n      var sourceTrackNode = PropertyBinding.findNode(root, sourceTrackBinding.nodeName);\n\n      if (sourceTrackBinding.propertyName !== \"morphTargetInfluences\" || sourceTrackBinding.propertyIndex === void 0) {\n        tracks.push(sourceTrack);\n        continue;\n      }\n\n      if (sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete && sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear) {\n        if (sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {\n          throw new Error(\"THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.\");\n        }\n\n        console.warn(\"THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.\");\n        sourceTrack = sourceTrack.clone();\n        sourceTrack.setInterpolation(InterpolateLinear);\n      }\n\n      var targetCount = sourceTrackNode.morphTargetInfluences.length;\n      var targetIndex = sourceTrackNode.morphTargetDictionary[sourceTrackBinding.propertyIndex];\n\n      if (targetIndex === void 0) {\n        throw new Error(\"THREE.GLTFExporter: Morph target name not found: \" + sourceTrackBinding.propertyIndex);\n      }\n\n      var mergedTrack = void 0;\n\n      if (mergedTracks[sourceTrackNode.uuid] === void 0) {\n        mergedTrack = sourceTrack.clone();\n        var values = new mergedTrack.ValueBufferType(targetCount * mergedTrack.times.length);\n\n        for (var j = 0; j < mergedTrack.times.length; j++) {\n          values[j * targetCount + targetIndex] = mergedTrack.values[j];\n        }\n\n        mergedTrack.name = (sourceTrackBinding.nodeName || \"\") + \".morphTargetInfluences\";\n        mergedTrack.values = values;\n        mergedTracks[sourceTrackNode.uuid] = mergedTrack;\n        tracks.push(mergedTrack);\n        continue;\n      }\n\n      var sourceInterpolant = sourceTrack.createInterpolant(new sourceTrack.ValueBufferType(1));\n      mergedTrack = mergedTracks[sourceTrackNode.uuid];\n\n      for (var _j = 0; _j < mergedTrack.times.length; _j++) {\n        mergedTrack.values[_j * targetCount + targetIndex] = sourceInterpolant.evaluate(mergedTrack.times[_j]);\n      }\n\n      for (var _j2 = 0; _j2 < sourceTrack.times.length; _j2++) {\n        var keyframeIndex = this.insertKeyframe(mergedTrack, sourceTrack.times[_j2]);\n        mergedTrack.values[keyframeIndex * targetCount + targetIndex] = sourceTrack.values[_j2];\n      }\n    }\n\n    clip.tracks = tracks;\n    return clip;\n  }\n};\nexport { GLTFExporter };","map":{"version":3,"sources":["/Users/theodaguier/Repositories/E-Do-Studio/node_modules/three-stdlib/exporters/GLTFExporter.js"],"names":["PlaneGeometry","ShaderMaterial","Uniform","Mesh","PerspectiveCamera","Scene","WebGLRenderer","Texture","NearestFilter","NearestMipmapNearestFilter","NearestMipmapLinearFilter","LinearFilter","LinearMipmapNearestFilter","LinearMipmapLinearFilter","ClampToEdgeWrapping","RepeatWrapping","MirroredRepeatWrapping","Color","MathUtils","Vector3","CompressedTexture","RGBAFormat","DoubleSide","REVISION","BufferAttribute","PropertyBinding","InterpolateDiscrete","Matrix4","InterpolateLinear","_renderer","fullscreenQuadGeometry","fullscreenQuadMaterial","fullscreenQuad","decompress","texture","maxTextureSize","Infinity","renderer","uniforms","blitTexture","vertexShader","fragmentShader","value","defines","IS_SRGB","colorSpace","encoding","needsUpdate","frustrumCulled","_camera","_scene","add","antialias","setSize","Math","min","image","width","height","clear","render","readableTexture","domElement","minFilter","magFilter","wrapS","wrapT","name","dispose","KHR_mesh_quantization_ExtraAttrTypes","POSITION","NORMAL","TANGENT","TEXCOORD","GLTFExporter","pluginCallbacks","register","writer","GLTFLightExtension","GLTFMaterialsUnlitExtension","GLTFMaterialsTransmissionExtension","GLTFMaterialsVolumeExtension","GLTFMaterialsIorExtension","GLTFMaterialsSpecularExtension","GLTFMaterialsClearcoatExtension","GLTFMaterialsIridescenceExtension","GLTFMaterialsSheenExtension","GLTFMaterialsAnisotropyExtension","GLTFMaterialsEmissiveStrengthExtension","callback","indexOf","push","splice","input","onDone","onError","options","GLTFWriter","plugins","i","il","length","setPlugins","write","catch","scope","Promise","resolve","reject","parse","WEBGL_CONSTANTS","POINTS","LINES","LINE_LOOP","LINE_STRIP","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN","BYTE","UNSIGNED_BYTE","SHORT","UNSIGNED_SHORT","INT","UNSIGNED_INT","FLOAT","ARRAY_BUFFER","ELEMENT_ARRAY_BUFFER","NEAREST","LINEAR","NEAREST_MIPMAP_NEAREST","LINEAR_MIPMAP_NEAREST","NEAREST_MIPMAP_LINEAR","LINEAR_MIPMAP_LINEAR","CLAMP_TO_EDGE","MIRRORED_REPEAT","REPEAT","KHR_MESH_QUANTIZATION","THREE_TO_WEBGL","PATH_PROPERTIES","scale","position","quaternion","morphTargetInfluences","DEFAULT_SPECULAR_COLOR","GLB_HEADER_BYTES","GLB_HEADER_MAGIC","GLB_VERSION","GLB_CHUNK_PREFIX_BYTES","GLB_CHUNK_TYPE_JSON","GLB_CHUNK_TYPE_BIN","equalArray","array1","array2","every","element","index","stringToArrayBuffer","text","TextEncoder","encode","buffer","isIdentityMatrix","matrix","elements","getMinMax","attribute","start","count","output","Array","itemSize","fill","Number","POSITIVE_INFINITY","max","NEGATIVE_INFINITY","a","array","getX","getY","getZ","getW","normalized","normalize","getPaddedBufferSize","bufferSize","ceil","getPaddedArrayBuffer","arrayBuffer","paddingByte","paddedLength","byteLength","Uint8Array","set","getCanvas","document","OffscreenCanvas","createElement","getToBlobPromise","canvas","mimeType","toBlob","quality","convertToBlob","type","pending","buffers","byteOffset","nodeMap","Map","skins","extensionsUsed","extensionsRequired","uids","uid","json","asset","version","generator","cache","meshes","attributes","attributesNormalized","materials","textures","images","Object","assign","binary","trs","onlyVisible","animations","includeCustomExtensions","processInput","all","blob","Blob","extensionsUsedList","keys","extensionsRequiredList","size","reader","FileReader","readAsArrayBuffer","onloadend","binaryChunk","result","binaryChunkPrefix","DataView","ArrayBuffer","setUint32","jsonChunk","JSON","stringify","jsonChunkPrefix","header","headerView","totalByteLength","glbBlob","glbReader","readAsDataURL","base64data","uri","object","objectDef","userData","gltfExtensions","extensions","extensionName","extras","error","console","warn","message","isRelativeCopy","has","uids2","get","normal","v","abs","fromBufferAttribute","clone","x","y","z","setX","setXYZ","mapDef","didTransform","transformDef","offset","toArray","rotation","repeat","metalnessMap","roughnessMap","getEncodingConversion","map","SRGBToLinear","c","pow","LinearToLinear","metalness","roughness","context","getContext","fillStyle","fillRect","composite","getImageData","drawImage","convert","data","putImageData","reference","source","channel","componentType","target","bufferViews","componentSize","dataView","setFloat32","setInt32","setInt16","setUint16","setInt8","setUint8","bufferViewDef","processBuffer","byteStride","id","geometry","types","constructor","Float32Array","Int32Array","Uint32Array","Int16Array","Uint16Array","Int8Array","Error","minMax","bufferViewTarget","bufferView","processBufferView","accessorDef","accessors","format","flipY","cachedImages","key","toString","imageDef","ctx","translate","Uint8ClampedArray","ImageData","then","processBufferViewImage","bufferViewIndex","toDataURL","dataURL","samplers","samplerDef","textureDef","sampler","processSampler","processImage","_invokeAll","ext","writeTexture","material","isShaderMaterial","materialDef","pbrMetallicRoughness","isMeshStandardMaterial","isMeshBasicMaterial","color","concat","opacity","baseColorFactor","metallicFactor","roughnessFactor","metalRoughTexture","buildMetalRoughTexture","metalRoughMapDef","processTexture","applyTextureTransform","metallicRoughnessTexture","baseColorMapDef","texCoord","baseColorTexture","emissive","maxEmissiveComponent","r","g","b","emissiveFactor","emissiveMap","emissiveMapDef","emissiveTexture","normalMap","normalMapDef","normalScale","normalTexture","aoMap","occlusionMapDef","aoMapIntensity","strength","occlusionTexture","transparent","alphaMode","alphaTest","alphaCutoff","side","doubleSided","serializeUserData","writeMaterial","mesh","meshCacheKeyParts","uuid","isArray","l","meshCacheKey","join","mode","isLineSegments","isLineLoop","isLine","isPoints","wireframe","meshDef","primitives","targets","nameConversion","uv","replace","originalNormal","getAttribute","isNormalizedNormalAttribute","setAttribute","createNormalizedNormalAttribute","modifiedAttribute","attributeName","slice","toUpperCase","validVertexAttributes","test","getUID","accessor","processAccessor","startsWith","detectMeshQuantization","weights","targetNames","reverseDictionary","morphTargetDictionary","warned","morphAttributes","gltfAttributeName","baseAttribute","relativeAttribute","morphTargetsRelative","j","jl","setY","setZ","setW","isMultiMaterial","groups","materialIndex","primitive","cacheKey","indices","processMaterial","writeMesh","attrType","attrNamePrefix","split","includes","camera","cameras","isOrtho","isOrthographicCamera","cameraDef","orthographic","xmag","right","ymag","top","zfar","far","znear","near","perspective","aspectRatio","aspect","yfov","degToRad","fov","clip","root","Utils","mergeMorphTargetTracks","tracks","channels","track","trackBinding","parseTrackName","trackNode","findNode","nodeName","trackProperty","propertyName","objectName","isSkinnedMesh","skeleton","getBoneByName","objectIndex","inputItemSize","outputItemSize","values","times","interpolation","createInterpolant","isInterpolantFactoryMethodGLTFCubicSpline","getInterpolation","node","path","nodes","rootJoint","bones","joints","inverseBindMatrices","temporaryBoneInverse","copy","boneInverses","multiply","bindMatrix","skinIndex","skin","nodeDef","translation","matrixAutoUpdate","updateMatrix","String","isMesh","meshIndex","processMesh","isCamera","processCamera","children","child","visible","nodeIndex2","processNode","writeNode","nodeIndex","scene","scenes","sceneDef","objects","processScene","beforeParse","objectsWithoutScene","processObjects","processSkin","processAnimation","afterParse","func","light","isLight","isDirectionalLight","isPointLight","isSpotLight","lightDef","intensity","distance","range","spot","innerConeAngle","penumbra","angle","outerConeAngle","decay","parent","lights","isMeshPhysicalMaterial","clearcoat","extensionDef","clearcoatFactor","clearcoatMap","clearcoatMapDef","clearcoatTexture","clearcoatRoughnessFactor","clearcoatRoughness","clearcoatRoughnessMap","clearcoatRoughnessMapDef","clearcoatRoughnessTexture","clearcoatNormalMap","clearcoatNormalMapDef","clearcoatNormalTexture","iridescence","iridescenceFactor","iridescenceMap","iridescenceMapDef","iridescenceTexture","iridescenceIor","iridescenceIOR","iridescenceThicknessMinimum","iridescenceThicknessRange","iridescenceThicknessMaximum","iridescenceThicknessMap","iridescenceThicknessMapDef","iridescenceThicknessTexture","transmission","transmissionFactor","transmissionMap","transmissionMapDef","transmissionTexture","thicknessFactor","thickness","thicknessMap","thicknessMapDef","thicknessTexture","attenuationDistance","attenuationColor","ior","specularIntensity","specularColor","equals","specularIntensityMap","specularColorTexture","specularIntensityMapDef","specularTexture","specularColorMap","specularColorMapDef","specularFactor","specularColorFactor","sheen","sheenRoughnessMap","sheenRoughnessMapDef","sheenRoughnessTexture","sheenColorMap","sheenColorMapDef","sheenColorTexture","sheenRoughnessFactor","sheenRoughness","sheenColorFactor","sheenColor","anisotropy","anisotropyMap","anisotropyMapDef","anisotropyTexture","anisotropyStrength","anisotropyRotation","emissiveIntensity","emissiveStrength","insertKeyframe","time","tolerance","valueSize","getValueSize","TimeBufferType","ValueBufferType","interpolant","evaluate","mergedTracks","sourceTracks","sourceTrack","sourceTrackBinding","sourceTrackNode","propertyIndex","InterpolantFactoryMethodDiscrete","InterpolantFactoryMethodLinear","setInterpolation","targetCount","targetIndex","mergedTrack","sourceInterpolant","keyframeIndex"],"mappings":"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","sourcesContent":["import { PlaneGeometry, ShaderMaterial, Uniform, Mesh, PerspectiveCamera, Scene, WebGLRenderer, Texture, NearestFilter, NearestMipmapNearestFilter, NearestMipmapLinearFilter, LinearFilter, LinearMipmapNearestFilter, LinearMipmapLinearFilter, ClampToEdgeWrapping, RepeatWrapping, MirroredRepeatWrapping, Color, MathUtils, Vector3, CompressedTexture, RGBAFormat, DoubleSide, REVISION, BufferAttribute, PropertyBinding, InterpolateDiscrete, Matrix4, InterpolateLinear } from \"three\";\nlet _renderer;\nlet fullscreenQuadGeometry;\nlet fullscreenQuadMaterial;\nlet fullscreenQuad;\nfunction decompress(texture, maxTextureSize = Infinity, renderer = null) {\n  if (!fullscreenQuadGeometry)\n    fullscreenQuadGeometry = new PlaneGeometry(2, 2, 1, 1);\n  if (!fullscreenQuadMaterial)\n    fullscreenQuadMaterial = new ShaderMaterial({\n      uniforms: { blitTexture: new Uniform(texture) },\n      vertexShader: (\n        /* glsl */\n        `\n        varying vec2 vUv;\n        void main(){\n            vUv = uv;\n            gl_Position = vec4(position.xy * 1.0,0.,.999999);\n        }\n      `\n      ),\n      fragmentShader: (\n        /* glsl */\n        `\n          uniform sampler2D blitTexture; \n          varying vec2 vUv;\n\n          void main(){ \n              gl_FragColor = vec4(vUv.xy, 0, 1);\n              \n              #ifdef IS_SRGB\n              gl_FragColor = LinearTosRGB( texture2D( blitTexture, vUv) );\n              #else\n              gl_FragColor = texture2D( blitTexture, vUv);\n              #endif\n          }\n      `\n      )\n    });\n  fullscreenQuadMaterial.uniforms.blitTexture.value = texture;\n  fullscreenQuadMaterial.defines.IS_SRGB = \"colorSpace\" in texture ? texture.colorSpace === \"srgb\" : texture.encoding === 3001;\n  fullscreenQuadMaterial.needsUpdate = true;\n  if (!fullscreenQuad) {\n    fullscreenQuad = new Mesh(fullscreenQuadGeometry, fullscreenQuadMaterial);\n    fullscreenQuad.frustrumCulled = false;\n  }\n  const _camera = new PerspectiveCamera();\n  const _scene = new Scene();\n  _scene.add(fullscreenQuad);\n  if (!renderer) {\n    renderer = _renderer = new WebGLRenderer({ antialias: false });\n  }\n  renderer.setSize(Math.min(texture.image.width, maxTextureSize), Math.min(texture.image.height, maxTextureSize));\n  renderer.clear();\n  renderer.render(_scene, _camera);\n  const readableTexture = new Texture(renderer.domElement);\n  readableTexture.minFilter = texture.minFilter;\n  readableTexture.magFilter = texture.magFilter;\n  readableTexture.wrapS = texture.wrapS;\n  readableTexture.wrapT = texture.wrapT;\n  readableTexture.name = texture.name;\n  if (_renderer) {\n    _renderer.dispose();\n    _renderer = null;\n  }\n  return readableTexture;\n}\nconst KHR_mesh_quantization_ExtraAttrTypes = {\n  POSITION: [\n    \"byte\",\n    \"byte normalized\",\n    \"unsigned byte\",\n    \"unsigned byte normalized\",\n    \"short\",\n    \"short normalized\",\n    \"unsigned short\",\n    \"unsigned short normalized\"\n  ],\n  NORMAL: [\"byte normalized\", \"short normalized\"],\n  TANGENT: [\"byte normalized\", \"short normalized\"],\n  TEXCOORD: [\"byte\", \"byte normalized\", \"unsigned byte\", \"short\", \"short normalized\", \"unsigned short\"]\n};\nclass GLTFExporter {\n  constructor() {\n    this.pluginCallbacks = [];\n    this.register(function(writer) {\n      return new GLTFLightExtension(writer);\n    });\n    this.register(function(writer) {\n      return new GLTFMaterialsUnlitExtension(writer);\n    });\n    this.register(function(writer) {\n      return new GLTFMaterialsTransmissionExtension(writer);\n    });\n    this.register(function(writer) {\n      return new GLTFMaterialsVolumeExtension(writer);\n    });\n    this.register(function(writer) {\n      return new GLTFMaterialsIorExtension(writer);\n    });\n    this.register(function(writer) {\n      return new GLTFMaterialsSpecularExtension(writer);\n    });\n    this.register(function(writer) {\n      return new GLTFMaterialsClearcoatExtension(writer);\n    });\n    this.register(function(writer) {\n      return new GLTFMaterialsIridescenceExtension(writer);\n    });\n    this.register(function(writer) {\n      return new GLTFMaterialsSheenExtension(writer);\n    });\n    this.register(function(writer) {\n      return new GLTFMaterialsAnisotropyExtension(writer);\n    });\n    this.register(function(writer) {\n      return new GLTFMaterialsEmissiveStrengthExtension(writer);\n    });\n  }\n  register(callback) {\n    if (this.pluginCallbacks.indexOf(callback) === -1) {\n      this.pluginCallbacks.push(callback);\n    }\n    return this;\n  }\n  unregister(callback) {\n    if (this.pluginCallbacks.indexOf(callback) !== -1) {\n      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);\n    }\n    return this;\n  }\n  /**\n   * Parse scenes and generate GLTF output\n   * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n   * @param  {Function} onDone  Callback on completed\n   * @param  {Function} onError  Callback on errors\n   * @param  {Object} options options\n   */\n  parse(input, onDone, onError, options) {\n    const writer = new GLTFWriter();\n    const plugins = [];\n    for (let i = 0, il = this.pluginCallbacks.length; i < il; i++) {\n      plugins.push(this.pluginCallbacks[i](writer));\n    }\n    writer.setPlugins(plugins);\n    writer.write(input, onDone, options).catch(onError);\n  }\n  parseAsync(input, options) {\n    const scope = this;\n    return new Promise(function(resolve, reject) {\n      scope.parse(input, resolve, reject, options);\n    });\n  }\n}\nconst WEBGL_CONSTANTS = {\n  POINTS: 0,\n  LINES: 1,\n  LINE_LOOP: 2,\n  LINE_STRIP: 3,\n  TRIANGLES: 4,\n  TRIANGLE_STRIP: 5,\n  TRIANGLE_FAN: 6,\n  BYTE: 5120,\n  UNSIGNED_BYTE: 5121,\n  SHORT: 5122,\n  UNSIGNED_SHORT: 5123,\n  INT: 5124,\n  UNSIGNED_INT: 5125,\n  FLOAT: 5126,\n  ARRAY_BUFFER: 34962,\n  ELEMENT_ARRAY_BUFFER: 34963,\n  NEAREST: 9728,\n  LINEAR: 9729,\n  NEAREST_MIPMAP_NEAREST: 9984,\n  LINEAR_MIPMAP_NEAREST: 9985,\n  NEAREST_MIPMAP_LINEAR: 9986,\n  LINEAR_MIPMAP_LINEAR: 9987,\n  CLAMP_TO_EDGE: 33071,\n  MIRRORED_REPEAT: 33648,\n  REPEAT: 10497\n};\nconst KHR_MESH_QUANTIZATION = \"KHR_mesh_quantization\";\nconst THREE_TO_WEBGL = {};\nTHREE_TO_WEBGL[NearestFilter] = WEBGL_CONSTANTS.NEAREST;\nTHREE_TO_WEBGL[NearestMipmapNearestFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[NearestMipmapLinearFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR;\nTHREE_TO_WEBGL[LinearFilter] = WEBGL_CONSTANTS.LINEAR;\nTHREE_TO_WEBGL[LinearMipmapNearestFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[LinearMipmapLinearFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR;\nTHREE_TO_WEBGL[ClampToEdgeWrapping] = WEBGL_CONSTANTS.CLAMP_TO_EDGE;\nTHREE_TO_WEBGL[RepeatWrapping] = WEBGL_CONSTANTS.REPEAT;\nTHREE_TO_WEBGL[MirroredRepeatWrapping] = WEBGL_CONSTANTS.MIRRORED_REPEAT;\nconst PATH_PROPERTIES = {\n  scale: \"scale\",\n  position: \"translation\",\n  quaternion: \"rotation\",\n  morphTargetInfluences: \"weights\"\n};\nconst DEFAULT_SPECULAR_COLOR = new Color();\nconst GLB_HEADER_BYTES = 12;\nconst GLB_HEADER_MAGIC = 1179937895;\nconst GLB_VERSION = 2;\nconst GLB_CHUNK_PREFIX_BYTES = 8;\nconst GLB_CHUNK_TYPE_JSON = 1313821514;\nconst GLB_CHUNK_TYPE_BIN = 5130562;\nfunction equalArray(array1, array2) {\n  return array1.length === array2.length && array1.every(function(element, index) {\n    return element === array2[index];\n  });\n}\nfunction stringToArrayBuffer(text) {\n  return new TextEncoder().encode(text).buffer;\n}\nfunction isIdentityMatrix(matrix) {\n  return equalArray(matrix.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\n}\nfunction getMinMax(attribute, start, count) {\n  const output = {\n    min: new Array(attribute.itemSize).fill(Number.POSITIVE_INFINITY),\n    max: new Array(attribute.itemSize).fill(Number.NEGATIVE_INFINITY)\n  };\n  for (let i = start; i < start + count; i++) {\n    for (let a = 0; a < attribute.itemSize; a++) {\n      let value;\n      if (attribute.itemSize > 4) {\n        value = attribute.array[i * attribute.itemSize + a];\n      } else {\n        if (a === 0)\n          value = attribute.getX(i);\n        else if (a === 1)\n          value = attribute.getY(i);\n        else if (a === 2)\n          value = attribute.getZ(i);\n        else if (a === 3)\n          value = attribute.getW(i);\n        if (attribute.normalized === true) {\n          value = MathUtils.normalize(value, attribute.array);\n        }\n      }\n      output.min[a] = Math.min(output.min[a], value);\n      output.max[a] = Math.max(output.max[a], value);\n    }\n  }\n  return output;\n}\nfunction getPaddedBufferSize(bufferSize) {\n  return Math.ceil(bufferSize / 4) * 4;\n}\nfunction getPaddedArrayBuffer(arrayBuffer, paddingByte = 0) {\n  const paddedLength = getPaddedBufferSize(arrayBuffer.byteLength);\n  if (paddedLength !== arrayBuffer.byteLength) {\n    const array = new Uint8Array(paddedLength);\n    array.set(new Uint8Array(arrayBuffer));\n    if (paddingByte !== 0) {\n      for (let i = arrayBuffer.byteLength; i < paddedLength; i++) {\n        array[i] = paddingByte;\n      }\n    }\n    return array.buffer;\n  }\n  return arrayBuffer;\n}\nfunction getCanvas() {\n  if (typeof document === \"undefined\" && typeof OffscreenCanvas !== \"undefined\") {\n    return new OffscreenCanvas(1, 1);\n  }\n  return document.createElement(\"canvas\");\n}\nfunction getToBlobPromise(canvas, mimeType) {\n  if (canvas.toBlob !== void 0) {\n    return new Promise((resolve) => canvas.toBlob(resolve, mimeType));\n  }\n  let quality;\n  if (mimeType === \"image/jpeg\") {\n    quality = 0.92;\n  } else if (mimeType === \"image/webp\") {\n    quality = 0.8;\n  }\n  return canvas.convertToBlob({\n    type: mimeType,\n    quality\n  });\n}\nclass GLTFWriter {\n  constructor() {\n    this.plugins = [];\n    this.options = {};\n    this.pending = [];\n    this.buffers = [];\n    this.byteOffset = 0;\n    this.buffers = [];\n    this.nodeMap = /* @__PURE__ */ new Map();\n    this.skins = [];\n    this.extensionsUsed = {};\n    this.extensionsRequired = {};\n    this.uids = /* @__PURE__ */ new Map();\n    this.uid = 0;\n    this.json = {\n      asset: {\n        version: \"2.0\",\n        generator: \"THREE.GLTFExporter\"\n      }\n    };\n    this.cache = {\n      meshes: /* @__PURE__ */ new Map(),\n      attributes: /* @__PURE__ */ new Map(),\n      attributesNormalized: /* @__PURE__ */ new Map(),\n      materials: /* @__PURE__ */ new Map(),\n      textures: /* @__PURE__ */ new Map(),\n      images: /* @__PURE__ */ new Map()\n    };\n  }\n  setPlugins(plugins) {\n    this.plugins = plugins;\n  }\n  /**\n   * Parse scenes and generate GLTF output\n   * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n   * @param  {Function} onDone  Callback on completed\n   * @param  {Object} options options\n   */\n  async write(input, onDone, options = {}) {\n    this.options = Object.assign(\n      {\n        // default options\n        binary: false,\n        trs: false,\n        onlyVisible: true,\n        maxTextureSize: Infinity,\n        animations: [],\n        includeCustomExtensions: false\n      },\n      options\n    );\n    if (this.options.animations.length > 0) {\n      this.options.trs = true;\n    }\n    this.processInput(input);\n    await Promise.all(this.pending);\n    const writer = this;\n    const buffers = writer.buffers;\n    const json = writer.json;\n    options = writer.options;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionsRequired = writer.extensionsRequired;\n    const blob = new Blob(buffers, { type: \"application/octet-stream\" });\n    const extensionsUsedList = Object.keys(extensionsUsed);\n    const extensionsRequiredList = Object.keys(extensionsRequired);\n    if (extensionsUsedList.length > 0)\n      json.extensionsUsed = extensionsUsedList;\n    if (extensionsRequiredList.length > 0)\n      json.extensionsRequired = extensionsRequiredList;\n    if (json.buffers && json.buffers.length > 0)\n      json.buffers[0].byteLength = blob.size;\n    if (options.binary === true) {\n      const reader = new FileReader();\n      reader.readAsArrayBuffer(blob);\n      reader.onloadend = function() {\n        const binaryChunk = getPaddedArrayBuffer(reader.result);\n        const binaryChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\n        binaryChunkPrefix.setUint32(0, binaryChunk.byteLength, true);\n        binaryChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_BIN, true);\n        const jsonChunk = getPaddedArrayBuffer(stringToArrayBuffer(JSON.stringify(json)), 32);\n        const jsonChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\n        jsonChunkPrefix.setUint32(0, jsonChunk.byteLength, true);\n        jsonChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_JSON, true);\n        const header = new ArrayBuffer(GLB_HEADER_BYTES);\n        const headerView = new DataView(header);\n        headerView.setUint32(0, GLB_HEADER_MAGIC, true);\n        headerView.setUint32(4, GLB_VERSION, true);\n        const totalByteLength = GLB_HEADER_BYTES + jsonChunkPrefix.byteLength + jsonChunk.byteLength + binaryChunkPrefix.byteLength + binaryChunk.byteLength;\n        headerView.setUint32(8, totalByteLength, true);\n        const glbBlob = new Blob([header, jsonChunkPrefix, jsonChunk, binaryChunkPrefix, binaryChunk], {\n          type: \"application/octet-stream\"\n        });\n        const glbReader = new FileReader();\n        glbReader.readAsArrayBuffer(glbBlob);\n        glbReader.onloadend = function() {\n          onDone(glbReader.result);\n        };\n      };\n    } else {\n      if (json.buffers && json.buffers.length > 0) {\n        const reader = new FileReader();\n        reader.readAsDataURL(blob);\n        reader.onloadend = function() {\n          const base64data = reader.result;\n          json.buffers[0].uri = base64data;\n          onDone(json);\n        };\n      } else {\n        onDone(json);\n      }\n    }\n  }\n  /**\n   * Serializes a userData.\n   *\n   * @param {THREE.Object3D|THREE.Material} object\n   * @param {Object} objectDef\n   */\n  serializeUserData(object, objectDef) {\n    if (Object.keys(object.userData).length === 0)\n      return;\n    const options = this.options;\n    const extensionsUsed = this.extensionsUsed;\n    try {\n      const json = JSON.parse(JSON.stringify(object.userData));\n      if (options.includeCustomExtensions && json.gltfExtensions) {\n        if (objectDef.extensions === void 0)\n          objectDef.extensions = {};\n        for (const extensionName in json.gltfExtensions) {\n          objectDef.extensions[extensionName] = json.gltfExtensions[extensionName];\n          extensionsUsed[extensionName] = true;\n        }\n        delete json.gltfExtensions;\n      }\n      if (Object.keys(json).length > 0)\n        objectDef.extras = json;\n    } catch (error) {\n      console.warn(\n        \"THREE.GLTFExporter: userData of '\" + object.name + \"' won't be serialized because of JSON.stringify error - \" + error.message\n      );\n    }\n  }\n  /**\n   * Returns ids for buffer attributes.\n   * @param  {Object} object\n   * @return {Integer}\n   */\n  getUID(attribute, isRelativeCopy = false) {\n    if (this.uids.has(attribute) === false) {\n      const uids2 = /* @__PURE__ */ new Map();\n      uids2.set(true, this.uid++);\n      uids2.set(false, this.uid++);\n      this.uids.set(attribute, uids2);\n    }\n    const uids = this.uids.get(attribute);\n    return uids.get(isRelativeCopy);\n  }\n  /**\n   * Checks if normal attribute values are normalized.\n   *\n   * @param {BufferAttribute} normal\n   * @returns {Boolean}\n   */\n  isNormalizedNormalAttribute(normal) {\n    const cache = this.cache;\n    if (cache.attributesNormalized.has(normal))\n      return false;\n    const v = new Vector3();\n    for (let i = 0, il = normal.count; i < il; i++) {\n      if (Math.abs(v.fromBufferAttribute(normal, i).length() - 1) > 5e-4)\n        return false;\n    }\n    return true;\n  }\n  /**\n   * Creates normalized normal buffer attribute.\n   *\n   * @param {BufferAttribute} normal\n   * @returns {BufferAttribute}\n   *\n   */\n  createNormalizedNormalAttribute(normal) {\n    const cache = this.cache;\n    if (cache.attributesNormalized.has(normal))\n      return cache.attributesNormalized.get(normal);\n    const attribute = normal.clone();\n    const v = new Vector3();\n    for (let i = 0, il = attribute.count; i < il; i++) {\n      v.fromBufferAttribute(attribute, i);\n      if (v.x === 0 && v.y === 0 && v.z === 0) {\n        v.setX(1);\n      } else {\n        v.normalize();\n      }\n      attribute.setXYZ(i, v.x, v.y, v.z);\n    }\n    cache.attributesNormalized.set(normal, attribute);\n    return attribute;\n  }\n  /**\n   * Applies a texture transform, if present, to the map definition. Requires\n   * the KHR_texture_transform extension.\n   *\n   * @param {Object} mapDef\n   * @param {THREE.Texture} texture\n   */\n  applyTextureTransform(mapDef, texture) {\n    let didTransform = false;\n    const transformDef = {};\n    if (texture.offset.x !== 0 || texture.offset.y !== 0) {\n      transformDef.offset = texture.offset.toArray();\n      didTransform = true;\n    }\n    if (texture.rotation !== 0) {\n      transformDef.rotation = texture.rotation;\n      didTransform = true;\n    }\n    if (texture.repeat.x !== 1 || texture.repeat.y !== 1) {\n      transformDef.scale = texture.repeat.toArray();\n      didTransform = true;\n    }\n    if (didTransform) {\n      mapDef.extensions = mapDef.extensions || {};\n      mapDef.extensions[\"KHR_texture_transform\"] = transformDef;\n      this.extensionsUsed[\"KHR_texture_transform\"] = true;\n    }\n  }\n  buildMetalRoughTexture(metalnessMap, roughnessMap) {\n    if (metalnessMap === roughnessMap)\n      return metalnessMap;\n    function getEncodingConversion(map) {\n      if (\"colorSpace\" in map ? map.colorSpace === \"srgb\" : map.encoding === 3001) {\n        return function SRGBToLinear(c) {\n          return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);\n        };\n      }\n      return function LinearToLinear(c) {\n        return c;\n      };\n    }\n    console.warn(\"THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures.\");\n    if (metalnessMap instanceof CompressedTexture) {\n      metalnessMap = decompress(metalnessMap);\n    }\n    if (roughnessMap instanceof CompressedTexture) {\n      roughnessMap = decompress(roughnessMap);\n    }\n    const metalness = metalnessMap ? metalnessMap.image : null;\n    const roughness = roughnessMap ? roughnessMap.image : null;\n    const width = Math.max(metalness ? metalness.width : 0, roughness ? roughness.width : 0);\n    const height = Math.max(metalness ? metalness.height : 0, roughness ? roughness.height : 0);\n    const canvas = getCanvas();\n    canvas.width = width;\n    canvas.height = height;\n    const context = canvas.getContext(\"2d\");\n    context.fillStyle = \"#00ffff\";\n    context.fillRect(0, 0, width, height);\n    const composite = context.getImageData(0, 0, width, height);\n    if (metalness) {\n      context.drawImage(metalness, 0, 0, width, height);\n      const convert = getEncodingConversion(metalnessMap);\n      const data = context.getImageData(0, 0, width, height).data;\n      for (let i = 2; i < data.length; i += 4) {\n        composite.data[i] = convert(data[i] / 256) * 256;\n      }\n    }\n    if (roughness) {\n      context.drawImage(roughness, 0, 0, width, height);\n      const convert = getEncodingConversion(roughnessMap);\n      const data = context.getImageData(0, 0, width, height).data;\n      for (let i = 1; i < data.length; i += 4) {\n        composite.data[i] = convert(data[i] / 256) * 256;\n      }\n    }\n    context.putImageData(composite, 0, 0);\n    const reference = metalnessMap || roughnessMap;\n    const texture = reference.clone();\n    texture.source = new Texture(canvas).source;\n    if (\"colorSpace\" in texture)\n      texture.colorSpace = \"\";\n    else\n      texture.encoding = 3e3;\n    texture.channel = (metalnessMap || roughnessMap).channel;\n    if (metalnessMap && roughnessMap && metalnessMap.channel !== roughnessMap.channel) {\n      console.warn(\"THREE.GLTFExporter: UV channels for metalnessMap and roughnessMap textures must match.\");\n    }\n    return texture;\n  }\n  /**\n   * Process a buffer to append to the default one.\n   * @param  {ArrayBuffer} buffer\n   * @return {Integer}\n   */\n  processBuffer(buffer) {\n    const json = this.json;\n    const buffers = this.buffers;\n    if (!json.buffers)\n      json.buffers = [{ byteLength: 0 }];\n    buffers.push(buffer);\n    return 0;\n  }\n  /**\n   * Process and generate a BufferView\n   * @param  {BufferAttribute} attribute\n   * @param  {number} componentType\n   * @param  {number} start\n   * @param  {number} count\n   * @param  {number} target (Optional) Target usage of the BufferView\n   * @return {Object}\n   */\n  processBufferView(attribute, componentType, start, count, target) {\n    const json = this.json;\n    if (!json.bufferViews)\n      json.bufferViews = [];\n    let componentSize;\n    switch (componentType) {\n      case WEBGL_CONSTANTS.BYTE:\n      case WEBGL_CONSTANTS.UNSIGNED_BYTE:\n        componentSize = 1;\n        break;\n      case WEBGL_CONSTANTS.SHORT:\n      case WEBGL_CONSTANTS.UNSIGNED_SHORT:\n        componentSize = 2;\n        break;\n      default:\n        componentSize = 4;\n    }\n    const byteLength = getPaddedBufferSize(count * attribute.itemSize * componentSize);\n    const dataView = new DataView(new ArrayBuffer(byteLength));\n    let offset = 0;\n    for (let i = start; i < start + count; i++) {\n      for (let a = 0; a < attribute.itemSize; a++) {\n        let value;\n        if (attribute.itemSize > 4) {\n          value = attribute.array[i * attribute.itemSize + a];\n        } else {\n          if (a === 0)\n            value = attribute.getX(i);\n          else if (a === 1)\n            value = attribute.getY(i);\n          else if (a === 2)\n            value = attribute.getZ(i);\n          else if (a === 3)\n            value = attribute.getW(i);\n          if (attribute.normalized === true) {\n            value = MathUtils.normalize(value, attribute.array);\n          }\n        }\n        if (componentType === WEBGL_CONSTANTS.FLOAT) {\n          dataView.setFloat32(offset, value, true);\n        } else if (componentType === WEBGL_CONSTANTS.INT) {\n          dataView.setInt32(offset, value, true);\n        } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_INT) {\n          dataView.setUint32(offset, value, true);\n        } else if (componentType === WEBGL_CONSTANTS.SHORT) {\n          dataView.setInt16(offset, value, true);\n        } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {\n          dataView.setUint16(offset, value, true);\n        } else if (componentType === WEBGL_CONSTANTS.BYTE) {\n          dataView.setInt8(offset, value);\n        } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {\n          dataView.setUint8(offset, value);\n        }\n        offset += componentSize;\n      }\n    }\n    const bufferViewDef = {\n      buffer: this.processBuffer(dataView.buffer),\n      byteOffset: this.byteOffset,\n      byteLength\n    };\n    if (target !== void 0)\n      bufferViewDef.target = target;\n    if (target === WEBGL_CONSTANTS.ARRAY_BUFFER) {\n      bufferViewDef.byteStride = attribute.itemSize * componentSize;\n    }\n    this.byteOffset += byteLength;\n    json.bufferViews.push(bufferViewDef);\n    const output = {\n      id: json.bufferViews.length - 1,\n      byteLength: 0\n    };\n    return output;\n  }\n  /**\n   * Process and generate a BufferView from an image Blob.\n   * @param {Blob} blob\n   * @return {Promise<Integer>}\n   */\n  processBufferViewImage(blob) {\n    const writer = this;\n    const json = writer.json;\n    if (!json.bufferViews)\n      json.bufferViews = [];\n    return new Promise(function(resolve) {\n      const reader = new FileReader();\n      reader.readAsArrayBuffer(blob);\n      reader.onloadend = function() {\n        const buffer = getPaddedArrayBuffer(reader.result);\n        const bufferViewDef = {\n          buffer: writer.processBuffer(buffer),\n          byteOffset: writer.byteOffset,\n          byteLength: buffer.byteLength\n        };\n        writer.byteOffset += buffer.byteLength;\n        resolve(json.bufferViews.push(bufferViewDef) - 1);\n      };\n    });\n  }\n  /**\n   * Process attribute to generate an accessor\n   * @param  {BufferAttribute} attribute Attribute to process\n   * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range\n   * @param  {Integer} start (Optional)\n   * @param  {Integer} count (Optional)\n   * @return {Integer|null} Index of the processed accessor on the \"accessors\" array\n   */\n  processAccessor(attribute, geometry, start, count) {\n    const json = this.json;\n    const types = {\n      1: \"SCALAR\",\n      2: \"VEC2\",\n      3: \"VEC3\",\n      4: \"VEC4\",\n      9: \"MAT3\",\n      16: \"MAT4\"\n    };\n    let componentType;\n    if (attribute.array.constructor === Float32Array) {\n      componentType = WEBGL_CONSTANTS.FLOAT;\n    } else if (attribute.array.constructor === Int32Array) {\n      componentType = WEBGL_CONSTANTS.INT;\n    } else if (attribute.array.constructor === Uint32Array) {\n      componentType = WEBGL_CONSTANTS.UNSIGNED_INT;\n    } else if (attribute.array.constructor === Int16Array) {\n      componentType = WEBGL_CONSTANTS.SHORT;\n    } else if (attribute.array.constructor === Uint16Array) {\n      componentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;\n    } else if (attribute.array.constructor === Int8Array) {\n      componentType = WEBGL_CONSTANTS.BYTE;\n    } else if (attribute.array.constructor === Uint8Array) {\n      componentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;\n    } else {\n      throw new Error(\n        \"THREE.GLTFExporter: Unsupported bufferAttribute component type: \" + attribute.array.constructor.name\n      );\n    }\n    if (start === void 0)\n      start = 0;\n    if (count === void 0)\n      count = attribute.count;\n    if (count === 0)\n      return null;\n    const minMax = getMinMax(attribute, start, count);\n    let bufferViewTarget;\n    if (geometry !== void 0) {\n      bufferViewTarget = attribute === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER;\n    }\n    const bufferView = this.processBufferView(attribute, componentType, start, count, bufferViewTarget);\n    const accessorDef = {\n      bufferView: bufferView.id,\n      byteOffset: bufferView.byteOffset,\n      componentType,\n      count,\n      max: minMax.max,\n      min: minMax.min,\n      type: types[attribute.itemSize]\n    };\n    if (attribute.normalized === true)\n      accessorDef.normalized = true;\n    if (!json.accessors)\n      json.accessors = [];\n    return json.accessors.push(accessorDef) - 1;\n  }\n  /**\n   * Process image\n   * @param  {Image} image to process\n   * @param  {Integer} format of the image (RGBAFormat)\n   * @param  {Boolean} flipY before writing out the image\n   * @param  {String} mimeType export format\n   * @return {Integer}     Index of the processed texture in the \"images\" array\n   */\n  processImage(image, format, flipY, mimeType = \"image/png\") {\n    if (image !== null) {\n      const writer = this;\n      const cache = writer.cache;\n      const json = writer.json;\n      const options = writer.options;\n      const pending = writer.pending;\n      if (!cache.images.has(image))\n        cache.images.set(image, {});\n      const cachedImages = cache.images.get(image);\n      const key = mimeType + \":flipY/\" + flipY.toString();\n      if (cachedImages[key] !== void 0)\n        return cachedImages[key];\n      if (!json.images)\n        json.images = [];\n      const imageDef = { mimeType };\n      const canvas = getCanvas();\n      canvas.width = Math.min(image.width, options.maxTextureSize);\n      canvas.height = Math.min(image.height, options.maxTextureSize);\n      const ctx = canvas.getContext(\"2d\");\n      if (flipY === true) {\n        ctx.translate(0, canvas.height);\n        ctx.scale(1, -1);\n      }\n      if (image.data !== void 0) {\n        if (format !== RGBAFormat) {\n          console.error(\"GLTFExporter: Only RGBAFormat is supported.\", format);\n        }\n        if (image.width > options.maxTextureSize || image.height > options.maxTextureSize) {\n          console.warn(\"GLTFExporter: Image size is bigger than maxTextureSize\", image);\n        }\n        const data = new Uint8ClampedArray(image.height * image.width * 4);\n        for (let i = 0; i < data.length; i += 4) {\n          data[i + 0] = image.data[i + 0];\n          data[i + 1] = image.data[i + 1];\n          data[i + 2] = image.data[i + 2];\n          data[i + 3] = image.data[i + 3];\n        }\n        ctx.putImageData(new ImageData(data, image.width, image.height), 0, 0);\n      } else {\n        ctx.drawImage(image, 0, 0, canvas.width, canvas.height);\n      }\n      if (options.binary === true) {\n        pending.push(\n          getToBlobPromise(canvas, mimeType).then((blob) => writer.processBufferViewImage(blob)).then((bufferViewIndex) => {\n            imageDef.bufferView = bufferViewIndex;\n          })\n        );\n      } else {\n        if (canvas.toDataURL !== void 0) {\n          imageDef.uri = canvas.toDataURL(mimeType);\n        } else {\n          pending.push(\n            getToBlobPromise(canvas, mimeType).then((blob) => new FileReader().readAsDataURL(blob)).then((dataURL) => {\n              imageDef.uri = dataURL;\n            })\n          );\n        }\n      }\n      const index = json.images.push(imageDef) - 1;\n      cachedImages[key] = index;\n      return index;\n    } else {\n      throw new Error(\"THREE.GLTFExporter: No valid image data found. Unable to process texture.\");\n    }\n  }\n  /**\n   * Process sampler\n   * @param  {Texture} map Texture to process\n   * @return {Integer}     Index of the processed texture in the \"samplers\" array\n   */\n  processSampler(map) {\n    const json = this.json;\n    if (!json.samplers)\n      json.samplers = [];\n    const samplerDef = {\n      magFilter: THREE_TO_WEBGL[map.magFilter],\n      minFilter: THREE_TO_WEBGL[map.minFilter],\n      wrapS: THREE_TO_WEBGL[map.wrapS],\n      wrapT: THREE_TO_WEBGL[map.wrapT]\n    };\n    return json.samplers.push(samplerDef) - 1;\n  }\n  /**\n   * Process texture\n   * @param  {Texture} map Map to process\n   * @return {Integer} Index of the processed texture in the \"textures\" array\n   */\n  processTexture(map) {\n    const writer = this;\n    const options = writer.options;\n    const cache = this.cache;\n    const json = this.json;\n    if (cache.textures.has(map))\n      return cache.textures.get(map);\n    if (!json.textures)\n      json.textures = [];\n    if (map instanceof CompressedTexture) {\n      map = decompress(map, options.maxTextureSize);\n    }\n    let mimeType = map.userData.mimeType;\n    if (mimeType === \"image/webp\")\n      mimeType = \"image/png\";\n    const textureDef = {\n      sampler: this.processSampler(map),\n      source: this.processImage(map.image, map.format, map.flipY, mimeType)\n    };\n    if (map.name)\n      textureDef.name = map.name;\n    this._invokeAll(function(ext) {\n      ext.writeTexture && ext.writeTexture(map, textureDef);\n    });\n    const index = json.textures.push(textureDef) - 1;\n    cache.textures.set(map, index);\n    return index;\n  }\n  /**\n   * Process material\n   * @param  {THREE.Material} material Material to process\n   * @return {Integer|null} Index of the processed material in the \"materials\" array\n   */\n  processMaterial(material) {\n    const cache = this.cache;\n    const json = this.json;\n    if (cache.materials.has(material))\n      return cache.materials.get(material);\n    if (material.isShaderMaterial) {\n      console.warn(\"GLTFExporter: THREE.ShaderMaterial not supported.\");\n      return null;\n    }\n    if (!json.materials)\n      json.materials = [];\n    const materialDef = { pbrMetallicRoughness: {} };\n    if (material.isMeshStandardMaterial !== true && material.isMeshBasicMaterial !== true) {\n      console.warn(\"GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.\");\n    }\n    const color = material.color.toArray().concat([material.opacity]);\n    if (!equalArray(color, [1, 1, 1, 1])) {\n      materialDef.pbrMetallicRoughness.baseColorFactor = color;\n    }\n    if (material.isMeshStandardMaterial) {\n      materialDef.pbrMetallicRoughness.metallicFactor = material.metalness;\n      materialDef.pbrMetallicRoughness.roughnessFactor = material.roughness;\n    } else {\n      materialDef.pbrMetallicRoughness.metallicFactor = 0.5;\n      materialDef.pbrMetallicRoughness.roughnessFactor = 0.5;\n    }\n    if (material.metalnessMap || material.roughnessMap) {\n      const metalRoughTexture = this.buildMetalRoughTexture(material.metalnessMap, material.roughnessMap);\n      const metalRoughMapDef = {\n        index: this.processTexture(metalRoughTexture),\n        channel: metalRoughTexture.channel\n      };\n      this.applyTextureTransform(metalRoughMapDef, metalRoughTexture);\n      materialDef.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef;\n    }\n    if (material.map) {\n      const baseColorMapDef = {\n        index: this.processTexture(material.map),\n        texCoord: material.map.channel\n      };\n      this.applyTextureTransform(baseColorMapDef, material.map);\n      materialDef.pbrMetallicRoughness.baseColorTexture = baseColorMapDef;\n    }\n    if (material.emissive) {\n      const emissive = material.emissive;\n      const maxEmissiveComponent = Math.max(emissive.r, emissive.g, emissive.b);\n      if (maxEmissiveComponent > 0) {\n        materialDef.emissiveFactor = material.emissive.toArray();\n      }\n      if (material.emissiveMap) {\n        const emissiveMapDef = {\n          index: this.processTexture(material.emissiveMap),\n          texCoord: material.emissiveMap.channel\n        };\n        this.applyTextureTransform(emissiveMapDef, material.emissiveMap);\n        materialDef.emissiveTexture = emissiveMapDef;\n      }\n    }\n    if (material.normalMap) {\n      const normalMapDef = {\n        index: this.processTexture(material.normalMap),\n        texCoord: material.normalMap.channel\n      };\n      if (material.normalScale && material.normalScale.x !== 1) {\n        normalMapDef.scale = material.normalScale.x;\n      }\n      this.applyTextureTransform(normalMapDef, material.normalMap);\n      materialDef.normalTexture = normalMapDef;\n    }\n    if (material.aoMap) {\n      const occlusionMapDef = {\n        index: this.processTexture(material.aoMap),\n        texCoord: material.aoMap.channel\n      };\n      if (material.aoMapIntensity !== 1) {\n        occlusionMapDef.strength = material.aoMapIntensity;\n      }\n      this.applyTextureTransform(occlusionMapDef, material.aoMap);\n      materialDef.occlusionTexture = occlusionMapDef;\n    }\n    if (material.transparent) {\n      materialDef.alphaMode = \"BLEND\";\n    } else {\n      if (material.alphaTest > 0) {\n        materialDef.alphaMode = \"MASK\";\n        materialDef.alphaCutoff = material.alphaTest;\n      }\n    }\n    if (material.side === DoubleSide)\n      materialDef.doubleSided = true;\n    if (material.name !== \"\")\n      materialDef.name = material.name;\n    this.serializeUserData(material, materialDef);\n    this._invokeAll(function(ext) {\n      ext.writeMaterial && ext.writeMaterial(material, materialDef);\n    });\n    const index = json.materials.push(materialDef) - 1;\n    cache.materials.set(material, index);\n    return index;\n  }\n  /**\n   * Process mesh\n   * @param  {THREE.Mesh} mesh Mesh to process\n   * @return {Integer|null} Index of the processed mesh in the \"meshes\" array\n   */\n  processMesh(mesh) {\n    const cache = this.cache;\n    const json = this.json;\n    const meshCacheKeyParts = [mesh.geometry.uuid];\n    if (Array.isArray(mesh.material)) {\n      for (let i = 0, l = mesh.material.length; i < l; i++) {\n        meshCacheKeyParts.push(mesh.material[i].uuid);\n      }\n    } else {\n      meshCacheKeyParts.push(mesh.material.uuid);\n    }\n    const meshCacheKey = meshCacheKeyParts.join(\":\");\n    if (cache.meshes.has(meshCacheKey))\n      return cache.meshes.get(meshCacheKey);\n    const geometry = mesh.geometry;\n    let mode;\n    if (mesh.isLineSegments) {\n      mode = WEBGL_CONSTANTS.LINES;\n    } else if (mesh.isLineLoop) {\n      mode = WEBGL_CONSTANTS.LINE_LOOP;\n    } else if (mesh.isLine) {\n      mode = WEBGL_CONSTANTS.LINE_STRIP;\n    } else if (mesh.isPoints) {\n      mode = WEBGL_CONSTANTS.POINTS;\n    } else {\n      mode = mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;\n    }\n    const meshDef = {};\n    const attributes = {};\n    const primitives = [];\n    const targets = [];\n    const nameConversion = {\n      uv: \"TEXCOORD_0\",\n      [REVISION.replace(/\\D+/g, \"\") >= 152 ? \"uv1\" : \"uv2\"]: \"TEXCOORD_1\",\n      color: \"COLOR_0\",\n      skinWeight: \"WEIGHTS_0\",\n      skinIndex: \"JOINTS_0\"\n    };\n    const originalNormal = geometry.getAttribute(\"normal\");\n    if (originalNormal !== void 0 && !this.isNormalizedNormalAttribute(originalNormal)) {\n      console.warn(\"THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.\");\n      geometry.setAttribute(\"normal\", this.createNormalizedNormalAttribute(originalNormal));\n    }\n    let modifiedAttribute = null;\n    for (let attributeName in geometry.attributes) {\n      if (attributeName.slice(0, 5) === \"morph\")\n        continue;\n      const attribute = geometry.attributes[attributeName];\n      attributeName = nameConversion[attributeName] || attributeName.toUpperCase();\n      const validVertexAttributes = /^(POSITION|NORMAL|TANGENT|TEXCOORD_\\d+|COLOR_\\d+|JOINTS_\\d+|WEIGHTS_\\d+)$/;\n      if (!validVertexAttributes.test(attributeName))\n        attributeName = \"_\" + attributeName;\n      if (cache.attributes.has(this.getUID(attribute))) {\n        attributes[attributeName] = cache.attributes.get(this.getUID(attribute));\n        continue;\n      }\n      modifiedAttribute = null;\n      const array = attribute.array;\n      if (attributeName === \"JOINTS_0\" && !(array instanceof Uint16Array) && !(array instanceof Uint8Array)) {\n        console.warn('GLTFExporter: Attribute \"skinIndex\" converted to type UNSIGNED_SHORT.');\n        modifiedAttribute = new BufferAttribute(new Uint16Array(array), attribute.itemSize, attribute.normalized);\n      }\n      const accessor = this.processAccessor(modifiedAttribute || attribute, geometry);\n      if (accessor !== null) {\n        if (!attributeName.startsWith(\"_\")) {\n          this.detectMeshQuantization(attributeName, attribute);\n        }\n        attributes[attributeName] = accessor;\n        cache.attributes.set(this.getUID(attribute), accessor);\n      }\n    }\n    if (originalNormal !== void 0)\n      geometry.setAttribute(\"normal\", originalNormal);\n    if (Object.keys(attributes).length === 0)\n      return null;\n    if (mesh.morphTargetInfluences !== void 0 && mesh.morphTargetInfluences.length > 0) {\n      const weights = [];\n      const targetNames = [];\n      const reverseDictionary = {};\n      if (mesh.morphTargetDictionary !== void 0) {\n        for (const key in mesh.morphTargetDictionary) {\n          reverseDictionary[mesh.morphTargetDictionary[key]] = key;\n        }\n      }\n      for (let i = 0; i < mesh.morphTargetInfluences.length; ++i) {\n        const target = {};\n        let warned = false;\n        for (const attributeName in geometry.morphAttributes) {\n          if (attributeName !== \"position\" && attributeName !== \"normal\") {\n            if (!warned) {\n              console.warn(\"GLTFExporter: Only POSITION and NORMAL morph are supported.\");\n              warned = true;\n            }\n            continue;\n          }\n          const attribute = geometry.morphAttributes[attributeName][i];\n          const gltfAttributeName = attributeName.toUpperCase();\n          const baseAttribute = geometry.attributes[attributeName];\n          if (cache.attributes.has(this.getUID(attribute, true))) {\n            target[gltfAttributeName] = cache.attributes.get(this.getUID(attribute, true));\n            continue;\n          }\n          const relativeAttribute = attribute.clone();\n          if (!geometry.morphTargetsRelative) {\n            for (let j = 0, jl = attribute.count; j < jl; j++) {\n              for (let a = 0; a < attribute.itemSize; a++) {\n                if (a === 0)\n                  relativeAttribute.setX(j, attribute.getX(j) - baseAttribute.getX(j));\n                if (a === 1)\n                  relativeAttribute.setY(j, attribute.getY(j) - baseAttribute.getY(j));\n                if (a === 2)\n                  relativeAttribute.setZ(j, attribute.getZ(j) - baseAttribute.getZ(j));\n                if (a === 3)\n                  relativeAttribute.setW(j, attribute.getW(j) - baseAttribute.getW(j));\n              }\n            }\n          }\n          target[gltfAttributeName] = this.processAccessor(relativeAttribute, geometry);\n          cache.attributes.set(this.getUID(baseAttribute, true), target[gltfAttributeName]);\n        }\n        targets.push(target);\n        weights.push(mesh.morphTargetInfluences[i]);\n        if (mesh.morphTargetDictionary !== void 0)\n          targetNames.push(reverseDictionary[i]);\n      }\n      meshDef.weights = weights;\n      if (targetNames.length > 0) {\n        meshDef.extras = {};\n        meshDef.extras.targetNames = targetNames;\n      }\n    }\n    const isMultiMaterial = Array.isArray(mesh.material);\n    if (isMultiMaterial && geometry.groups.length === 0)\n      return null;\n    const materials = isMultiMaterial ? mesh.material : [mesh.material];\n    const groups = isMultiMaterial ? geometry.groups : [{ materialIndex: 0, start: void 0, count: void 0 }];\n    for (let i = 0, il = groups.length; i < il; i++) {\n      const primitive = {\n        mode,\n        attributes\n      };\n      this.serializeUserData(geometry, primitive);\n      if (targets.length > 0)\n        primitive.targets = targets;\n      if (geometry.index !== null) {\n        let cacheKey = this.getUID(geometry.index);\n        if (groups[i].start !== void 0 || groups[i].count !== void 0) {\n          cacheKey += \":\" + groups[i].start + \":\" + groups[i].count;\n        }\n        if (cache.attributes.has(cacheKey)) {\n          primitive.indices = cache.attributes.get(cacheKey);\n        } else {\n          primitive.indices = this.processAccessor(geometry.index, geometry, groups[i].start, groups[i].count);\n          cache.attributes.set(cacheKey, primitive.indices);\n        }\n        if (primitive.indices === null)\n          delete primitive.indices;\n      }\n      const material = this.processMaterial(materials[groups[i].materialIndex]);\n      if (material !== null)\n        primitive.material = material;\n      primitives.push(primitive);\n    }\n    meshDef.primitives = primitives;\n    if (!json.meshes)\n      json.meshes = [];\n    this._invokeAll(function(ext) {\n      ext.writeMesh && ext.writeMesh(mesh, meshDef);\n    });\n    const index = json.meshes.push(meshDef) - 1;\n    cache.meshes.set(meshCacheKey, index);\n    return index;\n  }\n  /**\n   * If a vertex attribute with a\n   * [non-standard data type](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#meshes-overview)\n   * is used, it is checked whether it is a valid data type according to the\n   * [KHR_mesh_quantization](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md)\n   * extension.\n   * In this case the extension is automatically added to the list of used extensions.\n   *\n   * @param {string} attributeName\n   * @param {THREE.BufferAttribute} attribute\n   */\n  detectMeshQuantization(attributeName, attribute) {\n    if (this.extensionsUsed[KHR_MESH_QUANTIZATION])\n      return;\n    let attrType = void 0;\n    switch (attribute.array.constructor) {\n      case Int8Array:\n        attrType = \"byte\";\n        break;\n      case Uint8Array:\n        attrType = \"unsigned byte\";\n        break;\n      case Int16Array:\n        attrType = \"short\";\n        break;\n      case Uint16Array:\n        attrType = \"unsigned short\";\n        break;\n      default:\n        return;\n    }\n    if (attribute.normalized)\n      attrType += \" normalized\";\n    const attrNamePrefix = attributeName.split(\"_\", 1)[0];\n    if (KHR_mesh_quantization_ExtraAttrTypes[attrNamePrefix] && KHR_mesh_quantization_ExtraAttrTypes[attrNamePrefix].includes(attrType)) {\n      this.extensionsUsed[KHR_MESH_QUANTIZATION] = true;\n      this.extensionsRequired[KHR_MESH_QUANTIZATION] = true;\n    }\n  }\n  /**\n   * Process camera\n   * @param  {THREE.Camera} camera Camera to process\n   * @return {Integer}      Index of the processed mesh in the \"camera\" array\n   */\n  processCamera(camera) {\n    const json = this.json;\n    if (!json.cameras)\n      json.cameras = [];\n    const isOrtho = camera.isOrthographicCamera;\n    const cameraDef = {\n      type: isOrtho ? \"orthographic\" : \"perspective\"\n    };\n    if (isOrtho) {\n      cameraDef.orthographic = {\n        xmag: camera.right * 2,\n        ymag: camera.top * 2,\n        zfar: camera.far <= 0 ? 1e-3 : camera.far,\n        znear: camera.near < 0 ? 0 : camera.near\n      };\n    } else {\n      cameraDef.perspective = {\n        aspectRatio: camera.aspect,\n        yfov: MathUtils.degToRad(camera.fov),\n        zfar: camera.far <= 0 ? 1e-3 : camera.far,\n        znear: camera.near < 0 ? 0 : camera.near\n      };\n    }\n    if (camera.name !== \"\")\n      cameraDef.name = camera.type;\n    return json.cameras.push(cameraDef) - 1;\n  }\n  /**\n   * Creates glTF animation entry from AnimationClip object.\n   *\n   * Status:\n   * - Only properties listed in PATH_PROPERTIES may be animated.\n   *\n   * @param {THREE.AnimationClip} clip\n   * @param {THREE.Object3D} root\n   * @return {number|null}\n   */\n  processAnimation(clip, root) {\n    const json = this.json;\n    const nodeMap = this.nodeMap;\n    if (!json.animations)\n      json.animations = [];\n    clip = GLTFExporter.Utils.mergeMorphTargetTracks(clip.clone(), root);\n    const tracks = clip.tracks;\n    const channels = [];\n    const samplers = [];\n    for (let i = 0; i < tracks.length; ++i) {\n      const track = tracks[i];\n      const trackBinding = PropertyBinding.parseTrackName(track.name);\n      let trackNode = PropertyBinding.findNode(root, trackBinding.nodeName);\n      const trackProperty = PATH_PROPERTIES[trackBinding.propertyName];\n      if (trackBinding.objectName === \"bones\") {\n        if (trackNode.isSkinnedMesh === true) {\n          trackNode = trackNode.skeleton.getBoneByName(trackBinding.objectIndex);\n        } else {\n          trackNode = void 0;\n        }\n      }\n      if (!trackNode || !trackProperty) {\n        console.warn('THREE.GLTFExporter: Could not export animation track \"%s\".', track.name);\n        return null;\n      }\n      const inputItemSize = 1;\n      let outputItemSize = track.values.length / track.times.length;\n      if (trackProperty === PATH_PROPERTIES.morphTargetInfluences) {\n        outputItemSize /= trackNode.morphTargetInfluences.length;\n      }\n      let interpolation;\n      if (track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === true) {\n        interpolation = \"CUBICSPLINE\";\n        outputItemSize /= 3;\n      } else if (track.getInterpolation() === InterpolateDiscrete) {\n        interpolation = \"STEP\";\n      } else {\n        interpolation = \"LINEAR\";\n      }\n      samplers.push({\n        input: this.processAccessor(new BufferAttribute(track.times, inputItemSize)),\n        output: this.processAccessor(new BufferAttribute(track.values, outputItemSize)),\n        interpolation\n      });\n      channels.push({\n        sampler: samplers.length - 1,\n        target: {\n          node: nodeMap.get(trackNode),\n          path: trackProperty\n        }\n      });\n    }\n    json.animations.push({\n      name: clip.name || \"clip_\" + json.animations.length,\n      samplers,\n      channels\n    });\n    return json.animations.length - 1;\n  }\n  /**\n   * @param {THREE.Object3D} object\n   * @return {number|null}\n   */\n  processSkin(object) {\n    const json = this.json;\n    const nodeMap = this.nodeMap;\n    const node = json.nodes[nodeMap.get(object)];\n    const skeleton = object.skeleton;\n    if (skeleton === void 0)\n      return null;\n    const rootJoint = object.skeleton.bones[0];\n    if (rootJoint === void 0)\n      return null;\n    const joints = [];\n    const inverseBindMatrices = new Float32Array(skeleton.bones.length * 16);\n    const temporaryBoneInverse = new Matrix4();\n    for (let i = 0; i < skeleton.bones.length; ++i) {\n      joints.push(nodeMap.get(skeleton.bones[i]));\n      temporaryBoneInverse.copy(skeleton.boneInverses[i]);\n      temporaryBoneInverse.multiply(object.bindMatrix).toArray(inverseBindMatrices, i * 16);\n    }\n    if (json.skins === void 0)\n      json.skins = [];\n    json.skins.push({\n      inverseBindMatrices: this.processAccessor(new BufferAttribute(inverseBindMatrices, 16)),\n      joints,\n      skeleton: nodeMap.get(rootJoint)\n    });\n    const skinIndex = node.skin = json.skins.length - 1;\n    return skinIndex;\n  }\n  /**\n   * Process Object3D node\n   * @param  {THREE.Object3D} node Object3D to processNode\n   * @return {Integer} Index of the node in the nodes list\n   */\n  processNode(object) {\n    const json = this.json;\n    const options = this.options;\n    const nodeMap = this.nodeMap;\n    if (!json.nodes)\n      json.nodes = [];\n    const nodeDef = {};\n    if (options.trs) {\n      const rotation = object.quaternion.toArray();\n      const position = object.position.toArray();\n      const scale = object.scale.toArray();\n      if (!equalArray(rotation, [0, 0, 0, 1])) {\n        nodeDef.rotation = rotation;\n      }\n      if (!equalArray(position, [0, 0, 0])) {\n        nodeDef.translation = position;\n      }\n      if (!equalArray(scale, [1, 1, 1])) {\n        nodeDef.scale = scale;\n      }\n    } else {\n      if (object.matrixAutoUpdate) {\n        object.updateMatrix();\n      }\n      if (isIdentityMatrix(object.matrix) === false) {\n        nodeDef.matrix = object.matrix.elements;\n      }\n    }\n    if (object.name !== \"\")\n      nodeDef.name = String(object.name);\n    this.serializeUserData(object, nodeDef);\n    if (object.isMesh || object.isLine || object.isPoints) {\n      const meshIndex = this.processMesh(object);\n      if (meshIndex !== null)\n        nodeDef.mesh = meshIndex;\n    } else if (object.isCamera) {\n      nodeDef.camera = this.processCamera(object);\n    }\n    if (object.isSkinnedMesh)\n      this.skins.push(object);\n    if (object.children.length > 0) {\n      const children = [];\n      for (let i = 0, l = object.children.length; i < l; i++) {\n        const child = object.children[i];\n        if (child.visible || options.onlyVisible === false) {\n          const nodeIndex2 = this.processNode(child);\n          if (nodeIndex2 !== null)\n            children.push(nodeIndex2);\n        }\n      }\n      if (children.length > 0)\n        nodeDef.children = children;\n    }\n    this._invokeAll(function(ext) {\n      ext.writeNode && ext.writeNode(object, nodeDef);\n    });\n    const nodeIndex = json.nodes.push(nodeDef) - 1;\n    nodeMap.set(object, nodeIndex);\n    return nodeIndex;\n  }\n  /**\n   * Process Scene\n   * @param  {Scene} node Scene to process\n   */\n  processScene(scene) {\n    const json = this.json;\n    const options = this.options;\n    if (!json.scenes) {\n      json.scenes = [];\n      json.scene = 0;\n    }\n    const sceneDef = {};\n    if (scene.name !== \"\")\n      sceneDef.name = scene.name;\n    json.scenes.push(sceneDef);\n    const nodes = [];\n    for (let i = 0, l = scene.children.length; i < l; i++) {\n      const child = scene.children[i];\n      if (child.visible || options.onlyVisible === false) {\n        const nodeIndex = this.processNode(child);\n        if (nodeIndex !== null)\n          nodes.push(nodeIndex);\n      }\n    }\n    if (nodes.length > 0)\n      sceneDef.nodes = nodes;\n    this.serializeUserData(scene, sceneDef);\n  }\n  /**\n   * Creates a Scene to hold a list of objects and parse it\n   * @param  {Array} objects List of objects to process\n   */\n  processObjects(objects) {\n    const scene = new Scene();\n    scene.name = \"AuxScene\";\n    for (let i = 0; i < objects.length; i++) {\n      scene.children.push(objects[i]);\n    }\n    this.processScene(scene);\n  }\n  /**\n   * @param {THREE.Object3D|Array<THREE.Object3D>} input\n   */\n  processInput(input) {\n    const options = this.options;\n    input = input instanceof Array ? input : [input];\n    this._invokeAll(function(ext) {\n      ext.beforeParse && ext.beforeParse(input);\n    });\n    const objectsWithoutScene = [];\n    for (let i = 0; i < input.length; i++) {\n      if (input[i] instanceof Scene) {\n        this.processScene(input[i]);\n      } else {\n        objectsWithoutScene.push(input[i]);\n      }\n    }\n    if (objectsWithoutScene.length > 0)\n      this.processObjects(objectsWithoutScene);\n    for (let i = 0; i < this.skins.length; ++i) {\n      this.processSkin(this.skins[i]);\n    }\n    for (let i = 0; i < options.animations.length; ++i) {\n      this.processAnimation(options.animations[i], input[0]);\n    }\n    this._invokeAll(function(ext) {\n      ext.afterParse && ext.afterParse(input);\n    });\n  }\n  _invokeAll(func) {\n    for (let i = 0, il = this.plugins.length; i < il; i++) {\n      func(this.plugins[i]);\n    }\n  }\n}\nclass GLTFLightExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_lights_punctual\";\n  }\n  writeNode(light, nodeDef) {\n    if (!light.isLight)\n      return;\n    if (!light.isDirectionalLight && !light.isPointLight && !light.isSpotLight) {\n      console.warn(\"THREE.GLTFExporter: Only directional, point, and spot lights are supported.\", light);\n      return;\n    }\n    const writer = this.writer;\n    const json = writer.json;\n    const extensionsUsed = writer.extensionsUsed;\n    const lightDef = {};\n    if (light.name)\n      lightDef.name = light.name;\n    lightDef.color = light.color.toArray();\n    lightDef.intensity = light.intensity;\n    if (light.isDirectionalLight) {\n      lightDef.type = \"directional\";\n    } else if (light.isPointLight) {\n      lightDef.type = \"point\";\n      if (light.distance > 0)\n        lightDef.range = light.distance;\n    } else if (light.isSpotLight) {\n      lightDef.type = \"spot\";\n      if (light.distance > 0)\n        lightDef.range = light.distance;\n      lightDef.spot = {};\n      lightDef.spot.innerConeAngle = (light.penumbra - 1) * light.angle * -1;\n      lightDef.spot.outerConeAngle = light.angle;\n    }\n    if (light.decay !== void 0 && light.decay !== 2) {\n      console.warn(\n        \"THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2.\"\n      );\n    }\n    if (light.target && (light.target.parent !== light || light.target.position.x !== 0 || light.target.position.y !== 0 || light.target.position.z !== -1)) {\n      console.warn(\n        \"THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1.\"\n      );\n    }\n    if (!extensionsUsed[this.name]) {\n      json.extensions = json.extensions || {};\n      json.extensions[this.name] = { lights: [] };\n      extensionsUsed[this.name] = true;\n    }\n    const lights = json.extensions[this.name].lights;\n    lights.push(lightDef);\n    nodeDef.extensions = nodeDef.extensions || {};\n    nodeDef.extensions[this.name] = { light: lights.length - 1 };\n  }\n}\nclass GLTFMaterialsUnlitExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_unlit\";\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshBasicMaterial)\n      return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = {};\n    extensionsUsed[this.name] = true;\n    materialDef.pbrMetallicRoughness.metallicFactor = 0;\n    materialDef.pbrMetallicRoughness.roughnessFactor = 0.9;\n  }\n}\nclass GLTFMaterialsClearcoatExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_clearcoat\";\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.clearcoat === 0)\n      return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.clearcoatFactor = material.clearcoat;\n    if (material.clearcoatMap) {\n      const clearcoatMapDef = {\n        index: writer.processTexture(material.clearcoatMap),\n        texCoord: material.clearcoatMap.channel\n      };\n      writer.applyTextureTransform(clearcoatMapDef, material.clearcoatMap);\n      extensionDef.clearcoatTexture = clearcoatMapDef;\n    }\n    extensionDef.clearcoatRoughnessFactor = material.clearcoatRoughness;\n    if (material.clearcoatRoughnessMap) {\n      const clearcoatRoughnessMapDef = {\n        index: writer.processTexture(material.clearcoatRoughnessMap),\n        texCoord: material.clearcoatRoughnessMap.channel\n      };\n      writer.applyTextureTransform(clearcoatRoughnessMapDef, material.clearcoatRoughnessMap);\n      extensionDef.clearcoatRoughnessTexture = clearcoatRoughnessMapDef;\n    }\n    if (material.clearcoatNormalMap) {\n      const clearcoatNormalMapDef = {\n        index: writer.processTexture(material.clearcoatNormalMap),\n        texCoord: material.clearcoatNormalMap.channel\n      };\n      writer.applyTextureTransform(clearcoatNormalMapDef, material.clearcoatNormalMap);\n      extensionDef.clearcoatNormalTexture = clearcoatNormalMapDef;\n    }\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\nclass GLTFMaterialsIridescenceExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_iridescence\";\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.iridescence === 0)\n      return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.iridescenceFactor = material.iridescence;\n    if (material.iridescenceMap) {\n      const iridescenceMapDef = {\n        index: writer.processTexture(material.iridescenceMap),\n        texCoord: material.iridescenceMap.channel\n      };\n      writer.applyTextureTransform(iridescenceMapDef, material.iridescenceMap);\n      extensionDef.iridescenceTexture = iridescenceMapDef;\n    }\n    extensionDef.iridescenceIor = material.iridescenceIOR;\n    extensionDef.iridescenceThicknessMinimum = material.iridescenceThicknessRange[0];\n    extensionDef.iridescenceThicknessMaximum = material.iridescenceThicknessRange[1];\n    if (material.iridescenceThicknessMap) {\n      const iridescenceThicknessMapDef = {\n        index: writer.processTexture(material.iridescenceThicknessMap),\n        texCoord: material.iridescenceThicknessMap.channel\n      };\n      writer.applyTextureTransform(iridescenceThicknessMapDef, material.iridescenceThicknessMap);\n      extensionDef.iridescenceThicknessTexture = iridescenceThicknessMapDef;\n    }\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\nclass GLTFMaterialsTransmissionExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_transmission\";\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.transmission === 0)\n      return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.transmissionFactor = material.transmission;\n    if (material.transmissionMap) {\n      const transmissionMapDef = {\n        index: writer.processTexture(material.transmissionMap),\n        texCoord: material.transmissionMap.channel\n      };\n      writer.applyTextureTransform(transmissionMapDef, material.transmissionMap);\n      extensionDef.transmissionTexture = transmissionMapDef;\n    }\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\nclass GLTFMaterialsVolumeExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_volume\";\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.transmission === 0)\n      return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.thicknessFactor = material.thickness;\n    if (material.thicknessMap) {\n      const thicknessMapDef = {\n        index: writer.processTexture(material.thicknessMap),\n        texCoord: material.thicknessMap.channel\n      };\n      writer.applyTextureTransform(thicknessMapDef, material.thicknessMap);\n      extensionDef.thicknessTexture = thicknessMapDef;\n    }\n    extensionDef.attenuationDistance = material.attenuationDistance;\n    extensionDef.attenuationColor = material.attenuationColor.toArray();\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\nclass GLTFMaterialsIorExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_ior\";\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.ior === 1.5)\n      return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.ior = material.ior;\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\nclass GLTFMaterialsSpecularExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_specular\";\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.specularIntensity === 1 && material.specularColor.equals(DEFAULT_SPECULAR_COLOR) && !material.specularIntensityMap && !material.specularColorTexture)\n      return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    if (material.specularIntensityMap) {\n      const specularIntensityMapDef = {\n        index: writer.processTexture(material.specularIntensityMap),\n        texCoord: material.specularIntensityMap.channel\n      };\n      writer.applyTextureTransform(specularIntensityMapDef, material.specularIntensityMap);\n      extensionDef.specularTexture = specularIntensityMapDef;\n    }\n    if (material.specularColorMap) {\n      const specularColorMapDef = {\n        index: writer.processTexture(material.specularColorMap),\n        texCoord: material.specularColorMap.channel\n      };\n      writer.applyTextureTransform(specularColorMapDef, material.specularColorMap);\n      extensionDef.specularColorTexture = specularColorMapDef;\n    }\n    extensionDef.specularFactor = material.specularIntensity;\n    extensionDef.specularColorFactor = material.specularColor.toArray();\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\nclass GLTFMaterialsSheenExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_sheen\";\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.sheen == 0)\n      return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    if (material.sheenRoughnessMap) {\n      const sheenRoughnessMapDef = {\n        index: writer.processTexture(material.sheenRoughnessMap),\n        texCoord: material.sheenRoughnessMap.channel\n      };\n      writer.applyTextureTransform(sheenRoughnessMapDef, material.sheenRoughnessMap);\n      extensionDef.sheenRoughnessTexture = sheenRoughnessMapDef;\n    }\n    if (material.sheenColorMap) {\n      const sheenColorMapDef = {\n        index: writer.processTexture(material.sheenColorMap),\n        texCoord: material.sheenColorMap.channel\n      };\n      writer.applyTextureTransform(sheenColorMapDef, material.sheenColorMap);\n      extensionDef.sheenColorTexture = sheenColorMapDef;\n    }\n    extensionDef.sheenRoughnessFactor = material.sheenRoughness;\n    extensionDef.sheenColorFactor = material.sheenColor.toArray();\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\nclass GLTFMaterialsAnisotropyExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_anisotropy\";\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.anisotropy == 0)\n      return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    if (material.anisotropyMap) {\n      const anisotropyMapDef = { index: writer.processTexture(material.anisotropyMap) };\n      writer.applyTextureTransform(anisotropyMapDef, material.anisotropyMap);\n      extensionDef.anisotropyTexture = anisotropyMapDef;\n    }\n    extensionDef.anisotropyStrength = material.anisotropy;\n    extensionDef.anisotropyRotation = material.anisotropyRotation;\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\nclass GLTFMaterialsEmissiveStrengthExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_emissive_strength\";\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshStandardMaterial || material.emissiveIntensity === 1)\n      return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.emissiveStrength = material.emissiveIntensity;\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\nGLTFExporter.Utils = {\n  insertKeyframe: function(track, time) {\n    const tolerance = 1e-3;\n    const valueSize = track.getValueSize();\n    const times = new track.TimeBufferType(track.times.length + 1);\n    const values = new track.ValueBufferType(track.values.length + valueSize);\n    const interpolant = track.createInterpolant(new track.ValueBufferType(valueSize));\n    let index;\n    if (track.times.length === 0) {\n      times[0] = time;\n      for (let i = 0; i < valueSize; i++) {\n        values[i] = 0;\n      }\n      index = 0;\n    } else if (time < track.times[0]) {\n      if (Math.abs(track.times[0] - time) < tolerance)\n        return 0;\n      times[0] = time;\n      times.set(track.times, 1);\n      values.set(interpolant.evaluate(time), 0);\n      values.set(track.values, valueSize);\n      index = 0;\n    } else if (time > track.times[track.times.length - 1]) {\n      if (Math.abs(track.times[track.times.length - 1] - time) < tolerance) {\n        return track.times.length - 1;\n      }\n      times[times.length - 1] = time;\n      times.set(track.times, 0);\n      values.set(track.values, 0);\n      values.set(interpolant.evaluate(time), track.values.length);\n      index = times.length - 1;\n    } else {\n      for (let i = 0; i < track.times.length; i++) {\n        if (Math.abs(track.times[i] - time) < tolerance)\n          return i;\n        if (track.times[i] < time && track.times[i + 1] > time) {\n          times.set(track.times.slice(0, i + 1), 0);\n          times[i + 1] = time;\n          times.set(track.times.slice(i + 1), i + 2);\n          values.set(track.values.slice(0, (i + 1) * valueSize), 0);\n          values.set(interpolant.evaluate(time), (i + 1) * valueSize);\n          values.set(track.values.slice((i + 1) * valueSize), (i + 2) * valueSize);\n          index = i + 1;\n          break;\n        }\n      }\n    }\n    track.times = times;\n    track.values = values;\n    return index;\n  },\n  mergeMorphTargetTracks: function(clip, root) {\n    const tracks = [];\n    const mergedTracks = {};\n    const sourceTracks = clip.tracks;\n    for (let i = 0; i < sourceTracks.length; ++i) {\n      let sourceTrack = sourceTracks[i];\n      const sourceTrackBinding = PropertyBinding.parseTrackName(sourceTrack.name);\n      const sourceTrackNode = PropertyBinding.findNode(root, sourceTrackBinding.nodeName);\n      if (sourceTrackBinding.propertyName !== \"morphTargetInfluences\" || sourceTrackBinding.propertyIndex === void 0) {\n        tracks.push(sourceTrack);\n        continue;\n      }\n      if (sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete && sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear) {\n        if (sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {\n          throw new Error(\"THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.\");\n        }\n        console.warn(\"THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.\");\n        sourceTrack = sourceTrack.clone();\n        sourceTrack.setInterpolation(InterpolateLinear);\n      }\n      const targetCount = sourceTrackNode.morphTargetInfluences.length;\n      const targetIndex = sourceTrackNode.morphTargetDictionary[sourceTrackBinding.propertyIndex];\n      if (targetIndex === void 0) {\n        throw new Error(\"THREE.GLTFExporter: Morph target name not found: \" + sourceTrackBinding.propertyIndex);\n      }\n      let mergedTrack;\n      if (mergedTracks[sourceTrackNode.uuid] === void 0) {\n        mergedTrack = sourceTrack.clone();\n        const values = new mergedTrack.ValueBufferType(targetCount * mergedTrack.times.length);\n        for (let j = 0; j < mergedTrack.times.length; j++) {\n          values[j * targetCount + targetIndex] = mergedTrack.values[j];\n        }\n        mergedTrack.name = (sourceTrackBinding.nodeName || \"\") + \".morphTargetInfluences\";\n        mergedTrack.values = values;\n        mergedTracks[sourceTrackNode.uuid] = mergedTrack;\n        tracks.push(mergedTrack);\n        continue;\n      }\n      const sourceInterpolant = sourceTrack.createInterpolant(new sourceTrack.ValueBufferType(1));\n      mergedTrack = mergedTracks[sourceTrackNode.uuid];\n      for (let j = 0; j < mergedTrack.times.length; j++) {\n        mergedTrack.values[j * targetCount + targetIndex] = sourceInterpolant.evaluate(mergedTrack.times[j]);\n      }\n      for (let j = 0; j < sourceTrack.times.length; j++) {\n        const keyframeIndex = this.insertKeyframe(mergedTrack, sourceTrack.times[j]);\n        mergedTrack.values[keyframeIndex * targetCount + targetIndex] = sourceTrack.values[j];\n      }\n    }\n    clip.tracks = tracks;\n    return clip;\n  }\n};\nexport {\n  GLTFExporter\n};\n"]},"metadata":{},"sourceType":"module"}