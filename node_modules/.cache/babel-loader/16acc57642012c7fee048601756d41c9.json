{"ast":null,"code":"import { Mesh, Vector3, Matrix3 } from \"three\";\n\nclass PLYExporter {\n  parse(object, onDone, options) {\n    if (onDone && typeof onDone === \"object\") {\n      console.warn('THREE.PLYExporter: The options parameter is now the third argument to the \"parse\" function. See the documentation for the new API.');\n      options = onDone;\n      onDone = void 0;\n    }\n\n    const defaultOptions = {\n      binary: false,\n      excludeAttributes: [],\n      // normal, uv, color, index\n      littleEndian: false\n    };\n    options = Object.assign(defaultOptions, options);\n    const excludeAttributes = options.excludeAttributes;\n    let includeNormals = false;\n    let includeColors = false;\n    let includeUVs = false;\n    let vertexCount = 0;\n    let faceCount = 0;\n    object.traverse(function (child) {\n      if (child instanceof Mesh && child.isMesh) {\n        const mesh = child;\n        const geometry = mesh.geometry;\n\n        if (!geometry.isBufferGeometry) {\n          throw new Error(\"THREE.PLYExporter: Geometry is not of type THREE.BufferGeometry.\");\n        }\n\n        const vertices = geometry.getAttribute(\"position\");\n        const normals = geometry.getAttribute(\"normal\");\n        const uvs = geometry.getAttribute(\"uv\");\n        const colors = geometry.getAttribute(\"color\");\n        const indices = geometry.getIndex();\n\n        if (vertices === void 0) {\n          return;\n        }\n\n        vertexCount += vertices.count;\n        faceCount += indices ? indices.count / 3 : vertices.count / 3;\n        if (normals !== void 0) includeNormals = true;\n        if (uvs !== void 0) includeUVs = true;\n        if (colors !== void 0) includeColors = true;\n      }\n    });\n    const includeIndices = (excludeAttributes == null ? void 0 : excludeAttributes.indexOf(\"index\")) === -1;\n    includeNormals = includeNormals && (excludeAttributes == null ? void 0 : excludeAttributes.indexOf(\"normal\")) === -1;\n    includeColors = includeColors && (excludeAttributes == null ? void 0 : excludeAttributes.indexOf(\"color\")) === -1;\n    includeUVs = includeUVs && (excludeAttributes == null ? void 0 : excludeAttributes.indexOf(\"uv\")) === -1;\n\n    if (includeIndices && faceCount !== Math.floor(faceCount)) {\n      console.error(\"PLYExporter: Failed to generate a valid PLY file with triangle indices because the number of indices is not divisible by 3.\");\n      return null;\n    }\n\n    const indexByteCount = 4;\n    let header = `ply\nformat ${options.binary ? options.littleEndian ? \"binary_little_endian\" : \"binary_big_endian\" : \"ascii\"} 1.0\nelement vertex ${vertexCount}\nproperty float x\nproperty float y\nproperty float z\n`;\n\n    if (includeNormals) {\n      header += \"property float nx\\nproperty float ny\\nproperty float nz\\n\";\n    }\n\n    if (includeUVs) {\n      header += \"property float s\\nproperty float t\\n\";\n    }\n\n    if (includeColors) {\n      header += \"property uchar red\\nproperty uchar green\\nproperty uchar blue\\n\";\n    }\n\n    if (includeIndices) {\n      header += `${`element face ${faceCount}\n`}property list uchar int vertex_index\n`;\n    }\n\n    header += \"end_header\\n\";\n    const vertex = new Vector3();\n    const normalMatrixWorld = new Matrix3();\n    let result = null;\n\n    if (options.binary) {\n      const headerBin = new TextEncoder().encode(header);\n      const vertexListLength = vertexCount * (4 * 3 + (includeNormals ? 4 * 3 : 0) + (includeColors ? 3 : 0) + (includeUVs ? 4 * 2 : 0));\n      const faceListLength = includeIndices ? faceCount * (indexByteCount * 3 + 1) : 0;\n      const output = new DataView(new ArrayBuffer(headerBin.length + vertexListLength + faceListLength));\n      new Uint8Array(output.buffer).set(headerBin, 0);\n      let vOffset = headerBin.length;\n      let fOffset = headerBin.length + vertexListLength;\n      let writtenVertices = 0;\n      this.traverseMeshes(object, function (mesh, geometry) {\n        const vertices = geometry.getAttribute(\"position\");\n        const normals = geometry.getAttribute(\"normal\");\n        const uvs = geometry.getAttribute(\"uv\");\n        const colors = geometry.getAttribute(\"color\");\n        const indices = geometry.getIndex();\n        normalMatrixWorld.getNormalMatrix(mesh.matrixWorld);\n\n        for (let i = 0, l = vertices.count; i < l; i++) {\n          vertex.x = vertices.getX(i);\n          vertex.y = vertices.getY(i);\n          vertex.z = vertices.getZ(i);\n          vertex.applyMatrix4(mesh.matrixWorld);\n          output.setFloat32(vOffset, vertex.x, options.littleEndian);\n          vOffset += 4;\n          output.setFloat32(vOffset, vertex.y, options.littleEndian);\n          vOffset += 4;\n          output.setFloat32(vOffset, vertex.z, options.littleEndian);\n          vOffset += 4;\n\n          if (includeNormals) {\n            if (normals != null) {\n              vertex.x = normals.getX(i);\n              vertex.y = normals.getY(i);\n              vertex.z = normals.getZ(i);\n              vertex.applyMatrix3(normalMatrixWorld).normalize();\n              output.setFloat32(vOffset, vertex.x, options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, vertex.y, options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, vertex.z, options.littleEndian);\n              vOffset += 4;\n            } else {\n              output.setFloat32(vOffset, 0, options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, 0, options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, 0, options.littleEndian);\n              vOffset += 4;\n            }\n          }\n\n          if (includeUVs) {\n            if (uvs != null) {\n              output.setFloat32(vOffset, uvs.getX(i), options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, uvs.getY(i), options.littleEndian);\n              vOffset += 4;\n            } else if (!includeUVs) {\n              output.setFloat32(vOffset, 0, options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, 0, options.littleEndian);\n              vOffset += 4;\n            }\n          }\n\n          if (includeColors) {\n            if (colors != null) {\n              output.setUint8(vOffset, Math.floor(colors.getX(i) * 255));\n              vOffset += 1;\n              output.setUint8(vOffset, Math.floor(colors.getY(i) * 255));\n              vOffset += 1;\n              output.setUint8(vOffset, Math.floor(colors.getZ(i) * 255));\n              vOffset += 1;\n            } else {\n              output.setUint8(vOffset, 255);\n              vOffset += 1;\n              output.setUint8(vOffset, 255);\n              vOffset += 1;\n              output.setUint8(vOffset, 255);\n              vOffset += 1;\n            }\n          }\n        }\n\n        if (includeIndices) {\n          if (indices !== null) {\n            for (let i = 0, l = indices.count; i < l; i += 3) {\n              output.setUint8(fOffset, 3);\n              fOffset += 1;\n              output.setUint32(fOffset, indices.getX(i + 0) + writtenVertices, options.littleEndian);\n              fOffset += indexByteCount;\n              output.setUint32(fOffset, indices.getX(i + 1) + writtenVertices, options.littleEndian);\n              fOffset += indexByteCount;\n              output.setUint32(fOffset, indices.getX(i + 2) + writtenVertices, options.littleEndian);\n              fOffset += indexByteCount;\n            }\n          } else {\n            for (let i = 0, l = vertices.count; i < l; i += 3) {\n              output.setUint8(fOffset, 3);\n              fOffset += 1;\n              output.setUint32(fOffset, writtenVertices + i, options.littleEndian);\n              fOffset += indexByteCount;\n              output.setUint32(fOffset, writtenVertices + i + 1, options.littleEndian);\n              fOffset += indexByteCount;\n              output.setUint32(fOffset, writtenVertices + i + 2, options.littleEndian);\n              fOffset += indexByteCount;\n            }\n          }\n        }\n\n        writtenVertices += vertices.count;\n      });\n      result = output.buffer;\n    } else {\n      let writtenVertices = 0;\n      let vertexList = \"\";\n      let faceList = \"\";\n      this.traverseMeshes(object, function (mesh, geometry) {\n        const vertices = geometry.getAttribute(\"position\");\n        const normals = geometry.getAttribute(\"normal\");\n        const uvs = geometry.getAttribute(\"uv\");\n        const colors = geometry.getAttribute(\"color\");\n        const indices = geometry.getIndex();\n        normalMatrixWorld.getNormalMatrix(mesh.matrixWorld);\n\n        for (let i = 0, l = vertices.count; i < l; i++) {\n          vertex.x = vertices.getX(i);\n          vertex.y = vertices.getY(i);\n          vertex.z = vertices.getZ(i);\n          vertex.applyMatrix4(mesh.matrixWorld);\n          let line = vertex.x + \" \" + vertex.y + \" \" + vertex.z;\n\n          if (includeNormals) {\n            if (normals != null) {\n              vertex.x = normals.getX(i);\n              vertex.y = normals.getY(i);\n              vertex.z = normals.getZ(i);\n              vertex.applyMatrix3(normalMatrixWorld).normalize();\n              line += \" \" + vertex.x + \" \" + vertex.y + \" \" + vertex.z;\n            } else {\n              line += \" 0 0 0\";\n            }\n          }\n\n          if (includeUVs) {\n            if (uvs != null) {\n              line += \" \" + uvs.getX(i) + \" \" + uvs.getY(i);\n            } else if (includeUVs) {\n              line += \" 0 0\";\n            }\n          }\n\n          if (includeColors) {\n            if (colors != null) {\n              line += \" \" + Math.floor(colors.getX(i) * 255) + \" \" + Math.floor(colors.getY(i) * 255) + \" \" + Math.floor(colors.getZ(i) * 255);\n            } else {\n              line += \" 255 255 255\";\n            }\n          }\n\n          vertexList += line + \"\\n\";\n        }\n\n        if (includeIndices) {\n          if (indices !== null) {\n            for (let i = 0, l = indices.count; i < l; i += 3) {\n              faceList += `3 ${indices.getX(i + 0) + writtenVertices}`;\n              faceList += ` ${indices.getX(i + 1) + writtenVertices}`;\n              faceList += ` ${indices.getX(i + 2) + writtenVertices}\n`;\n            }\n          } else {\n            for (let i = 0, l = vertices.count; i < l; i += 3) {\n              faceList += `3 ${writtenVertices + i} ${writtenVertices + i + 1} ${writtenVertices + i + 2}\n`;\n            }\n          }\n\n          faceCount += indices ? indices.count / 3 : vertices.count / 3;\n        }\n\n        writtenVertices += vertices.count;\n      });\n      result = `${header}${vertexList}${includeIndices ? `${faceList}\n` : \"\\n\"}`;\n    }\n\n    if (typeof onDone === \"function\") {\n      requestAnimationFrame(() => onDone && onDone(typeof result === \"string\" ? result : \"\"));\n    }\n\n    return result;\n  } // Iterate over the valid meshes in the object\n\n\n  traverseMeshes(object, cb) {\n    object.traverse(function (child) {\n      if (child instanceof Mesh && child.isMesh) {\n        const mesh = child;\n        const geometry = mesh.geometry;\n\n        if (!geometry.isBufferGeometry) {\n          throw new Error(\"THREE.PLYExporter: Geometry is not of type THREE.BufferGeometry.\");\n        }\n\n        if (geometry.hasAttribute(\"position\")) {\n          cb(mesh, geometry);\n        }\n      }\n    });\n  }\n\n}\n\nexport { PLYExporter };","map":{"version":3,"sources":["/Users/theodaguier/Repositories/E-Do-Studio/node_modules/three-stdlib/exporters/PLYExporter.js"],"names":["Mesh","Vector3","Matrix3","PLYExporter","parse","object","onDone","options","console","warn","defaultOptions","binary","excludeAttributes","littleEndian","Object","assign","includeNormals","includeColors","includeUVs","vertexCount","faceCount","traverse","child","isMesh","mesh","geometry","isBufferGeometry","Error","vertices","getAttribute","normals","uvs","colors","indices","getIndex","count","includeIndices","indexOf","Math","floor","error","indexByteCount","header","vertex","normalMatrixWorld","result","headerBin","TextEncoder","encode","vertexListLength","faceListLength","output","DataView","ArrayBuffer","length","Uint8Array","buffer","set","vOffset","fOffset","writtenVertices","traverseMeshes","getNormalMatrix","matrixWorld","i","l","x","getX","y","getY","z","getZ","applyMatrix4","setFloat32","applyMatrix3","normalize","setUint8","setUint32","vertexList","faceList","line","requestAnimationFrame","cb","hasAttribute"],"mappings":"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","sourcesContent":["import { Mesh, Vector3, Matrix3 } from \"three\";\nclass PLYExporter {\n  parse(object, onDone, options) {\n    if (onDone && typeof onDone === \"object\") {\n      console.warn(\n        'THREE.PLYExporter: The options parameter is now the third argument to the \"parse\" function. See the documentation for the new API.'\n      );\n      options = onDone;\n      onDone = void 0;\n    }\n    const defaultOptions = {\n      binary: false,\n      excludeAttributes: [],\n      // normal, uv, color, index\n      littleEndian: false\n    };\n    options = Object.assign(defaultOptions, options);\n    const excludeAttributes = options.excludeAttributes;\n    let includeNormals = false;\n    let includeColors = false;\n    let includeUVs = false;\n    let vertexCount = 0;\n    let faceCount = 0;\n    object.traverse(function(child) {\n      if (child instanceof Mesh && child.isMesh) {\n        const mesh = child;\n        const geometry = mesh.geometry;\n        if (!geometry.isBufferGeometry) {\n          throw new Error(\"THREE.PLYExporter: Geometry is not of type THREE.BufferGeometry.\");\n        }\n        const vertices = geometry.getAttribute(\"position\");\n        const normals = geometry.getAttribute(\"normal\");\n        const uvs = geometry.getAttribute(\"uv\");\n        const colors = geometry.getAttribute(\"color\");\n        const indices = geometry.getIndex();\n        if (vertices === void 0) {\n          return;\n        }\n        vertexCount += vertices.count;\n        faceCount += indices ? indices.count / 3 : vertices.count / 3;\n        if (normals !== void 0)\n          includeNormals = true;\n        if (uvs !== void 0)\n          includeUVs = true;\n        if (colors !== void 0)\n          includeColors = true;\n      }\n    });\n    const includeIndices = (excludeAttributes == null ? void 0 : excludeAttributes.indexOf(\"index\")) === -1;\n    includeNormals = includeNormals && (excludeAttributes == null ? void 0 : excludeAttributes.indexOf(\"normal\")) === -1;\n    includeColors = includeColors && (excludeAttributes == null ? void 0 : excludeAttributes.indexOf(\"color\")) === -1;\n    includeUVs = includeUVs && (excludeAttributes == null ? void 0 : excludeAttributes.indexOf(\"uv\")) === -1;\n    if (includeIndices && faceCount !== Math.floor(faceCount)) {\n      console.error(\n        \"PLYExporter: Failed to generate a valid PLY file with triangle indices because the number of indices is not divisible by 3.\"\n      );\n      return null;\n    }\n    const indexByteCount = 4;\n    let header = `ply\nformat ${options.binary ? options.littleEndian ? \"binary_little_endian\" : \"binary_big_endian\" : \"ascii\"} 1.0\nelement vertex ${vertexCount}\nproperty float x\nproperty float y\nproperty float z\n`;\n    if (includeNormals) {\n      header += \"property float nx\\nproperty float ny\\nproperty float nz\\n\";\n    }\n    if (includeUVs) {\n      header += \"property float s\\nproperty float t\\n\";\n    }\n    if (includeColors) {\n      header += \"property uchar red\\nproperty uchar green\\nproperty uchar blue\\n\";\n    }\n    if (includeIndices) {\n      header += `${`element face ${faceCount}\n`}property list uchar int vertex_index\n`;\n    }\n    header += \"end_header\\n\";\n    const vertex = new Vector3();\n    const normalMatrixWorld = new Matrix3();\n    let result = null;\n    if (options.binary) {\n      const headerBin = new TextEncoder().encode(header);\n      const vertexListLength = vertexCount * (4 * 3 + (includeNormals ? 4 * 3 : 0) + (includeColors ? 3 : 0) + (includeUVs ? 4 * 2 : 0));\n      const faceListLength = includeIndices ? faceCount * (indexByteCount * 3 + 1) : 0;\n      const output = new DataView(new ArrayBuffer(headerBin.length + vertexListLength + faceListLength));\n      new Uint8Array(output.buffer).set(headerBin, 0);\n      let vOffset = headerBin.length;\n      let fOffset = headerBin.length + vertexListLength;\n      let writtenVertices = 0;\n      this.traverseMeshes(object, function(mesh, geometry) {\n        const vertices = geometry.getAttribute(\"position\");\n        const normals = geometry.getAttribute(\"normal\");\n        const uvs = geometry.getAttribute(\"uv\");\n        const colors = geometry.getAttribute(\"color\");\n        const indices = geometry.getIndex();\n        normalMatrixWorld.getNormalMatrix(mesh.matrixWorld);\n        for (let i = 0, l = vertices.count; i < l; i++) {\n          vertex.x = vertices.getX(i);\n          vertex.y = vertices.getY(i);\n          vertex.z = vertices.getZ(i);\n          vertex.applyMatrix4(mesh.matrixWorld);\n          output.setFloat32(vOffset, vertex.x, options.littleEndian);\n          vOffset += 4;\n          output.setFloat32(vOffset, vertex.y, options.littleEndian);\n          vOffset += 4;\n          output.setFloat32(vOffset, vertex.z, options.littleEndian);\n          vOffset += 4;\n          if (includeNormals) {\n            if (normals != null) {\n              vertex.x = normals.getX(i);\n              vertex.y = normals.getY(i);\n              vertex.z = normals.getZ(i);\n              vertex.applyMatrix3(normalMatrixWorld).normalize();\n              output.setFloat32(vOffset, vertex.x, options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, vertex.y, options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, vertex.z, options.littleEndian);\n              vOffset += 4;\n            } else {\n              output.setFloat32(vOffset, 0, options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, 0, options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, 0, options.littleEndian);\n              vOffset += 4;\n            }\n          }\n          if (includeUVs) {\n            if (uvs != null) {\n              output.setFloat32(vOffset, uvs.getX(i), options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, uvs.getY(i), options.littleEndian);\n              vOffset += 4;\n            } else if (!includeUVs) {\n              output.setFloat32(vOffset, 0, options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, 0, options.littleEndian);\n              vOffset += 4;\n            }\n          }\n          if (includeColors) {\n            if (colors != null) {\n              output.setUint8(vOffset, Math.floor(colors.getX(i) * 255));\n              vOffset += 1;\n              output.setUint8(vOffset, Math.floor(colors.getY(i) * 255));\n              vOffset += 1;\n              output.setUint8(vOffset, Math.floor(colors.getZ(i) * 255));\n              vOffset += 1;\n            } else {\n              output.setUint8(vOffset, 255);\n              vOffset += 1;\n              output.setUint8(vOffset, 255);\n              vOffset += 1;\n              output.setUint8(vOffset, 255);\n              vOffset += 1;\n            }\n          }\n        }\n        if (includeIndices) {\n          if (indices !== null) {\n            for (let i = 0, l = indices.count; i < l; i += 3) {\n              output.setUint8(fOffset, 3);\n              fOffset += 1;\n              output.setUint32(fOffset, indices.getX(i + 0) + writtenVertices, options.littleEndian);\n              fOffset += indexByteCount;\n              output.setUint32(fOffset, indices.getX(i + 1) + writtenVertices, options.littleEndian);\n              fOffset += indexByteCount;\n              output.setUint32(fOffset, indices.getX(i + 2) + writtenVertices, options.littleEndian);\n              fOffset += indexByteCount;\n            }\n          } else {\n            for (let i = 0, l = vertices.count; i < l; i += 3) {\n              output.setUint8(fOffset, 3);\n              fOffset += 1;\n              output.setUint32(fOffset, writtenVertices + i, options.littleEndian);\n              fOffset += indexByteCount;\n              output.setUint32(fOffset, writtenVertices + i + 1, options.littleEndian);\n              fOffset += indexByteCount;\n              output.setUint32(fOffset, writtenVertices + i + 2, options.littleEndian);\n              fOffset += indexByteCount;\n            }\n          }\n        }\n        writtenVertices += vertices.count;\n      });\n      result = output.buffer;\n    } else {\n      let writtenVertices = 0;\n      let vertexList = \"\";\n      let faceList = \"\";\n      this.traverseMeshes(object, function(mesh, geometry) {\n        const vertices = geometry.getAttribute(\"position\");\n        const normals = geometry.getAttribute(\"normal\");\n        const uvs = geometry.getAttribute(\"uv\");\n        const colors = geometry.getAttribute(\"color\");\n        const indices = geometry.getIndex();\n        normalMatrixWorld.getNormalMatrix(mesh.matrixWorld);\n        for (let i = 0, l = vertices.count; i < l; i++) {\n          vertex.x = vertices.getX(i);\n          vertex.y = vertices.getY(i);\n          vertex.z = vertices.getZ(i);\n          vertex.applyMatrix4(mesh.matrixWorld);\n          let line = vertex.x + \" \" + vertex.y + \" \" + vertex.z;\n          if (includeNormals) {\n            if (normals != null) {\n              vertex.x = normals.getX(i);\n              vertex.y = normals.getY(i);\n              vertex.z = normals.getZ(i);\n              vertex.applyMatrix3(normalMatrixWorld).normalize();\n              line += \" \" + vertex.x + \" \" + vertex.y + \" \" + vertex.z;\n            } else {\n              line += \" 0 0 0\";\n            }\n          }\n          if (includeUVs) {\n            if (uvs != null) {\n              line += \" \" + uvs.getX(i) + \" \" + uvs.getY(i);\n            } else if (includeUVs) {\n              line += \" 0 0\";\n            }\n          }\n          if (includeColors) {\n            if (colors != null) {\n              line += \" \" + Math.floor(colors.getX(i) * 255) + \" \" + Math.floor(colors.getY(i) * 255) + \" \" + Math.floor(colors.getZ(i) * 255);\n            } else {\n              line += \" 255 255 255\";\n            }\n          }\n          vertexList += line + \"\\n\";\n        }\n        if (includeIndices) {\n          if (indices !== null) {\n            for (let i = 0, l = indices.count; i < l; i += 3) {\n              faceList += `3 ${indices.getX(i + 0) + writtenVertices}`;\n              faceList += ` ${indices.getX(i + 1) + writtenVertices}`;\n              faceList += ` ${indices.getX(i + 2) + writtenVertices}\n`;\n            }\n          } else {\n            for (let i = 0, l = vertices.count; i < l; i += 3) {\n              faceList += `3 ${writtenVertices + i} ${writtenVertices + i + 1} ${writtenVertices + i + 2}\n`;\n            }\n          }\n          faceCount += indices ? indices.count / 3 : vertices.count / 3;\n        }\n        writtenVertices += vertices.count;\n      });\n      result = `${header}${vertexList}${includeIndices ? `${faceList}\n` : \"\\n\"}`;\n    }\n    if (typeof onDone === \"function\") {\n      requestAnimationFrame(() => onDone && onDone(typeof result === \"string\" ? result : \"\"));\n    }\n    return result;\n  }\n  // Iterate over the valid meshes in the object\n  traverseMeshes(object, cb) {\n    object.traverse(function(child) {\n      if (child instanceof Mesh && child.isMesh) {\n        const mesh = child;\n        const geometry = mesh.geometry;\n        if (!geometry.isBufferGeometry) {\n          throw new Error(\"THREE.PLYExporter: Geometry is not of type THREE.BufferGeometry.\");\n        }\n        if (geometry.hasAttribute(\"position\")) {\n          cb(mesh, geometry);\n        }\n      }\n    });\n  }\n}\nexport {\n  PLYExporter\n};\n"]},"metadata":{},"sourceType":"module"}