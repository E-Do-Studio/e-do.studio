{"ast":null,"code":"import { ShaderLib, Mesh, BoxGeometry, ShaderMaterial, UniformsUtils, BackSide, Scene, PerspectiveCamera } from \"three\";\nimport { Pass } from \"./Pass.js\";\n\nclass CubeTexturePass extends Pass {\n  constructor(camera, tCube, opacity = 1) {\n    super();\n    this.camera = camera;\n    this.needsSwap = false;\n    this.cubeShader = ShaderLib[\"cube\"];\n    this.cubeMesh = new Mesh(new BoxGeometry(10, 10, 10), new ShaderMaterial({\n      uniforms: UniformsUtils.clone(this.cubeShader.uniforms),\n      vertexShader: this.cubeShader.vertexShader,\n      fragmentShader: this.cubeShader.fragmentShader,\n      depthTest: false,\n      depthWrite: false,\n      side: BackSide\n    }));\n    Object.defineProperty(this.cubeMesh.material, \"envMap\", {\n      get: function () {\n        return this.uniforms.tCube.value;\n      }\n    });\n    this.tCube = tCube;\n    this.opacity = opacity;\n    this.cubeScene = new Scene();\n    this.cubeCamera = new PerspectiveCamera();\n    this.cubeScene.add(this.cubeMesh);\n  }\n\n  render(renderer, writeBuffer, readBuffer) {\n    const oldAutoClear = renderer.autoClear;\n    renderer.autoClear = false;\n    this.cubeCamera.projectionMatrix.copy(this.camera.projectionMatrix);\n    this.cubeCamera.quaternion.setFromRotationMatrix(this.camera.matrixWorld);\n    this.cubeMesh.material.uniforms.tCube.value = this.tCube;\n    this.cubeMesh.material.uniforms.tFlip.value = this.tCube.isCubeTexture && this.tCube.isRenderTargetTexture === false ? -1 : 1;\n    this.cubeMesh.material.uniforms.opacity.value = this.opacity;\n    this.cubeMesh.material.transparent = this.opacity < 1;\n    renderer.setRenderTarget(this.renderToScreen ? null : readBuffer);\n    if (this.clear) renderer.clear();\n    renderer.render(this.cubeScene, this.cubeCamera);\n    renderer.autoClear = oldAutoClear;\n  }\n\n  dispose() {\n    this.cubeMesh.geometry.dispose();\n    this.cubeMesh.material.dispose();\n  }\n\n}\n\nexport { CubeTexturePass };","map":{"version":3,"sources":["/Users/theodaguier/Repositories/E-Do-Studio/node_modules/three-stdlib/postprocessing/CubeTexturePass.js"],"names":["ShaderLib","Mesh","BoxGeometry","ShaderMaterial","UniformsUtils","BackSide","Scene","PerspectiveCamera","Pass","CubeTexturePass","constructor","camera","tCube","opacity","needsSwap","cubeShader","cubeMesh","uniforms","clone","vertexShader","fragmentShader","depthTest","depthWrite","side","Object","defineProperty","material","get","value","cubeScene","cubeCamera","add","render","renderer","writeBuffer","readBuffer","oldAutoClear","autoClear","projectionMatrix","copy","quaternion","setFromRotationMatrix","matrixWorld","tFlip","isCubeTexture","isRenderTargetTexture","transparent","setRenderTarget","renderToScreen","clear","dispose","geometry"],"mappings":"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","sourcesContent":["import { ShaderLib, Mesh, BoxGeometry, ShaderMaterial, UniformsUtils, BackSide, Scene, PerspectiveCamera } from \"three\";\nimport { Pass } from \"./Pass.js\";\nclass CubeTexturePass extends Pass {\n  constructor(camera, tCube, opacity = 1) {\n    super();\n    this.camera = camera;\n    this.needsSwap = false;\n    this.cubeShader = ShaderLib[\"cube\"];\n    this.cubeMesh = new Mesh(\n      new BoxGeometry(10, 10, 10),\n      new ShaderMaterial({\n        uniforms: UniformsUtils.clone(this.cubeShader.uniforms),\n        vertexShader: this.cubeShader.vertexShader,\n        fragmentShader: this.cubeShader.fragmentShader,\n        depthTest: false,\n        depthWrite: false,\n        side: BackSide\n      })\n    );\n    Object.defineProperty(this.cubeMesh.material, \"envMap\", {\n      get: function() {\n        return this.uniforms.tCube.value;\n      }\n    });\n    this.tCube = tCube;\n    this.opacity = opacity;\n    this.cubeScene = new Scene();\n    this.cubeCamera = new PerspectiveCamera();\n    this.cubeScene.add(this.cubeMesh);\n  }\n  render(renderer, writeBuffer, readBuffer) {\n    const oldAutoClear = renderer.autoClear;\n    renderer.autoClear = false;\n    this.cubeCamera.projectionMatrix.copy(this.camera.projectionMatrix);\n    this.cubeCamera.quaternion.setFromRotationMatrix(this.camera.matrixWorld);\n    this.cubeMesh.material.uniforms.tCube.value = this.tCube;\n    this.cubeMesh.material.uniforms.tFlip.value = this.tCube.isCubeTexture && this.tCube.isRenderTargetTexture === false ? -1 : 1;\n    this.cubeMesh.material.uniforms.opacity.value = this.opacity;\n    this.cubeMesh.material.transparent = this.opacity < 1;\n    renderer.setRenderTarget(this.renderToScreen ? null : readBuffer);\n    if (this.clear)\n      renderer.clear();\n    renderer.render(this.cubeScene, this.cubeCamera);\n    renderer.autoClear = oldAutoClear;\n  }\n  dispose() {\n    this.cubeMesh.geometry.dispose();\n    this.cubeMesh.material.dispose();\n  }\n}\nexport {\n  CubeTexturePass\n};\n"]},"metadata":{},"sourceType":"module"}