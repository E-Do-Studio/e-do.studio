{"ast":null,"code":"import _classCallCheck from \"/Users/theodaguier/Repositories/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/theodaguier/Repositories/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/theodaguier/Repositories/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/theodaguier/Repositories/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { Vector2, RGBAFormat, MeshNormalMaterial, ShaderMaterial, Vector4, WebGLRenderTarget, DepthTexture, NearestFilter } from \"three\";\nimport { Pass, FullScreenQuad } from \"./Pass.js\";\n\nvar RenderPixelatedPass = /*#__PURE__*/function (_Pass) {\n  _inherits(RenderPixelatedPass, _Pass);\n\n  var _super = _createSuper(RenderPixelatedPass);\n\n  function RenderPixelatedPass(resolution, pixelSize, scene, camera) {\n    var _this;\n\n    var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n\n    _classCallCheck(this, RenderPixelatedPass);\n\n    var _a, _b;\n\n    _this = _super.call(this);\n    _this.pixelSize = pixelSize;\n    _this.resolution = new Vector2();\n    _this.renderResolution = new Vector2();\n\n    _this.setSize(resolution.x, resolution.y);\n\n    _this.fsQuad = new FullScreenQuad(_this.material());\n    _this.scene = scene;\n    _this.camera = camera;\n    _this.normalEdgeStrength = (_a = options.normalEdgeStrength) != null ? _a : 0.3;\n    _this.depthEdgeStrength = (_b = options.depthEdgeStrength) != null ? _b : 0.4;\n    _this.rgbRenderTarget = pixelRenderTarget(_this.renderResolution, RGBAFormat, true);\n    _this.normalRenderTarget = pixelRenderTarget(_this.renderResolution, RGBAFormat, false);\n    _this.normalMaterial = new MeshNormalMaterial();\n    return _this;\n  }\n\n  _createClass(RenderPixelatedPass, [{\n    key: \"dispose\",\n    value: function dispose() {\n      this.rgbRenderTarget.dispose();\n      this.normalRenderTarget.dispose();\n      this.fsQuad.dispose();\n    }\n  }, {\n    key: \"setSize\",\n    value: function setSize(width, height) {\n      var _a, _b, _c;\n\n      this.resolution.set(width, height);\n      this.renderResolution.set(width / this.pixelSize | 0, height / this.pixelSize | 0);\n      var _this$renderResolutio = this.renderResolution,\n          x = _this$renderResolutio.x,\n          y = _this$renderResolutio.y;\n      (_a = this.rgbRenderTarget) == null ? void 0 : _a.setSize(x, y);\n      (_b = this.normalRenderTarget) == null ? void 0 : _b.setSize(x, y);\n      (_c = this.fsQuad) == null ? void 0 : _c.material.uniforms.resolution.value.set(x, y, 1 / x, 1 / y);\n    }\n  }, {\n    key: \"setPixelSize\",\n    value: function setPixelSize(pixelSize) {\n      this.pixelSize = pixelSize;\n      this.setSize(this.resolution.x, this.resolution.y);\n    }\n  }, {\n    key: \"render\",\n    value: function render(renderer, writeBuffer) {\n      var uniforms = this.fsQuad.material.uniforms;\n      uniforms.normalEdgeStrength.value = this.normalEdgeStrength;\n      uniforms.depthEdgeStrength.value = this.depthEdgeStrength;\n      renderer.setRenderTarget(this.rgbRenderTarget);\n      renderer.render(this.scene, this.camera);\n      var overrideMaterial_old = this.scene.overrideMaterial;\n      renderer.setRenderTarget(this.normalRenderTarget);\n      this.scene.overrideMaterial = this.normalMaterial;\n      renderer.render(this.scene, this.camera);\n      this.scene.overrideMaterial = overrideMaterial_old;\n      uniforms.tDiffuse.value = this.rgbRenderTarget.texture;\n      uniforms.tDepth.value = this.rgbRenderTarget.depthTexture;\n      uniforms.tNormal.value = this.normalRenderTarget.texture;\n\n      if (this.renderToScreen) {\n        renderer.setRenderTarget(null);\n      } else {\n        renderer.setRenderTarget(writeBuffer);\n        if (this.clear) renderer.clear();\n      }\n\n      this.fsQuad.render(renderer);\n    }\n  }, {\n    key: \"material\",\n    value: function material() {\n      return new ShaderMaterial({\n        uniforms: {\n          tDiffuse: {\n            value: null\n          },\n          tDepth: {\n            value: null\n          },\n          tNormal: {\n            value: null\n          },\n          resolution: {\n            value: new Vector4(this.renderResolution.x, this.renderResolution.y, 1 / this.renderResolution.x, 1 / this.renderResolution.y)\n          },\n          normalEdgeStrength: {\n            value: 0\n          },\n          depthEdgeStrength: {\n            value: 0\n          }\n        },\n        vertexShader: \"\\n\\t\\t\\t\\tvarying vec2 vUv;\\n\\n\\t\\t\\t\\tvoid main() {\\n\\n\\t\\t\\t\\t\\tvUv = uv;\\n\\t\\t\\t\\t\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\",\n        fragmentShader: \"\\n\\t\\t\\t\\tuniform sampler2D tDiffuse;\\n\\t\\t\\t\\tuniform sampler2D tDepth;\\n\\t\\t\\t\\tuniform sampler2D tNormal;\\n\\t\\t\\t\\tuniform vec4 resolution;\\n\\t\\t\\t\\tuniform float normalEdgeStrength;\\n\\t\\t\\t\\tuniform float depthEdgeStrength;\\n\\t\\t\\t\\tvarying vec2 vUv;\\n\\n\\t\\t\\t\\tfloat getDepth(int x, int y) {\\n\\n\\t\\t\\t\\t\\treturn texture2D( tDepth, vUv + vec2(x, y) * resolution.zw ).r;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvec3 getNormal(int x, int y) {\\n\\n\\t\\t\\t\\t\\treturn texture2D( tNormal, vUv + vec2(x, y) * resolution.zw ).rgb * 2.0 - 1.0;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tfloat depthEdgeIndicator(float depth, vec3 normal) {\\n\\n\\t\\t\\t\\t\\tfloat diff = 0.0;\\n\\t\\t\\t\\t\\tdiff += clamp(getDepth(1, 0) - depth, 0.0, 1.0);\\n\\t\\t\\t\\t\\tdiff += clamp(getDepth(-1, 0) - depth, 0.0, 1.0);\\n\\t\\t\\t\\t\\tdiff += clamp(getDepth(0, 1) - depth, 0.0, 1.0);\\n\\t\\t\\t\\t\\tdiff += clamp(getDepth(0, -1) - depth, 0.0, 1.0);\\n\\t\\t\\t\\t\\treturn floor(smoothstep(0.01, 0.02, diff) * 2.) / 2.;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tfloat neighborNormalEdgeIndicator(int x, int y, float depth, vec3 normal) {\\n\\n\\t\\t\\t\\t\\tfloat depthDiff = getDepth(x, y) - depth;\\n\\t\\t\\t\\t\\tvec3 neighborNormal = getNormal(x, y);\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// Edge pixels should yield to faces who's normals are closer to the bias normal.\\n\\t\\t\\t\\t\\tvec3 normalEdgeBias = vec3(1., 1., 1.); // This should probably be a parameter.\\n\\t\\t\\t\\t\\tfloat normalDiff = dot(normal - neighborNormal, normalEdgeBias);\\n\\t\\t\\t\\t\\tfloat normalIndicator = clamp(smoothstep(-.01, .01, normalDiff), 0.0, 1.0);\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// Only the shallower pixel should detect the normal edge.\\n\\t\\t\\t\\t\\tfloat depthIndicator = clamp(sign(depthDiff * .25 + .0025), 0.0, 1.0);\\n\\n\\t\\t\\t\\t\\treturn (1.0 - dot(normal, neighborNormal)) * depthIndicator * normalIndicator;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tfloat normalEdgeIndicator(float depth, vec3 normal) {\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tfloat indicator = 0.0;\\n\\n\\t\\t\\t\\t\\tindicator += neighborNormalEdgeIndicator(0, -1, depth, normal);\\n\\t\\t\\t\\t\\tindicator += neighborNormalEdgeIndicator(0, 1, depth, normal);\\n\\t\\t\\t\\t\\tindicator += neighborNormalEdgeIndicator(-1, 0, depth, normal);\\n\\t\\t\\t\\t\\tindicator += neighborNormalEdgeIndicator(1, 0, depth, normal);\\n\\n\\t\\t\\t\\t\\treturn step(0.1, indicator);\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvoid main() {\\n\\n\\t\\t\\t\\t\\tvec4 texel = texture2D( tDiffuse, vUv );\\n\\n\\t\\t\\t\\t\\tfloat depth = 0.0;\\n\\t\\t\\t\\t\\tvec3 normal = vec3(0.0);\\n\\n\\t\\t\\t\\t\\tif (depthEdgeStrength > 0.0 || normalEdgeStrength > 0.0) {\\n\\n\\t\\t\\t\\t\\t\\tdepth = getDepth(0, 0);\\n\\t\\t\\t\\t\\t\\tnormal = getNormal(0, 0);\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tfloat dei = 0.0;\\n\\t\\t\\t\\t\\tif (depthEdgeStrength > 0.0) \\n\\t\\t\\t\\t\\t\\tdei = depthEdgeIndicator(depth, normal);\\n\\n\\t\\t\\t\\t\\tfloat nei = 0.0; \\n\\t\\t\\t\\t\\tif (normalEdgeStrength > 0.0) \\n\\t\\t\\t\\t\\t\\tnei = normalEdgeIndicator(depth, normal);\\n\\n\\t\\t\\t\\t\\tfloat Strength = dei > 0.0 ? (1.0 - depthEdgeStrength * dei) : (1.0 + normalEdgeStrength * nei);\\n\\n\\t\\t\\t\\t\\tgl_FragColor = texel * Strength;\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\"\n      });\n    }\n  }]);\n\n  return RenderPixelatedPass;\n}(Pass);\n\nfunction pixelRenderTarget(resolution, pixelFormat, useDepthTexture) {\n  var renderTarget = new WebGLRenderTarget(resolution.x, resolution.y, !useDepthTexture ? void 0 : {\n    depthTexture: new DepthTexture(resolution.x, resolution.y),\n    depthBuffer: true\n  });\n  renderTarget.texture.format = pixelFormat;\n  renderTarget.texture.minFilter = NearestFilter;\n  renderTarget.texture.magFilter = NearestFilter;\n  renderTarget.texture.generateMipmaps = false;\n  renderTarget.stencilBuffer = false;\n  return renderTarget;\n}\n\nexport { RenderPixelatedPass };","map":{"version":3,"sources":["/Users/theodaguier/Repositories/E-Do-Studio/node_modules/three-stdlib/postprocessing/RenderPixelatedPass.js"],"names":["Vector2","RGBAFormat","MeshNormalMaterial","ShaderMaterial","Vector4","WebGLRenderTarget","DepthTexture","NearestFilter","Pass","FullScreenQuad","RenderPixelatedPass","resolution","pixelSize","scene","camera","options","_a","_b","renderResolution","setSize","x","y","fsQuad","material","normalEdgeStrength","depthEdgeStrength","rgbRenderTarget","pixelRenderTarget","normalRenderTarget","normalMaterial","dispose","width","height","_c","set","uniforms","value","renderer","writeBuffer","setRenderTarget","render","overrideMaterial_old","overrideMaterial","tDiffuse","texture","tDepth","depthTexture","tNormal","renderToScreen","clear","vertexShader","fragmentShader","pixelFormat","useDepthTexture","renderTarget","depthBuffer","format","minFilter","magFilter","generateMipmaps","stencilBuffer"],"mappings":"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","sourcesContent":["import { Vector2, RGBAFormat, MeshNormalMaterial, ShaderMaterial, Vector4, WebGLRenderTarget, DepthTexture, NearestFilter } from \"three\";\nimport { Pass, FullScreenQuad } from \"./Pass.js\";\nclass RenderPixelatedPass extends Pass {\n  constructor(resolution, pixelSize, scene, camera, options = {}) {\n    var _a, _b;\n    super();\n    this.pixelSize = pixelSize;\n    this.resolution = new Vector2();\n    this.renderResolution = new Vector2();\n    this.setSize(resolution.x, resolution.y);\n    this.fsQuad = new FullScreenQuad(this.material());\n    this.scene = scene;\n    this.camera = camera;\n    this.normalEdgeStrength = (_a = options.normalEdgeStrength) != null ? _a : 0.3;\n    this.depthEdgeStrength = (_b = options.depthEdgeStrength) != null ? _b : 0.4;\n    this.rgbRenderTarget = pixelRenderTarget(this.renderResolution, RGBAFormat, true);\n    this.normalRenderTarget = pixelRenderTarget(this.renderResolution, RGBAFormat, false);\n    this.normalMaterial = new MeshNormalMaterial();\n  }\n  dispose() {\n    this.rgbRenderTarget.dispose();\n    this.normalRenderTarget.dispose();\n    this.fsQuad.dispose();\n  }\n  setSize(width, height) {\n    var _a, _b, _c;\n    this.resolution.set(width, height);\n    this.renderResolution.set(width / this.pixelSize | 0, height / this.pixelSize | 0);\n    const { x, y } = this.renderResolution;\n    (_a = this.rgbRenderTarget) == null ? void 0 : _a.setSize(x, y);\n    (_b = this.normalRenderTarget) == null ? void 0 : _b.setSize(x, y);\n    (_c = this.fsQuad) == null ? void 0 : _c.material.uniforms.resolution.value.set(x, y, 1 / x, 1 / y);\n  }\n  setPixelSize(pixelSize) {\n    this.pixelSize = pixelSize;\n    this.setSize(this.resolution.x, this.resolution.y);\n  }\n  render(renderer, writeBuffer) {\n    const uniforms = this.fsQuad.material.uniforms;\n    uniforms.normalEdgeStrength.value = this.normalEdgeStrength;\n    uniforms.depthEdgeStrength.value = this.depthEdgeStrength;\n    renderer.setRenderTarget(this.rgbRenderTarget);\n    renderer.render(this.scene, this.camera);\n    const overrideMaterial_old = this.scene.overrideMaterial;\n    renderer.setRenderTarget(this.normalRenderTarget);\n    this.scene.overrideMaterial = this.normalMaterial;\n    renderer.render(this.scene, this.camera);\n    this.scene.overrideMaterial = overrideMaterial_old;\n    uniforms.tDiffuse.value = this.rgbRenderTarget.texture;\n    uniforms.tDepth.value = this.rgbRenderTarget.depthTexture;\n    uniforms.tNormal.value = this.normalRenderTarget.texture;\n    if (this.renderToScreen) {\n      renderer.setRenderTarget(null);\n    } else {\n      renderer.setRenderTarget(writeBuffer);\n      if (this.clear)\n        renderer.clear();\n    }\n    this.fsQuad.render(renderer);\n  }\n  material() {\n    return new ShaderMaterial({\n      uniforms: {\n        tDiffuse: { value: null },\n        tDepth: { value: null },\n        tNormal: { value: null },\n        resolution: {\n          value: new Vector4(\n            this.renderResolution.x,\n            this.renderResolution.y,\n            1 / this.renderResolution.x,\n            1 / this.renderResolution.y\n          )\n        },\n        normalEdgeStrength: { value: 0 },\n        depthEdgeStrength: { value: 0 }\n      },\n      vertexShader: `\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\t\t\t\t`,\n      fragmentShader: `\n\t\t\t\tuniform sampler2D tDiffuse;\n\t\t\t\tuniform sampler2D tDepth;\n\t\t\t\tuniform sampler2D tNormal;\n\t\t\t\tuniform vec4 resolution;\n\t\t\t\tuniform float normalEdgeStrength;\n\t\t\t\tuniform float depthEdgeStrength;\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tfloat getDepth(int x, int y) {\n\n\t\t\t\t\treturn texture2D( tDepth, vUv + vec2(x, y) * resolution.zw ).r;\n\n\t\t\t\t}\n\n\t\t\t\tvec3 getNormal(int x, int y) {\n\n\t\t\t\t\treturn texture2D( tNormal, vUv + vec2(x, y) * resolution.zw ).rgb * 2.0 - 1.0;\n\n\t\t\t\t}\n\n\t\t\t\tfloat depthEdgeIndicator(float depth, vec3 normal) {\n\n\t\t\t\t\tfloat diff = 0.0;\n\t\t\t\t\tdiff += clamp(getDepth(1, 0) - depth, 0.0, 1.0);\n\t\t\t\t\tdiff += clamp(getDepth(-1, 0) - depth, 0.0, 1.0);\n\t\t\t\t\tdiff += clamp(getDepth(0, 1) - depth, 0.0, 1.0);\n\t\t\t\t\tdiff += clamp(getDepth(0, -1) - depth, 0.0, 1.0);\n\t\t\t\t\treturn floor(smoothstep(0.01, 0.02, diff) * 2.) / 2.;\n\n\t\t\t\t}\n\n\t\t\t\tfloat neighborNormalEdgeIndicator(int x, int y, float depth, vec3 normal) {\n\n\t\t\t\t\tfloat depthDiff = getDepth(x, y) - depth;\n\t\t\t\t\tvec3 neighborNormal = getNormal(x, y);\n\t\t\t\t\t\n\t\t\t\t\t// Edge pixels should yield to faces who's normals are closer to the bias normal.\n\t\t\t\t\tvec3 normalEdgeBias = vec3(1., 1., 1.); // This should probably be a parameter.\n\t\t\t\t\tfloat normalDiff = dot(normal - neighborNormal, normalEdgeBias);\n\t\t\t\t\tfloat normalIndicator = clamp(smoothstep(-.01, .01, normalDiff), 0.0, 1.0);\n\t\t\t\t\t\n\t\t\t\t\t// Only the shallower pixel should detect the normal edge.\n\t\t\t\t\tfloat depthIndicator = clamp(sign(depthDiff * .25 + .0025), 0.0, 1.0);\n\n\t\t\t\t\treturn (1.0 - dot(normal, neighborNormal)) * depthIndicator * normalIndicator;\n\n\t\t\t\t}\n\n\t\t\t\tfloat normalEdgeIndicator(float depth, vec3 normal) {\n\t\t\t\t\t\n\t\t\t\t\tfloat indicator = 0.0;\n\n\t\t\t\t\tindicator += neighborNormalEdgeIndicator(0, -1, depth, normal);\n\t\t\t\t\tindicator += neighborNormalEdgeIndicator(0, 1, depth, normal);\n\t\t\t\t\tindicator += neighborNormalEdgeIndicator(-1, 0, depth, normal);\n\t\t\t\t\tindicator += neighborNormalEdgeIndicator(1, 0, depth, normal);\n\n\t\t\t\t\treturn step(0.1, indicator);\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\n\t\t\t\t\tfloat depth = 0.0;\n\t\t\t\t\tvec3 normal = vec3(0.0);\n\n\t\t\t\t\tif (depthEdgeStrength > 0.0 || normalEdgeStrength > 0.0) {\n\n\t\t\t\t\t\tdepth = getDepth(0, 0);\n\t\t\t\t\t\tnormal = getNormal(0, 0);\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat dei = 0.0;\n\t\t\t\t\tif (depthEdgeStrength > 0.0) \n\t\t\t\t\t\tdei = depthEdgeIndicator(depth, normal);\n\n\t\t\t\t\tfloat nei = 0.0; \n\t\t\t\t\tif (normalEdgeStrength > 0.0) \n\t\t\t\t\t\tnei = normalEdgeIndicator(depth, normal);\n\n\t\t\t\t\tfloat Strength = dei > 0.0 ? (1.0 - depthEdgeStrength * dei) : (1.0 + normalEdgeStrength * nei);\n\n\t\t\t\t\tgl_FragColor = texel * Strength;\n\n\t\t\t\t}\n\t\t\t\t`\n    });\n  }\n}\nfunction pixelRenderTarget(resolution, pixelFormat, useDepthTexture) {\n  const renderTarget = new WebGLRenderTarget(\n    resolution.x,\n    resolution.y,\n    !useDepthTexture ? void 0 : {\n      depthTexture: new DepthTexture(resolution.x, resolution.y),\n      depthBuffer: true\n    }\n  );\n  renderTarget.texture.format = pixelFormat;\n  renderTarget.texture.minFilter = NearestFilter;\n  renderTarget.texture.magFilter = NearestFilter;\n  renderTarget.texture.generateMipmaps = false;\n  renderTarget.stencilBuffer = false;\n  return renderTarget;\n}\nexport {\n  RenderPixelatedPass\n};\n"]},"metadata":{},"sourceType":"module"}