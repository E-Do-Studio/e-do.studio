{"ast":null,"code":"import { Loader, FileLoader, Vector3, Matrix4 } from \"three\";\nimport { gunzipSync } from \"fflate\";\nimport { Volume } from \"../misc/Volume.js\";\n\nclass NRRDLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setResponseType(\"arraybuffer\");\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (data) {\n      try {\n        onLoad(scope.parse(data));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n\n  parse(data) {\n    let _data = data;\n    let _dataPointer = 0;\n\n    const _nativeLittleEndian = new Int8Array(new Int16Array([1]).buffer)[0] > 0;\n\n    const _littleEndian = true;\n    const headerObject = {};\n\n    function scan(type, chunks) {\n      if (chunks === void 0 || chunks === null) {\n        chunks = 1;\n      }\n\n      let _chunkSize = 1;\n      let _array_type = Uint8Array;\n\n      switch (type) {\n        case \"uchar\":\n          break;\n\n        case \"schar\":\n          _array_type = Int8Array;\n          break;\n\n        case \"ushort\":\n          _array_type = Uint16Array;\n          _chunkSize = 2;\n          break;\n\n        case \"sshort\":\n          _array_type = Int16Array;\n          _chunkSize = 2;\n          break;\n\n        case \"uint\":\n          _array_type = Uint32Array;\n          _chunkSize = 4;\n          break;\n\n        case \"sint\":\n          _array_type = Int32Array;\n          _chunkSize = 4;\n          break;\n\n        case \"float\":\n          _array_type = Float32Array;\n          _chunkSize = 4;\n          break;\n\n        case \"complex\":\n          _array_type = Float64Array;\n          _chunkSize = 8;\n          break;\n\n        case \"double\":\n          _array_type = Float64Array;\n          _chunkSize = 8;\n          break;\n      }\n\n      let _bytes2 = new _array_type(_data.slice(_dataPointer, _dataPointer += chunks * _chunkSize));\n\n      if (_nativeLittleEndian != _littleEndian) {\n        _bytes2 = flipEndianness(_bytes2, _chunkSize);\n      }\n\n      if (chunks == 1) {\n        return _bytes2[0];\n      }\n\n      return _bytes2;\n    }\n\n    function flipEndianness(array, chunkSize) {\n      const u8 = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);\n\n      for (let i2 = 0; i2 < array.byteLength; i2 += chunkSize) {\n        for (let j = i2 + chunkSize - 1, k = i2; j > k; j--, k++) {\n          const tmp = u8[k];\n          u8[k] = u8[j];\n          u8[j] = tmp;\n        }\n      }\n\n      return array;\n    }\n\n    function parseHeader(header) {\n      let data2, field, fn, i2, l, m, _i, _len;\n\n      const lines = header.split(/\\r?\\n/);\n\n      for (_i = 0, _len = lines.length; _i < _len; _i++) {\n        l = lines[_i];\n\n        if (l.match(/NRRD\\d+/)) {\n          headerObject.isNrrd = true;\n        } else if (l.match(/^#/)) {} else if (m = l.match(/(.*):(.*)/)) {\n          field = m[1].trim();\n          data2 = m[2].trim();\n          fn = _fieldFunctions[field];\n\n          if (fn) {\n            fn.call(headerObject, data2);\n          } else {\n            headerObject[field] = data2;\n          }\n        }\n      }\n\n      if (!headerObject.isNrrd) {\n        throw new Error(\"Not an NRRD file\");\n      }\n\n      if (headerObject.encoding === \"bz2\" || headerObject.encoding === \"bzip2\") {\n        throw new Error(\"Bzip is not supported\");\n      }\n\n      if (!headerObject.vectors) {\n        headerObject.vectors = [new Vector3(1, 0, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1)];\n\n        if (headerObject.spacings) {\n          for (i2 = 0; i2 <= 2; i2++) {\n            if (!isNaN(headerObject.spacings[i2])) {\n              headerObject.vectors[i2].multiplyScalar(headerObject.spacings[i2]);\n            }\n          }\n        }\n      }\n    }\n\n    function parseDataAsText(data2, start, end) {\n      let number = \"\";\n      start = start || 0;\n      end = end || data2.length;\n      let value;\n      const lengthOfTheResult = headerObject.sizes.reduce(function (previous, current) {\n        return previous * current;\n      }, 1);\n      let base = 10;\n\n      if (headerObject.encoding === \"hex\") {\n        base = 16;\n      }\n\n      const result = new headerObject.__array(lengthOfTheResult);\n      let resultIndex = 0;\n      let parsingFunction = parseInt;\n\n      if (headerObject.__array === Float32Array || headerObject.__array === Float64Array) {\n        parsingFunction = parseFloat;\n      }\n\n      for (let i2 = start; i2 < end; i2++) {\n        value = data2[i2];\n\n        if ((value < 9 || value > 13) && value !== 32) {\n          number += String.fromCharCode(value);\n        } else {\n          if (number !== \"\") {\n            result[resultIndex] = parsingFunction(number, base);\n            resultIndex++;\n          }\n\n          number = \"\";\n        }\n      }\n\n      if (number !== \"\") {\n        result[resultIndex] = parsingFunction(number, base);\n        resultIndex++;\n      }\n\n      return result;\n    }\n\n    const _bytes = scan(\"uchar\", data.byteLength);\n\n    const _length = _bytes.length;\n    let _header = null;\n    let _data_start = 0;\n    let i;\n\n    for (i = 1; i < _length; i++) {\n      if (_bytes[i - 1] == 10 && _bytes[i] == 10) {\n        _header = this.parseChars(_bytes, 0, i - 2);\n        _data_start = i + 1;\n        break;\n      }\n    }\n\n    parseHeader(_header);\n    _data = _bytes.subarray(_data_start);\n\n    if (headerObject.encoding.substring(0, 2) === \"gz\") {\n      _data = gunzipSync(new Uint8Array(_data));\n    } else if (headerObject.encoding === \"ascii\" || headerObject.encoding === \"text\" || headerObject.encoding === \"txt\" || headerObject.encoding === \"hex\") {\n      _data = parseDataAsText(_data);\n    } else if (headerObject.encoding === \"raw\") {\n      const _copy = new Uint8Array(_data.length);\n\n      for (let i2 = 0; i2 < _data.length; i2++) {\n        _copy[i2] = _data[i2];\n      }\n\n      _data = _copy;\n    }\n\n    _data = _data.buffer;\n    const volume = new Volume();\n    volume.header = headerObject;\n    volume.data = new headerObject.__array(_data);\n    const min_max = volume.computeMinMax();\n    const min = min_max[0];\n    const max = min_max[1];\n    volume.windowLow = min;\n    volume.windowHigh = max;\n    volume.dimensions = [headerObject.sizes[0], headerObject.sizes[1], headerObject.sizes[2]];\n    volume.xLength = volume.dimensions[0];\n    volume.yLength = volume.dimensions[1];\n    volume.zLength = volume.dimensions[2];\n    const spacingX = new Vector3(headerObject.vectors[0][0], headerObject.vectors[0][1], headerObject.vectors[0][2]).length();\n    const spacingY = new Vector3(headerObject.vectors[1][0], headerObject.vectors[1][1], headerObject.vectors[1][2]).length();\n    const spacingZ = new Vector3(headerObject.vectors[2][0], headerObject.vectors[2][1], headerObject.vectors[2][2]).length();\n    volume.spacing = [spacingX, spacingY, spacingZ];\n    volume.matrix = new Matrix4();\n    let _spaceX = 1;\n    let _spaceY = 1;\n    const _spaceZ = 1;\n\n    if (headerObject.space == \"left-posterior-superior\") {\n      _spaceX = -1;\n      _spaceY = -1;\n    } else if (headerObject.space === \"left-anterior-superior\") {\n      _spaceX = -1;\n    }\n\n    if (!headerObject.vectors) {\n      volume.matrix.set(_spaceX, 0, 0, 0, 0, _spaceY, 0, 0, 0, 0, _spaceZ, 0, 0, 0, 0, 1);\n    } else {\n      const v = headerObject.vectors;\n      volume.matrix.set(_spaceX * v[0][0], _spaceX * v[1][0], _spaceX * v[2][0], 0, _spaceY * v[0][1], _spaceY * v[1][1], _spaceY * v[2][1], 0, _spaceZ * v[0][2], _spaceZ * v[1][2], _spaceZ * v[2][2], 0, 0, 0, 0, 1);\n    }\n\n    volume.inverseMatrix = new Matrix4();\n    volume.inverseMatrix.copy(volume.matrix).invert();\n    volume.RASDimensions = new Vector3(volume.xLength, volume.yLength, volume.zLength).applyMatrix4(volume.matrix).round().toArray().map(Math.abs);\n\n    if (volume.lowerThreshold === -Infinity) {\n      volume.lowerThreshold = min;\n    }\n\n    if (volume.upperThreshold === Infinity) {\n      volume.upperThreshold = max;\n    }\n\n    return volume;\n  }\n\n  parseChars(array, start, end) {\n    if (start === void 0) {\n      start = 0;\n    }\n\n    if (end === void 0) {\n      end = array.length;\n    }\n\n    let output = \"\";\n    let i = 0;\n\n    for (i = start; i < end; ++i) {\n      output += String.fromCharCode(array[i]);\n    }\n\n    return output;\n  }\n\n}\n\nconst _fieldFunctions = {\n  type: function (data) {\n    switch (data) {\n      case \"uchar\":\n      case \"unsigned char\":\n      case \"uint8\":\n      case \"uint8_t\":\n        this.__array = Uint8Array;\n        break;\n\n      case \"signed char\":\n      case \"int8\":\n      case \"int8_t\":\n        this.__array = Int8Array;\n        break;\n\n      case \"short\":\n      case \"short int\":\n      case \"signed short\":\n      case \"signed short int\":\n      case \"int16\":\n      case \"int16_t\":\n        this.__array = Int16Array;\n        break;\n\n      case \"ushort\":\n      case \"unsigned short\":\n      case \"unsigned short int\":\n      case \"uint16\":\n      case \"uint16_t\":\n        this.__array = Uint16Array;\n        break;\n\n      case \"int\":\n      case \"signed int\":\n      case \"int32\":\n      case \"int32_t\":\n        this.__array = Int32Array;\n        break;\n\n      case \"uint\":\n      case \"unsigned int\":\n      case \"uint32\":\n      case \"uint32_t\":\n        this.__array = Uint32Array;\n        break;\n\n      case \"float\":\n        this.__array = Float32Array;\n        break;\n\n      case \"double\":\n        this.__array = Float64Array;\n        break;\n\n      default:\n        throw new Error(\"Unsupported NRRD data type: \" + data);\n    }\n\n    return this.type = data;\n  },\n  endian: function (data) {\n    return this.endian = data;\n  },\n  encoding: function (data) {\n    return this.encoding = data;\n  },\n  dimension: function (data) {\n    return this.dim = parseInt(data, 10);\n  },\n  sizes: function (data) {\n    let i;\n    return this.sizes = function () {\n      const _ref = data.split(/\\s+/);\n\n      const _results = [];\n\n      for (let _i = 0, _len = _ref.length; _i < _len; _i++) {\n        i = _ref[_i];\n\n        _results.push(parseInt(i, 10));\n      }\n\n      return _results;\n    }();\n  },\n  space: function (data) {\n    return this.space = data;\n  },\n  \"space origin\": function (data) {\n    return this.space_origin = data.split(\"(\")[1].split(\")\")[0].split(\",\");\n  },\n  \"space directions\": function (data) {\n    let f, v;\n    const parts = data.match(/\\(.*?\\)/g);\n    return this.vectors = function () {\n      const _results = [];\n\n      for (let _i = 0, _len = parts.length; _i < _len; _i++) {\n        v = parts[_i];\n\n        _results.push(function () {\n          const _ref = v.slice(1, -1).split(/,/);\n\n          const _results2 = [];\n\n          for (let _j = 0, _len2 = _ref.length; _j < _len2; _j++) {\n            f = _ref[_j];\n\n            _results2.push(parseFloat(f));\n          }\n\n          return _results2;\n        }());\n      }\n\n      return _results;\n    }();\n  },\n  spacings: function (data) {\n    let f;\n    const parts = data.split(/\\s+/);\n    return this.spacings = function () {\n      const _results = [];\n\n      for (let _i = 0, _len = parts.length; _i < _len; _i++) {\n        f = parts[_i];\n\n        _results.push(parseFloat(f));\n      }\n\n      return _results;\n    }();\n  }\n};\nexport { NRRDLoader };","map":{"version":3,"sources":["/Users/theodaguier/Repositories/E-Do-Studio/node_modules/three-stdlib/loaders/NRRDLoader.js"],"names":["Loader","FileLoader","Vector3","Matrix4","gunzipSync","Volume","NRRDLoader","constructor","manager","load","url","onLoad","onProgress","onError","scope","loader","setPath","path","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","data","parse","e","console","error","itemError","_data","_dataPointer","_nativeLittleEndian","Int8Array","Int16Array","buffer","_littleEndian","headerObject","scan","type","chunks","_chunkSize","_array_type","Uint8Array","Uint16Array","Uint32Array","Int32Array","Float32Array","Float64Array","_bytes2","slice","flipEndianness","array","chunkSize","u8","byteOffset","byteLength","i2","j","k","tmp","parseHeader","header","data2","field","fn","l","m","_i","_len","lines","split","length","match","isNrrd","trim","_fieldFunctions","call","Error","encoding","vectors","spacings","isNaN","multiplyScalar","parseDataAsText","start","end","number","value","lengthOfTheResult","sizes","reduce","previous","current","base","result","__array","resultIndex","parsingFunction","parseInt","parseFloat","String","fromCharCode","_bytes","_length","_header","_data_start","i","parseChars","subarray","substring","_copy","volume","min_max","computeMinMax","min","max","windowLow","windowHigh","dimensions","xLength","yLength","zLength","spacingX","spacingY","spacingZ","spacing","matrix","_spaceX","_spaceY","_spaceZ","space","set","v","inverseMatrix","copy","invert","RASDimensions","applyMatrix4","round","toArray","map","Math","abs","lowerThreshold","Infinity","upperThreshold","output","endian","dimension","dim","_ref","_results","push","space_origin","f","parts","_results2","_j","_len2"],"mappings":"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","sourcesContent":["import { Loader, FileLoader, Vector3, Matrix4 } from \"three\";\nimport { gunzipSync } from \"fflate\";\nimport { Volume } from \"../misc/Volume.js\";\nclass NRRDLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setResponseType(\"arraybuffer\");\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(\n      url,\n      function(data) {\n        try {\n          onLoad(scope.parse(data));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n          scope.manager.itemError(url);\n        }\n      },\n      onProgress,\n      onError\n    );\n  }\n  parse(data) {\n    let _data = data;\n    let _dataPointer = 0;\n    const _nativeLittleEndian = new Int8Array(new Int16Array([1]).buffer)[0] > 0;\n    const _littleEndian = true;\n    const headerObject = {};\n    function scan(type, chunks) {\n      if (chunks === void 0 || chunks === null) {\n        chunks = 1;\n      }\n      let _chunkSize = 1;\n      let _array_type = Uint8Array;\n      switch (type) {\n        case \"uchar\":\n          break;\n        case \"schar\":\n          _array_type = Int8Array;\n          break;\n        case \"ushort\":\n          _array_type = Uint16Array;\n          _chunkSize = 2;\n          break;\n        case \"sshort\":\n          _array_type = Int16Array;\n          _chunkSize = 2;\n          break;\n        case \"uint\":\n          _array_type = Uint32Array;\n          _chunkSize = 4;\n          break;\n        case \"sint\":\n          _array_type = Int32Array;\n          _chunkSize = 4;\n          break;\n        case \"float\":\n          _array_type = Float32Array;\n          _chunkSize = 4;\n          break;\n        case \"complex\":\n          _array_type = Float64Array;\n          _chunkSize = 8;\n          break;\n        case \"double\":\n          _array_type = Float64Array;\n          _chunkSize = 8;\n          break;\n      }\n      let _bytes2 = new _array_type(_data.slice(_dataPointer, _dataPointer += chunks * _chunkSize));\n      if (_nativeLittleEndian != _littleEndian) {\n        _bytes2 = flipEndianness(_bytes2, _chunkSize);\n      }\n      if (chunks == 1) {\n        return _bytes2[0];\n      }\n      return _bytes2;\n    }\n    function flipEndianness(array, chunkSize) {\n      const u8 = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);\n      for (let i2 = 0; i2 < array.byteLength; i2 += chunkSize) {\n        for (let j = i2 + chunkSize - 1, k = i2; j > k; j--, k++) {\n          const tmp = u8[k];\n          u8[k] = u8[j];\n          u8[j] = tmp;\n        }\n      }\n      return array;\n    }\n    function parseHeader(header) {\n      let data2, field, fn, i2, l, m, _i, _len;\n      const lines = header.split(/\\r?\\n/);\n      for (_i = 0, _len = lines.length; _i < _len; _i++) {\n        l = lines[_i];\n        if (l.match(/NRRD\\d+/)) {\n          headerObject.isNrrd = true;\n        } else if (l.match(/^#/)) {\n        } else if (m = l.match(/(.*):(.*)/)) {\n          field = m[1].trim();\n          data2 = m[2].trim();\n          fn = _fieldFunctions[field];\n          if (fn) {\n            fn.call(headerObject, data2);\n          } else {\n            headerObject[field] = data2;\n          }\n        }\n      }\n      if (!headerObject.isNrrd) {\n        throw new Error(\"Not an NRRD file\");\n      }\n      if (headerObject.encoding === \"bz2\" || headerObject.encoding === \"bzip2\") {\n        throw new Error(\"Bzip is not supported\");\n      }\n      if (!headerObject.vectors) {\n        headerObject.vectors = [new Vector3(1, 0, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1)];\n        if (headerObject.spacings) {\n          for (i2 = 0; i2 <= 2; i2++) {\n            if (!isNaN(headerObject.spacings[i2])) {\n              headerObject.vectors[i2].multiplyScalar(headerObject.spacings[i2]);\n            }\n          }\n        }\n      }\n    }\n    function parseDataAsText(data2, start, end) {\n      let number = \"\";\n      start = start || 0;\n      end = end || data2.length;\n      let value;\n      const lengthOfTheResult = headerObject.sizes.reduce(function(previous, current) {\n        return previous * current;\n      }, 1);\n      let base = 10;\n      if (headerObject.encoding === \"hex\") {\n        base = 16;\n      }\n      const result = new headerObject.__array(lengthOfTheResult);\n      let resultIndex = 0;\n      let parsingFunction = parseInt;\n      if (headerObject.__array === Float32Array || headerObject.__array === Float64Array) {\n        parsingFunction = parseFloat;\n      }\n      for (let i2 = start; i2 < end; i2++) {\n        value = data2[i2];\n        if ((value < 9 || value > 13) && value !== 32) {\n          number += String.fromCharCode(value);\n        } else {\n          if (number !== \"\") {\n            result[resultIndex] = parsingFunction(number, base);\n            resultIndex++;\n          }\n          number = \"\";\n        }\n      }\n      if (number !== \"\") {\n        result[resultIndex] = parsingFunction(number, base);\n        resultIndex++;\n      }\n      return result;\n    }\n    const _bytes = scan(\"uchar\", data.byteLength);\n    const _length = _bytes.length;\n    let _header = null;\n    let _data_start = 0;\n    let i;\n    for (i = 1; i < _length; i++) {\n      if (_bytes[i - 1] == 10 && _bytes[i] == 10) {\n        _header = this.parseChars(_bytes, 0, i - 2);\n        _data_start = i + 1;\n        break;\n      }\n    }\n    parseHeader(_header);\n    _data = _bytes.subarray(_data_start);\n    if (headerObject.encoding.substring(0, 2) === \"gz\") {\n      _data = gunzipSync(new Uint8Array(_data));\n    } else if (headerObject.encoding === \"ascii\" || headerObject.encoding === \"text\" || headerObject.encoding === \"txt\" || headerObject.encoding === \"hex\") {\n      _data = parseDataAsText(_data);\n    } else if (headerObject.encoding === \"raw\") {\n      const _copy = new Uint8Array(_data.length);\n      for (let i2 = 0; i2 < _data.length; i2++) {\n        _copy[i2] = _data[i2];\n      }\n      _data = _copy;\n    }\n    _data = _data.buffer;\n    const volume = new Volume();\n    volume.header = headerObject;\n    volume.data = new headerObject.__array(_data);\n    const min_max = volume.computeMinMax();\n    const min = min_max[0];\n    const max = min_max[1];\n    volume.windowLow = min;\n    volume.windowHigh = max;\n    volume.dimensions = [headerObject.sizes[0], headerObject.sizes[1], headerObject.sizes[2]];\n    volume.xLength = volume.dimensions[0];\n    volume.yLength = volume.dimensions[1];\n    volume.zLength = volume.dimensions[2];\n    const spacingX = new Vector3(\n      headerObject.vectors[0][0],\n      headerObject.vectors[0][1],\n      headerObject.vectors[0][2]\n    ).length();\n    const spacingY = new Vector3(\n      headerObject.vectors[1][0],\n      headerObject.vectors[1][1],\n      headerObject.vectors[1][2]\n    ).length();\n    const spacingZ = new Vector3(\n      headerObject.vectors[2][0],\n      headerObject.vectors[2][1],\n      headerObject.vectors[2][2]\n    ).length();\n    volume.spacing = [spacingX, spacingY, spacingZ];\n    volume.matrix = new Matrix4();\n    let _spaceX = 1;\n    let _spaceY = 1;\n    const _spaceZ = 1;\n    if (headerObject.space == \"left-posterior-superior\") {\n      _spaceX = -1;\n      _spaceY = -1;\n    } else if (headerObject.space === \"left-anterior-superior\") {\n      _spaceX = -1;\n    }\n    if (!headerObject.vectors) {\n      volume.matrix.set(_spaceX, 0, 0, 0, 0, _spaceY, 0, 0, 0, 0, _spaceZ, 0, 0, 0, 0, 1);\n    } else {\n      const v = headerObject.vectors;\n      volume.matrix.set(\n        _spaceX * v[0][0],\n        _spaceX * v[1][0],\n        _spaceX * v[2][0],\n        0,\n        _spaceY * v[0][1],\n        _spaceY * v[1][1],\n        _spaceY * v[2][1],\n        0,\n        _spaceZ * v[0][2],\n        _spaceZ * v[1][2],\n        _spaceZ * v[2][2],\n        0,\n        0,\n        0,\n        0,\n        1\n      );\n    }\n    volume.inverseMatrix = new Matrix4();\n    volume.inverseMatrix.copy(volume.matrix).invert();\n    volume.RASDimensions = new Vector3(volume.xLength, volume.yLength, volume.zLength).applyMatrix4(volume.matrix).round().toArray().map(Math.abs);\n    if (volume.lowerThreshold === -Infinity) {\n      volume.lowerThreshold = min;\n    }\n    if (volume.upperThreshold === Infinity) {\n      volume.upperThreshold = max;\n    }\n    return volume;\n  }\n  parseChars(array, start, end) {\n    if (start === void 0) {\n      start = 0;\n    }\n    if (end === void 0) {\n      end = array.length;\n    }\n    let output = \"\";\n    let i = 0;\n    for (i = start; i < end; ++i) {\n      output += String.fromCharCode(array[i]);\n    }\n    return output;\n  }\n}\nconst _fieldFunctions = {\n  type: function(data) {\n    switch (data) {\n      case \"uchar\":\n      case \"unsigned char\":\n      case \"uint8\":\n      case \"uint8_t\":\n        this.__array = Uint8Array;\n        break;\n      case \"signed char\":\n      case \"int8\":\n      case \"int8_t\":\n        this.__array = Int8Array;\n        break;\n      case \"short\":\n      case \"short int\":\n      case \"signed short\":\n      case \"signed short int\":\n      case \"int16\":\n      case \"int16_t\":\n        this.__array = Int16Array;\n        break;\n      case \"ushort\":\n      case \"unsigned short\":\n      case \"unsigned short int\":\n      case \"uint16\":\n      case \"uint16_t\":\n        this.__array = Uint16Array;\n        break;\n      case \"int\":\n      case \"signed int\":\n      case \"int32\":\n      case \"int32_t\":\n        this.__array = Int32Array;\n        break;\n      case \"uint\":\n      case \"unsigned int\":\n      case \"uint32\":\n      case \"uint32_t\":\n        this.__array = Uint32Array;\n        break;\n      case \"float\":\n        this.__array = Float32Array;\n        break;\n      case \"double\":\n        this.__array = Float64Array;\n        break;\n      default:\n        throw new Error(\"Unsupported NRRD data type: \" + data);\n    }\n    return this.type = data;\n  },\n  endian: function(data) {\n    return this.endian = data;\n  },\n  encoding: function(data) {\n    return this.encoding = data;\n  },\n  dimension: function(data) {\n    return this.dim = parseInt(data, 10);\n  },\n  sizes: function(data) {\n    let i;\n    return this.sizes = function() {\n      const _ref = data.split(/\\s+/);\n      const _results = [];\n      for (let _i = 0, _len = _ref.length; _i < _len; _i++) {\n        i = _ref[_i];\n        _results.push(parseInt(i, 10));\n      }\n      return _results;\n    }();\n  },\n  space: function(data) {\n    return this.space = data;\n  },\n  \"space origin\": function(data) {\n    return this.space_origin = data.split(\"(\")[1].split(\")\")[0].split(\",\");\n  },\n  \"space directions\": function(data) {\n    let f, v;\n    const parts = data.match(/\\(.*?\\)/g);\n    return this.vectors = function() {\n      const _results = [];\n      for (let _i = 0, _len = parts.length; _i < _len; _i++) {\n        v = parts[_i];\n        _results.push(\n          function() {\n            const _ref = v.slice(1, -1).split(/,/);\n            const _results2 = [];\n            for (let _j = 0, _len2 = _ref.length; _j < _len2; _j++) {\n              f = _ref[_j];\n              _results2.push(parseFloat(f));\n            }\n            return _results2;\n          }()\n        );\n      }\n      return _results;\n    }();\n  },\n  spacings: function(data) {\n    let f;\n    const parts = data.split(/\\s+/);\n    return this.spacings = function() {\n      const _results = [];\n      for (let _i = 0, _len = parts.length; _i < _len; _i++) {\n        f = parts[_i];\n        _results.push(parseFloat(f));\n      }\n      return _results;\n    }();\n  }\n};\nexport {\n  NRRDLoader\n};\n"]},"metadata":{},"sourceType":"module"}