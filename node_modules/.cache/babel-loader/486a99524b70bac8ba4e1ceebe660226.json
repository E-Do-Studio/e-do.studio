{"ast":null,"code":"import _classCallCheck from \"/Users/theodaguier/_workdir/dev/pro/e-do/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/theodaguier/_workdir/dev/pro/e-do/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/theodaguier/_workdir/dev/pro/e-do/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/theodaguier/_workdir/dev/pro/e-do/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { Loader, LoaderUtils, FileLoader, FrontSide, RepeatWrapping, Color, MeshPhongMaterial, Vector2, DefaultLoadingManager, TextureLoader } from \"three\";\n\nvar MTLLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(MTLLoader, _Loader);\n\n  var _super = _createSuper(MTLLoader);\n\n  function MTLLoader(manager) {\n    _classCallCheck(this, MTLLoader);\n\n    return _super.call(this, manager);\n  }\n  /**\n   * Loads and parses a MTL asset from a URL.\n   *\n   * @param {String} url - URL to the MTL file.\n   * @param {Function} [onLoad] - Callback invoked with the loaded object.\n   * @param {Function} [onProgress] - Callback for download progress.\n   * @param {Function} [onError] - Callback for download errors.\n   *\n   * @see setPath setResourcePath\n   *\n   * @note In order for relative texture references to resolve correctly\n   * you must call setResourcePath() explicitly prior to load.\n   */\n\n\n  _createClass(MTLLoader, [{\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var path = this.path === \"\" ? LoaderUtils.extractUrlBase(url) : this.path;\n      var loader = new FileLoader(this.manager);\n      loader.setPath(this.path);\n      loader.setRequestHeader(this.requestHeader);\n      loader.setWithCredentials(this.withCredentials);\n      loader.load(url, function (text) {\n        try {\n          onLoad(scope.parse(text, path));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    }\n  }, {\n    key: \"setMaterialOptions\",\n    value: function setMaterialOptions(value) {\n      this.materialOptions = value;\n      return this;\n    }\n    /**\n     * Parses a MTL file.\n     *\n     * @param {String} text - Content of MTL file\n     * @return {MaterialCreator}\n     *\n     * @see setPath setResourcePath\n     *\n     * @note In order for relative texture references to resolve correctly\n     * you must call setResourcePath() explicitly prior to parse.\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(text, path) {\n      var lines = text.split(\"\\n\");\n      var info = {};\n      var delimiter_pattern = /\\s+/;\n      var materialsInfo = {};\n\n      for (var i = 0; i < lines.length; i++) {\n        var line = lines[i];\n        line = line.trim();\n\n        if (line.length === 0 || line.charAt(0) === \"#\") {\n          continue;\n        }\n\n        var pos = line.indexOf(\" \");\n        var key = pos >= 0 ? line.substring(0, pos) : line;\n        key = key.toLowerCase();\n        var value = pos >= 0 ? line.substring(pos + 1) : \"\";\n        value = value.trim();\n\n        if (key === \"newmtl\") {\n          info = {\n            name: value\n          };\n          materialsInfo[value] = info;\n        } else {\n          if (key === \"ka\" || key === \"kd\" || key === \"ks\" || key === \"ke\") {\n            var ss = value.split(delimiter_pattern, 3);\n            info[key] = [parseFloat(ss[0]), parseFloat(ss[1]), parseFloat(ss[2])];\n          } else {\n            info[key] = value;\n          }\n        }\n      }\n\n      var materialCreator = new MaterialCreator(this.resourcePath || path, this.materialOptions);\n      materialCreator.setCrossOrigin(this.crossOrigin);\n      materialCreator.setManager(this.manager);\n      materialCreator.setMaterials(materialsInfo);\n      return materialCreator;\n    }\n  }]);\n\n  return MTLLoader;\n}(Loader);\n\nvar MaterialCreator = /*#__PURE__*/function () {\n  function MaterialCreator() {\n    var baseUrl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, MaterialCreator);\n\n    this.baseUrl = baseUrl;\n    this.options = options;\n    this.materialsInfo = {};\n    this.materials = {};\n    this.materialsArray = [];\n    this.nameLookup = {};\n    this.crossOrigin = \"anonymous\";\n    this.side = this.options.side !== void 0 ? this.options.side : FrontSide;\n    this.wrap = this.options.wrap !== void 0 ? this.options.wrap : RepeatWrapping;\n  }\n\n  _createClass(MaterialCreator, [{\n    key: \"setCrossOrigin\",\n    value: function setCrossOrigin(value) {\n      this.crossOrigin = value;\n      return this;\n    }\n  }, {\n    key: \"setManager\",\n    value: function setManager(value) {\n      this.manager = value;\n    }\n  }, {\n    key: \"setMaterials\",\n    value: function setMaterials(materialsInfo) {\n      this.materialsInfo = this.convert(materialsInfo);\n      this.materials = {};\n      this.materialsArray = [];\n      this.nameLookup = {};\n    }\n  }, {\n    key: \"convert\",\n    value: function convert(materialsInfo) {\n      if (!this.options) return materialsInfo;\n      var converted = {};\n\n      for (var mn in materialsInfo) {\n        var mat = materialsInfo[mn];\n        var covmat = {};\n        converted[mn] = covmat;\n\n        for (var prop in mat) {\n          var save = true;\n          var value = mat[prop];\n          var lprop = prop.toLowerCase();\n\n          switch (lprop) {\n            case \"kd\":\n            case \"ka\":\n            case \"ks\":\n              if (this.options && this.options.normalizeRGB) {\n                value = [value[0] / 255, value[1] / 255, value[2] / 255];\n              }\n\n              if (this.options && this.options.ignoreZeroRGBs) {\n                if (value[0] === 0 && value[1] === 0 && value[2] === 0) {\n                  save = false;\n                }\n              }\n\n              break;\n\n            default:\n              break;\n          }\n\n          if (save) {\n            covmat[lprop] = value;\n          }\n        }\n      }\n\n      return converted;\n    }\n  }, {\n    key: \"preload\",\n    value: function preload() {\n      for (var mn in this.materialsInfo) {\n        this.create(mn);\n      }\n    }\n  }, {\n    key: \"getIndex\",\n    value: function getIndex(materialName) {\n      return this.nameLookup[materialName];\n    }\n  }, {\n    key: \"getAsArray\",\n    value: function getAsArray() {\n      var index = 0;\n\n      for (var mn in this.materialsInfo) {\n        this.materialsArray[index] = this.create(mn);\n        this.nameLookup[mn] = index;\n        index++;\n      }\n\n      return this.materialsArray;\n    }\n  }, {\n    key: \"create\",\n    value: function create(materialName) {\n      if (this.materials[materialName] === void 0) {\n        this.createMaterial_(materialName);\n      }\n\n      return this.materials[materialName];\n    }\n  }, {\n    key: \"createMaterial_\",\n    value: function createMaterial_(materialName) {\n      var scope = this;\n      var mat = this.materialsInfo[materialName];\n      var params = {\n        name: materialName,\n        side: this.side\n      };\n\n      function resolveURL(baseUrl, url) {\n        if (typeof url !== \"string\" || url === \"\") return \"\";\n        if (/^https?:\\/\\//i.test(url)) return url;\n        return baseUrl + url;\n      }\n\n      function setMapForType(mapType, value) {\n        if (params[mapType]) return;\n        var texParams = scope.getTextureParams(value, params);\n        var map = scope.loadTexture(resolveURL(scope.baseUrl, texParams.url));\n        map.repeat.copy(texParams.scale);\n        map.offset.copy(texParams.offset);\n        map.wrapS = scope.wrap;\n        map.wrapT = scope.wrap;\n        params[mapType] = map;\n      }\n\n      for (var prop in mat) {\n        var value = mat[prop];\n        var n = void 0;\n        if (value === \"\") continue;\n\n        switch (prop.toLowerCase()) {\n          case \"kd\":\n            params.color = new Color().fromArray(value);\n            break;\n\n          case \"ks\":\n            params.specular = new Color().fromArray(value);\n            break;\n\n          case \"ke\":\n            params.emissive = new Color().fromArray(value);\n            break;\n\n          case \"map_kd\":\n            setMapForType(\"map\", value);\n            break;\n\n          case \"map_ks\":\n            setMapForType(\"specularMap\", value);\n            break;\n\n          case \"map_ke\":\n            setMapForType(\"emissiveMap\", value);\n            break;\n\n          case \"norm\":\n            setMapForType(\"normalMap\", value);\n            break;\n\n          case \"map_bump\":\n          case \"bump\":\n            setMapForType(\"bumpMap\", value);\n            break;\n\n          case \"map_d\":\n            setMapForType(\"alphaMap\", value);\n            params.transparent = true;\n            break;\n\n          case \"ns\":\n            params.shininess = parseFloat(value);\n            break;\n\n          case \"d\":\n            n = parseFloat(value);\n\n            if (n < 1) {\n              params.opacity = n;\n              params.transparent = true;\n            }\n\n            break;\n\n          case \"tr\":\n            n = parseFloat(value);\n            if (this.options && this.options.invertTrProperty) n = 1 - n;\n\n            if (n > 0) {\n              params.opacity = 1 - n;\n              params.transparent = true;\n            }\n\n            break;\n\n          default:\n            break;\n        }\n      }\n\n      this.materials[materialName] = new MeshPhongMaterial(params);\n      return this.materials[materialName];\n    }\n  }, {\n    key: \"getTextureParams\",\n    value: function getTextureParams(value, matParams) {\n      var texParams = {\n        scale: new Vector2(1, 1),\n        offset: new Vector2(0, 0)\n      };\n      var items = value.split(/\\s+/);\n      var pos;\n      pos = items.indexOf(\"-bm\");\n\n      if (pos >= 0) {\n        matParams.bumpScale = parseFloat(items[pos + 1]);\n        items.splice(pos, 2);\n      }\n\n      pos = items.indexOf(\"-s\");\n\n      if (pos >= 0) {\n        texParams.scale.set(parseFloat(items[pos + 1]), parseFloat(items[pos + 2]));\n        items.splice(pos, 4);\n      }\n\n      pos = items.indexOf(\"-o\");\n\n      if (pos >= 0) {\n        texParams.offset.set(parseFloat(items[pos + 1]), parseFloat(items[pos + 2]));\n        items.splice(pos, 4);\n      }\n\n      texParams.url = items.join(\" \").trim();\n      return texParams;\n    }\n  }, {\n    key: \"loadTexture\",\n    value: function loadTexture(url, mapping, onLoad, onProgress, onError) {\n      var manager = this.manager !== void 0 ? this.manager : DefaultLoadingManager;\n      var loader = manager.getHandler(url);\n\n      if (loader === null) {\n        loader = new TextureLoader(manager);\n      }\n\n      if (loader.setCrossOrigin) loader.setCrossOrigin(this.crossOrigin);\n      var texture = loader.load(url, onLoad, onProgress, onError);\n      if (mapping !== void 0) texture.mapping = mapping;\n      return texture;\n    }\n  }]);\n\n  return MaterialCreator;\n}();\n\nexport { MTLLoader };","map":{"version":3,"sources":["/Users/theodaguier/_workdir/dev/pro/e-do/E-Do-Studio/node_modules/three-stdlib/loaders/MTLLoader.js"],"names":["Loader","LoaderUtils","FileLoader","FrontSide","RepeatWrapping","Color","MeshPhongMaterial","Vector2","DefaultLoadingManager","TextureLoader","MTLLoader","manager","url","onLoad","onProgress","onError","scope","path","extractUrlBase","loader","setPath","setRequestHeader","requestHeader","setWithCredentials","withCredentials","load","text","parse","e","console","error","itemError","value","materialOptions","lines","split","info","delimiter_pattern","materialsInfo","i","length","line","trim","charAt","pos","indexOf","key","substring","toLowerCase","name","ss","parseFloat","materialCreator","MaterialCreator","resourcePath","setCrossOrigin","crossOrigin","setManager","setMaterials","baseUrl","options","materials","materialsArray","nameLookup","side","wrap","convert","converted","mn","mat","covmat","prop","save","lprop","normalizeRGB","ignoreZeroRGBs","create","materialName","index","createMaterial_","params","resolveURL","test","setMapForType","mapType","texParams","getTextureParams","map","loadTexture","repeat","copy","scale","offset","wrapS","wrapT","n","color","fromArray","specular","emissive","transparent","shininess","opacity","invertTrProperty","matParams","items","bumpScale","splice","set","join","mapping","getHandler","texture"],"mappings":"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","sourcesContent":["import { Loader, LoaderUtils, FileLoader, FrontSide, RepeatWrapping, Color, MeshPhongMaterial, Vector2, DefaultLoadingManager, TextureLoader } from \"three\";\nclass MTLLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  /**\n   * Loads and parses a MTL asset from a URL.\n   *\n   * @param {String} url - URL to the MTL file.\n   * @param {Function} [onLoad] - Callback invoked with the loaded object.\n   * @param {Function} [onProgress] - Callback for download progress.\n   * @param {Function} [onError] - Callback for download errors.\n   *\n   * @see setPath setResourcePath\n   *\n   * @note In order for relative texture references to resolve correctly\n   * you must call setResourcePath() explicitly prior to load.\n   */\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const path = this.path === \"\" ? LoaderUtils.extractUrlBase(url) : this.path;\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(\n      url,\n      function(text) {\n        try {\n          onLoad(scope.parse(text, path));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n          scope.manager.itemError(url);\n        }\n      },\n      onProgress,\n      onError\n    );\n  }\n  setMaterialOptions(value) {\n    this.materialOptions = value;\n    return this;\n  }\n  /**\n   * Parses a MTL file.\n   *\n   * @param {String} text - Content of MTL file\n   * @return {MaterialCreator}\n   *\n   * @see setPath setResourcePath\n   *\n   * @note In order for relative texture references to resolve correctly\n   * you must call setResourcePath() explicitly prior to parse.\n   */\n  parse(text, path) {\n    const lines = text.split(\"\\n\");\n    let info = {};\n    const delimiter_pattern = /\\s+/;\n    const materialsInfo = {};\n    for (let i = 0; i < lines.length; i++) {\n      let line = lines[i];\n      line = line.trim();\n      if (line.length === 0 || line.charAt(0) === \"#\") {\n        continue;\n      }\n      const pos = line.indexOf(\" \");\n      let key = pos >= 0 ? line.substring(0, pos) : line;\n      key = key.toLowerCase();\n      let value = pos >= 0 ? line.substring(pos + 1) : \"\";\n      value = value.trim();\n      if (key === \"newmtl\") {\n        info = { name: value };\n        materialsInfo[value] = info;\n      } else {\n        if (key === \"ka\" || key === \"kd\" || key === \"ks\" || key === \"ke\") {\n          const ss = value.split(delimiter_pattern, 3);\n          info[key] = [parseFloat(ss[0]), parseFloat(ss[1]), parseFloat(ss[2])];\n        } else {\n          info[key] = value;\n        }\n      }\n    }\n    const materialCreator = new MaterialCreator(this.resourcePath || path, this.materialOptions);\n    materialCreator.setCrossOrigin(this.crossOrigin);\n    materialCreator.setManager(this.manager);\n    materialCreator.setMaterials(materialsInfo);\n    return materialCreator;\n  }\n}\nclass MaterialCreator {\n  constructor(baseUrl = \"\", options = {}) {\n    this.baseUrl = baseUrl;\n    this.options = options;\n    this.materialsInfo = {};\n    this.materials = {};\n    this.materialsArray = [];\n    this.nameLookup = {};\n    this.crossOrigin = \"anonymous\";\n    this.side = this.options.side !== void 0 ? this.options.side : FrontSide;\n    this.wrap = this.options.wrap !== void 0 ? this.options.wrap : RepeatWrapping;\n  }\n  setCrossOrigin(value) {\n    this.crossOrigin = value;\n    return this;\n  }\n  setManager(value) {\n    this.manager = value;\n  }\n  setMaterials(materialsInfo) {\n    this.materialsInfo = this.convert(materialsInfo);\n    this.materials = {};\n    this.materialsArray = [];\n    this.nameLookup = {};\n  }\n  convert(materialsInfo) {\n    if (!this.options)\n      return materialsInfo;\n    const converted = {};\n    for (const mn in materialsInfo) {\n      const mat = materialsInfo[mn];\n      const covmat = {};\n      converted[mn] = covmat;\n      for (const prop in mat) {\n        let save = true;\n        let value = mat[prop];\n        const lprop = prop.toLowerCase();\n        switch (lprop) {\n          case \"kd\":\n          case \"ka\":\n          case \"ks\":\n            if (this.options && this.options.normalizeRGB) {\n              value = [value[0] / 255, value[1] / 255, value[2] / 255];\n            }\n            if (this.options && this.options.ignoreZeroRGBs) {\n              if (value[0] === 0 && value[1] === 0 && value[2] === 0) {\n                save = false;\n              }\n            }\n            break;\n          default:\n            break;\n        }\n        if (save) {\n          covmat[lprop] = value;\n        }\n      }\n    }\n    return converted;\n  }\n  preload() {\n    for (const mn in this.materialsInfo) {\n      this.create(mn);\n    }\n  }\n  getIndex(materialName) {\n    return this.nameLookup[materialName];\n  }\n  getAsArray() {\n    let index = 0;\n    for (const mn in this.materialsInfo) {\n      this.materialsArray[index] = this.create(mn);\n      this.nameLookup[mn] = index;\n      index++;\n    }\n    return this.materialsArray;\n  }\n  create(materialName) {\n    if (this.materials[materialName] === void 0) {\n      this.createMaterial_(materialName);\n    }\n    return this.materials[materialName];\n  }\n  createMaterial_(materialName) {\n    const scope = this;\n    const mat = this.materialsInfo[materialName];\n    const params = {\n      name: materialName,\n      side: this.side\n    };\n    function resolveURL(baseUrl, url) {\n      if (typeof url !== \"string\" || url === \"\")\n        return \"\";\n      if (/^https?:\\/\\//i.test(url))\n        return url;\n      return baseUrl + url;\n    }\n    function setMapForType(mapType, value) {\n      if (params[mapType])\n        return;\n      const texParams = scope.getTextureParams(value, params);\n      const map = scope.loadTexture(resolveURL(scope.baseUrl, texParams.url));\n      map.repeat.copy(texParams.scale);\n      map.offset.copy(texParams.offset);\n      map.wrapS = scope.wrap;\n      map.wrapT = scope.wrap;\n      params[mapType] = map;\n    }\n    for (const prop in mat) {\n      const value = mat[prop];\n      let n;\n      if (value === \"\")\n        continue;\n      switch (prop.toLowerCase()) {\n        case \"kd\":\n          params.color = new Color().fromArray(value);\n          break;\n        case \"ks\":\n          params.specular = new Color().fromArray(value);\n          break;\n        case \"ke\":\n          params.emissive = new Color().fromArray(value);\n          break;\n        case \"map_kd\":\n          setMapForType(\"map\", value);\n          break;\n        case \"map_ks\":\n          setMapForType(\"specularMap\", value);\n          break;\n        case \"map_ke\":\n          setMapForType(\"emissiveMap\", value);\n          break;\n        case \"norm\":\n          setMapForType(\"normalMap\", value);\n          break;\n        case \"map_bump\":\n        case \"bump\":\n          setMapForType(\"bumpMap\", value);\n          break;\n        case \"map_d\":\n          setMapForType(\"alphaMap\", value);\n          params.transparent = true;\n          break;\n        case \"ns\":\n          params.shininess = parseFloat(value);\n          break;\n        case \"d\":\n          n = parseFloat(value);\n          if (n < 1) {\n            params.opacity = n;\n            params.transparent = true;\n          }\n          break;\n        case \"tr\":\n          n = parseFloat(value);\n          if (this.options && this.options.invertTrProperty)\n            n = 1 - n;\n          if (n > 0) {\n            params.opacity = 1 - n;\n            params.transparent = true;\n          }\n          break;\n        default:\n          break;\n      }\n    }\n    this.materials[materialName] = new MeshPhongMaterial(params);\n    return this.materials[materialName];\n  }\n  getTextureParams(value, matParams) {\n    const texParams = {\n      scale: new Vector2(1, 1),\n      offset: new Vector2(0, 0)\n    };\n    const items = value.split(/\\s+/);\n    let pos;\n    pos = items.indexOf(\"-bm\");\n    if (pos >= 0) {\n      matParams.bumpScale = parseFloat(items[pos + 1]);\n      items.splice(pos, 2);\n    }\n    pos = items.indexOf(\"-s\");\n    if (pos >= 0) {\n      texParams.scale.set(parseFloat(items[pos + 1]), parseFloat(items[pos + 2]));\n      items.splice(pos, 4);\n    }\n    pos = items.indexOf(\"-o\");\n    if (pos >= 0) {\n      texParams.offset.set(parseFloat(items[pos + 1]), parseFloat(items[pos + 2]));\n      items.splice(pos, 4);\n    }\n    texParams.url = items.join(\" \").trim();\n    return texParams;\n  }\n  loadTexture(url, mapping, onLoad, onProgress, onError) {\n    const manager = this.manager !== void 0 ? this.manager : DefaultLoadingManager;\n    let loader = manager.getHandler(url);\n    if (loader === null) {\n      loader = new TextureLoader(manager);\n    }\n    if (loader.setCrossOrigin)\n      loader.setCrossOrigin(this.crossOrigin);\n    const texture = loader.load(url, onLoad, onProgress, onError);\n    if (mapping !== void 0)\n      texture.mapping = mapping;\n    return texture;\n  }\n}\nexport {\n  MTLLoader\n};\n"]},"metadata":{},"sourceType":"module"}