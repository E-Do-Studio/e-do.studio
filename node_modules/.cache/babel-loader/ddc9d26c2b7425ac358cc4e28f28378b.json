{"ast":null,"code":"import { Mesh, PlaneGeometry, MeshBasicMaterial, CanvasTexture, LinearFilter, Color } from \"three\";\n\nclass HTMLMesh extends Mesh {\n  constructor(dom) {\n    const texture = new HTMLTexture(dom);\n    const geometry = new PlaneGeometry(texture.image.width * 1e-3, texture.image.height * 1e-3);\n    const material = new MeshBasicMaterial({\n      map: texture,\n      toneMapped: false,\n      transparent: true\n    });\n    super(geometry, material);\n\n    function onEvent(event) {\n      material.map.dispatchDOMEvent(event);\n    }\n\n    this.addEventListener(\"mousedown\", onEvent);\n    this.addEventListener(\"mousemove\", onEvent);\n    this.addEventListener(\"mouseup\", onEvent);\n    this.addEventListener(\"click\", onEvent);\n\n    this.dispose = function () {\n      geometry.dispose();\n      material.dispose();\n      material.map.dispose();\n      canvases.delete(dom);\n      this.removeEventListener(\"mousedown\", onEvent);\n      this.removeEventListener(\"mousemove\", onEvent);\n      this.removeEventListener(\"mouseup\", onEvent);\n      this.removeEventListener(\"click\", onEvent);\n    };\n  }\n\n}\n\nclass HTMLTexture extends CanvasTexture {\n  constructor(dom) {\n    super(html2canvas(dom));\n    this.dom = dom;\n    this.anisotropy = 16;\n    if (\"colorSpace\" in this) this.colorSpace = \"srgb\";else this.encoding = 3001;\n    this.minFilter = LinearFilter;\n    this.magFilter = LinearFilter;\n    const observer = new MutationObserver(() => {\n      if (!this.scheduleUpdate) {\n        this.scheduleUpdate = setTimeout(() => this.update(), 16);\n      }\n    });\n    const config = {\n      attributes: true,\n      childList: true,\n      subtree: true,\n      characterData: true\n    };\n    observer.observe(dom, config);\n    this.observer = observer;\n  }\n\n  dispatchDOMEvent(event) {\n    if (event.data) {\n      htmlevent(this.dom, event.type, event.data.x, event.data.y);\n    }\n  }\n\n  update() {\n    this.image = html2canvas(this.dom);\n    this.needsUpdate = true;\n    this.scheduleUpdate = null;\n  }\n\n  dispose() {\n    if (this.observer) {\n      this.observer.disconnect();\n    }\n\n    this.scheduleUpdate = clearTimeout(this.scheduleUpdate);\n    super.dispose();\n  }\n\n}\n\nconst canvases = /* @__PURE__ */new WeakMap();\n\nfunction html2canvas(element) {\n  const range = document.createRange();\n  const color = new Color();\n\n  function Clipper(context2) {\n    const clips = [];\n    let isClipping = false;\n\n    function doClip() {\n      if (isClipping) {\n        isClipping = false;\n        context2.restore();\n      }\n\n      if (clips.length === 0) return;\n      let minX = -Infinity,\n          minY = -Infinity;\n      let maxX = Infinity,\n          maxY = Infinity;\n\n      for (let i = 0; i < clips.length; i++) {\n        const clip = clips[i];\n        minX = Math.max(minX, clip.x);\n        minY = Math.max(minY, clip.y);\n        maxX = Math.min(maxX, clip.x + clip.width);\n        maxY = Math.min(maxY, clip.y + clip.height);\n      }\n\n      context2.save();\n      context2.beginPath();\n      context2.rect(minX, minY, maxX - minX, maxY - minY);\n      context2.clip();\n      isClipping = true;\n    }\n\n    return {\n      add: function (clip) {\n        clips.push(clip);\n        doClip();\n      },\n      remove: function () {\n        clips.pop();\n        doClip();\n      }\n    };\n  }\n\n  function drawText(style, x, y, string) {\n    if (string !== \"\") {\n      if (style.textTransform === \"uppercase\") {\n        string = string.toUpperCase();\n      }\n\n      context.font = style.fontWeight + \" \" + style.fontSize + \" \" + style.fontFamily;\n      context.textBaseline = \"top\";\n      context.fillStyle = style.color;\n      context.fillText(string, x, y + parseFloat(style.fontSize) * 0.1);\n    }\n  }\n\n  function buildRectPath(x, y, w, h, r) {\n    if (w < 2 * r) r = w / 2;\n    if (h < 2 * r) r = h / 2;\n    context.beginPath();\n    context.moveTo(x + r, y);\n    context.arcTo(x + w, y, x + w, y + h, r);\n    context.arcTo(x + w, y + h, x, y + h, r);\n    context.arcTo(x, y + h, x, y, r);\n    context.arcTo(x, y, x + w, y, r);\n    context.closePath();\n  }\n\n  function drawBorder(style, which, x, y, width, height) {\n    const borderWidth = style[which + \"Width\"];\n    const borderStyle = style[which + \"Style\"];\n    const borderColor = style[which + \"Color\"];\n\n    if (borderWidth !== \"0px\" && borderStyle !== \"none\" && borderColor !== \"transparent\" && borderColor !== \"rgba(0, 0, 0, 0)\") {\n      context.strokeStyle = borderColor;\n      context.lineWidth = parseFloat(borderWidth);\n      context.beginPath();\n      context.moveTo(x, y);\n      context.lineTo(x + width, y + height);\n      context.stroke();\n    }\n  }\n\n  function drawElement(element2, style) {\n    let x = 0,\n        y = 0,\n        width = 0,\n        height = 0;\n\n    if (element2.nodeType === Node.TEXT_NODE) {\n      range.selectNode(element2);\n      const rect = range.getBoundingClientRect();\n      x = rect.left - offset.left - 0.5;\n      y = rect.top - offset.top - 0.5;\n      width = rect.width;\n      height = rect.height;\n      drawText(style, x, y, element2.nodeValue.trim());\n    } else if (element2.nodeType === Node.COMMENT_NODE) {\n      return;\n    } else if (element2 instanceof HTMLCanvasElement) {\n      if (element2.style.display === \"none\") return;\n      context.save();\n      const dpr = window.devicePixelRatio;\n      context.scale(1 / dpr, 1 / dpr);\n      context.drawImage(element2, 0, 0);\n      context.restore();\n    } else {\n      if (element2.style.display === \"none\") return;\n      const rect = element2.getBoundingClientRect();\n      x = rect.left - offset.left - 0.5;\n      y = rect.top - offset.top - 0.5;\n      width = rect.width;\n      height = rect.height;\n      style = window.getComputedStyle(element2);\n      buildRectPath(x, y, width, height, parseFloat(style.borderRadius));\n      const backgroundColor = style.backgroundColor;\n\n      if (backgroundColor !== \"transparent\" && backgroundColor !== \"rgba(0, 0, 0, 0)\") {\n        context.fillStyle = backgroundColor;\n        context.fill();\n      }\n\n      const borders = [\"borderTop\", \"borderLeft\", \"borderBottom\", \"borderRight\"];\n      let match = true;\n      let prevBorder = null;\n\n      for (const border of borders) {\n        if (prevBorder !== null) {\n          match = style[border + \"Width\"] === style[prevBorder + \"Width\"] && style[border + \"Color\"] === style[prevBorder + \"Color\"] && style[border + \"Style\"] === style[prevBorder + \"Style\"];\n        }\n\n        if (match === false) break;\n        prevBorder = border;\n      }\n\n      if (match === true) {\n        const width2 = parseFloat(style.borderTopWidth);\n\n        if (style.borderTopWidth !== \"0px\" && style.borderTopStyle !== \"none\" && style.borderTopColor !== \"transparent\" && style.borderTopColor !== \"rgba(0, 0, 0, 0)\") {\n          context.strokeStyle = style.borderTopColor;\n          context.lineWidth = width2;\n          context.stroke();\n        }\n      } else {\n        drawBorder(style, \"borderTop\", x, y, width, 0);\n        drawBorder(style, \"borderLeft\", x, y, 0, height);\n        drawBorder(style, \"borderBottom\", x, y + height, width, 0);\n        drawBorder(style, \"borderRight\", x + width, y, 0, height);\n      }\n\n      if (element2 instanceof HTMLInputElement) {\n        let accentColor = style.accentColor;\n        if (accentColor === void 0 || accentColor === \"auto\") accentColor = style.color;\n        color.set(accentColor);\n        const luminance = Math.sqrt(0.299 * color.r ** 2 + 0.587 * color.g ** 2 + 0.114 * color.b ** 2);\n        const accentTextColor = luminance < 0.5 ? \"white\" : \"#111111\";\n\n        if (element2.type === \"radio\") {\n          buildRectPath(x, y, width, height, height);\n          context.fillStyle = \"white\";\n          context.strokeStyle = accentColor;\n          context.lineWidth = 1;\n          context.fill();\n          context.stroke();\n\n          if (element2.checked) {\n            buildRectPath(x + 2, y + 2, width - 4, height - 4, height);\n            context.fillStyle = accentColor;\n            context.strokeStyle = accentTextColor;\n            context.lineWidth = 2;\n            context.fill();\n            context.stroke();\n          }\n        }\n\n        if (element2.type === \"checkbox\") {\n          buildRectPath(x, y, width, height, 2);\n          context.fillStyle = element2.checked ? accentColor : \"white\";\n          context.strokeStyle = element2.checked ? accentTextColor : accentColor;\n          context.lineWidth = 1;\n          context.stroke();\n          context.fill();\n\n          if (element2.checked) {\n            const currentTextAlign = context.textAlign;\n            context.textAlign = \"center\";\n            const properties = {\n              color: accentTextColor,\n              fontFamily: style.fontFamily,\n              fontSize: height + \"px\",\n              fontWeight: \"bold\"\n            };\n            drawText(properties, x + width / 2, y, \"✔\");\n            context.textAlign = currentTextAlign;\n          }\n        }\n\n        if (element2.type === \"range\") {\n          const [min, max, value] = [\"min\", \"max\", \"value\"].map(property => parseFloat(element2[property]));\n          const position = (value - min) / (max - min) * (width - height);\n          buildRectPath(x, y + height / 4, width, height / 2, height / 4);\n          context.fillStyle = accentTextColor;\n          context.strokeStyle = accentColor;\n          context.lineWidth = 1;\n          context.fill();\n          context.stroke();\n          buildRectPath(x, y + height / 4, position + height / 2, height / 2, height / 4);\n          context.fillStyle = accentColor;\n          context.fill();\n          buildRectPath(x + position, y, height, height, height / 2);\n          context.fillStyle = accentColor;\n          context.fill();\n        }\n\n        if (element2.type === \"color\" || element2.type === \"text\" || element2.type === \"number\") {\n          clipper.add({\n            x,\n            y,\n            width,\n            height\n          });\n          drawText(style, x + parseInt(style.paddingLeft), y + parseInt(style.paddingTop), element2.value);\n          clipper.remove();\n        }\n      }\n    }\n\n    const isClipping = style.overflow === \"auto\" || style.overflow === \"hidden\";\n    if (isClipping) clipper.add({\n      x,\n      y,\n      width,\n      height\n    });\n\n    for (let i = 0; i < element2.childNodes.length; i++) {\n      drawElement(element2.childNodes[i], style);\n    }\n\n    if (isClipping) clipper.remove();\n  }\n\n  const offset = element.getBoundingClientRect();\n  let canvas = canvases.get(element);\n\n  if (canvas === void 0) {\n    canvas = document.createElement(\"canvas\");\n    canvas.width = offset.width;\n    canvas.height = offset.height;\n    canvases.set(element, canvas);\n  }\n\n  const context = canvas.getContext(\"2d\"\n  /*, { alpha: false }*/\n  );\n  const clipper = new Clipper(context);\n  drawElement(element);\n  return canvas;\n}\n\nfunction htmlevent(element, event, x, y) {\n  const mouseEventInit = {\n    clientX: x * element.offsetWidth + element.offsetLeft,\n    clientY: y * element.offsetHeight + element.offsetTop,\n    view: element.ownerDocument.defaultView\n  };\n  window.dispatchEvent(new MouseEvent(event, mouseEventInit));\n  const rect = element.getBoundingClientRect();\n  x = x * rect.width + rect.left;\n  y = y * rect.height + rect.top;\n\n  function traverse(element2) {\n    if (element2.nodeType !== Node.TEXT_NODE && element2.nodeType !== Node.COMMENT_NODE) {\n      const rect2 = element2.getBoundingClientRect();\n\n      if (x > rect2.left && x < rect2.right && y > rect2.top && y < rect2.bottom) {\n        element2.dispatchEvent(new MouseEvent(event, mouseEventInit));\n\n        if (element2 instanceof HTMLInputElement && element2.type === \"range\" && (event === \"mousedown\" || event === \"click\")) {\n          const [min, max] = [\"min\", \"max\"].map(property => parseFloat(element2[property]));\n          const width = rect2.width;\n          const offsetX = x - rect2.x;\n          const proportion = offsetX / width;\n          element2.value = min + (max - min) * proportion;\n          element2.dispatchEvent(new InputEvent(\"input\", {\n            bubbles: true\n          }));\n        }\n      }\n\n      for (let i = 0; i < element2.childNodes.length; i++) {\n        traverse(element2.childNodes[i]);\n      }\n    }\n  }\n\n  traverse(element);\n}\n\nexport { HTMLMesh };","map":{"version":3,"sources":["/Users/theodaguier/Repositories/E-Do-Studio/node_modules/three-stdlib/interactive/HTMLMesh.js"],"names":["Mesh","PlaneGeometry","MeshBasicMaterial","CanvasTexture","LinearFilter","Color","HTMLMesh","constructor","dom","texture","HTMLTexture","geometry","image","width","height","material","map","toneMapped","transparent","onEvent","event","dispatchDOMEvent","addEventListener","dispose","canvases","delete","removeEventListener","html2canvas","anisotropy","colorSpace","encoding","minFilter","magFilter","observer","MutationObserver","scheduleUpdate","setTimeout","update","config","attributes","childList","subtree","characterData","observe","data","htmlevent","type","x","y","needsUpdate","disconnect","clearTimeout","WeakMap","element","range","document","createRange","color","Clipper","context2","clips","isClipping","doClip","restore","length","minX","Infinity","minY","maxX","maxY","i","clip","Math","max","min","save","beginPath","rect","add","push","remove","pop","drawText","style","string","textTransform","toUpperCase","context","font","fontWeight","fontSize","fontFamily","textBaseline","fillStyle","fillText","parseFloat","buildRectPath","w","h","r","moveTo","arcTo","closePath","drawBorder","which","borderWidth","borderStyle","borderColor","strokeStyle","lineWidth","lineTo","stroke","drawElement","element2","nodeType","Node","TEXT_NODE","selectNode","getBoundingClientRect","left","offset","top","nodeValue","trim","COMMENT_NODE","HTMLCanvasElement","display","dpr","window","devicePixelRatio","scale","drawImage","getComputedStyle","borderRadius","backgroundColor","fill","borders","match","prevBorder","border","width2","borderTopWidth","borderTopStyle","borderTopColor","HTMLInputElement","accentColor","set","luminance","sqrt","g","b","accentTextColor","checked","currentTextAlign","textAlign","properties","value","property","position","clipper","parseInt","paddingLeft","paddingTop","overflow","childNodes","canvas","get","createElement","getContext","mouseEventInit","clientX","offsetWidth","offsetLeft","clientY","offsetHeight","offsetTop","view","ownerDocument","defaultView","dispatchEvent","MouseEvent","traverse","rect2","right","bottom","offsetX","proportion","InputEvent","bubbles"],"mappings":"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","sourcesContent":["import { Mesh, PlaneGeometry, MeshBasicMaterial, CanvasTexture, LinearFilter, Color } from \"three\";\nclass HTMLMesh extends Mesh {\n  constructor(dom) {\n    const texture = new HTMLTexture(dom);\n    const geometry = new PlaneGeometry(texture.image.width * 1e-3, texture.image.height * 1e-3);\n    const material = new MeshBasicMaterial({ map: texture, toneMapped: false, transparent: true });\n    super(geometry, material);\n    function onEvent(event) {\n      material.map.dispatchDOMEvent(event);\n    }\n    this.addEventListener(\"mousedown\", onEvent);\n    this.addEventListener(\"mousemove\", onEvent);\n    this.addEventListener(\"mouseup\", onEvent);\n    this.addEventListener(\"click\", onEvent);\n    this.dispose = function() {\n      geometry.dispose();\n      material.dispose();\n      material.map.dispose();\n      canvases.delete(dom);\n      this.removeEventListener(\"mousedown\", onEvent);\n      this.removeEventListener(\"mousemove\", onEvent);\n      this.removeEventListener(\"mouseup\", onEvent);\n      this.removeEventListener(\"click\", onEvent);\n    };\n  }\n}\nclass HTMLTexture extends CanvasTexture {\n  constructor(dom) {\n    super(html2canvas(dom));\n    this.dom = dom;\n    this.anisotropy = 16;\n    if (\"colorSpace\" in this)\n      this.colorSpace = \"srgb\";\n    else\n      this.encoding = 3001;\n    this.minFilter = LinearFilter;\n    this.magFilter = LinearFilter;\n    const observer = new MutationObserver(() => {\n      if (!this.scheduleUpdate) {\n        this.scheduleUpdate = setTimeout(() => this.update(), 16);\n      }\n    });\n    const config = { attributes: true, childList: true, subtree: true, characterData: true };\n    observer.observe(dom, config);\n    this.observer = observer;\n  }\n  dispatchDOMEvent(event) {\n    if (event.data) {\n      htmlevent(this.dom, event.type, event.data.x, event.data.y);\n    }\n  }\n  update() {\n    this.image = html2canvas(this.dom);\n    this.needsUpdate = true;\n    this.scheduleUpdate = null;\n  }\n  dispose() {\n    if (this.observer) {\n      this.observer.disconnect();\n    }\n    this.scheduleUpdate = clearTimeout(this.scheduleUpdate);\n    super.dispose();\n  }\n}\nconst canvases = /* @__PURE__ */ new WeakMap();\nfunction html2canvas(element) {\n  const range = document.createRange();\n  const color = new Color();\n  function Clipper(context2) {\n    const clips = [];\n    let isClipping = false;\n    function doClip() {\n      if (isClipping) {\n        isClipping = false;\n        context2.restore();\n      }\n      if (clips.length === 0)\n        return;\n      let minX = -Infinity, minY = -Infinity;\n      let maxX = Infinity, maxY = Infinity;\n      for (let i = 0; i < clips.length; i++) {\n        const clip = clips[i];\n        minX = Math.max(minX, clip.x);\n        minY = Math.max(minY, clip.y);\n        maxX = Math.min(maxX, clip.x + clip.width);\n        maxY = Math.min(maxY, clip.y + clip.height);\n      }\n      context2.save();\n      context2.beginPath();\n      context2.rect(minX, minY, maxX - minX, maxY - minY);\n      context2.clip();\n      isClipping = true;\n    }\n    return {\n      add: function(clip) {\n        clips.push(clip);\n        doClip();\n      },\n      remove: function() {\n        clips.pop();\n        doClip();\n      }\n    };\n  }\n  function drawText(style, x, y, string) {\n    if (string !== \"\") {\n      if (style.textTransform === \"uppercase\") {\n        string = string.toUpperCase();\n      }\n      context.font = style.fontWeight + \" \" + style.fontSize + \" \" + style.fontFamily;\n      context.textBaseline = \"top\";\n      context.fillStyle = style.color;\n      context.fillText(string, x, y + parseFloat(style.fontSize) * 0.1);\n    }\n  }\n  function buildRectPath(x, y, w, h, r) {\n    if (w < 2 * r)\n      r = w / 2;\n    if (h < 2 * r)\n      r = h / 2;\n    context.beginPath();\n    context.moveTo(x + r, y);\n    context.arcTo(x + w, y, x + w, y + h, r);\n    context.arcTo(x + w, y + h, x, y + h, r);\n    context.arcTo(x, y + h, x, y, r);\n    context.arcTo(x, y, x + w, y, r);\n    context.closePath();\n  }\n  function drawBorder(style, which, x, y, width, height) {\n    const borderWidth = style[which + \"Width\"];\n    const borderStyle = style[which + \"Style\"];\n    const borderColor = style[which + \"Color\"];\n    if (borderWidth !== \"0px\" && borderStyle !== \"none\" && borderColor !== \"transparent\" && borderColor !== \"rgba(0, 0, 0, 0)\") {\n      context.strokeStyle = borderColor;\n      context.lineWidth = parseFloat(borderWidth);\n      context.beginPath();\n      context.moveTo(x, y);\n      context.lineTo(x + width, y + height);\n      context.stroke();\n    }\n  }\n  function drawElement(element2, style) {\n    let x = 0, y = 0, width = 0, height = 0;\n    if (element2.nodeType === Node.TEXT_NODE) {\n      range.selectNode(element2);\n      const rect = range.getBoundingClientRect();\n      x = rect.left - offset.left - 0.5;\n      y = rect.top - offset.top - 0.5;\n      width = rect.width;\n      height = rect.height;\n      drawText(style, x, y, element2.nodeValue.trim());\n    } else if (element2.nodeType === Node.COMMENT_NODE) {\n      return;\n    } else if (element2 instanceof HTMLCanvasElement) {\n      if (element2.style.display === \"none\")\n        return;\n      context.save();\n      const dpr = window.devicePixelRatio;\n      context.scale(1 / dpr, 1 / dpr);\n      context.drawImage(element2, 0, 0);\n      context.restore();\n    } else {\n      if (element2.style.display === \"none\")\n        return;\n      const rect = element2.getBoundingClientRect();\n      x = rect.left - offset.left - 0.5;\n      y = rect.top - offset.top - 0.5;\n      width = rect.width;\n      height = rect.height;\n      style = window.getComputedStyle(element2);\n      buildRectPath(x, y, width, height, parseFloat(style.borderRadius));\n      const backgroundColor = style.backgroundColor;\n      if (backgroundColor !== \"transparent\" && backgroundColor !== \"rgba(0, 0, 0, 0)\") {\n        context.fillStyle = backgroundColor;\n        context.fill();\n      }\n      const borders = [\"borderTop\", \"borderLeft\", \"borderBottom\", \"borderRight\"];\n      let match = true;\n      let prevBorder = null;\n      for (const border of borders) {\n        if (prevBorder !== null) {\n          match = style[border + \"Width\"] === style[prevBorder + \"Width\"] && style[border + \"Color\"] === style[prevBorder + \"Color\"] && style[border + \"Style\"] === style[prevBorder + \"Style\"];\n        }\n        if (match === false)\n          break;\n        prevBorder = border;\n      }\n      if (match === true) {\n        const width2 = parseFloat(style.borderTopWidth);\n        if (style.borderTopWidth !== \"0px\" && style.borderTopStyle !== \"none\" && style.borderTopColor !== \"transparent\" && style.borderTopColor !== \"rgba(0, 0, 0, 0)\") {\n          context.strokeStyle = style.borderTopColor;\n          context.lineWidth = width2;\n          context.stroke();\n        }\n      } else {\n        drawBorder(style, \"borderTop\", x, y, width, 0);\n        drawBorder(style, \"borderLeft\", x, y, 0, height);\n        drawBorder(style, \"borderBottom\", x, y + height, width, 0);\n        drawBorder(style, \"borderRight\", x + width, y, 0, height);\n      }\n      if (element2 instanceof HTMLInputElement) {\n        let accentColor = style.accentColor;\n        if (accentColor === void 0 || accentColor === \"auto\")\n          accentColor = style.color;\n        color.set(accentColor);\n        const luminance = Math.sqrt(0.299 * color.r ** 2 + 0.587 * color.g ** 2 + 0.114 * color.b ** 2);\n        const accentTextColor = luminance < 0.5 ? \"white\" : \"#111111\";\n        if (element2.type === \"radio\") {\n          buildRectPath(x, y, width, height, height);\n          context.fillStyle = \"white\";\n          context.strokeStyle = accentColor;\n          context.lineWidth = 1;\n          context.fill();\n          context.stroke();\n          if (element2.checked) {\n            buildRectPath(x + 2, y + 2, width - 4, height - 4, height);\n            context.fillStyle = accentColor;\n            context.strokeStyle = accentTextColor;\n            context.lineWidth = 2;\n            context.fill();\n            context.stroke();\n          }\n        }\n        if (element2.type === \"checkbox\") {\n          buildRectPath(x, y, width, height, 2);\n          context.fillStyle = element2.checked ? accentColor : \"white\";\n          context.strokeStyle = element2.checked ? accentTextColor : accentColor;\n          context.lineWidth = 1;\n          context.stroke();\n          context.fill();\n          if (element2.checked) {\n            const currentTextAlign = context.textAlign;\n            context.textAlign = \"center\";\n            const properties = {\n              color: accentTextColor,\n              fontFamily: style.fontFamily,\n              fontSize: height + \"px\",\n              fontWeight: \"bold\"\n            };\n            drawText(properties, x + width / 2, y, \"✔\");\n            context.textAlign = currentTextAlign;\n          }\n        }\n        if (element2.type === \"range\") {\n          const [min, max, value] = [\"min\", \"max\", \"value\"].map((property) => parseFloat(element2[property]));\n          const position = (value - min) / (max - min) * (width - height);\n          buildRectPath(x, y + height / 4, width, height / 2, height / 4);\n          context.fillStyle = accentTextColor;\n          context.strokeStyle = accentColor;\n          context.lineWidth = 1;\n          context.fill();\n          context.stroke();\n          buildRectPath(x, y + height / 4, position + height / 2, height / 2, height / 4);\n          context.fillStyle = accentColor;\n          context.fill();\n          buildRectPath(x + position, y, height, height, height / 2);\n          context.fillStyle = accentColor;\n          context.fill();\n        }\n        if (element2.type === \"color\" || element2.type === \"text\" || element2.type === \"number\") {\n          clipper.add({ x, y, width, height });\n          drawText(style, x + parseInt(style.paddingLeft), y + parseInt(style.paddingTop), element2.value);\n          clipper.remove();\n        }\n      }\n    }\n    const isClipping = style.overflow === \"auto\" || style.overflow === \"hidden\";\n    if (isClipping)\n      clipper.add({ x, y, width, height });\n    for (let i = 0; i < element2.childNodes.length; i++) {\n      drawElement(element2.childNodes[i], style);\n    }\n    if (isClipping)\n      clipper.remove();\n  }\n  const offset = element.getBoundingClientRect();\n  let canvas = canvases.get(element);\n  if (canvas === void 0) {\n    canvas = document.createElement(\"canvas\");\n    canvas.width = offset.width;\n    canvas.height = offset.height;\n    canvases.set(element, canvas);\n  }\n  const context = canvas.getContext(\n    \"2d\"\n    /*, { alpha: false }*/\n  );\n  const clipper = new Clipper(context);\n  drawElement(element);\n  return canvas;\n}\nfunction htmlevent(element, event, x, y) {\n  const mouseEventInit = {\n    clientX: x * element.offsetWidth + element.offsetLeft,\n    clientY: y * element.offsetHeight + element.offsetTop,\n    view: element.ownerDocument.defaultView\n  };\n  window.dispatchEvent(new MouseEvent(event, mouseEventInit));\n  const rect = element.getBoundingClientRect();\n  x = x * rect.width + rect.left;\n  y = y * rect.height + rect.top;\n  function traverse(element2) {\n    if (element2.nodeType !== Node.TEXT_NODE && element2.nodeType !== Node.COMMENT_NODE) {\n      const rect2 = element2.getBoundingClientRect();\n      if (x > rect2.left && x < rect2.right && y > rect2.top && y < rect2.bottom) {\n        element2.dispatchEvent(new MouseEvent(event, mouseEventInit));\n        if (element2 instanceof HTMLInputElement && element2.type === \"range\" && (event === \"mousedown\" || event === \"click\")) {\n          const [min, max] = [\"min\", \"max\"].map((property) => parseFloat(element2[property]));\n          const width = rect2.width;\n          const offsetX = x - rect2.x;\n          const proportion = offsetX / width;\n          element2.value = min + (max - min) * proportion;\n          element2.dispatchEvent(new InputEvent(\"input\", { bubbles: true }));\n        }\n      }\n      for (let i = 0; i < element2.childNodes.length; i++) {\n        traverse(element2.childNodes[i]);\n      }\n    }\n  }\n  traverse(element);\n}\nexport {\n  HTMLMesh\n};\n"]},"metadata":{},"sourceType":"module"}