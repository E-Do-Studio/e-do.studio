{"ast":null,"code":"import _classCallCheck from \"/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { Mesh, MathUtils } from \"three\";\n\nvar MorphBlendMesh = /*#__PURE__*/function (_Mesh) {\n  _inherits(MorphBlendMesh, _Mesh);\n\n  var _super = _createSuper(MorphBlendMesh);\n\n  function MorphBlendMesh(geometry, material) {\n    var _this;\n\n    _classCallCheck(this, MorphBlendMesh);\n\n    _this = _super.call(this, geometry, material);\n    _this.animationsMap = {};\n    _this.animationsList = [];\n    var numFrames = Object.keys(_this.morphTargetDictionary).length;\n    var name = \"__default\";\n    var startFrame = 0;\n    var endFrame = numFrames - 1;\n    var fps = numFrames / 1;\n\n    _this.createAnimation(name, startFrame, endFrame, fps);\n\n    _this.setAnimationWeight(name, 1);\n\n    return _this;\n  }\n\n  _createClass(MorphBlendMesh, [{\n    key: \"createAnimation\",\n    value: function createAnimation(name, start, end, fps) {\n      var animation = {\n        start: start,\n        end: end,\n        length: end - start + 1,\n        fps: fps,\n        duration: (end - start) / fps,\n        lastFrame: 0,\n        currentFrame: 0,\n        active: false,\n        time: 0,\n        direction: 1,\n        weight: 1,\n        directionBackwards: false,\n        mirroredLoop: false\n      };\n      this.animationsMap[name] = animation;\n      this.animationsList.push(animation);\n    }\n  }, {\n    key: \"autoCreateAnimations\",\n    value: function autoCreateAnimations(fps) {\n      var pattern = /([a-z]+)_?(\\d+)/i;\n      var firstAnimation;\n      var frameRanges = {};\n      var i = 0;\n\n      for (var key in this.morphTargetDictionary) {\n        var chunks = key.match(pattern);\n\n        if (chunks && chunks.length > 1) {\n          var name = chunks[1];\n          if (!frameRanges[name]) frameRanges[name] = {\n            start: Infinity,\n            end: -Infinity\n          };\n          var range = frameRanges[name];\n          if (i < range.start) range.start = i;\n          if (i > range.end) range.end = i;\n          if (!firstAnimation) firstAnimation = name;\n        }\n\n        i++;\n      }\n\n      for (var _name in frameRanges) {\n        var _range = frameRanges[_name];\n        this.createAnimation(_name, _range.start, _range.end, fps);\n      }\n\n      this.firstAnimation = firstAnimation;\n    }\n  }, {\n    key: \"setAnimationDirectionForward\",\n    value: function setAnimationDirectionForward(name) {\n      var animation = this.animationsMap[name];\n\n      if (animation) {\n        animation.direction = 1;\n        animation.directionBackwards = false;\n      }\n    }\n  }, {\n    key: \"setAnimationDirectionBackward\",\n    value: function setAnimationDirectionBackward(name) {\n      var animation = this.animationsMap[name];\n\n      if (animation) {\n        animation.direction = -1;\n        animation.directionBackwards = true;\n      }\n    }\n  }, {\n    key: \"setAnimationFPS\",\n    value: function setAnimationFPS(name, fps) {\n      var animation = this.animationsMap[name];\n\n      if (animation) {\n        animation.fps = fps;\n        animation.duration = (animation.end - animation.start) / animation.fps;\n      }\n    }\n  }, {\n    key: \"setAnimationDuration\",\n    value: function setAnimationDuration(name, duration) {\n      var animation = this.animationsMap[name];\n\n      if (animation) {\n        animation.duration = duration;\n        animation.fps = (animation.end - animation.start) / animation.duration;\n      }\n    }\n  }, {\n    key: \"setAnimationWeight\",\n    value: function setAnimationWeight(name, weight) {\n      var animation = this.animationsMap[name];\n\n      if (animation) {\n        animation.weight = weight;\n      }\n    }\n  }, {\n    key: \"setAnimationTime\",\n    value: function setAnimationTime(name, time) {\n      var animation = this.animationsMap[name];\n\n      if (animation) {\n        animation.time = time;\n      }\n    }\n  }, {\n    key: \"getAnimationTime\",\n    value: function getAnimationTime(name) {\n      var time = 0;\n      var animation = this.animationsMap[name];\n\n      if (animation) {\n        time = animation.time;\n      }\n\n      return time;\n    }\n  }, {\n    key: \"getAnimationDuration\",\n    value: function getAnimationDuration(name) {\n      var duration = -1;\n      var animation = this.animationsMap[name];\n\n      if (animation) {\n        duration = animation.duration;\n      }\n\n      return duration;\n    }\n  }, {\n    key: \"playAnimation\",\n    value: function playAnimation(name) {\n      var animation = this.animationsMap[name];\n\n      if (animation) {\n        animation.time = 0;\n        animation.active = true;\n      } else {\n        console.warn(\"THREE.MorphBlendMesh: animation[\" + name + \"] undefined in .playAnimation()\");\n      }\n    }\n  }, {\n    key: \"stopAnimation\",\n    value: function stopAnimation(name) {\n      var animation = this.animationsMap[name];\n\n      if (animation) {\n        animation.active = false;\n      }\n    }\n  }, {\n    key: \"update\",\n    value: function update(delta) {\n      for (var i = 0, il = this.animationsList.length; i < il; i++) {\n        var animation = this.animationsList[i];\n        if (!animation.active) continue;\n        var frameTime = animation.duration / animation.length;\n        animation.time += animation.direction * delta;\n\n        if (animation.mirroredLoop) {\n          if (animation.time > animation.duration || animation.time < 0) {\n            animation.direction *= -1;\n\n            if (animation.time > animation.duration) {\n              animation.time = animation.duration;\n              animation.directionBackwards = true;\n            }\n\n            if (animation.time < 0) {\n              animation.time = 0;\n              animation.directionBackwards = false;\n            }\n          }\n        } else {\n          animation.time = animation.time % animation.duration;\n          if (animation.time < 0) animation.time += animation.duration;\n        }\n\n        var keyframe = animation.start + MathUtils.clamp(Math.floor(animation.time / frameTime), 0, animation.length - 1);\n        var weight = animation.weight;\n\n        if (keyframe !== animation.currentFrame) {\n          this.morphTargetInfluences[animation.lastFrame] = 0;\n          this.morphTargetInfluences[animation.currentFrame] = 1 * weight;\n          this.morphTargetInfluences[keyframe] = 0;\n          animation.lastFrame = animation.currentFrame;\n          animation.currentFrame = keyframe;\n        }\n\n        var mix = animation.time % frameTime / frameTime;\n        if (animation.directionBackwards) mix = 1 - mix;\n\n        if (animation.currentFrame !== animation.lastFrame) {\n          this.morphTargetInfluences[animation.currentFrame] = mix * weight;\n          this.morphTargetInfluences[animation.lastFrame] = (1 - mix) * weight;\n        } else {\n          this.morphTargetInfluences[animation.currentFrame] = weight;\n        }\n      }\n    }\n  }]);\n\n  return MorphBlendMesh;\n}(Mesh);\n\nexport { MorphBlendMesh };","map":{"version":3,"sources":["/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/three-stdlib/misc/MorphBlendMesh.js"],"names":["Mesh","MathUtils","MorphBlendMesh","geometry","material","animationsMap","animationsList","numFrames","Object","keys","morphTargetDictionary","length","name","startFrame","endFrame","fps","createAnimation","setAnimationWeight","start","end","animation","duration","lastFrame","currentFrame","active","time","direction","weight","directionBackwards","mirroredLoop","push","pattern","firstAnimation","frameRanges","i","key","chunks","match","Infinity","range","console","warn","delta","il","frameTime","keyframe","clamp","Math","floor","morphTargetInfluences","mix"],"mappings":"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","sourcesContent":["import { Mesh, MathUtils } from \"three\";\nclass MorphBlendMesh extends Mesh {\n  constructor(geometry, material) {\n    super(geometry, material);\n    this.animationsMap = {};\n    this.animationsList = [];\n    const numFrames = Object.keys(this.morphTargetDictionary).length;\n    const name = \"__default\";\n    const startFrame = 0;\n    const endFrame = numFrames - 1;\n    const fps = numFrames / 1;\n    this.createAnimation(name, startFrame, endFrame, fps);\n    this.setAnimationWeight(name, 1);\n  }\n  createAnimation(name, start, end, fps) {\n    const animation = {\n      start,\n      end,\n      length: end - start + 1,\n      fps,\n      duration: (end - start) / fps,\n      lastFrame: 0,\n      currentFrame: 0,\n      active: false,\n      time: 0,\n      direction: 1,\n      weight: 1,\n      directionBackwards: false,\n      mirroredLoop: false\n    };\n    this.animationsMap[name] = animation;\n    this.animationsList.push(animation);\n  }\n  autoCreateAnimations(fps) {\n    const pattern = /([a-z]+)_?(\\d+)/i;\n    let firstAnimation;\n    const frameRanges = {};\n    let i = 0;\n    for (const key in this.morphTargetDictionary) {\n      const chunks = key.match(pattern);\n      if (chunks && chunks.length > 1) {\n        const name = chunks[1];\n        if (!frameRanges[name])\n          frameRanges[name] = { start: Infinity, end: -Infinity };\n        const range = frameRanges[name];\n        if (i < range.start)\n          range.start = i;\n        if (i > range.end)\n          range.end = i;\n        if (!firstAnimation)\n          firstAnimation = name;\n      }\n      i++;\n    }\n    for (const name in frameRanges) {\n      const range = frameRanges[name];\n      this.createAnimation(name, range.start, range.end, fps);\n    }\n    this.firstAnimation = firstAnimation;\n  }\n  setAnimationDirectionForward(name) {\n    const animation = this.animationsMap[name];\n    if (animation) {\n      animation.direction = 1;\n      animation.directionBackwards = false;\n    }\n  }\n  setAnimationDirectionBackward(name) {\n    const animation = this.animationsMap[name];\n    if (animation) {\n      animation.direction = -1;\n      animation.directionBackwards = true;\n    }\n  }\n  setAnimationFPS(name, fps) {\n    const animation = this.animationsMap[name];\n    if (animation) {\n      animation.fps = fps;\n      animation.duration = (animation.end - animation.start) / animation.fps;\n    }\n  }\n  setAnimationDuration(name, duration) {\n    const animation = this.animationsMap[name];\n    if (animation) {\n      animation.duration = duration;\n      animation.fps = (animation.end - animation.start) / animation.duration;\n    }\n  }\n  setAnimationWeight(name, weight) {\n    const animation = this.animationsMap[name];\n    if (animation) {\n      animation.weight = weight;\n    }\n  }\n  setAnimationTime(name, time) {\n    const animation = this.animationsMap[name];\n    if (animation) {\n      animation.time = time;\n    }\n  }\n  getAnimationTime(name) {\n    let time = 0;\n    const animation = this.animationsMap[name];\n    if (animation) {\n      time = animation.time;\n    }\n    return time;\n  }\n  getAnimationDuration(name) {\n    let duration = -1;\n    const animation = this.animationsMap[name];\n    if (animation) {\n      duration = animation.duration;\n    }\n    return duration;\n  }\n  playAnimation(name) {\n    const animation = this.animationsMap[name];\n    if (animation) {\n      animation.time = 0;\n      animation.active = true;\n    } else {\n      console.warn(\"THREE.MorphBlendMesh: animation[\" + name + \"] undefined in .playAnimation()\");\n    }\n  }\n  stopAnimation(name) {\n    const animation = this.animationsMap[name];\n    if (animation) {\n      animation.active = false;\n    }\n  }\n  update(delta) {\n    for (let i = 0, il = this.animationsList.length; i < il; i++) {\n      const animation = this.animationsList[i];\n      if (!animation.active)\n        continue;\n      const frameTime = animation.duration / animation.length;\n      animation.time += animation.direction * delta;\n      if (animation.mirroredLoop) {\n        if (animation.time > animation.duration || animation.time < 0) {\n          animation.direction *= -1;\n          if (animation.time > animation.duration) {\n            animation.time = animation.duration;\n            animation.directionBackwards = true;\n          }\n          if (animation.time < 0) {\n            animation.time = 0;\n            animation.directionBackwards = false;\n          }\n        }\n      } else {\n        animation.time = animation.time % animation.duration;\n        if (animation.time < 0)\n          animation.time += animation.duration;\n      }\n      const keyframe = animation.start + MathUtils.clamp(Math.floor(animation.time / frameTime), 0, animation.length - 1);\n      const weight = animation.weight;\n      if (keyframe !== animation.currentFrame) {\n        this.morphTargetInfluences[animation.lastFrame] = 0;\n        this.morphTargetInfluences[animation.currentFrame] = 1 * weight;\n        this.morphTargetInfluences[keyframe] = 0;\n        animation.lastFrame = animation.currentFrame;\n        animation.currentFrame = keyframe;\n      }\n      let mix = animation.time % frameTime / frameTime;\n      if (animation.directionBackwards)\n        mix = 1 - mix;\n      if (animation.currentFrame !== animation.lastFrame) {\n        this.morphTargetInfluences[animation.currentFrame] = mix * weight;\n        this.morphTargetInfluences[animation.lastFrame] = (1 - mix) * weight;\n      } else {\n        this.morphTargetInfluences[animation.currentFrame] = weight;\n      }\n    }\n  }\n}\nexport {\n  MorphBlendMesh\n};\n"]},"metadata":{},"sourceType":"module"}