{"ast":null,"code":"import { Quaternion, Vector3, Matrix4, Object3D, SphereGeometry, MeshBasicMaterial, Color, LineBasicMaterial, BufferGeometry, BufferAttribute, Mesh, Line } from \"three\";\n\nconst _q = /* @__PURE__ */new Quaternion();\n\nconst _targetPos = /* @__PURE__ */new Vector3();\n\nconst _targetVec = /* @__PURE__ */new Vector3();\n\nconst _effectorPos = /* @__PURE__ */new Vector3();\n\nconst _effectorVec = /* @__PURE__ */new Vector3();\n\nconst _linkPos = /* @__PURE__ */new Vector3();\n\nconst _invLinkQ = /* @__PURE__ */new Quaternion();\n\nconst _linkScale = /* @__PURE__ */new Vector3();\n\nconst _axis = /* @__PURE__ */new Vector3();\n\nconst _vector = /* @__PURE__ */new Vector3();\n\nconst _matrix = /* @__PURE__ */new Matrix4();\n\nclass CCDIKSolver {\n  /**\n   * @param {THREE.SkinnedMesh} mesh\n   * @param {Array<Object>} iks\n   */\n  constructor(mesh, iks = []) {\n    this.mesh = mesh;\n    this.iks = iks;\n\n    this._valid();\n  }\n  /**\n   * Update all IK bones.\n   *\n   * @return {CCDIKSolver}\n   */\n\n\n  update() {\n    const iks = this.iks;\n\n    for (let i = 0, il = iks.length; i < il; i++) {\n      this.updateOne(iks[i]);\n    }\n\n    return this;\n  }\n  /**\n   * Update one IK bone\n   *\n   * @param {Object} ik parameter\n   * @return {CCDIKSolver}\n   */\n\n\n  updateOne(ik) {\n    const bones = this.mesh.skeleton.bones;\n    const math = Math;\n    const effector = bones[ik.effector];\n    const target = bones[ik.target];\n\n    _targetPos.setFromMatrixPosition(target.matrixWorld);\n\n    const links = ik.links;\n    const iteration = ik.iteration !== void 0 ? ik.iteration : 1;\n\n    for (let i = 0; i < iteration; i++) {\n      let rotated = false;\n\n      for (let j = 0, jl = links.length; j < jl; j++) {\n        const link = bones[links[j].index];\n        if (links[j].enabled === false) break;\n        const limitation = links[j].limitation;\n        const rotationMin = links[j].rotationMin;\n        const rotationMax = links[j].rotationMax;\n        link.matrixWorld.decompose(_linkPos, _invLinkQ, _linkScale);\n\n        _invLinkQ.invert();\n\n        _effectorPos.setFromMatrixPosition(effector.matrixWorld);\n\n        _effectorVec.subVectors(_effectorPos, _linkPos);\n\n        _effectorVec.applyQuaternion(_invLinkQ);\n\n        _effectorVec.normalize();\n\n        _targetVec.subVectors(_targetPos, _linkPos);\n\n        _targetVec.applyQuaternion(_invLinkQ);\n\n        _targetVec.normalize();\n\n        let angle = _targetVec.dot(_effectorVec);\n\n        if (angle > 1) {\n          angle = 1;\n        } else if (angle < -1) {\n          angle = -1;\n        }\n\n        angle = math.acos(angle);\n        if (angle < 1e-5) continue;\n\n        if (ik.minAngle !== void 0 && angle < ik.minAngle) {\n          angle = ik.minAngle;\n        }\n\n        if (ik.maxAngle !== void 0 && angle > ik.maxAngle) {\n          angle = ik.maxAngle;\n        }\n\n        _axis.crossVectors(_effectorVec, _targetVec);\n\n        _axis.normalize();\n\n        _q.setFromAxisAngle(_axis, angle);\n\n        link.quaternion.multiply(_q);\n\n        if (limitation !== void 0) {\n          let c = link.quaternion.w;\n          if (c > 1) c = 1;\n          const c2 = math.sqrt(1 - c * c);\n          link.quaternion.set(limitation.x * c2, limitation.y * c2, limitation.z * c2, c);\n        }\n\n        if (rotationMin !== void 0) {\n          link.rotation.setFromVector3(_vector.setFromEuler(link.rotation).max(rotationMin));\n        }\n\n        if (rotationMax !== void 0) {\n          link.rotation.setFromVector3(_vector.setFromEuler(link.rotation).min(rotationMax));\n        }\n\n        link.updateMatrixWorld(true);\n        rotated = true;\n      }\n\n      if (!rotated) break;\n    }\n\n    return this;\n  }\n  /**\n   * Creates Helper\n   *\n   * @return {CCDIKHelper}\n   */\n\n\n  createHelper() {\n    return new CCDIKHelper(this.mesh, this.iks);\n  } // private methods\n\n\n  _valid() {\n    const iks = this.iks;\n    const bones = this.mesh.skeleton.bones;\n\n    for (let i = 0, il = iks.length; i < il; i++) {\n      const ik = iks[i];\n      const effector = bones[ik.effector];\n      const links = ik.links;\n      let link0, link1;\n      link0 = effector;\n\n      for (let j = 0, jl = links.length; j < jl; j++) {\n        link1 = bones[links[j].index];\n\n        if (link0.parent !== link1) {\n          console.warn(\"THREE.CCDIKSolver: bone \" + link0.name + \" is not the child of bone \" + link1.name);\n        }\n\n        link0 = link1;\n      }\n    }\n  }\n\n}\n\nfunction getPosition(bone, matrixWorldInv) {\n  return _vector.setFromMatrixPosition(bone.matrixWorld).applyMatrix4(matrixWorldInv);\n}\n\nfunction setPositionOfBoneToAttributeArray(array, index, bone, matrixWorldInv) {\n  const v = getPosition(bone, matrixWorldInv);\n  array[index * 3 + 0] = v.x;\n  array[index * 3 + 1] = v.y;\n  array[index * 3 + 2] = v.z;\n}\n\nclass CCDIKHelper extends Object3D {\n  constructor(mesh, iks = [], sphereSize = 0.25) {\n    super();\n    this.root = mesh;\n    this.iks = iks;\n    this.matrix.copy(mesh.matrixWorld);\n    this.matrixAutoUpdate = false;\n    this.sphereGeometry = new SphereGeometry(sphereSize, 16, 8);\n    this.targetSphereMaterial = new MeshBasicMaterial({\n      color: new Color(16746632),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    this.effectorSphereMaterial = new MeshBasicMaterial({\n      color: new Color(8978312),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    this.linkSphereMaterial = new MeshBasicMaterial({\n      color: new Color(8947967),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    this.lineMaterial = new LineBasicMaterial({\n      color: new Color(16711680),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n\n    this._init();\n  }\n  /**\n   * Updates IK bones visualization.\n   */\n\n\n  updateMatrixWorld(force) {\n    const mesh = this.root;\n\n    if (this.visible) {\n      let offset = 0;\n      const iks = this.iks;\n      const bones = mesh.skeleton.bones;\n\n      _matrix.copy(mesh.matrixWorld).invert();\n\n      for (let i = 0, il = iks.length; i < il; i++) {\n        const ik = iks[i];\n        const targetBone = bones[ik.target];\n        const effectorBone = bones[ik.effector];\n        const targetMesh = this.children[offset++];\n        const effectorMesh = this.children[offset++];\n        targetMesh.position.copy(getPosition(targetBone, _matrix));\n        effectorMesh.position.copy(getPosition(effectorBone, _matrix));\n\n        for (let j = 0, jl = ik.links.length; j < jl; j++) {\n          const link = ik.links[j];\n          const linkBone = bones[link.index];\n          const linkMesh = this.children[offset++];\n          linkMesh.position.copy(getPosition(linkBone, _matrix));\n        }\n\n        const line = this.children[offset++];\n        const array = line.geometry.attributes.position.array;\n        setPositionOfBoneToAttributeArray(array, 0, targetBone, _matrix);\n        setPositionOfBoneToAttributeArray(array, 1, effectorBone, _matrix);\n\n        for (let j = 0, jl = ik.links.length; j < jl; j++) {\n          const link = ik.links[j];\n          const linkBone = bones[link.index];\n          setPositionOfBoneToAttributeArray(array, j + 2, linkBone, _matrix);\n        }\n\n        line.geometry.attributes.position.needsUpdate = true;\n      }\n    }\n\n    this.matrix.copy(mesh.matrixWorld);\n    super.updateMatrixWorld(force);\n  }\n  /**\n   * Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app.\n   */\n\n\n  dispose() {\n    this.sphereGeometry.dispose();\n    this.targetSphereMaterial.dispose();\n    this.effectorSphereMaterial.dispose();\n    this.linkSphereMaterial.dispose();\n    this.lineMaterial.dispose();\n    const children = this.children;\n\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      if (child.isLine) child.geometry.dispose();\n    }\n  } // private method\n\n\n  _init() {\n    const scope = this;\n    const iks = this.iks;\n\n    function createLineGeometry(ik) {\n      const geometry = new BufferGeometry();\n      const vertices = new Float32Array((2 + ik.links.length) * 3);\n      geometry.setAttribute(\"position\", new BufferAttribute(vertices, 3));\n      return geometry;\n    }\n\n    function createTargetMesh() {\n      return new Mesh(scope.sphereGeometry, scope.targetSphereMaterial);\n    }\n\n    function createEffectorMesh() {\n      return new Mesh(scope.sphereGeometry, scope.effectorSphereMaterial);\n    }\n\n    function createLinkMesh() {\n      return new Mesh(scope.sphereGeometry, scope.linkSphereMaterial);\n    }\n\n    function createLine(ik) {\n      return new Line(createLineGeometry(ik), scope.lineMaterial);\n    }\n\n    for (let i = 0, il = iks.length; i < il; i++) {\n      const ik = iks[i];\n      this.add(createTargetMesh());\n      this.add(createEffectorMesh());\n\n      for (let j = 0, jl = ik.links.length; j < jl; j++) {\n        this.add(createLinkMesh());\n      }\n\n      this.add(createLine(ik));\n    }\n  }\n\n}\n\nexport { CCDIKHelper, CCDIKSolver };","map":{"version":3,"sources":["/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/three-stdlib/animation/CCDIKSolver.js"],"names":["Quaternion","Vector3","Matrix4","Object3D","SphereGeometry","MeshBasicMaterial","Color","LineBasicMaterial","BufferGeometry","BufferAttribute","Mesh","Line","_q","_targetPos","_targetVec","_effectorPos","_effectorVec","_linkPos","_invLinkQ","_linkScale","_axis","_vector","_matrix","CCDIKSolver","constructor","mesh","iks","_valid","update","i","il","length","updateOne","ik","bones","skeleton","math","Math","effector","target","setFromMatrixPosition","matrixWorld","links","iteration","rotated","j","jl","link","index","enabled","limitation","rotationMin","rotationMax","decompose","invert","subVectors","applyQuaternion","normalize","angle","dot","acos","minAngle","maxAngle","crossVectors","setFromAxisAngle","quaternion","multiply","c","w","c2","sqrt","set","x","y","z","rotation","setFromVector3","setFromEuler","max","min","updateMatrixWorld","createHelper","CCDIKHelper","link0","link1","parent","console","warn","name","getPosition","bone","matrixWorldInv","applyMatrix4","setPositionOfBoneToAttributeArray","array","v","sphereSize","root","matrix","copy","matrixAutoUpdate","sphereGeometry","targetSphereMaterial","color","depthTest","depthWrite","transparent","effectorSphereMaterial","linkSphereMaterial","lineMaterial","_init","force","visible","offset","targetBone","effectorBone","targetMesh","children","effectorMesh","position","linkBone","linkMesh","line","geometry","attributes","needsUpdate","dispose","child","isLine","scope","createLineGeometry","vertices","Float32Array","setAttribute","createTargetMesh","createEffectorMesh","createLinkMesh","createLine","add"],"mappings":"AAAA,SAASA,UAAT,EAAqBC,OAArB,EAA8BC,OAA9B,EAAuCC,QAAvC,EAAiDC,cAAjD,EAAiEC,iBAAjE,EAAoFC,KAApF,EAA2FC,iBAA3F,EAA8GC,cAA9G,EAA8HC,eAA9H,EAA+IC,IAA/I,EAAqJC,IAArJ,QAAiK,OAAjK;;AACA,MAAMC,EAAE,GAAG,eAAgB,IAAIZ,UAAJ,EAA3B;;AACA,MAAMa,UAAU,GAAG,eAAgB,IAAIZ,OAAJ,EAAnC;;AACA,MAAMa,UAAU,GAAG,eAAgB,IAAIb,OAAJ,EAAnC;;AACA,MAAMc,YAAY,GAAG,eAAgB,IAAId,OAAJ,EAArC;;AACA,MAAMe,YAAY,GAAG,eAAgB,IAAIf,OAAJ,EAArC;;AACA,MAAMgB,QAAQ,GAAG,eAAgB,IAAIhB,OAAJ,EAAjC;;AACA,MAAMiB,SAAS,GAAG,eAAgB,IAAIlB,UAAJ,EAAlC;;AACA,MAAMmB,UAAU,GAAG,eAAgB,IAAIlB,OAAJ,EAAnC;;AACA,MAAMmB,KAAK,GAAG,eAAgB,IAAInB,OAAJ,EAA9B;;AACA,MAAMoB,OAAO,GAAG,eAAgB,IAAIpB,OAAJ,EAAhC;;AACA,MAAMqB,OAAO,GAAG,eAAgB,IAAIpB,OAAJ,EAAhC;;AACA,MAAMqB,WAAN,CAAkB;AAChB;AACF;AACA;AACA;AACEC,EAAAA,WAAW,CAACC,IAAD,EAAOC,GAAG,GAAG,EAAb,EAAiB;AAC1B,SAAKD,IAAL,GAAYA,IAAZ;AACA,SAAKC,GAAL,GAAWA,GAAX;;AACA,SAAKC,MAAL;AACD;AACD;AACF;AACA;AACA;AACA;;;AACEC,EAAAA,MAAM,GAAG;AACP,UAAMF,GAAG,GAAG,KAAKA,GAAjB;;AACA,SAAK,IAAIG,CAAC,GAAG,CAAR,EAAWC,EAAE,GAAGJ,GAAG,CAACK,MAAzB,EAAiCF,CAAC,GAAGC,EAArC,EAAyCD,CAAC,EAA1C,EAA8C;AAC5C,WAAKG,SAAL,CAAeN,GAAG,CAACG,CAAD,CAAlB;AACD;;AACD,WAAO,IAAP;AACD;AACD;AACF;AACA;AACA;AACA;AACA;;;AACEG,EAAAA,SAAS,CAACC,EAAD,EAAK;AACZ,UAAMC,KAAK,GAAG,KAAKT,IAAL,CAAUU,QAAV,CAAmBD,KAAjC;AACA,UAAME,IAAI,GAAGC,IAAb;AACA,UAAMC,QAAQ,GAAGJ,KAAK,CAACD,EAAE,CAACK,QAAJ,CAAtB;AACA,UAAMC,MAAM,GAAGL,KAAK,CAACD,EAAE,CAACM,MAAJ,CAApB;;AACA1B,IAAAA,UAAU,CAAC2B,qBAAX,CAAiCD,MAAM,CAACE,WAAxC;;AACA,UAAMC,KAAK,GAAGT,EAAE,CAACS,KAAjB;AACA,UAAMC,SAAS,GAAGV,EAAE,CAACU,SAAH,KAAiB,KAAK,CAAtB,GAA0BV,EAAE,CAACU,SAA7B,GAAyC,CAA3D;;AACA,SAAK,IAAId,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGc,SAApB,EAA+Bd,CAAC,EAAhC,EAAoC;AAClC,UAAIe,OAAO,GAAG,KAAd;;AACA,WAAK,IAAIC,CAAC,GAAG,CAAR,EAAWC,EAAE,GAAGJ,KAAK,CAACX,MAA3B,EAAmCc,CAAC,GAAGC,EAAvC,EAA2CD,CAAC,EAA5C,EAAgD;AAC9C,cAAME,IAAI,GAAGb,KAAK,CAACQ,KAAK,CAACG,CAAD,CAAL,CAASG,KAAV,CAAlB;AACA,YAAIN,KAAK,CAACG,CAAD,CAAL,CAASI,OAAT,KAAqB,KAAzB,EACE;AACF,cAAMC,UAAU,GAAGR,KAAK,CAACG,CAAD,CAAL,CAASK,UAA5B;AACA,cAAMC,WAAW,GAAGT,KAAK,CAACG,CAAD,CAAL,CAASM,WAA7B;AACA,cAAMC,WAAW,GAAGV,KAAK,CAACG,CAAD,CAAL,CAASO,WAA7B;AACAL,QAAAA,IAAI,CAACN,WAAL,CAAiBY,SAAjB,CAA2BpC,QAA3B,EAAqCC,SAArC,EAAgDC,UAAhD;;AACAD,QAAAA,SAAS,CAACoC,MAAV;;AACAvC,QAAAA,YAAY,CAACyB,qBAAb,CAAmCF,QAAQ,CAACG,WAA5C;;AACAzB,QAAAA,YAAY,CAACuC,UAAb,CAAwBxC,YAAxB,EAAsCE,QAAtC;;AACAD,QAAAA,YAAY,CAACwC,eAAb,CAA6BtC,SAA7B;;AACAF,QAAAA,YAAY,CAACyC,SAAb;;AACA3C,QAAAA,UAAU,CAACyC,UAAX,CAAsB1C,UAAtB,EAAkCI,QAAlC;;AACAH,QAAAA,UAAU,CAAC0C,eAAX,CAA2BtC,SAA3B;;AACAJ,QAAAA,UAAU,CAAC2C,SAAX;;AACA,YAAIC,KAAK,GAAG5C,UAAU,CAAC6C,GAAX,CAAe3C,YAAf,CAAZ;;AACA,YAAI0C,KAAK,GAAG,CAAZ,EAAe;AACbA,UAAAA,KAAK,GAAG,CAAR;AACD,SAFD,MAEO,IAAIA,KAAK,GAAG,CAAC,CAAb,EAAgB;AACrBA,UAAAA,KAAK,GAAG,CAAC,CAAT;AACD;;AACDA,QAAAA,KAAK,GAAGtB,IAAI,CAACwB,IAAL,CAAUF,KAAV,CAAR;AACA,YAAIA,KAAK,GAAG,IAAZ,EACE;;AACF,YAAIzB,EAAE,CAAC4B,QAAH,KAAgB,KAAK,CAArB,IAA0BH,KAAK,GAAGzB,EAAE,CAAC4B,QAAzC,EAAmD;AACjDH,UAAAA,KAAK,GAAGzB,EAAE,CAAC4B,QAAX;AACD;;AACD,YAAI5B,EAAE,CAAC6B,QAAH,KAAgB,KAAK,CAArB,IAA0BJ,KAAK,GAAGzB,EAAE,CAAC6B,QAAzC,EAAmD;AACjDJ,UAAAA,KAAK,GAAGzB,EAAE,CAAC6B,QAAX;AACD;;AACD1C,QAAAA,KAAK,CAAC2C,YAAN,CAAmB/C,YAAnB,EAAiCF,UAAjC;;AACAM,QAAAA,KAAK,CAACqC,SAAN;;AACA7C,QAAAA,EAAE,CAACoD,gBAAH,CAAoB5C,KAApB,EAA2BsC,KAA3B;;AACAX,QAAAA,IAAI,CAACkB,UAAL,CAAgBC,QAAhB,CAAyBtD,EAAzB;;AACA,YAAIsC,UAAU,KAAK,KAAK,CAAxB,EAA2B;AACzB,cAAIiB,CAAC,GAAGpB,IAAI,CAACkB,UAAL,CAAgBG,CAAxB;AACA,cAAID,CAAC,GAAG,CAAR,EACEA,CAAC,GAAG,CAAJ;AACF,gBAAME,EAAE,GAAGjC,IAAI,CAACkC,IAAL,CAAU,IAAIH,CAAC,GAAGA,CAAlB,CAAX;AACApB,UAAAA,IAAI,CAACkB,UAAL,CAAgBM,GAAhB,CAAoBrB,UAAU,CAACsB,CAAX,GAAeH,EAAnC,EAAuCnB,UAAU,CAACuB,CAAX,GAAeJ,EAAtD,EAA0DnB,UAAU,CAACwB,CAAX,GAAeL,EAAzE,EAA6EF,CAA7E;AACD;;AACD,YAAIhB,WAAW,KAAK,KAAK,CAAzB,EAA4B;AAC1BJ,UAAAA,IAAI,CAAC4B,QAAL,CAAcC,cAAd,CAA6BvD,OAAO,CAACwD,YAAR,CAAqB9B,IAAI,CAAC4B,QAA1B,EAAoCG,GAApC,CAAwC3B,WAAxC,CAA7B;AACD;;AACD,YAAIC,WAAW,KAAK,KAAK,CAAzB,EAA4B;AAC1BL,UAAAA,IAAI,CAAC4B,QAAL,CAAcC,cAAd,CAA6BvD,OAAO,CAACwD,YAAR,CAAqB9B,IAAI,CAAC4B,QAA1B,EAAoCI,GAApC,CAAwC3B,WAAxC,CAA7B;AACD;;AACDL,QAAAA,IAAI,CAACiC,iBAAL,CAAuB,IAAvB;AACApC,QAAAA,OAAO,GAAG,IAAV;AACD;;AACD,UAAI,CAACA,OAAL,EACE;AACH;;AACD,WAAO,IAAP;AACD;AACD;AACF;AACA;AACA;AACA;;;AACEqC,EAAAA,YAAY,GAAG;AACb,WAAO,IAAIC,WAAJ,CAAgB,KAAKzD,IAArB,EAA2B,KAAKC,GAAhC,CAAP;AACD,GArGe,CAsGhB;;;AACAC,EAAAA,MAAM,GAAG;AACP,UAAMD,GAAG,GAAG,KAAKA,GAAjB;AACA,UAAMQ,KAAK,GAAG,KAAKT,IAAL,CAAUU,QAAV,CAAmBD,KAAjC;;AACA,SAAK,IAAIL,CAAC,GAAG,CAAR,EAAWC,EAAE,GAAGJ,GAAG,CAACK,MAAzB,EAAiCF,CAAC,GAAGC,EAArC,EAAyCD,CAAC,EAA1C,EAA8C;AAC5C,YAAMI,EAAE,GAAGP,GAAG,CAACG,CAAD,CAAd;AACA,YAAMS,QAAQ,GAAGJ,KAAK,CAACD,EAAE,CAACK,QAAJ,CAAtB;AACA,YAAMI,KAAK,GAAGT,EAAE,CAACS,KAAjB;AACA,UAAIyC,KAAJ,EAAWC,KAAX;AACAD,MAAAA,KAAK,GAAG7C,QAAR;;AACA,WAAK,IAAIO,CAAC,GAAG,CAAR,EAAWC,EAAE,GAAGJ,KAAK,CAACX,MAA3B,EAAmCc,CAAC,GAAGC,EAAvC,EAA2CD,CAAC,EAA5C,EAAgD;AAC9CuC,QAAAA,KAAK,GAAGlD,KAAK,CAACQ,KAAK,CAACG,CAAD,CAAL,CAASG,KAAV,CAAb;;AACA,YAAImC,KAAK,CAACE,MAAN,KAAiBD,KAArB,EAA4B;AAC1BE,UAAAA,OAAO,CAACC,IAAR,CAAa,6BAA6BJ,KAAK,CAACK,IAAnC,GAA0C,4BAA1C,GAAyEJ,KAAK,CAACI,IAA5F;AACD;;AACDL,QAAAA,KAAK,GAAGC,KAAR;AACD;AACF;AACF;;AAxHe;;AA0HlB,SAASK,WAAT,CAAqBC,IAArB,EAA2BC,cAA3B,EAA2C;AACzC,SAAOtE,OAAO,CAACmB,qBAAR,CAA8BkD,IAAI,CAACjD,WAAnC,EAAgDmD,YAAhD,CAA6DD,cAA7D,CAAP;AACD;;AACD,SAASE,iCAAT,CAA2CC,KAA3C,EAAkD9C,KAAlD,EAAyD0C,IAAzD,EAA+DC,cAA/D,EAA+E;AAC7E,QAAMI,CAAC,GAAGN,WAAW,CAACC,IAAD,EAAOC,cAAP,CAArB;AACAG,EAAAA,KAAK,CAAC9C,KAAK,GAAG,CAAR,GAAY,CAAb,CAAL,GAAuB+C,CAAC,CAACvB,CAAzB;AACAsB,EAAAA,KAAK,CAAC9C,KAAK,GAAG,CAAR,GAAY,CAAb,CAAL,GAAuB+C,CAAC,CAACtB,CAAzB;AACAqB,EAAAA,KAAK,CAAC9C,KAAK,GAAG,CAAR,GAAY,CAAb,CAAL,GAAuB+C,CAAC,CAACrB,CAAzB;AACD;;AACD,MAAMQ,WAAN,SAA0B/E,QAA1B,CAAmC;AACjCqB,EAAAA,WAAW,CAACC,IAAD,EAAOC,GAAG,GAAG,EAAb,EAAiBsE,UAAU,GAAG,IAA9B,EAAoC;AAC7C;AACA,SAAKC,IAAL,GAAYxE,IAAZ;AACA,SAAKC,GAAL,GAAWA,GAAX;AACA,SAAKwE,MAAL,CAAYC,IAAZ,CAAiB1E,IAAI,CAACgB,WAAtB;AACA,SAAK2D,gBAAL,GAAwB,KAAxB;AACA,SAAKC,cAAL,GAAsB,IAAIjG,cAAJ,CAAmB4F,UAAnB,EAA+B,EAA/B,EAAmC,CAAnC,CAAtB;AACA,SAAKM,oBAAL,GAA4B,IAAIjG,iBAAJ,CAAsB;AAChDkG,MAAAA,KAAK,EAAE,IAAIjG,KAAJ,CAAU,QAAV,CADyC;AAEhDkG,MAAAA,SAAS,EAAE,KAFqC;AAGhDC,MAAAA,UAAU,EAAE,KAHoC;AAIhDC,MAAAA,WAAW,EAAE;AAJmC,KAAtB,CAA5B;AAMA,SAAKC,sBAAL,GAA8B,IAAItG,iBAAJ,CAAsB;AAClDkG,MAAAA,KAAK,EAAE,IAAIjG,KAAJ,CAAU,OAAV,CAD2C;AAElDkG,MAAAA,SAAS,EAAE,KAFuC;AAGlDC,MAAAA,UAAU,EAAE,KAHsC;AAIlDC,MAAAA,WAAW,EAAE;AAJqC,KAAtB,CAA9B;AAMA,SAAKE,kBAAL,GAA0B,IAAIvG,iBAAJ,CAAsB;AAC9CkG,MAAAA,KAAK,EAAE,IAAIjG,KAAJ,CAAU,OAAV,CADuC;AAE9CkG,MAAAA,SAAS,EAAE,KAFmC;AAG9CC,MAAAA,UAAU,EAAE,KAHkC;AAI9CC,MAAAA,WAAW,EAAE;AAJiC,KAAtB,CAA1B;AAMA,SAAKG,YAAL,GAAoB,IAAItG,iBAAJ,CAAsB;AACxCgG,MAAAA,KAAK,EAAE,IAAIjG,KAAJ,CAAU,QAAV,CADiC;AAExCkG,MAAAA,SAAS,EAAE,KAF6B;AAGxCC,MAAAA,UAAU,EAAE,KAH4B;AAIxCC,MAAAA,WAAW,EAAE;AAJ2B,KAAtB,CAApB;;AAMA,SAAKI,KAAL;AACD;AACD;AACF;AACA;;;AACE9B,EAAAA,iBAAiB,CAAC+B,KAAD,EAAQ;AACvB,UAAMtF,IAAI,GAAG,KAAKwE,IAAlB;;AACA,QAAI,KAAKe,OAAT,EAAkB;AAChB,UAAIC,MAAM,GAAG,CAAb;AACA,YAAMvF,GAAG,GAAG,KAAKA,GAAjB;AACA,YAAMQ,KAAK,GAAGT,IAAI,CAACU,QAAL,CAAcD,KAA5B;;AACAZ,MAAAA,OAAO,CAAC6E,IAAR,CAAa1E,IAAI,CAACgB,WAAlB,EAA+Ba,MAA/B;;AACA,WAAK,IAAIzB,CAAC,GAAG,CAAR,EAAWC,EAAE,GAAGJ,GAAG,CAACK,MAAzB,EAAiCF,CAAC,GAAGC,EAArC,EAAyCD,CAAC,EAA1C,EAA8C;AAC5C,cAAMI,EAAE,GAAGP,GAAG,CAACG,CAAD,CAAd;AACA,cAAMqF,UAAU,GAAGhF,KAAK,CAACD,EAAE,CAACM,MAAJ,CAAxB;AACA,cAAM4E,YAAY,GAAGjF,KAAK,CAACD,EAAE,CAACK,QAAJ,CAA1B;AACA,cAAM8E,UAAU,GAAG,KAAKC,QAAL,CAAcJ,MAAM,EAApB,CAAnB;AACA,cAAMK,YAAY,GAAG,KAAKD,QAAL,CAAcJ,MAAM,EAApB,CAArB;AACAG,QAAAA,UAAU,CAACG,QAAX,CAAoBpB,IAApB,CAAyBV,WAAW,CAACyB,UAAD,EAAa5F,OAAb,CAApC;AACAgG,QAAAA,YAAY,CAACC,QAAb,CAAsBpB,IAAtB,CAA2BV,WAAW,CAAC0B,YAAD,EAAe7F,OAAf,CAAtC;;AACA,aAAK,IAAIuB,CAAC,GAAG,CAAR,EAAWC,EAAE,GAAGb,EAAE,CAACS,KAAH,CAASX,MAA9B,EAAsCc,CAAC,GAAGC,EAA1C,EAA8CD,CAAC,EAA/C,EAAmD;AACjD,gBAAME,IAAI,GAAGd,EAAE,CAACS,KAAH,CAASG,CAAT,CAAb;AACA,gBAAM2E,QAAQ,GAAGtF,KAAK,CAACa,IAAI,CAACC,KAAN,CAAtB;AACA,gBAAMyE,QAAQ,GAAG,KAAKJ,QAAL,CAAcJ,MAAM,EAApB,CAAjB;AACAQ,UAAAA,QAAQ,CAACF,QAAT,CAAkBpB,IAAlB,CAAuBV,WAAW,CAAC+B,QAAD,EAAWlG,OAAX,CAAlC;AACD;;AACD,cAAMoG,IAAI,GAAG,KAAKL,QAAL,CAAcJ,MAAM,EAApB,CAAb;AACA,cAAMnB,KAAK,GAAG4B,IAAI,CAACC,QAAL,CAAcC,UAAd,CAAyBL,QAAzB,CAAkCzB,KAAhD;AACAD,QAAAA,iCAAiC,CAACC,KAAD,EAAQ,CAAR,EAAWoB,UAAX,EAAuB5F,OAAvB,CAAjC;AACAuE,QAAAA,iCAAiC,CAACC,KAAD,EAAQ,CAAR,EAAWqB,YAAX,EAAyB7F,OAAzB,CAAjC;;AACA,aAAK,IAAIuB,CAAC,GAAG,CAAR,EAAWC,EAAE,GAAGb,EAAE,CAACS,KAAH,CAASX,MAA9B,EAAsCc,CAAC,GAAGC,EAA1C,EAA8CD,CAAC,EAA/C,EAAmD;AACjD,gBAAME,IAAI,GAAGd,EAAE,CAACS,KAAH,CAASG,CAAT,CAAb;AACA,gBAAM2E,QAAQ,GAAGtF,KAAK,CAACa,IAAI,CAACC,KAAN,CAAtB;AACA6C,UAAAA,iCAAiC,CAACC,KAAD,EAAQjD,CAAC,GAAG,CAAZ,EAAe2E,QAAf,EAAyBlG,OAAzB,CAAjC;AACD;;AACDoG,QAAAA,IAAI,CAACC,QAAL,CAAcC,UAAd,CAAyBL,QAAzB,CAAkCM,WAAlC,GAAgD,IAAhD;AACD;AACF;;AACD,SAAK3B,MAAL,CAAYC,IAAZ,CAAiB1E,IAAI,CAACgB,WAAtB;AACA,UAAMuC,iBAAN,CAAwB+B,KAAxB;AACD;AACD;AACF;AACA;;;AACEe,EAAAA,OAAO,GAAG;AACR,SAAKzB,cAAL,CAAoByB,OAApB;AACA,SAAKxB,oBAAL,CAA0BwB,OAA1B;AACA,SAAKnB,sBAAL,CAA4BmB,OAA5B;AACA,SAAKlB,kBAAL,CAAwBkB,OAAxB;AACA,SAAKjB,YAAL,CAAkBiB,OAAlB;AACA,UAAMT,QAAQ,GAAG,KAAKA,QAAtB;;AACA,SAAK,IAAIxF,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGwF,QAAQ,CAACtF,MAA7B,EAAqCF,CAAC,EAAtC,EAA0C;AACxC,YAAMkG,KAAK,GAAGV,QAAQ,CAACxF,CAAD,CAAtB;AACA,UAAIkG,KAAK,CAACC,MAAV,EACED,KAAK,CAACJ,QAAN,CAAeG,OAAf;AACH;AACF,GAxFgC,CAyFjC;;;AACAhB,EAAAA,KAAK,GAAG;AACN,UAAMmB,KAAK,GAAG,IAAd;AACA,UAAMvG,GAAG,GAAG,KAAKA,GAAjB;;AACA,aAASwG,kBAAT,CAA4BjG,EAA5B,EAAgC;AAC9B,YAAM0F,QAAQ,GAAG,IAAInH,cAAJ,EAAjB;AACA,YAAM2H,QAAQ,GAAG,IAAIC,YAAJ,CAAiB,CAAC,IAAInG,EAAE,CAACS,KAAH,CAASX,MAAd,IAAwB,CAAzC,CAAjB;AACA4F,MAAAA,QAAQ,CAACU,YAAT,CAAsB,UAAtB,EAAkC,IAAI5H,eAAJ,CAAoB0H,QAApB,EAA8B,CAA9B,CAAlC;AACA,aAAOR,QAAP;AACD;;AACD,aAASW,gBAAT,GAA4B;AAC1B,aAAO,IAAI5H,IAAJ,CAASuH,KAAK,CAAC5B,cAAf,EAA+B4B,KAAK,CAAC3B,oBAArC,CAAP;AACD;;AACD,aAASiC,kBAAT,GAA8B;AAC5B,aAAO,IAAI7H,IAAJ,CAASuH,KAAK,CAAC5B,cAAf,EAA+B4B,KAAK,CAACtB,sBAArC,CAAP;AACD;;AACD,aAAS6B,cAAT,GAA0B;AACxB,aAAO,IAAI9H,IAAJ,CAASuH,KAAK,CAAC5B,cAAf,EAA+B4B,KAAK,CAACrB,kBAArC,CAAP;AACD;;AACD,aAAS6B,UAAT,CAAoBxG,EAApB,EAAwB;AACtB,aAAO,IAAItB,IAAJ,CAASuH,kBAAkB,CAACjG,EAAD,CAA3B,EAAiCgG,KAAK,CAACpB,YAAvC,CAAP;AACD;;AACD,SAAK,IAAIhF,CAAC,GAAG,CAAR,EAAWC,EAAE,GAAGJ,GAAG,CAACK,MAAzB,EAAiCF,CAAC,GAAGC,EAArC,EAAyCD,CAAC,EAA1C,EAA8C;AAC5C,YAAMI,EAAE,GAAGP,GAAG,CAACG,CAAD,CAAd;AACA,WAAK6G,GAAL,CAASJ,gBAAgB,EAAzB;AACA,WAAKI,GAAL,CAASH,kBAAkB,EAA3B;;AACA,WAAK,IAAI1F,CAAC,GAAG,CAAR,EAAWC,EAAE,GAAGb,EAAE,CAACS,KAAH,CAASX,MAA9B,EAAsCc,CAAC,GAAGC,EAA1C,EAA8CD,CAAC,EAA/C,EAAmD;AACjD,aAAK6F,GAAL,CAASF,cAAc,EAAvB;AACD;;AACD,WAAKE,GAAL,CAASD,UAAU,CAACxG,EAAD,CAAnB;AACD;AACF;;AAxHgC;;AA0HnC,SACEiD,WADF,EAEE3D,WAFF","sourcesContent":["import { Quaternion, Vector3, Matrix4, Object3D, SphereGeometry, MeshBasicMaterial, Color, LineBasicMaterial, BufferGeometry, BufferAttribute, Mesh, Line } from \"three\";\nconst _q = /* @__PURE__ */ new Quaternion();\nconst _targetPos = /* @__PURE__ */ new Vector3();\nconst _targetVec = /* @__PURE__ */ new Vector3();\nconst _effectorPos = /* @__PURE__ */ new Vector3();\nconst _effectorVec = /* @__PURE__ */ new Vector3();\nconst _linkPos = /* @__PURE__ */ new Vector3();\nconst _invLinkQ = /* @__PURE__ */ new Quaternion();\nconst _linkScale = /* @__PURE__ */ new Vector3();\nconst _axis = /* @__PURE__ */ new Vector3();\nconst _vector = /* @__PURE__ */ new Vector3();\nconst _matrix = /* @__PURE__ */ new Matrix4();\nclass CCDIKSolver {\n  /**\n   * @param {THREE.SkinnedMesh} mesh\n   * @param {Array<Object>} iks\n   */\n  constructor(mesh, iks = []) {\n    this.mesh = mesh;\n    this.iks = iks;\n    this._valid();\n  }\n  /**\n   * Update all IK bones.\n   *\n   * @return {CCDIKSolver}\n   */\n  update() {\n    const iks = this.iks;\n    for (let i = 0, il = iks.length; i < il; i++) {\n      this.updateOne(iks[i]);\n    }\n    return this;\n  }\n  /**\n   * Update one IK bone\n   *\n   * @param {Object} ik parameter\n   * @return {CCDIKSolver}\n   */\n  updateOne(ik) {\n    const bones = this.mesh.skeleton.bones;\n    const math = Math;\n    const effector = bones[ik.effector];\n    const target = bones[ik.target];\n    _targetPos.setFromMatrixPosition(target.matrixWorld);\n    const links = ik.links;\n    const iteration = ik.iteration !== void 0 ? ik.iteration : 1;\n    for (let i = 0; i < iteration; i++) {\n      let rotated = false;\n      for (let j = 0, jl = links.length; j < jl; j++) {\n        const link = bones[links[j].index];\n        if (links[j].enabled === false)\n          break;\n        const limitation = links[j].limitation;\n        const rotationMin = links[j].rotationMin;\n        const rotationMax = links[j].rotationMax;\n        link.matrixWorld.decompose(_linkPos, _invLinkQ, _linkScale);\n        _invLinkQ.invert();\n        _effectorPos.setFromMatrixPosition(effector.matrixWorld);\n        _effectorVec.subVectors(_effectorPos, _linkPos);\n        _effectorVec.applyQuaternion(_invLinkQ);\n        _effectorVec.normalize();\n        _targetVec.subVectors(_targetPos, _linkPos);\n        _targetVec.applyQuaternion(_invLinkQ);\n        _targetVec.normalize();\n        let angle = _targetVec.dot(_effectorVec);\n        if (angle > 1) {\n          angle = 1;\n        } else if (angle < -1) {\n          angle = -1;\n        }\n        angle = math.acos(angle);\n        if (angle < 1e-5)\n          continue;\n        if (ik.minAngle !== void 0 && angle < ik.minAngle) {\n          angle = ik.minAngle;\n        }\n        if (ik.maxAngle !== void 0 && angle > ik.maxAngle) {\n          angle = ik.maxAngle;\n        }\n        _axis.crossVectors(_effectorVec, _targetVec);\n        _axis.normalize();\n        _q.setFromAxisAngle(_axis, angle);\n        link.quaternion.multiply(_q);\n        if (limitation !== void 0) {\n          let c = link.quaternion.w;\n          if (c > 1)\n            c = 1;\n          const c2 = math.sqrt(1 - c * c);\n          link.quaternion.set(limitation.x * c2, limitation.y * c2, limitation.z * c2, c);\n        }\n        if (rotationMin !== void 0) {\n          link.rotation.setFromVector3(_vector.setFromEuler(link.rotation).max(rotationMin));\n        }\n        if (rotationMax !== void 0) {\n          link.rotation.setFromVector3(_vector.setFromEuler(link.rotation).min(rotationMax));\n        }\n        link.updateMatrixWorld(true);\n        rotated = true;\n      }\n      if (!rotated)\n        break;\n    }\n    return this;\n  }\n  /**\n   * Creates Helper\n   *\n   * @return {CCDIKHelper}\n   */\n  createHelper() {\n    return new CCDIKHelper(this.mesh, this.iks);\n  }\n  // private methods\n  _valid() {\n    const iks = this.iks;\n    const bones = this.mesh.skeleton.bones;\n    for (let i = 0, il = iks.length; i < il; i++) {\n      const ik = iks[i];\n      const effector = bones[ik.effector];\n      const links = ik.links;\n      let link0, link1;\n      link0 = effector;\n      for (let j = 0, jl = links.length; j < jl; j++) {\n        link1 = bones[links[j].index];\n        if (link0.parent !== link1) {\n          console.warn(\"THREE.CCDIKSolver: bone \" + link0.name + \" is not the child of bone \" + link1.name);\n        }\n        link0 = link1;\n      }\n    }\n  }\n}\nfunction getPosition(bone, matrixWorldInv) {\n  return _vector.setFromMatrixPosition(bone.matrixWorld).applyMatrix4(matrixWorldInv);\n}\nfunction setPositionOfBoneToAttributeArray(array, index, bone, matrixWorldInv) {\n  const v = getPosition(bone, matrixWorldInv);\n  array[index * 3 + 0] = v.x;\n  array[index * 3 + 1] = v.y;\n  array[index * 3 + 2] = v.z;\n}\nclass CCDIKHelper extends Object3D {\n  constructor(mesh, iks = [], sphereSize = 0.25) {\n    super();\n    this.root = mesh;\n    this.iks = iks;\n    this.matrix.copy(mesh.matrixWorld);\n    this.matrixAutoUpdate = false;\n    this.sphereGeometry = new SphereGeometry(sphereSize, 16, 8);\n    this.targetSphereMaterial = new MeshBasicMaterial({\n      color: new Color(16746632),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    this.effectorSphereMaterial = new MeshBasicMaterial({\n      color: new Color(8978312),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    this.linkSphereMaterial = new MeshBasicMaterial({\n      color: new Color(8947967),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    this.lineMaterial = new LineBasicMaterial({\n      color: new Color(16711680),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    this._init();\n  }\n  /**\n   * Updates IK bones visualization.\n   */\n  updateMatrixWorld(force) {\n    const mesh = this.root;\n    if (this.visible) {\n      let offset = 0;\n      const iks = this.iks;\n      const bones = mesh.skeleton.bones;\n      _matrix.copy(mesh.matrixWorld).invert();\n      for (let i = 0, il = iks.length; i < il; i++) {\n        const ik = iks[i];\n        const targetBone = bones[ik.target];\n        const effectorBone = bones[ik.effector];\n        const targetMesh = this.children[offset++];\n        const effectorMesh = this.children[offset++];\n        targetMesh.position.copy(getPosition(targetBone, _matrix));\n        effectorMesh.position.copy(getPosition(effectorBone, _matrix));\n        for (let j = 0, jl = ik.links.length; j < jl; j++) {\n          const link = ik.links[j];\n          const linkBone = bones[link.index];\n          const linkMesh = this.children[offset++];\n          linkMesh.position.copy(getPosition(linkBone, _matrix));\n        }\n        const line = this.children[offset++];\n        const array = line.geometry.attributes.position.array;\n        setPositionOfBoneToAttributeArray(array, 0, targetBone, _matrix);\n        setPositionOfBoneToAttributeArray(array, 1, effectorBone, _matrix);\n        for (let j = 0, jl = ik.links.length; j < jl; j++) {\n          const link = ik.links[j];\n          const linkBone = bones[link.index];\n          setPositionOfBoneToAttributeArray(array, j + 2, linkBone, _matrix);\n        }\n        line.geometry.attributes.position.needsUpdate = true;\n      }\n    }\n    this.matrix.copy(mesh.matrixWorld);\n    super.updateMatrixWorld(force);\n  }\n  /**\n   * Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app.\n   */\n  dispose() {\n    this.sphereGeometry.dispose();\n    this.targetSphereMaterial.dispose();\n    this.effectorSphereMaterial.dispose();\n    this.linkSphereMaterial.dispose();\n    this.lineMaterial.dispose();\n    const children = this.children;\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      if (child.isLine)\n        child.geometry.dispose();\n    }\n  }\n  // private method\n  _init() {\n    const scope = this;\n    const iks = this.iks;\n    function createLineGeometry(ik) {\n      const geometry = new BufferGeometry();\n      const vertices = new Float32Array((2 + ik.links.length) * 3);\n      geometry.setAttribute(\"position\", new BufferAttribute(vertices, 3));\n      return geometry;\n    }\n    function createTargetMesh() {\n      return new Mesh(scope.sphereGeometry, scope.targetSphereMaterial);\n    }\n    function createEffectorMesh() {\n      return new Mesh(scope.sphereGeometry, scope.effectorSphereMaterial);\n    }\n    function createLinkMesh() {\n      return new Mesh(scope.sphereGeometry, scope.linkSphereMaterial);\n    }\n    function createLine(ik) {\n      return new Line(createLineGeometry(ik), scope.lineMaterial);\n    }\n    for (let i = 0, il = iks.length; i < il; i++) {\n      const ik = iks[i];\n      this.add(createTargetMesh());\n      this.add(createEffectorMesh());\n      for (let j = 0, jl = ik.links.length; j < jl; j++) {\n        this.add(createLinkMesh());\n      }\n      this.add(createLine(ik));\n    }\n  }\n}\nexport {\n  CCDIKHelper,\n  CCDIKSolver\n};\n"]},"metadata":{},"sourceType":"module"}