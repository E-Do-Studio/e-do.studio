{"ast":null,"code":"var ParallaxShader = {\n  // Ordered from fastest to best quality.\n  modes: {\n    none: \"NO_PARALLAX\",\n    basic: \"USE_BASIC_PARALLAX\",\n    steep: \"USE_STEEP_PARALLAX\",\n    occlusion: \"USE_OCLUSION_PARALLAX\",\n    // a.k.a. POM\n    relief: \"USE_RELIEF_PARALLAX\"\n  },\n  uniforms: {\n    bumpMap: {\n      value: null\n    },\n    map: {\n      value: null\n    },\n    parallaxScale: {\n      value: null\n    },\n    parallaxMinLayers: {\n      value: null\n    },\n    parallaxMaxLayers: {\n      value: null\n    }\n  },\n  vertexShader: [\"varying vec2 vUv;\", \"varying vec3 vViewPosition;\", \"varying vec3 vNormal;\", \"void main() {\", \"\tvUv = uv;\", \"\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\", \"\tvViewPosition = -mvPosition.xyz;\", \"\tvNormal = normalize( normalMatrix * normal );\", \"\tgl_Position = projectionMatrix * mvPosition;\", \"}\"].join(\"\\n\"),\n  fragmentShader: [\"uniform sampler2D bumpMap;\", \"uniform sampler2D map;\", \"uniform float parallaxScale;\", \"uniform float parallaxMinLayers;\", \"uniform float parallaxMaxLayers;\", \"varying vec2 vUv;\", \"varying vec3 vViewPosition;\", \"varying vec3 vNormal;\", \"#ifdef USE_BASIC_PARALLAX\", \"\tvec2 parallaxMap( in vec3 V ) {\", \"\t\tfloat initialHeight = texture2D( bumpMap, vUv ).r;\", // No Offset Limitting: messy, floating output at grazing angles.\n  //\"vec2 texCoordOffset = parallaxScale * V.xy / V.z * initialHeight;\",\n  // Offset Limiting\n  \"\t\tvec2 texCoordOffset = parallaxScale * V.xy * initialHeight;\", \"\t\treturn vUv - texCoordOffset;\", \"\t}\", \"#else\", \"\tvec2 parallaxMap( in vec3 V ) {\", // Determine number of layers from angle between V and N\n  \"\t\tfloat numLayers = mix( parallaxMaxLayers, parallaxMinLayers, abs( dot( vec3( 0.0, 0.0, 1.0 ), V ) ) );\", \"\t\tfloat layerHeight = 1.0 / numLayers;\", \"\t\tfloat currentLayerHeight = 0.0;\", // Shift of texture coordinates for each iteration\n  \"\t\tvec2 dtex = parallaxScale * V.xy / V.z / numLayers;\", \"\t\tvec2 currentTextureCoords = vUv;\", \"\t\tfloat heightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;\", // while ( heightFromTexture > currentLayerHeight )\n  // Infinite loops are not well supported. Do a \"large\" finite\n  // loop, but not too large, as it slows down some compilers.\n  \"\t\tfor ( int i = 0; i < 30; i += 1 ) {\", \"\t\t\tif ( heightFromTexture <= currentLayerHeight ) {\", \"\t\t\t\tbreak;\", \"\t\t\t}\", \"\t\t\tcurrentLayerHeight += layerHeight;\", // Shift texture coordinates along vector V\n  \"\t\t\tcurrentTextureCoords -= dtex;\", \"\t\t\theightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;\", \"\t\t}\", \"\t\t#ifdef USE_STEEP_PARALLAX\", \"\t\t\treturn currentTextureCoords;\", \"\t\t#elif defined( USE_RELIEF_PARALLAX )\", \"\t\t\tvec2 deltaTexCoord = dtex / 2.0;\", \"\t\t\tfloat deltaHeight = layerHeight / 2.0;\", // Return to the mid point of previous layer\n  \"\t\t\tcurrentTextureCoords += deltaTexCoord;\", \"\t\t\tcurrentLayerHeight -= deltaHeight;\", // Binary search to increase precision of Steep Parallax Mapping\n  \"\t\t\tconst int numSearches = 5;\", \"\t\t\tfor ( int i = 0; i < numSearches; i += 1 ) {\", \"\t\t\t\tdeltaTexCoord /= 2.0;\", \"\t\t\t\tdeltaHeight /= 2.0;\", \"\t\t\t\theightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;\", // Shift along or against vector V\n  \"\t\t\t\tif( heightFromTexture > currentLayerHeight ) {\", // Below the surface\n  \"\t\t\t\t\tcurrentTextureCoords -= deltaTexCoord;\", \"\t\t\t\t\tcurrentLayerHeight += deltaHeight;\", \"\t\t\t\t} else {\", // above the surface\n  \"\t\t\t\t\tcurrentTextureCoords += deltaTexCoord;\", \"\t\t\t\t\tcurrentLayerHeight -= deltaHeight;\", \"\t\t\t\t}\", \"\t\t\t}\", \"\t\t\treturn currentTextureCoords;\", \"\t\t#elif defined( USE_OCLUSION_PARALLAX )\", \"\t\t\tvec2 prevTCoords = currentTextureCoords + dtex;\", // Heights for linear interpolation\n  \"\t\t\tfloat nextH = heightFromTexture - currentLayerHeight;\", \"\t\t\tfloat prevH = texture2D( bumpMap, prevTCoords ).r - currentLayerHeight + layerHeight;\", // Proportions for linear interpolation\n  \"\t\t\tfloat weight = nextH / ( nextH - prevH );\", // Interpolation of texture coordinates\n  \"\t\t\treturn prevTCoords * weight + currentTextureCoords * ( 1.0 - weight );\", \"\t\t#else\", // NO_PARALLAX\n  \"\t\t\treturn vUv;\", \"\t\t#endif\", \"\t}\", \"#endif\", \"vec2 perturbUv( vec3 surfPosition, vec3 surfNormal, vec3 viewPosition ) {\", \"\tvec2 texDx = dFdx( vUv );\", \"\tvec2 texDy = dFdy( vUv );\", \"\tvec3 vSigmaX = dFdx( surfPosition );\", \"\tvec3 vSigmaY = dFdy( surfPosition );\", \"\tvec3 vR1 = cross( vSigmaY, surfNormal );\", \"\tvec3 vR2 = cross( surfNormal, vSigmaX );\", \"\tfloat fDet = dot( vSigmaX, vR1 );\", \"\tvec2 vProjVscr = ( 1.0 / fDet ) * vec2( dot( vR1, viewPosition ), dot( vR2, viewPosition ) );\", \"\tvec3 vProjVtex;\", \"\tvProjVtex.xy = texDx * vProjVscr.x + texDy * vProjVscr.y;\", \"\tvProjVtex.z = dot( surfNormal, viewPosition );\", \"\treturn parallaxMap( vProjVtex );\", \"}\", \"void main() {\", \"\tvec2 mapUv = perturbUv( -vViewPosition, normalize( vNormal ), normalize( vViewPosition ) );\", \"\tgl_FragColor = texture2D( map, mapUv );\", \"}\"].join(\"\\n\")\n};\nexport { ParallaxShader };","map":{"version":3,"sources":["/Users/theodaguier/_workdir/dev/pro/e-do/E-Do-Studio/node_modules/three-stdlib/shaders/ParallaxShader.js"],"names":["ParallaxShader","modes","none","basic","steep","occlusion","relief","uniforms","bumpMap","value","map","parallaxScale","parallaxMinLayers","parallaxMaxLayers","vertexShader","join","fragmentShader"],"mappings":"AAAA,IAAMA,cAAc,GAAG;AACrB;AACAC,EAAAA,KAAK,EAAE;AACLC,IAAAA,IAAI,EAAE,aADD;AAELC,IAAAA,KAAK,EAAE,oBAFF;AAGLC,IAAAA,KAAK,EAAE,oBAHF;AAILC,IAAAA,SAAS,EAAE,uBAJN;AAKL;AACAC,IAAAA,MAAM,EAAE;AANH,GAFc;AAUrBC,EAAAA,QAAQ,EAAE;AACRC,IAAAA,OAAO,EAAE;AAAEC,MAAAA,KAAK,EAAE;AAAT,KADD;AAERC,IAAAA,GAAG,EAAE;AAAED,MAAAA,KAAK,EAAE;AAAT,KAFG;AAGRE,IAAAA,aAAa,EAAE;AAAEF,MAAAA,KAAK,EAAE;AAAT,KAHP;AAIRG,IAAAA,iBAAiB,EAAE;AAAEH,MAAAA,KAAK,EAAE;AAAT,KAJX;AAKRI,IAAAA,iBAAiB,EAAE;AAAEJ,MAAAA,KAAK,EAAE;AAAT;AALX,GAVW;AAiBrBK,EAAAA,YAAY,EAAE,CACZ,mBADY,EAEZ,6BAFY,EAGZ,uBAHY,EAIZ,eAJY,EAKZ,YALY,EAMZ,6DANY,EAOZ,mCAPY,EAQZ,gDARY,EASZ,+CATY,EAUZ,GAVY,EAWZC,IAXY,CAWP,IAXO,CAjBO;AA6BrBC,EAAAA,cAAc,EAAE,CACd,4BADc,EAEd,wBAFc,EAGd,8BAHc,EAId,kCAJc,EAKd,kCALc,EAMd,mBANc,EAOd,6BAPc,EAQd,uBARc,EASd,2BATc,EAUd,kCAVc,EAWd,sDAXc,EAYd;AACA;AACA;AACA,iEAfc,EAgBd,gCAhBc,EAiBd,IAjBc,EAkBd,OAlBc,EAmBd,kCAnBc,EAoBd;AACA,4GArBc,EAsBd,wCAtBc,EAuBd,mCAvBc,EAwBd;AACA,yDAzBc,EA0Bd,oCA1Bc,EA2Bd,2EA3Bc,EA4Bd;AACA;AACA;AACA,yCA/Bc,EAgCd,qDAhCc,EAiCd,YAjCc,EAkCd,MAlCc,EAmCd,uCAnCc,EAoCd;AACA,oCArCc,EAsCd,sEAtCc,EAuCd,KAvCc,EAwCd,6BAxCc,EAyCd,iCAzCc,EA0Cd,wCA1Cc,EA2Cd,qCA3Cc,EA4Cd,2CA5Cc,EA6Cd;AACA,6CA9Cc,EA+Cd,uCA/Cc,EAgDd;AACA,iCAjDc,EAkDd,iDAlDc,EAmDd,2BAnDc,EAoDd,yBApDc,EAqDd,uEArDc,EAsDd;AACA,sDAvDc,EAwDd;AACA,+CAzDc,EA0Dd,yCA1Dc,EA2Dd,cA3Dc,EA4Dd;AACA,+CA7Dc,EA8Dd,yCA9Dc,EA+Dd,OA/Dc,EAgEd,MAhEc,EAiEd,iCAjEc,EAkEd,0CAlEc,EAmEd,oDAnEc,EAoEd;AACA,4DArEc,EAsEd,0FAtEc,EAuEd;AACA,gDAxEc,EAyEd;AACA,6EA1Ec,EA2Ed,SA3Ec,EA4Ed;AACA,kBA7Ec,EA8Ed,UA9Ec,EA+Ed,IA/Ec,EAgFd,QAhFc,EAiFd,2EAjFc,EAkFd,4BAlFc,EAmFd,4BAnFc,EAoFd,uCApFc,EAqFd,uCArFc,EAsFd,2CAtFc,EAuFd,2CAvFc,EAwFd,oCAxFc,EAyFd,gGAzFc,EA0Fd,kBA1Fc,EA2Fd,4DA3Fc,EA4Fd,iDA5Fc,EA6Fd,mCA7Fc,EA8Fd,GA9Fc,EA+Fd,eA/Fc,EAgGd,8FAhGc,EAiGd,0CAjGc,EAkGd,GAlGc,EAmGdD,IAnGc,CAmGT,IAnGS;AA7BK,CAAvB;AAkIA,SACEf,cADF","sourcesContent":["const ParallaxShader = {\n  // Ordered from fastest to best quality.\n  modes: {\n    none: \"NO_PARALLAX\",\n    basic: \"USE_BASIC_PARALLAX\",\n    steep: \"USE_STEEP_PARALLAX\",\n    occlusion: \"USE_OCLUSION_PARALLAX\",\n    // a.k.a. POM\n    relief: \"USE_RELIEF_PARALLAX\"\n  },\n  uniforms: {\n    bumpMap: { value: null },\n    map: { value: null },\n    parallaxScale: { value: null },\n    parallaxMinLayers: { value: null },\n    parallaxMaxLayers: { value: null }\n  },\n  vertexShader: [\n    \"varying vec2 vUv;\",\n    \"varying vec3 vViewPosition;\",\n    \"varying vec3 vNormal;\",\n    \"void main() {\",\n    \"\tvUv = uv;\",\n    \"\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\n    \"\tvViewPosition = -mvPosition.xyz;\",\n    \"\tvNormal = normalize( normalMatrix * normal );\",\n    \"\tgl_Position = projectionMatrix * mvPosition;\",\n    \"}\"\n  ].join(\"\\n\"),\n  fragmentShader: [\n    \"uniform sampler2D bumpMap;\",\n    \"uniform sampler2D map;\",\n    \"uniform float parallaxScale;\",\n    \"uniform float parallaxMinLayers;\",\n    \"uniform float parallaxMaxLayers;\",\n    \"varying vec2 vUv;\",\n    \"varying vec3 vViewPosition;\",\n    \"varying vec3 vNormal;\",\n    \"#ifdef USE_BASIC_PARALLAX\",\n    \"\tvec2 parallaxMap( in vec3 V ) {\",\n    \"\t\tfloat initialHeight = texture2D( bumpMap, vUv ).r;\",\n    // No Offset Limitting: messy, floating output at grazing angles.\n    //\"vec2 texCoordOffset = parallaxScale * V.xy / V.z * initialHeight;\",\n    // Offset Limiting\n    \"\t\tvec2 texCoordOffset = parallaxScale * V.xy * initialHeight;\",\n    \"\t\treturn vUv - texCoordOffset;\",\n    \"\t}\",\n    \"#else\",\n    \"\tvec2 parallaxMap( in vec3 V ) {\",\n    // Determine number of layers from angle between V and N\n    \"\t\tfloat numLayers = mix( parallaxMaxLayers, parallaxMinLayers, abs( dot( vec3( 0.0, 0.0, 1.0 ), V ) ) );\",\n    \"\t\tfloat layerHeight = 1.0 / numLayers;\",\n    \"\t\tfloat currentLayerHeight = 0.0;\",\n    // Shift of texture coordinates for each iteration\n    \"\t\tvec2 dtex = parallaxScale * V.xy / V.z / numLayers;\",\n    \"\t\tvec2 currentTextureCoords = vUv;\",\n    \"\t\tfloat heightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;\",\n    // while ( heightFromTexture > currentLayerHeight )\n    // Infinite loops are not well supported. Do a \"large\" finite\n    // loop, but not too large, as it slows down some compilers.\n    \"\t\tfor ( int i = 0; i < 30; i += 1 ) {\",\n    \"\t\t\tif ( heightFromTexture <= currentLayerHeight ) {\",\n    \"\t\t\t\tbreak;\",\n    \"\t\t\t}\",\n    \"\t\t\tcurrentLayerHeight += layerHeight;\",\n    // Shift texture coordinates along vector V\n    \"\t\t\tcurrentTextureCoords -= dtex;\",\n    \"\t\t\theightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;\",\n    \"\t\t}\",\n    \"\t\t#ifdef USE_STEEP_PARALLAX\",\n    \"\t\t\treturn currentTextureCoords;\",\n    \"\t\t#elif defined( USE_RELIEF_PARALLAX )\",\n    \"\t\t\tvec2 deltaTexCoord = dtex / 2.0;\",\n    \"\t\t\tfloat deltaHeight = layerHeight / 2.0;\",\n    // Return to the mid point of previous layer\n    \"\t\t\tcurrentTextureCoords += deltaTexCoord;\",\n    \"\t\t\tcurrentLayerHeight -= deltaHeight;\",\n    // Binary search to increase precision of Steep Parallax Mapping\n    \"\t\t\tconst int numSearches = 5;\",\n    \"\t\t\tfor ( int i = 0; i < numSearches; i += 1 ) {\",\n    \"\t\t\t\tdeltaTexCoord /= 2.0;\",\n    \"\t\t\t\tdeltaHeight /= 2.0;\",\n    \"\t\t\t\theightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;\",\n    // Shift along or against vector V\n    \"\t\t\t\tif( heightFromTexture > currentLayerHeight ) {\",\n    // Below the surface\n    \"\t\t\t\t\tcurrentTextureCoords -= deltaTexCoord;\",\n    \"\t\t\t\t\tcurrentLayerHeight += deltaHeight;\",\n    \"\t\t\t\t} else {\",\n    // above the surface\n    \"\t\t\t\t\tcurrentTextureCoords += deltaTexCoord;\",\n    \"\t\t\t\t\tcurrentLayerHeight -= deltaHeight;\",\n    \"\t\t\t\t}\",\n    \"\t\t\t}\",\n    \"\t\t\treturn currentTextureCoords;\",\n    \"\t\t#elif defined( USE_OCLUSION_PARALLAX )\",\n    \"\t\t\tvec2 prevTCoords = currentTextureCoords + dtex;\",\n    // Heights for linear interpolation\n    \"\t\t\tfloat nextH = heightFromTexture - currentLayerHeight;\",\n    \"\t\t\tfloat prevH = texture2D( bumpMap, prevTCoords ).r - currentLayerHeight + layerHeight;\",\n    // Proportions for linear interpolation\n    \"\t\t\tfloat weight = nextH / ( nextH - prevH );\",\n    // Interpolation of texture coordinates\n    \"\t\t\treturn prevTCoords * weight + currentTextureCoords * ( 1.0 - weight );\",\n    \"\t\t#else\",\n    // NO_PARALLAX\n    \"\t\t\treturn vUv;\",\n    \"\t\t#endif\",\n    \"\t}\",\n    \"#endif\",\n    \"vec2 perturbUv( vec3 surfPosition, vec3 surfNormal, vec3 viewPosition ) {\",\n    \"\tvec2 texDx = dFdx( vUv );\",\n    \"\tvec2 texDy = dFdy( vUv );\",\n    \"\tvec3 vSigmaX = dFdx( surfPosition );\",\n    \"\tvec3 vSigmaY = dFdy( surfPosition );\",\n    \"\tvec3 vR1 = cross( vSigmaY, surfNormal );\",\n    \"\tvec3 vR2 = cross( surfNormal, vSigmaX );\",\n    \"\tfloat fDet = dot( vSigmaX, vR1 );\",\n    \"\tvec2 vProjVscr = ( 1.0 / fDet ) * vec2( dot( vR1, viewPosition ), dot( vR2, viewPosition ) );\",\n    \"\tvec3 vProjVtex;\",\n    \"\tvProjVtex.xy = texDx * vProjVscr.x + texDy * vProjVscr.y;\",\n    \"\tvProjVtex.z = dot( surfNormal, viewPosition );\",\n    \"\treturn parallaxMap( vProjVtex );\",\n    \"}\",\n    \"void main() {\",\n    \"\tvec2 mapUv = perturbUv( -vViewPosition, normalize( vNormal ), normalize( vViewPosition ) );\",\n    \"\tgl_FragColor = texture2D( map, mapUv );\",\n    \"}\"\n  ].join(\"\\n\")\n};\nexport {\n  ParallaxShader\n};\n"]},"metadata":{},"sourceType":"module"}