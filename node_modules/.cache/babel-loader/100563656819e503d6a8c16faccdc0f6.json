{"ast":null,"code":"import { Vector3, Line3, Plane, Triangle } from \"three\";\nconst Visible = 0;\nconst Deleted = 1;\n\nconst _v1 = /* @__PURE__ */new Vector3();\n\nconst _line3 = /* @__PURE__ */new Line3();\n\nconst _plane = /* @__PURE__ */new Plane();\n\nconst _closestPoint = /* @__PURE__ */new Vector3();\n\nconst _triangle = /* @__PURE__ */new Triangle();\n\nclass ConvexHull {\n  constructor() {\n    this.tolerance = -1;\n    this.faces = [];\n    this.newFaces = [];\n    this.assigned = new VertexList();\n    this.unassigned = new VertexList();\n    this.vertices = [];\n  }\n\n  setFromPoints(points) {\n    if (points.length >= 4) {\n      this.makeEmpty();\n\n      for (let i = 0, l = points.length; i < l; i++) {\n        this.vertices.push(new VertexNode(points[i]));\n      }\n\n      this.compute();\n    }\n\n    return this;\n  }\n\n  setFromObject(object) {\n    const points = [];\n    object.updateMatrixWorld(true);\n    object.traverse(function (node) {\n      const geometry = node.geometry;\n\n      if (geometry !== void 0) {\n        const attribute = geometry.attributes.position;\n\n        if (attribute !== void 0) {\n          for (let i = 0, l = attribute.count; i < l; i++) {\n            const point = new Vector3();\n            point.fromBufferAttribute(attribute, i).applyMatrix4(node.matrixWorld);\n            points.push(point);\n          }\n        }\n      }\n    });\n    return this.setFromPoints(points);\n  }\n\n  containsPoint(point) {\n    const faces = this.faces;\n\n    for (let i = 0, l = faces.length; i < l; i++) {\n      const face = faces[i];\n      if (face.distanceToPoint(point) > this.tolerance) return false;\n    }\n\n    return true;\n  }\n\n  intersectRay(ray, target) {\n    const faces = this.faces;\n    let tNear = -Infinity;\n    let tFar = Infinity;\n\n    for (let i = 0, l = faces.length; i < l; i++) {\n      const face = faces[i];\n      const vN = face.distanceToPoint(ray.origin);\n      const vD = face.normal.dot(ray.direction);\n      if (vN > 0 && vD >= 0) return null;\n      const t = vD !== 0 ? -vN / vD : 0;\n      if (t <= 0) continue;\n\n      if (vD > 0) {\n        tFar = Math.min(t, tFar);\n      } else {\n        tNear = Math.max(t, tNear);\n      }\n\n      if (tNear > tFar) {\n        return null;\n      }\n    }\n\n    if (tNear !== -Infinity) {\n      ray.at(tNear, target);\n    } else {\n      ray.at(tFar, target);\n    }\n\n    return target;\n  }\n\n  intersectsRay(ray) {\n    return this.intersectRay(ray, _v1) !== null;\n  }\n\n  makeEmpty() {\n    this.faces = [];\n    this.vertices = [];\n    return this;\n  } // Adds a vertex to the 'assigned' list of vertices and assigns it to the given face\n\n\n  addVertexToFace(vertex, face) {\n    vertex.face = face;\n\n    if (face.outside === null) {\n      this.assigned.append(vertex);\n    } else {\n      this.assigned.insertBefore(face.outside, vertex);\n    }\n\n    face.outside = vertex;\n    return this;\n  } // Removes a vertex from the 'assigned' list of vertices and from the given face\n\n\n  removeVertexFromFace(vertex, face) {\n    if (vertex === face.outside) {\n      if (vertex.next !== null && vertex.next.face === face) {\n        face.outside = vertex.next;\n      } else {\n        face.outside = null;\n      }\n    }\n\n    this.assigned.remove(vertex);\n    return this;\n  } // Removes all the visible vertices that a given face is able to see which are stored in the 'assigned' vertex list\n\n\n  removeAllVerticesFromFace(face) {\n    if (face.outside !== null) {\n      const start = face.outside;\n      let end = face.outside;\n\n      while (end.next !== null && end.next.face === face) {\n        end = end.next;\n      }\n\n      this.assigned.removeSubList(start, end);\n      start.prev = end.next = null;\n      face.outside = null;\n      return start;\n    }\n  } // Removes all the visible vertices that 'face' is able to see\n\n\n  deleteFaceVertices(face, absorbingFace) {\n    const faceVertices = this.removeAllVerticesFromFace(face);\n\n    if (faceVertices !== void 0) {\n      if (absorbingFace === void 0) {\n        this.unassigned.appendChain(faceVertices);\n      } else {\n        let vertex = faceVertices;\n\n        do {\n          const nextVertex = vertex.next;\n          const distance = absorbingFace.distanceToPoint(vertex.point);\n\n          if (distance > this.tolerance) {\n            this.addVertexToFace(vertex, absorbingFace);\n          } else {\n            this.unassigned.append(vertex);\n          }\n\n          vertex = nextVertex;\n        } while (vertex !== null);\n      }\n    }\n\n    return this;\n  } // Reassigns as many vertices as possible from the unassigned list to the new faces\n\n\n  resolveUnassignedPoints(newFaces) {\n    if (this.unassigned.isEmpty() === false) {\n      let vertex = this.unassigned.first();\n\n      do {\n        const nextVertex = vertex.next;\n        let maxDistance = this.tolerance;\n        let maxFace = null;\n\n        for (let i = 0; i < newFaces.length; i++) {\n          const face = newFaces[i];\n\n          if (face.mark === Visible) {\n            const distance = face.distanceToPoint(vertex.point);\n\n            if (distance > maxDistance) {\n              maxDistance = distance;\n              maxFace = face;\n            }\n\n            if (maxDistance > 1e3 * this.tolerance) break;\n          }\n        }\n\n        if (maxFace !== null) {\n          this.addVertexToFace(vertex, maxFace);\n        }\n\n        vertex = nextVertex;\n      } while (vertex !== null);\n    }\n\n    return this;\n  } // Computes the extremes of a simplex which will be the initial hull\n\n\n  computeExtremes() {\n    const min = new Vector3();\n    const max = new Vector3();\n    const minVertices = [];\n    const maxVertices = [];\n\n    for (let i = 0; i < 3; i++) {\n      minVertices[i] = maxVertices[i] = this.vertices[0];\n    }\n\n    min.copy(this.vertices[0].point);\n    max.copy(this.vertices[0].point);\n\n    for (let i = 0, l = this.vertices.length; i < l; i++) {\n      const vertex = this.vertices[i];\n      const point = vertex.point;\n\n      for (let j = 0; j < 3; j++) {\n        if (point.getComponent(j) < min.getComponent(j)) {\n          min.setComponent(j, point.getComponent(j));\n          minVertices[j] = vertex;\n        }\n      }\n\n      for (let j = 0; j < 3; j++) {\n        if (point.getComponent(j) > max.getComponent(j)) {\n          max.setComponent(j, point.getComponent(j));\n          maxVertices[j] = vertex;\n        }\n      }\n    }\n\n    this.tolerance = 3 * Number.EPSILON * (Math.max(Math.abs(min.x), Math.abs(max.x)) + Math.max(Math.abs(min.y), Math.abs(max.y)) + Math.max(Math.abs(min.z), Math.abs(max.z)));\n    return {\n      min: minVertices,\n      max: maxVertices\n    };\n  } // Computes the initial simplex assigning to its faces all the points\n  // that are candidates to form part of the hull\n\n\n  computeInitialHull() {\n    const vertices = this.vertices;\n    const extremes = this.computeExtremes();\n    const min = extremes.min;\n    const max = extremes.max;\n    let maxDistance = 0;\n    let index = 0;\n\n    for (let i = 0; i < 3; i++) {\n      const distance = max[i].point.getComponent(i) - min[i].point.getComponent(i);\n\n      if (distance > maxDistance) {\n        maxDistance = distance;\n        index = i;\n      }\n    }\n\n    const v0 = min[index];\n    const v1 = max[index];\n    let v2;\n    let v3;\n    maxDistance = 0;\n\n    _line3.set(v0.point, v1.point);\n\n    for (let i = 0, l = this.vertices.length; i < l; i++) {\n      const vertex = vertices[i];\n\n      if (vertex !== v0 && vertex !== v1) {\n        _line3.closestPointToPoint(vertex.point, true, _closestPoint);\n\n        const distance = _closestPoint.distanceToSquared(vertex.point);\n\n        if (distance > maxDistance) {\n          maxDistance = distance;\n          v2 = vertex;\n        }\n      }\n    }\n\n    maxDistance = -1;\n\n    _plane.setFromCoplanarPoints(v0.point, v1.point, v2.point);\n\n    for (let i = 0, l = this.vertices.length; i < l; i++) {\n      const vertex = vertices[i];\n\n      if (vertex !== v0 && vertex !== v1 && vertex !== v2) {\n        const distance = Math.abs(_plane.distanceToPoint(vertex.point));\n\n        if (distance > maxDistance) {\n          maxDistance = distance;\n          v3 = vertex;\n        }\n      }\n    }\n\n    const faces = [];\n\n    if (_plane.distanceToPoint(v3.point) < 0) {\n      faces.push(Face.create(v0, v1, v2), Face.create(v3, v1, v0), Face.create(v3, v2, v1), Face.create(v3, v0, v2));\n\n      for (let i = 0; i < 3; i++) {\n        const j = (i + 1) % 3;\n        faces[i + 1].getEdge(2).setTwin(faces[0].getEdge(j));\n        faces[i + 1].getEdge(1).setTwin(faces[j + 1].getEdge(0));\n      }\n    } else {\n      faces.push(Face.create(v0, v2, v1), Face.create(v3, v0, v1), Face.create(v3, v1, v2), Face.create(v3, v2, v0));\n\n      for (let i = 0; i < 3; i++) {\n        const j = (i + 1) % 3;\n        faces[i + 1].getEdge(2).setTwin(faces[0].getEdge((3 - i) % 3));\n        faces[i + 1].getEdge(0).setTwin(faces[j + 1].getEdge(1));\n      }\n    }\n\n    for (let i = 0; i < 4; i++) {\n      this.faces.push(faces[i]);\n    }\n\n    for (let i = 0, l = vertices.length; i < l; i++) {\n      const vertex = vertices[i];\n\n      if (vertex !== v0 && vertex !== v1 && vertex !== v2 && vertex !== v3) {\n        maxDistance = this.tolerance;\n        let maxFace = null;\n\n        for (let j = 0; j < 4; j++) {\n          const distance = this.faces[j].distanceToPoint(vertex.point);\n\n          if (distance > maxDistance) {\n            maxDistance = distance;\n            maxFace = this.faces[j];\n          }\n        }\n\n        if (maxFace !== null) {\n          this.addVertexToFace(vertex, maxFace);\n        }\n      }\n    }\n\n    return this;\n  } // Removes inactive faces\n\n\n  reindexFaces() {\n    const activeFaces = [];\n\n    for (let i = 0; i < this.faces.length; i++) {\n      const face = this.faces[i];\n\n      if (face.mark === Visible) {\n        activeFaces.push(face);\n      }\n    }\n\n    this.faces = activeFaces;\n    return this;\n  } // Finds the next vertex to create faces with the current hull\n\n\n  nextVertexToAdd() {\n    if (this.assigned.isEmpty() === false) {\n      let eyeVertex,\n          maxDistance = 0;\n      const eyeFace = this.assigned.first().face;\n      let vertex = eyeFace.outside;\n\n      do {\n        const distance = eyeFace.distanceToPoint(vertex.point);\n\n        if (distance > maxDistance) {\n          maxDistance = distance;\n          eyeVertex = vertex;\n        }\n\n        vertex = vertex.next;\n      } while (vertex !== null && vertex.face === eyeFace);\n\n      return eyeVertex;\n    }\n  } // Computes a chain of half edges in CCW order called the 'horizon'.\n  // For an edge to be part of the horizon it must join a face that can see\n  // 'eyePoint' and a face that cannot see 'eyePoint'.\n\n\n  computeHorizon(eyePoint, crossEdge, face, horizon) {\n    this.deleteFaceVertices(face);\n    face.mark = Deleted;\n    let edge;\n\n    if (crossEdge === null) {\n      edge = crossEdge = face.getEdge(0);\n    } else {\n      edge = crossEdge.next;\n    }\n\n    do {\n      const twinEdge = edge.twin;\n      const oppositeFace = twinEdge.face;\n\n      if (oppositeFace.mark === Visible) {\n        if (oppositeFace.distanceToPoint(eyePoint) > this.tolerance) {\n          this.computeHorizon(eyePoint, twinEdge, oppositeFace, horizon);\n        } else {\n          horizon.push(edge);\n        }\n      }\n\n      edge = edge.next;\n    } while (edge !== crossEdge);\n\n    return this;\n  } // Creates a face with the vertices 'eyeVertex.point', 'horizonEdge.tail' and 'horizonEdge.head' in CCW order\n\n\n  addAdjoiningFace(eyeVertex, horizonEdge) {\n    const face = Face.create(eyeVertex, horizonEdge.tail(), horizonEdge.head());\n    this.faces.push(face);\n    face.getEdge(-1).setTwin(horizonEdge.twin);\n    return face.getEdge(0);\n  } //  Adds 'horizon.length' faces to the hull, each face will be linked with the\n  //  horizon opposite face and the face on the left/right\n\n\n  addNewFaces(eyeVertex, horizon) {\n    this.newFaces = [];\n    let firstSideEdge = null;\n    let previousSideEdge = null;\n\n    for (let i = 0; i < horizon.length; i++) {\n      const horizonEdge = horizon[i];\n      const sideEdge = this.addAdjoiningFace(eyeVertex, horizonEdge);\n\n      if (firstSideEdge === null) {\n        firstSideEdge = sideEdge;\n      } else {\n        sideEdge.next.setTwin(previousSideEdge);\n      }\n\n      this.newFaces.push(sideEdge.face);\n      previousSideEdge = sideEdge;\n    }\n\n    firstSideEdge.next.setTwin(previousSideEdge);\n    return this;\n  } // Adds a vertex to the hull\n\n\n  addVertexToHull(eyeVertex) {\n    const horizon = [];\n    this.unassigned.clear();\n    this.removeVertexFromFace(eyeVertex, eyeVertex.face);\n    this.computeHorizon(eyeVertex.point, null, eyeVertex.face, horizon);\n    this.addNewFaces(eyeVertex, horizon);\n    this.resolveUnassignedPoints(this.newFaces);\n    return this;\n  }\n\n  cleanup() {\n    this.assigned.clear();\n    this.unassigned.clear();\n    this.newFaces = [];\n    return this;\n  }\n\n  compute() {\n    let vertex;\n    this.computeInitialHull();\n\n    while ((vertex = this.nextVertexToAdd()) !== void 0) {\n      this.addVertexToHull(vertex);\n    }\n\n    this.reindexFaces();\n    this.cleanup();\n    return this;\n  }\n\n}\n\nclass Face {\n  constructor() {\n    this.normal = new Vector3();\n    this.midpoint = new Vector3();\n    this.area = 0;\n    this.constant = 0;\n    this.outside = null;\n    this.mark = Visible;\n    this.edge = null;\n  }\n\n  static create(a, b, c) {\n    const face = new Face();\n    const e0 = new HalfEdge(a, face);\n    const e1 = new HalfEdge(b, face);\n    const e2 = new HalfEdge(c, face);\n    e0.next = e2.prev = e1;\n    e1.next = e0.prev = e2;\n    e2.next = e1.prev = e0;\n    face.edge = e0;\n    return face.compute();\n  }\n\n  getEdge(i) {\n    let edge = this.edge;\n\n    while (i > 0) {\n      edge = edge.next;\n      i--;\n    }\n\n    while (i < 0) {\n      edge = edge.prev;\n      i++;\n    }\n\n    return edge;\n  }\n\n  compute() {\n    const a = this.edge.tail();\n    const b = this.edge.head();\n    const c = this.edge.next.head();\n\n    _triangle.set(a.point, b.point, c.point);\n\n    _triangle.getNormal(this.normal);\n\n    _triangle.getMidpoint(this.midpoint);\n\n    this.area = _triangle.getArea();\n    this.constant = this.normal.dot(this.midpoint);\n    return this;\n  }\n\n  distanceToPoint(point) {\n    return this.normal.dot(point) - this.constant;\n  }\n\n}\n\nclass HalfEdge {\n  constructor(vertex, face) {\n    this.vertex = vertex;\n    this.prev = null;\n    this.next = null;\n    this.twin = null;\n    this.face = face;\n  }\n\n  head() {\n    return this.vertex;\n  }\n\n  tail() {\n    return this.prev ? this.prev.vertex : null;\n  }\n\n  length() {\n    const head = this.head();\n    const tail = this.tail();\n\n    if (tail !== null) {\n      return tail.point.distanceTo(head.point);\n    }\n\n    return -1;\n  }\n\n  lengthSquared() {\n    const head = this.head();\n    const tail = this.tail();\n\n    if (tail !== null) {\n      return tail.point.distanceToSquared(head.point);\n    }\n\n    return -1;\n  }\n\n  setTwin(edge) {\n    this.twin = edge;\n    edge.twin = this;\n    return this;\n  }\n\n}\n\nclass VertexNode {\n  constructor(point) {\n    this.point = point;\n    this.prev = null;\n    this.next = null;\n    this.face = null;\n  }\n\n}\n\nclass VertexList {\n  constructor() {\n    this.head = null;\n    this.tail = null;\n  }\n\n  first() {\n    return this.head;\n  }\n\n  last() {\n    return this.tail;\n  }\n\n  clear() {\n    this.head = this.tail = null;\n    return this;\n  } // Inserts a vertex before the target vertex\n\n\n  insertBefore(target, vertex) {\n    vertex.prev = target.prev;\n    vertex.next = target;\n\n    if (vertex.prev === null) {\n      this.head = vertex;\n    } else {\n      vertex.prev.next = vertex;\n    }\n\n    target.prev = vertex;\n    return this;\n  } // Inserts a vertex after the target vertex\n\n\n  insertAfter(target, vertex) {\n    vertex.prev = target;\n    vertex.next = target.next;\n\n    if (vertex.next === null) {\n      this.tail = vertex;\n    } else {\n      vertex.next.prev = vertex;\n    }\n\n    target.next = vertex;\n    return this;\n  } // Appends a vertex to the end of the linked list\n\n\n  append(vertex) {\n    if (this.head === null) {\n      this.head = vertex;\n    } else {\n      this.tail.next = vertex;\n    }\n\n    vertex.prev = this.tail;\n    vertex.next = null;\n    this.tail = vertex;\n    return this;\n  } // Appends a chain of vertices where 'vertex' is the head.\n\n\n  appendChain(vertex) {\n    if (this.head === null) {\n      this.head = vertex;\n    } else {\n      this.tail.next = vertex;\n    }\n\n    vertex.prev = this.tail;\n\n    while (vertex.next !== null) {\n      vertex = vertex.next;\n    }\n\n    this.tail = vertex;\n    return this;\n  } // Removes a vertex from the linked list\n\n\n  remove(vertex) {\n    if (vertex.prev === null) {\n      this.head = vertex.next;\n    } else {\n      vertex.prev.next = vertex.next;\n    }\n\n    if (vertex.next === null) {\n      this.tail = vertex.prev;\n    } else {\n      vertex.next.prev = vertex.prev;\n    }\n\n    return this;\n  } // Removes a list of vertices whose 'head' is 'a' and whose 'tail' is b\n\n\n  removeSubList(a, b) {\n    if (a.prev === null) {\n      this.head = b.next;\n    } else {\n      a.prev.next = b.next;\n    }\n\n    if (b.next === null) {\n      this.tail = a.prev;\n    } else {\n      b.next.prev = a.prev;\n    }\n\n    return this;\n  }\n\n  isEmpty() {\n    return this.head === null;\n  }\n\n}\n\nexport { ConvexHull, Face, HalfEdge, VertexList, VertexNode };","map":{"version":3,"sources":["/Users/theodaguier/Repositories/E-Do-Studio/node_modules/three-stdlib/math/ConvexHull.js"],"names":["Vector3","Line3","Plane","Triangle","Visible","Deleted","_v1","_line3","_plane","_closestPoint","_triangle","ConvexHull","constructor","tolerance","faces","newFaces","assigned","VertexList","unassigned","vertices","setFromPoints","points","length","makeEmpty","i","l","push","VertexNode","compute","setFromObject","object","updateMatrixWorld","traverse","node","geometry","attribute","attributes","position","count","point","fromBufferAttribute","applyMatrix4","matrixWorld","containsPoint","face","distanceToPoint","intersectRay","ray","target","tNear","Infinity","tFar","vN","origin","vD","normal","dot","direction","t","Math","min","max","at","intersectsRay","addVertexToFace","vertex","outside","append","insertBefore","removeVertexFromFace","next","remove","removeAllVerticesFromFace","start","end","removeSubList","prev","deleteFaceVertices","absorbingFace","faceVertices","appendChain","nextVertex","distance","resolveUnassignedPoints","isEmpty","first","maxDistance","maxFace","mark","computeExtremes","minVertices","maxVertices","copy","j","getComponent","setComponent","Number","EPSILON","abs","x","y","z","computeInitialHull","extremes","index","v0","v1","v2","v3","set","closestPointToPoint","distanceToSquared","setFromCoplanarPoints","Face","create","getEdge","setTwin","reindexFaces","activeFaces","nextVertexToAdd","eyeVertex","eyeFace","computeHorizon","eyePoint","crossEdge","horizon","edge","twinEdge","twin","oppositeFace","addAdjoiningFace","horizonEdge","tail","head","addNewFaces","firstSideEdge","previousSideEdge","sideEdge","addVertexToHull","clear","cleanup","midpoint","area","constant","a","b","c","e0","HalfEdge","e1","e2","getNormal","getMidpoint","getArea","distanceTo","lengthSquared","last","insertAfter"],"mappings":"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","sourcesContent":["import { Vector3, Line3, Plane, Triangle } from \"three\";\nconst Visible = 0;\nconst Deleted = 1;\nconst _v1 = /* @__PURE__ */ new Vector3();\nconst _line3 = /* @__PURE__ */ new Line3();\nconst _plane = /* @__PURE__ */ new Plane();\nconst _closestPoint = /* @__PURE__ */ new Vector3();\nconst _triangle = /* @__PURE__ */ new Triangle();\nclass ConvexHull {\n  constructor() {\n    this.tolerance = -1;\n    this.faces = [];\n    this.newFaces = [];\n    this.assigned = new VertexList();\n    this.unassigned = new VertexList();\n    this.vertices = [];\n  }\n  setFromPoints(points) {\n    if (points.length >= 4) {\n      this.makeEmpty();\n      for (let i = 0, l = points.length; i < l; i++) {\n        this.vertices.push(new VertexNode(points[i]));\n      }\n      this.compute();\n    }\n    return this;\n  }\n  setFromObject(object) {\n    const points = [];\n    object.updateMatrixWorld(true);\n    object.traverse(function(node) {\n      const geometry = node.geometry;\n      if (geometry !== void 0) {\n        const attribute = geometry.attributes.position;\n        if (attribute !== void 0) {\n          for (let i = 0, l = attribute.count; i < l; i++) {\n            const point = new Vector3();\n            point.fromBufferAttribute(attribute, i).applyMatrix4(node.matrixWorld);\n            points.push(point);\n          }\n        }\n      }\n    });\n    return this.setFromPoints(points);\n  }\n  containsPoint(point) {\n    const faces = this.faces;\n    for (let i = 0, l = faces.length; i < l; i++) {\n      const face = faces[i];\n      if (face.distanceToPoint(point) > this.tolerance)\n        return false;\n    }\n    return true;\n  }\n  intersectRay(ray, target) {\n    const faces = this.faces;\n    let tNear = -Infinity;\n    let tFar = Infinity;\n    for (let i = 0, l = faces.length; i < l; i++) {\n      const face = faces[i];\n      const vN = face.distanceToPoint(ray.origin);\n      const vD = face.normal.dot(ray.direction);\n      if (vN > 0 && vD >= 0)\n        return null;\n      const t = vD !== 0 ? -vN / vD : 0;\n      if (t <= 0)\n        continue;\n      if (vD > 0) {\n        tFar = Math.min(t, tFar);\n      } else {\n        tNear = Math.max(t, tNear);\n      }\n      if (tNear > tFar) {\n        return null;\n      }\n    }\n    if (tNear !== -Infinity) {\n      ray.at(tNear, target);\n    } else {\n      ray.at(tFar, target);\n    }\n    return target;\n  }\n  intersectsRay(ray) {\n    return this.intersectRay(ray, _v1) !== null;\n  }\n  makeEmpty() {\n    this.faces = [];\n    this.vertices = [];\n    return this;\n  }\n  // Adds a vertex to the 'assigned' list of vertices and assigns it to the given face\n  addVertexToFace(vertex, face) {\n    vertex.face = face;\n    if (face.outside === null) {\n      this.assigned.append(vertex);\n    } else {\n      this.assigned.insertBefore(face.outside, vertex);\n    }\n    face.outside = vertex;\n    return this;\n  }\n  // Removes a vertex from the 'assigned' list of vertices and from the given face\n  removeVertexFromFace(vertex, face) {\n    if (vertex === face.outside) {\n      if (vertex.next !== null && vertex.next.face === face) {\n        face.outside = vertex.next;\n      } else {\n        face.outside = null;\n      }\n    }\n    this.assigned.remove(vertex);\n    return this;\n  }\n  // Removes all the visible vertices that a given face is able to see which are stored in the 'assigned' vertex list\n  removeAllVerticesFromFace(face) {\n    if (face.outside !== null) {\n      const start = face.outside;\n      let end = face.outside;\n      while (end.next !== null && end.next.face === face) {\n        end = end.next;\n      }\n      this.assigned.removeSubList(start, end);\n      start.prev = end.next = null;\n      face.outside = null;\n      return start;\n    }\n  }\n  // Removes all the visible vertices that 'face' is able to see\n  deleteFaceVertices(face, absorbingFace) {\n    const faceVertices = this.removeAllVerticesFromFace(face);\n    if (faceVertices !== void 0) {\n      if (absorbingFace === void 0) {\n        this.unassigned.appendChain(faceVertices);\n      } else {\n        let vertex = faceVertices;\n        do {\n          const nextVertex = vertex.next;\n          const distance = absorbingFace.distanceToPoint(vertex.point);\n          if (distance > this.tolerance) {\n            this.addVertexToFace(vertex, absorbingFace);\n          } else {\n            this.unassigned.append(vertex);\n          }\n          vertex = nextVertex;\n        } while (vertex !== null);\n      }\n    }\n    return this;\n  }\n  // Reassigns as many vertices as possible from the unassigned list to the new faces\n  resolveUnassignedPoints(newFaces) {\n    if (this.unassigned.isEmpty() === false) {\n      let vertex = this.unassigned.first();\n      do {\n        const nextVertex = vertex.next;\n        let maxDistance = this.tolerance;\n        let maxFace = null;\n        for (let i = 0; i < newFaces.length; i++) {\n          const face = newFaces[i];\n          if (face.mark === Visible) {\n            const distance = face.distanceToPoint(vertex.point);\n            if (distance > maxDistance) {\n              maxDistance = distance;\n              maxFace = face;\n            }\n            if (maxDistance > 1e3 * this.tolerance)\n              break;\n          }\n        }\n        if (maxFace !== null) {\n          this.addVertexToFace(vertex, maxFace);\n        }\n        vertex = nextVertex;\n      } while (vertex !== null);\n    }\n    return this;\n  }\n  // Computes the extremes of a simplex which will be the initial hull\n  computeExtremes() {\n    const min = new Vector3();\n    const max = new Vector3();\n    const minVertices = [];\n    const maxVertices = [];\n    for (let i = 0; i < 3; i++) {\n      minVertices[i] = maxVertices[i] = this.vertices[0];\n    }\n    min.copy(this.vertices[0].point);\n    max.copy(this.vertices[0].point);\n    for (let i = 0, l = this.vertices.length; i < l; i++) {\n      const vertex = this.vertices[i];\n      const point = vertex.point;\n      for (let j = 0; j < 3; j++) {\n        if (point.getComponent(j) < min.getComponent(j)) {\n          min.setComponent(j, point.getComponent(j));\n          minVertices[j] = vertex;\n        }\n      }\n      for (let j = 0; j < 3; j++) {\n        if (point.getComponent(j) > max.getComponent(j)) {\n          max.setComponent(j, point.getComponent(j));\n          maxVertices[j] = vertex;\n        }\n      }\n    }\n    this.tolerance = 3 * Number.EPSILON * (Math.max(Math.abs(min.x), Math.abs(max.x)) + Math.max(Math.abs(min.y), Math.abs(max.y)) + Math.max(Math.abs(min.z), Math.abs(max.z)));\n    return { min: minVertices, max: maxVertices };\n  }\n  // Computes the initial simplex assigning to its faces all the points\n  // that are candidates to form part of the hull\n  computeInitialHull() {\n    const vertices = this.vertices;\n    const extremes = this.computeExtremes();\n    const min = extremes.min;\n    const max = extremes.max;\n    let maxDistance = 0;\n    let index = 0;\n    for (let i = 0; i < 3; i++) {\n      const distance = max[i].point.getComponent(i) - min[i].point.getComponent(i);\n      if (distance > maxDistance) {\n        maxDistance = distance;\n        index = i;\n      }\n    }\n    const v0 = min[index];\n    const v1 = max[index];\n    let v2;\n    let v3;\n    maxDistance = 0;\n    _line3.set(v0.point, v1.point);\n    for (let i = 0, l = this.vertices.length; i < l; i++) {\n      const vertex = vertices[i];\n      if (vertex !== v0 && vertex !== v1) {\n        _line3.closestPointToPoint(vertex.point, true, _closestPoint);\n        const distance = _closestPoint.distanceToSquared(vertex.point);\n        if (distance > maxDistance) {\n          maxDistance = distance;\n          v2 = vertex;\n        }\n      }\n    }\n    maxDistance = -1;\n    _plane.setFromCoplanarPoints(v0.point, v1.point, v2.point);\n    for (let i = 0, l = this.vertices.length; i < l; i++) {\n      const vertex = vertices[i];\n      if (vertex !== v0 && vertex !== v1 && vertex !== v2) {\n        const distance = Math.abs(_plane.distanceToPoint(vertex.point));\n        if (distance > maxDistance) {\n          maxDistance = distance;\n          v3 = vertex;\n        }\n      }\n    }\n    const faces = [];\n    if (_plane.distanceToPoint(v3.point) < 0) {\n      faces.push(Face.create(v0, v1, v2), Face.create(v3, v1, v0), Face.create(v3, v2, v1), Face.create(v3, v0, v2));\n      for (let i = 0; i < 3; i++) {\n        const j = (i + 1) % 3;\n        faces[i + 1].getEdge(2).setTwin(faces[0].getEdge(j));\n        faces[i + 1].getEdge(1).setTwin(faces[j + 1].getEdge(0));\n      }\n    } else {\n      faces.push(Face.create(v0, v2, v1), Face.create(v3, v0, v1), Face.create(v3, v1, v2), Face.create(v3, v2, v0));\n      for (let i = 0; i < 3; i++) {\n        const j = (i + 1) % 3;\n        faces[i + 1].getEdge(2).setTwin(faces[0].getEdge((3 - i) % 3));\n        faces[i + 1].getEdge(0).setTwin(faces[j + 1].getEdge(1));\n      }\n    }\n    for (let i = 0; i < 4; i++) {\n      this.faces.push(faces[i]);\n    }\n    for (let i = 0, l = vertices.length; i < l; i++) {\n      const vertex = vertices[i];\n      if (vertex !== v0 && vertex !== v1 && vertex !== v2 && vertex !== v3) {\n        maxDistance = this.tolerance;\n        let maxFace = null;\n        for (let j = 0; j < 4; j++) {\n          const distance = this.faces[j].distanceToPoint(vertex.point);\n          if (distance > maxDistance) {\n            maxDistance = distance;\n            maxFace = this.faces[j];\n          }\n        }\n        if (maxFace !== null) {\n          this.addVertexToFace(vertex, maxFace);\n        }\n      }\n    }\n    return this;\n  }\n  // Removes inactive faces\n  reindexFaces() {\n    const activeFaces = [];\n    for (let i = 0; i < this.faces.length; i++) {\n      const face = this.faces[i];\n      if (face.mark === Visible) {\n        activeFaces.push(face);\n      }\n    }\n    this.faces = activeFaces;\n    return this;\n  }\n  // Finds the next vertex to create faces with the current hull\n  nextVertexToAdd() {\n    if (this.assigned.isEmpty() === false) {\n      let eyeVertex, maxDistance = 0;\n      const eyeFace = this.assigned.first().face;\n      let vertex = eyeFace.outside;\n      do {\n        const distance = eyeFace.distanceToPoint(vertex.point);\n        if (distance > maxDistance) {\n          maxDistance = distance;\n          eyeVertex = vertex;\n        }\n        vertex = vertex.next;\n      } while (vertex !== null && vertex.face === eyeFace);\n      return eyeVertex;\n    }\n  }\n  // Computes a chain of half edges in CCW order called the 'horizon'.\n  // For an edge to be part of the horizon it must join a face that can see\n  // 'eyePoint' and a face that cannot see 'eyePoint'.\n  computeHorizon(eyePoint, crossEdge, face, horizon) {\n    this.deleteFaceVertices(face);\n    face.mark = Deleted;\n    let edge;\n    if (crossEdge === null) {\n      edge = crossEdge = face.getEdge(0);\n    } else {\n      edge = crossEdge.next;\n    }\n    do {\n      const twinEdge = edge.twin;\n      const oppositeFace = twinEdge.face;\n      if (oppositeFace.mark === Visible) {\n        if (oppositeFace.distanceToPoint(eyePoint) > this.tolerance) {\n          this.computeHorizon(eyePoint, twinEdge, oppositeFace, horizon);\n        } else {\n          horizon.push(edge);\n        }\n      }\n      edge = edge.next;\n    } while (edge !== crossEdge);\n    return this;\n  }\n  // Creates a face with the vertices 'eyeVertex.point', 'horizonEdge.tail' and 'horizonEdge.head' in CCW order\n  addAdjoiningFace(eyeVertex, horizonEdge) {\n    const face = Face.create(eyeVertex, horizonEdge.tail(), horizonEdge.head());\n    this.faces.push(face);\n    face.getEdge(-1).setTwin(horizonEdge.twin);\n    return face.getEdge(0);\n  }\n  //  Adds 'horizon.length' faces to the hull, each face will be linked with the\n  //  horizon opposite face and the face on the left/right\n  addNewFaces(eyeVertex, horizon) {\n    this.newFaces = [];\n    let firstSideEdge = null;\n    let previousSideEdge = null;\n    for (let i = 0; i < horizon.length; i++) {\n      const horizonEdge = horizon[i];\n      const sideEdge = this.addAdjoiningFace(eyeVertex, horizonEdge);\n      if (firstSideEdge === null) {\n        firstSideEdge = sideEdge;\n      } else {\n        sideEdge.next.setTwin(previousSideEdge);\n      }\n      this.newFaces.push(sideEdge.face);\n      previousSideEdge = sideEdge;\n    }\n    firstSideEdge.next.setTwin(previousSideEdge);\n    return this;\n  }\n  // Adds a vertex to the hull\n  addVertexToHull(eyeVertex) {\n    const horizon = [];\n    this.unassigned.clear();\n    this.removeVertexFromFace(eyeVertex, eyeVertex.face);\n    this.computeHorizon(eyeVertex.point, null, eyeVertex.face, horizon);\n    this.addNewFaces(eyeVertex, horizon);\n    this.resolveUnassignedPoints(this.newFaces);\n    return this;\n  }\n  cleanup() {\n    this.assigned.clear();\n    this.unassigned.clear();\n    this.newFaces = [];\n    return this;\n  }\n  compute() {\n    let vertex;\n    this.computeInitialHull();\n    while ((vertex = this.nextVertexToAdd()) !== void 0) {\n      this.addVertexToHull(vertex);\n    }\n    this.reindexFaces();\n    this.cleanup();\n    return this;\n  }\n}\nclass Face {\n  constructor() {\n    this.normal = new Vector3();\n    this.midpoint = new Vector3();\n    this.area = 0;\n    this.constant = 0;\n    this.outside = null;\n    this.mark = Visible;\n    this.edge = null;\n  }\n  static create(a, b, c) {\n    const face = new Face();\n    const e0 = new HalfEdge(a, face);\n    const e1 = new HalfEdge(b, face);\n    const e2 = new HalfEdge(c, face);\n    e0.next = e2.prev = e1;\n    e1.next = e0.prev = e2;\n    e2.next = e1.prev = e0;\n    face.edge = e0;\n    return face.compute();\n  }\n  getEdge(i) {\n    let edge = this.edge;\n    while (i > 0) {\n      edge = edge.next;\n      i--;\n    }\n    while (i < 0) {\n      edge = edge.prev;\n      i++;\n    }\n    return edge;\n  }\n  compute() {\n    const a = this.edge.tail();\n    const b = this.edge.head();\n    const c = this.edge.next.head();\n    _triangle.set(a.point, b.point, c.point);\n    _triangle.getNormal(this.normal);\n    _triangle.getMidpoint(this.midpoint);\n    this.area = _triangle.getArea();\n    this.constant = this.normal.dot(this.midpoint);\n    return this;\n  }\n  distanceToPoint(point) {\n    return this.normal.dot(point) - this.constant;\n  }\n}\nclass HalfEdge {\n  constructor(vertex, face) {\n    this.vertex = vertex;\n    this.prev = null;\n    this.next = null;\n    this.twin = null;\n    this.face = face;\n  }\n  head() {\n    return this.vertex;\n  }\n  tail() {\n    return this.prev ? this.prev.vertex : null;\n  }\n  length() {\n    const head = this.head();\n    const tail = this.tail();\n    if (tail !== null) {\n      return tail.point.distanceTo(head.point);\n    }\n    return -1;\n  }\n  lengthSquared() {\n    const head = this.head();\n    const tail = this.tail();\n    if (tail !== null) {\n      return tail.point.distanceToSquared(head.point);\n    }\n    return -1;\n  }\n  setTwin(edge) {\n    this.twin = edge;\n    edge.twin = this;\n    return this;\n  }\n}\nclass VertexNode {\n  constructor(point) {\n    this.point = point;\n    this.prev = null;\n    this.next = null;\n    this.face = null;\n  }\n}\nclass VertexList {\n  constructor() {\n    this.head = null;\n    this.tail = null;\n  }\n  first() {\n    return this.head;\n  }\n  last() {\n    return this.tail;\n  }\n  clear() {\n    this.head = this.tail = null;\n    return this;\n  }\n  // Inserts a vertex before the target vertex\n  insertBefore(target, vertex) {\n    vertex.prev = target.prev;\n    vertex.next = target;\n    if (vertex.prev === null) {\n      this.head = vertex;\n    } else {\n      vertex.prev.next = vertex;\n    }\n    target.prev = vertex;\n    return this;\n  }\n  // Inserts a vertex after the target vertex\n  insertAfter(target, vertex) {\n    vertex.prev = target;\n    vertex.next = target.next;\n    if (vertex.next === null) {\n      this.tail = vertex;\n    } else {\n      vertex.next.prev = vertex;\n    }\n    target.next = vertex;\n    return this;\n  }\n  // Appends a vertex to the end of the linked list\n  append(vertex) {\n    if (this.head === null) {\n      this.head = vertex;\n    } else {\n      this.tail.next = vertex;\n    }\n    vertex.prev = this.tail;\n    vertex.next = null;\n    this.tail = vertex;\n    return this;\n  }\n  // Appends a chain of vertices where 'vertex' is the head.\n  appendChain(vertex) {\n    if (this.head === null) {\n      this.head = vertex;\n    } else {\n      this.tail.next = vertex;\n    }\n    vertex.prev = this.tail;\n    while (vertex.next !== null) {\n      vertex = vertex.next;\n    }\n    this.tail = vertex;\n    return this;\n  }\n  // Removes a vertex from the linked list\n  remove(vertex) {\n    if (vertex.prev === null) {\n      this.head = vertex.next;\n    } else {\n      vertex.prev.next = vertex.next;\n    }\n    if (vertex.next === null) {\n      this.tail = vertex.prev;\n    } else {\n      vertex.next.prev = vertex.prev;\n    }\n    return this;\n  }\n  // Removes a list of vertices whose 'head' is 'a' and whose 'tail' is b\n  removeSubList(a, b) {\n    if (a.prev === null) {\n      this.head = b.next;\n    } else {\n      a.prev.next = b.next;\n    }\n    if (b.next === null) {\n      this.tail = a.prev;\n    } else {\n      b.next.prev = a.prev;\n    }\n    return this;\n  }\n  isEmpty() {\n    return this.head === null;\n  }\n}\nexport {\n  ConvexHull,\n  Face,\n  HalfEdge,\n  VertexList,\n  VertexNode\n};\n"]},"metadata":{},"sourceType":"module"}