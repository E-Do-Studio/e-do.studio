{"ast":null,"code":"import { DataTextureLoader, LinearMipmapLinearFilter } from \"three\";\n\nclass TGALoader extends DataTextureLoader {\n  constructor(manager) {\n    super(manager);\n  }\n\n  parse(buffer) {\n    function tgaCheckHeader(header2) {\n      switch (header2.image_type) {\n        case TGA_TYPE_INDEXED:\n        case TGA_TYPE_RLE_INDEXED:\n          if (header2.colormap_length > 256 || header2.colormap_size !== 24 || header2.colormap_type !== 1) {\n            console.error(\"THREE.TGALoader: Invalid type colormap data for indexed type.\");\n          }\n\n          break;\n\n        case TGA_TYPE_RGB:\n        case TGA_TYPE_GREY:\n        case TGA_TYPE_RLE_RGB:\n        case TGA_TYPE_RLE_GREY:\n          if (header2.colormap_type) {\n            console.error(\"THREE.TGALoader: Invalid type colormap data for colormap type.\");\n          }\n\n          break;\n\n        case TGA_TYPE_NO_DATA:\n          console.error(\"THREE.TGALoader: No data.\");\n\n        default:\n          console.error('THREE.TGALoader: Invalid type \"%s\".', header2.image_type);\n      }\n\n      if (header2.width <= 0 || header2.height <= 0) {\n        console.error(\"THREE.TGALoader: Invalid image size.\");\n      }\n\n      if (header2.pixel_size !== 8 && header2.pixel_size !== 16 && header2.pixel_size !== 24 && header2.pixel_size !== 32) {\n        console.error('THREE.TGALoader: Invalid pixel size \"%s\".', header2.pixel_size);\n      }\n    }\n\n    function tgaParse(use_rle2, use_pal2, header2, offset2, data) {\n      let pixel_data, palettes;\n      const pixel_size = header2.pixel_size >> 3;\n      const pixel_total = header2.width * header2.height * pixel_size;\n\n      if (use_pal2) {\n        palettes = data.subarray(offset2, offset2 += header2.colormap_length * (header2.colormap_size >> 3));\n      }\n\n      if (use_rle2) {\n        pixel_data = new Uint8Array(pixel_total);\n        let c, count, i;\n        let shift = 0;\n        const pixels = new Uint8Array(pixel_size);\n\n        while (shift < pixel_total) {\n          c = data[offset2++];\n          count = (c & 127) + 1;\n\n          if (c & 128) {\n            for (i = 0; i < pixel_size; ++i) {\n              pixels[i] = data[offset2++];\n            }\n\n            for (i = 0; i < count; ++i) {\n              pixel_data.set(pixels, shift + i * pixel_size);\n            }\n\n            shift += pixel_size * count;\n          } else {\n            count *= pixel_size;\n\n            for (i = 0; i < count; ++i) {\n              pixel_data[shift + i] = data[offset2++];\n            }\n\n            shift += count;\n          }\n        }\n      } else {\n        pixel_data = data.subarray(offset2, offset2 += use_pal2 ? header2.width * header2.height : pixel_total);\n      }\n\n      return {\n        pixel_data,\n        palettes\n      };\n    }\n\n    function tgaGetImageData8bits(imageData2, y_start, y_step, y_end, x_start, x_step, x_end, image, palettes) {\n      const colormap = palettes;\n      let color,\n          i = 0,\n          x,\n          y;\n      const width = header.width;\n\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i++) {\n          color = image[i];\n          imageData2[(x + width * y) * 4 + 3] = 255;\n          imageData2[(x + width * y) * 4 + 2] = colormap[color * 3 + 0];\n          imageData2[(x + width * y) * 4 + 1] = colormap[color * 3 + 1];\n          imageData2[(x + width * y) * 4 + 0] = colormap[color * 3 + 2];\n        }\n      }\n\n      return imageData2;\n    }\n\n    function tgaGetImageData16bits(imageData2, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n      let color,\n          i = 0,\n          x,\n          y;\n      const width = header.width;\n\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i += 2) {\n          color = image[i + 0] + (image[i + 1] << 8);\n          imageData2[(x + width * y) * 4 + 0] = (color & 31744) >> 7;\n          imageData2[(x + width * y) * 4 + 1] = (color & 992) >> 2;\n          imageData2[(x + width * y) * 4 + 2] = (color & 31) >> 3;\n          imageData2[(x + width * y) * 4 + 3] = color & 32768 ? 0 : 255;\n        }\n      }\n\n      return imageData2;\n    }\n\n    function tgaGetImageData24bits(imageData2, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n      let i = 0,\n          x,\n          y;\n      const width = header.width;\n\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i += 3) {\n          imageData2[(x + width * y) * 4 + 3] = 255;\n          imageData2[(x + width * y) * 4 + 2] = image[i + 0];\n          imageData2[(x + width * y) * 4 + 1] = image[i + 1];\n          imageData2[(x + width * y) * 4 + 0] = image[i + 2];\n        }\n      }\n\n      return imageData2;\n    }\n\n    function tgaGetImageData32bits(imageData2, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n      let i = 0,\n          x,\n          y;\n      const width = header.width;\n\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i += 4) {\n          imageData2[(x + width * y) * 4 + 2] = image[i + 0];\n          imageData2[(x + width * y) * 4 + 1] = image[i + 1];\n          imageData2[(x + width * y) * 4 + 0] = image[i + 2];\n          imageData2[(x + width * y) * 4 + 3] = image[i + 3];\n        }\n      }\n\n      return imageData2;\n    }\n\n    function tgaGetImageDataGrey8bits(imageData2, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n      let color,\n          i = 0,\n          x,\n          y;\n      const width = header.width;\n\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i++) {\n          color = image[i];\n          imageData2[(x + width * y) * 4 + 0] = color;\n          imageData2[(x + width * y) * 4 + 1] = color;\n          imageData2[(x + width * y) * 4 + 2] = color;\n          imageData2[(x + width * y) * 4 + 3] = 255;\n        }\n      }\n\n      return imageData2;\n    }\n\n    function tgaGetImageDataGrey16bits(imageData2, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n      let i = 0,\n          x,\n          y;\n      const width = header.width;\n\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i += 2) {\n          imageData2[(x + width * y) * 4 + 0] = image[i + 0];\n          imageData2[(x + width * y) * 4 + 1] = image[i + 0];\n          imageData2[(x + width * y) * 4 + 2] = image[i + 0];\n          imageData2[(x + width * y) * 4 + 3] = image[i + 1];\n        }\n      }\n\n      return imageData2;\n    }\n\n    function getTgaRGBA(data, width, height, image, palette) {\n      let x_start, y_start, x_step, y_step, x_end, y_end;\n\n      switch ((header.flags & TGA_ORIGIN_MASK) >> TGA_ORIGIN_SHIFT) {\n        default:\n        case TGA_ORIGIN_UL:\n          x_start = 0;\n          x_step = 1;\n          x_end = width;\n          y_start = 0;\n          y_step = 1;\n          y_end = height;\n          break;\n\n        case TGA_ORIGIN_BL:\n          x_start = 0;\n          x_step = 1;\n          x_end = width;\n          y_start = height - 1;\n          y_step = -1;\n          y_end = -1;\n          break;\n\n        case TGA_ORIGIN_UR:\n          x_start = width - 1;\n          x_step = -1;\n          x_end = -1;\n          y_start = 0;\n          y_step = 1;\n          y_end = height;\n          break;\n\n        case TGA_ORIGIN_BR:\n          x_start = width - 1;\n          x_step = -1;\n          x_end = -1;\n          y_start = height - 1;\n          y_step = -1;\n          y_end = -1;\n          break;\n      }\n\n      if (use_grey) {\n        switch (header.pixel_size) {\n          case 8:\n            tgaGetImageDataGrey8bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n            break;\n\n          case 16:\n            tgaGetImageDataGrey16bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n            break;\n\n          default:\n            console.error(\"THREE.TGALoader: Format not supported.\");\n            break;\n        }\n      } else {\n        switch (header.pixel_size) {\n          case 8:\n            tgaGetImageData8bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image, palette);\n            break;\n\n          case 16:\n            tgaGetImageData16bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n            break;\n\n          case 24:\n            tgaGetImageData24bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n            break;\n\n          case 32:\n            tgaGetImageData32bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n            break;\n\n          default:\n            console.error(\"THREE.TGALoader: Format not supported.\");\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    const TGA_TYPE_NO_DATA = 0,\n          TGA_TYPE_INDEXED = 1,\n          TGA_TYPE_RGB = 2,\n          TGA_TYPE_GREY = 3,\n          TGA_TYPE_RLE_INDEXED = 9,\n          TGA_TYPE_RLE_RGB = 10,\n          TGA_TYPE_RLE_GREY = 11,\n          TGA_ORIGIN_MASK = 48,\n          TGA_ORIGIN_SHIFT = 4,\n          TGA_ORIGIN_BL = 0,\n          TGA_ORIGIN_BR = 1,\n          TGA_ORIGIN_UL = 2,\n          TGA_ORIGIN_UR = 3;\n    if (buffer.length < 19) console.error(\"THREE.TGALoader: Not enough data to contain header.\");\n    let offset = 0;\n    const content = new Uint8Array(buffer),\n          header = {\n      id_length: content[offset++],\n      colormap_type: content[offset++],\n      image_type: content[offset++],\n      colormap_index: content[offset++] | content[offset++] << 8,\n      colormap_length: content[offset++] | content[offset++] << 8,\n      colormap_size: content[offset++],\n      origin: [content[offset++] | content[offset++] << 8, content[offset++] | content[offset++] << 8],\n      width: content[offset++] | content[offset++] << 8,\n      height: content[offset++] | content[offset++] << 8,\n      pixel_size: content[offset++],\n      flags: content[offset++]\n    };\n    tgaCheckHeader(header);\n\n    if (header.id_length + offset > buffer.length) {\n      console.error(\"THREE.TGALoader: No data.\");\n    }\n\n    offset += header.id_length;\n    let use_rle = false,\n        use_pal = false,\n        use_grey = false;\n\n    switch (header.image_type) {\n      case TGA_TYPE_RLE_INDEXED:\n        use_rle = true;\n        use_pal = true;\n        break;\n\n      case TGA_TYPE_INDEXED:\n        use_pal = true;\n        break;\n\n      case TGA_TYPE_RLE_RGB:\n        use_rle = true;\n        break;\n\n      case TGA_TYPE_RGB:\n        break;\n\n      case TGA_TYPE_RLE_GREY:\n        use_rle = true;\n        use_grey = true;\n        break;\n\n      case TGA_TYPE_GREY:\n        use_grey = true;\n        break;\n    }\n\n    const imageData = new Uint8Array(header.width * header.height * 4);\n    const result = tgaParse(use_rle, use_pal, header, offset, content);\n    getTgaRGBA(imageData, header.width, header.height, result.pixel_data, result.palettes);\n    return {\n      data: imageData,\n      width: header.width,\n      height: header.height,\n      flipY: true,\n      generateMipmaps: true,\n      minFilter: LinearMipmapLinearFilter\n    };\n  }\n\n}\n\nexport { TGALoader };","map":{"version":3,"sources":["/Users/theodaguier/Repositories/E-Do-Studio/node_modules/three-stdlib/loaders/TGALoader.js"],"names":["DataTextureLoader","LinearMipmapLinearFilter","TGALoader","constructor","manager","parse","buffer","tgaCheckHeader","header2","image_type","TGA_TYPE_INDEXED","TGA_TYPE_RLE_INDEXED","colormap_length","colormap_size","colormap_type","console","error","TGA_TYPE_RGB","TGA_TYPE_GREY","TGA_TYPE_RLE_RGB","TGA_TYPE_RLE_GREY","TGA_TYPE_NO_DATA","width","height","pixel_size","tgaParse","use_rle2","use_pal2","offset2","data","pixel_data","palettes","pixel_total","subarray","Uint8Array","c","count","i","shift","pixels","set","tgaGetImageData8bits","imageData2","y_start","y_step","y_end","x_start","x_step","x_end","image","colormap","color","x","y","header","tgaGetImageData16bits","tgaGetImageData24bits","tgaGetImageData32bits","tgaGetImageDataGrey8bits","tgaGetImageDataGrey16bits","getTgaRGBA","palette","flags","TGA_ORIGIN_MASK","TGA_ORIGIN_SHIFT","TGA_ORIGIN_UL","TGA_ORIGIN_BL","TGA_ORIGIN_UR","TGA_ORIGIN_BR","use_grey","length","offset","content","id_length","colormap_index","origin","use_rle","use_pal","imageData","result","flipY","generateMipmaps","minFilter"],"mappings":"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","sourcesContent":["import { DataTextureLoader, LinearMipmapLinearFilter } from \"three\";\nclass TGALoader extends DataTextureLoader {\n  constructor(manager) {\n    super(manager);\n  }\n  parse(buffer) {\n    function tgaCheckHeader(header2) {\n      switch (header2.image_type) {\n        case TGA_TYPE_INDEXED:\n        case TGA_TYPE_RLE_INDEXED:\n          if (header2.colormap_length > 256 || header2.colormap_size !== 24 || header2.colormap_type !== 1) {\n            console.error(\"THREE.TGALoader: Invalid type colormap data for indexed type.\");\n          }\n          break;\n        case TGA_TYPE_RGB:\n        case TGA_TYPE_GREY:\n        case TGA_TYPE_RLE_RGB:\n        case TGA_TYPE_RLE_GREY:\n          if (header2.colormap_type) {\n            console.error(\"THREE.TGALoader: Invalid type colormap data for colormap type.\");\n          }\n          break;\n        case TGA_TYPE_NO_DATA:\n          console.error(\"THREE.TGALoader: No data.\");\n        default:\n          console.error('THREE.TGALoader: Invalid type \"%s\".', header2.image_type);\n      }\n      if (header2.width <= 0 || header2.height <= 0) {\n        console.error(\"THREE.TGALoader: Invalid image size.\");\n      }\n      if (header2.pixel_size !== 8 && header2.pixel_size !== 16 && header2.pixel_size !== 24 && header2.pixel_size !== 32) {\n        console.error('THREE.TGALoader: Invalid pixel size \"%s\".', header2.pixel_size);\n      }\n    }\n    function tgaParse(use_rle2, use_pal2, header2, offset2, data) {\n      let pixel_data, palettes;\n      const pixel_size = header2.pixel_size >> 3;\n      const pixel_total = header2.width * header2.height * pixel_size;\n      if (use_pal2) {\n        palettes = data.subarray(offset2, offset2 += header2.colormap_length * (header2.colormap_size >> 3));\n      }\n      if (use_rle2) {\n        pixel_data = new Uint8Array(pixel_total);\n        let c, count, i;\n        let shift = 0;\n        const pixels = new Uint8Array(pixel_size);\n        while (shift < pixel_total) {\n          c = data[offset2++];\n          count = (c & 127) + 1;\n          if (c & 128) {\n            for (i = 0; i < pixel_size; ++i) {\n              pixels[i] = data[offset2++];\n            }\n            for (i = 0; i < count; ++i) {\n              pixel_data.set(pixels, shift + i * pixel_size);\n            }\n            shift += pixel_size * count;\n          } else {\n            count *= pixel_size;\n            for (i = 0; i < count; ++i) {\n              pixel_data[shift + i] = data[offset2++];\n            }\n            shift += count;\n          }\n        }\n      } else {\n        pixel_data = data.subarray(offset2, offset2 += use_pal2 ? header2.width * header2.height : pixel_total);\n      }\n      return {\n        pixel_data,\n        palettes\n      };\n    }\n    function tgaGetImageData8bits(imageData2, y_start, y_step, y_end, x_start, x_step, x_end, image, palettes) {\n      const colormap = palettes;\n      let color, i = 0, x, y;\n      const width = header.width;\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i++) {\n          color = image[i];\n          imageData2[(x + width * y) * 4 + 3] = 255;\n          imageData2[(x + width * y) * 4 + 2] = colormap[color * 3 + 0];\n          imageData2[(x + width * y) * 4 + 1] = colormap[color * 3 + 1];\n          imageData2[(x + width * y) * 4 + 0] = colormap[color * 3 + 2];\n        }\n      }\n      return imageData2;\n    }\n    function tgaGetImageData16bits(imageData2, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n      let color, i = 0, x, y;\n      const width = header.width;\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i += 2) {\n          color = image[i + 0] + (image[i + 1] << 8);\n          imageData2[(x + width * y) * 4 + 0] = (color & 31744) >> 7;\n          imageData2[(x + width * y) * 4 + 1] = (color & 992) >> 2;\n          imageData2[(x + width * y) * 4 + 2] = (color & 31) >> 3;\n          imageData2[(x + width * y) * 4 + 3] = color & 32768 ? 0 : 255;\n        }\n      }\n      return imageData2;\n    }\n    function tgaGetImageData24bits(imageData2, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n      let i = 0, x, y;\n      const width = header.width;\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i += 3) {\n          imageData2[(x + width * y) * 4 + 3] = 255;\n          imageData2[(x + width * y) * 4 + 2] = image[i + 0];\n          imageData2[(x + width * y) * 4 + 1] = image[i + 1];\n          imageData2[(x + width * y) * 4 + 0] = image[i + 2];\n        }\n      }\n      return imageData2;\n    }\n    function tgaGetImageData32bits(imageData2, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n      let i = 0, x, y;\n      const width = header.width;\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i += 4) {\n          imageData2[(x + width * y) * 4 + 2] = image[i + 0];\n          imageData2[(x + width * y) * 4 + 1] = image[i + 1];\n          imageData2[(x + width * y) * 4 + 0] = image[i + 2];\n          imageData2[(x + width * y) * 4 + 3] = image[i + 3];\n        }\n      }\n      return imageData2;\n    }\n    function tgaGetImageDataGrey8bits(imageData2, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n      let color, i = 0, x, y;\n      const width = header.width;\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i++) {\n          color = image[i];\n          imageData2[(x + width * y) * 4 + 0] = color;\n          imageData2[(x + width * y) * 4 + 1] = color;\n          imageData2[(x + width * y) * 4 + 2] = color;\n          imageData2[(x + width * y) * 4 + 3] = 255;\n        }\n      }\n      return imageData2;\n    }\n    function tgaGetImageDataGrey16bits(imageData2, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n      let i = 0, x, y;\n      const width = header.width;\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i += 2) {\n          imageData2[(x + width * y) * 4 + 0] = image[i + 0];\n          imageData2[(x + width * y) * 4 + 1] = image[i + 0];\n          imageData2[(x + width * y) * 4 + 2] = image[i + 0];\n          imageData2[(x + width * y) * 4 + 3] = image[i + 1];\n        }\n      }\n      return imageData2;\n    }\n    function getTgaRGBA(data, width, height, image, palette) {\n      let x_start, y_start, x_step, y_step, x_end, y_end;\n      switch ((header.flags & TGA_ORIGIN_MASK) >> TGA_ORIGIN_SHIFT) {\n        default:\n        case TGA_ORIGIN_UL:\n          x_start = 0;\n          x_step = 1;\n          x_end = width;\n          y_start = 0;\n          y_step = 1;\n          y_end = height;\n          break;\n        case TGA_ORIGIN_BL:\n          x_start = 0;\n          x_step = 1;\n          x_end = width;\n          y_start = height - 1;\n          y_step = -1;\n          y_end = -1;\n          break;\n        case TGA_ORIGIN_UR:\n          x_start = width - 1;\n          x_step = -1;\n          x_end = -1;\n          y_start = 0;\n          y_step = 1;\n          y_end = height;\n          break;\n        case TGA_ORIGIN_BR:\n          x_start = width - 1;\n          x_step = -1;\n          x_end = -1;\n          y_start = height - 1;\n          y_step = -1;\n          y_end = -1;\n          break;\n      }\n      if (use_grey) {\n        switch (header.pixel_size) {\n          case 8:\n            tgaGetImageDataGrey8bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n            break;\n          case 16:\n            tgaGetImageDataGrey16bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n            break;\n          default:\n            console.error(\"THREE.TGALoader: Format not supported.\");\n            break;\n        }\n      } else {\n        switch (header.pixel_size) {\n          case 8:\n            tgaGetImageData8bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image, palette);\n            break;\n          case 16:\n            tgaGetImageData16bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n            break;\n          case 24:\n            tgaGetImageData24bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n            break;\n          case 32:\n            tgaGetImageData32bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n            break;\n          default:\n            console.error(\"THREE.TGALoader: Format not supported.\");\n            break;\n        }\n      }\n      return data;\n    }\n    const TGA_TYPE_NO_DATA = 0, TGA_TYPE_INDEXED = 1, TGA_TYPE_RGB = 2, TGA_TYPE_GREY = 3, TGA_TYPE_RLE_INDEXED = 9, TGA_TYPE_RLE_RGB = 10, TGA_TYPE_RLE_GREY = 11, TGA_ORIGIN_MASK = 48, TGA_ORIGIN_SHIFT = 4, TGA_ORIGIN_BL = 0, TGA_ORIGIN_BR = 1, TGA_ORIGIN_UL = 2, TGA_ORIGIN_UR = 3;\n    if (buffer.length < 19)\n      console.error(\"THREE.TGALoader: Not enough data to contain header.\");\n    let offset = 0;\n    const content = new Uint8Array(buffer), header = {\n      id_length: content[offset++],\n      colormap_type: content[offset++],\n      image_type: content[offset++],\n      colormap_index: content[offset++] | content[offset++] << 8,\n      colormap_length: content[offset++] | content[offset++] << 8,\n      colormap_size: content[offset++],\n      origin: [content[offset++] | content[offset++] << 8, content[offset++] | content[offset++] << 8],\n      width: content[offset++] | content[offset++] << 8,\n      height: content[offset++] | content[offset++] << 8,\n      pixel_size: content[offset++],\n      flags: content[offset++]\n    };\n    tgaCheckHeader(header);\n    if (header.id_length + offset > buffer.length) {\n      console.error(\"THREE.TGALoader: No data.\");\n    }\n    offset += header.id_length;\n    let use_rle = false, use_pal = false, use_grey = false;\n    switch (header.image_type) {\n      case TGA_TYPE_RLE_INDEXED:\n        use_rle = true;\n        use_pal = true;\n        break;\n      case TGA_TYPE_INDEXED:\n        use_pal = true;\n        break;\n      case TGA_TYPE_RLE_RGB:\n        use_rle = true;\n        break;\n      case TGA_TYPE_RGB:\n        break;\n      case TGA_TYPE_RLE_GREY:\n        use_rle = true;\n        use_grey = true;\n        break;\n      case TGA_TYPE_GREY:\n        use_grey = true;\n        break;\n    }\n    const imageData = new Uint8Array(header.width * header.height * 4);\n    const result = tgaParse(use_rle, use_pal, header, offset, content);\n    getTgaRGBA(imageData, header.width, header.height, result.pixel_data, result.palettes);\n    return {\n      data: imageData,\n      width: header.width,\n      height: header.height,\n      flipY: true,\n      generateMipmaps: true,\n      minFilter: LinearMipmapLinearFilter\n    };\n  }\n}\nexport {\n  TGALoader\n};\n"]},"metadata":{},"sourceType":"module"}