{"ast":null,"code":"import { Loader, FileLoader, BufferGeometry, Float32BufferAttribute, LoaderUtils } from \"three\";\n\nclass PLYLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.propertyNameMapping = {};\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType(\"arraybuffer\");\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(text));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n\n  setPropertyNameMapping(mapping) {\n    this.propertyNameMapping = mapping;\n  }\n\n  parse(data) {\n    function parseHeader(data2) {\n      const patternHeader = /ply([\\s\\S]*)end_header\\r?\\n/;\n      let headerText = \"\";\n      let headerLength = 0;\n      const result = patternHeader.exec(data2);\n\n      if (result !== null) {\n        headerText = result[1];\n        headerLength = new Blob([result[0]]).size;\n      }\n\n      const header = {\n        comments: [],\n        elements: [],\n        headerLength,\n        objInfo: \"\"\n      };\n      const lines = headerText.split(\"\\n\");\n      let currentElement;\n\n      function make_ply_element_property(propertValues, propertyNameMapping) {\n        const property = {\n          type: propertValues[0]\n        };\n\n        if (property.type === \"list\") {\n          property.name = propertValues[3];\n          property.countType = propertValues[1];\n          property.itemType = propertValues[2];\n        } else {\n          property.name = propertValues[1];\n        }\n\n        if (property.name in propertyNameMapping) {\n          property.name = propertyNameMapping[property.name];\n        }\n\n        return property;\n      }\n\n      for (let i = 0; i < lines.length; i++) {\n        let line = lines[i];\n        line = line.trim();\n        if (line === \"\") continue;\n        const lineValues = line.split(/\\s+/);\n        const lineType = lineValues.shift();\n        line = lineValues.join(\" \");\n\n        switch (lineType) {\n          case \"format\":\n            header.format = lineValues[0];\n            header.version = lineValues[1];\n            break;\n\n          case \"comment\":\n            header.comments.push(line);\n            break;\n\n          case \"element\":\n            if (currentElement !== void 0) {\n              header.elements.push(currentElement);\n            }\n\n            currentElement = {};\n            currentElement.name = lineValues[0];\n            currentElement.count = parseInt(lineValues[1]);\n            currentElement.properties = [];\n            break;\n\n          case \"property\":\n            currentElement.properties.push(make_ply_element_property(lineValues, scope.propertyNameMapping));\n            break;\n\n          case \"obj_info\":\n            header.objInfo = line;\n            break;\n\n          default:\n            console.log(\"unhandled\", lineType, lineValues);\n        }\n      }\n\n      if (currentElement !== void 0) {\n        header.elements.push(currentElement);\n      }\n\n      return header;\n    }\n\n    function parseASCIINumber(n, type) {\n      switch (type) {\n        case \"char\":\n        case \"uchar\":\n        case \"short\":\n        case \"ushort\":\n        case \"int\":\n        case \"uint\":\n        case \"int8\":\n        case \"uint8\":\n        case \"int16\":\n        case \"uint16\":\n        case \"int32\":\n        case \"uint32\":\n          return parseInt(n);\n\n        case \"float\":\n        case \"double\":\n        case \"float32\":\n        case \"float64\":\n          return parseFloat(n);\n      }\n    }\n\n    function parseASCIIElement(properties, line) {\n      const values = line.split(/\\s+/);\n      const element = {};\n\n      for (let i = 0; i < properties.length; i++) {\n        if (properties[i].type === \"list\") {\n          const list = [];\n          const n = parseASCIINumber(values.shift(), properties[i].countType);\n\n          for (let j = 0; j < n; j++) {\n            list.push(parseASCIINumber(values.shift(), properties[i].itemType));\n          }\n\n          element[properties[i].name] = list;\n        } else {\n          element[properties[i].name] = parseASCIINumber(values.shift(), properties[i].type);\n        }\n      }\n\n      return element;\n    }\n\n    function parseASCII(data2, header) {\n      const buffer = {\n        indices: [],\n        vertices: [],\n        normals: [],\n        uvs: [],\n        faceVertexUvs: [],\n        colors: []\n      };\n      let result;\n      const patternBody = /end_header\\s([\\s\\S]*)$/;\n      let body = \"\";\n\n      if ((result = patternBody.exec(data2)) !== null) {\n        body = result[1];\n      }\n\n      const lines = body.split(\"\\n\");\n      let currentElement = 0;\n      let currentElementCount = 0;\n\n      for (let i = 0; i < lines.length; i++) {\n        let line = lines[i];\n        line = line.trim();\n\n        if (line === \"\") {\n          continue;\n        }\n\n        if (currentElementCount >= header.elements[currentElement].count) {\n          currentElement++;\n          currentElementCount = 0;\n        }\n\n        const element = parseASCIIElement(header.elements[currentElement].properties, line);\n        handleElement(buffer, header.elements[currentElement].name, element);\n        currentElementCount++;\n      }\n\n      return postProcess(buffer);\n    }\n\n    function postProcess(buffer) {\n      let geometry2 = new BufferGeometry();\n\n      if (buffer.indices.length > 0) {\n        geometry2.setIndex(buffer.indices);\n      }\n\n      geometry2.setAttribute(\"position\", new Float32BufferAttribute(buffer.vertices, 3));\n\n      if (buffer.normals.length > 0) {\n        geometry2.setAttribute(\"normal\", new Float32BufferAttribute(buffer.normals, 3));\n      }\n\n      if (buffer.uvs.length > 0) {\n        geometry2.setAttribute(\"uv\", new Float32BufferAttribute(buffer.uvs, 2));\n      }\n\n      if (buffer.colors.length > 0) {\n        geometry2.setAttribute(\"color\", new Float32BufferAttribute(buffer.colors, 3));\n      }\n\n      if (buffer.faceVertexUvs.length > 0) {\n        geometry2 = geometry2.toNonIndexed();\n        geometry2.setAttribute(\"uv\", new Float32BufferAttribute(buffer.faceVertexUvs, 2));\n      }\n\n      geometry2.computeBoundingSphere();\n      return geometry2;\n    }\n\n    function handleElement(buffer, elementName, element) {\n      if (elementName === \"vertex\") {\n        buffer.vertices.push(element.x, element.y, element.z);\n\n        if (\"nx\" in element && \"ny\" in element && \"nz\" in element) {\n          buffer.normals.push(element.nx, element.ny, element.nz);\n        }\n\n        if (\"s\" in element && \"t\" in element) {\n          buffer.uvs.push(element.s, element.t);\n        }\n\n        if (\"red\" in element && \"green\" in element && \"blue\" in element) {\n          buffer.colors.push(element.red / 255, element.green / 255, element.blue / 255);\n        }\n      } else if (elementName === \"face\") {\n        const vertex_indices = element.vertex_indices || element.vertex_index;\n        const texcoord = element.texcoord;\n\n        if (vertex_indices.length === 3) {\n          buffer.indices.push(vertex_indices[0], vertex_indices[1], vertex_indices[2]);\n\n          if (texcoord && texcoord.length === 6) {\n            buffer.faceVertexUvs.push(texcoord[0], texcoord[1]);\n            buffer.faceVertexUvs.push(texcoord[2], texcoord[3]);\n            buffer.faceVertexUvs.push(texcoord[4], texcoord[5]);\n          }\n        } else if (vertex_indices.length === 4) {\n          buffer.indices.push(vertex_indices[0], vertex_indices[1], vertex_indices[3]);\n          buffer.indices.push(vertex_indices[1], vertex_indices[2], vertex_indices[3]);\n        }\n      }\n    }\n\n    function binaryRead(dataview, at, type, little_endian) {\n      switch (type) {\n        case \"int8\":\n        case \"char\":\n          return [dataview.getInt8(at), 1];\n\n        case \"uint8\":\n        case \"uchar\":\n          return [dataview.getUint8(at), 1];\n\n        case \"int16\":\n        case \"short\":\n          return [dataview.getInt16(at, little_endian), 2];\n\n        case \"uint16\":\n        case \"ushort\":\n          return [dataview.getUint16(at, little_endian), 2];\n\n        case \"int32\":\n        case \"int\":\n          return [dataview.getInt32(at, little_endian), 4];\n\n        case \"uint32\":\n        case \"uint\":\n          return [dataview.getUint32(at, little_endian), 4];\n\n        case \"float32\":\n        case \"float\":\n          return [dataview.getFloat32(at, little_endian), 4];\n\n        case \"float64\":\n        case \"double\":\n          return [dataview.getFloat64(at, little_endian), 8];\n      }\n    }\n\n    function binaryReadElement(dataview, at, properties, little_endian) {\n      const element = {};\n      let result,\n          read = 0;\n\n      for (let i = 0; i < properties.length; i++) {\n        if (properties[i].type === \"list\") {\n          const list = [];\n          result = binaryRead(dataview, at + read, properties[i].countType, little_endian);\n          const n = result[0];\n          read += result[1];\n\n          for (let j = 0; j < n; j++) {\n            result = binaryRead(dataview, at + read, properties[i].itemType, little_endian);\n            list.push(result[0]);\n            read += result[1];\n          }\n\n          element[properties[i].name] = list;\n        } else {\n          result = binaryRead(dataview, at + read, properties[i].type, little_endian);\n          element[properties[i].name] = result[0];\n          read += result[1];\n        }\n      }\n\n      return [element, read];\n    }\n\n    function parseBinary(data2, header) {\n      const buffer = {\n        indices: [],\n        vertices: [],\n        normals: [],\n        uvs: [],\n        faceVertexUvs: [],\n        colors: []\n      };\n      const little_endian = header.format === \"binary_little_endian\";\n      const body = new DataView(data2, header.headerLength);\n      let result,\n          loc = 0;\n\n      for (let currentElement = 0; currentElement < header.elements.length; currentElement++) {\n        for (let currentElementCount = 0; currentElementCount < header.elements[currentElement].count; currentElementCount++) {\n          result = binaryReadElement(body, loc, header.elements[currentElement].properties, little_endian);\n          loc += result[1];\n          const element = result[0];\n          handleElement(buffer, header.elements[currentElement].name, element);\n        }\n      }\n\n      return postProcess(buffer);\n    }\n\n    let geometry;\n    const scope = this;\n\n    if (data instanceof ArrayBuffer) {\n      const text = LoaderUtils.decodeText(new Uint8Array(data));\n      const header = parseHeader(text);\n      geometry = header.format === \"ascii\" ? parseASCII(text, header) : parseBinary(data, header);\n    } else {\n      geometry = parseASCII(data, parseHeader(data));\n    }\n\n    return geometry;\n  }\n\n}\n\nexport { PLYLoader };","map":{"version":3,"sources":["/Users/theodaguier/_workdir/dev/pro/e-do/E-Do-Studio/node_modules/three-stdlib/loaders/PLYLoader.js"],"names":["Loader","FileLoader","BufferGeometry","Float32BufferAttribute","LoaderUtils","PLYLoader","constructor","manager","propertyNameMapping","load","url","onLoad","onProgress","onError","scope","loader","setPath","path","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","e","console","error","itemError","setPropertyNameMapping","mapping","data","parseHeader","data2","patternHeader","headerText","headerLength","result","exec","Blob","size","header","comments","elements","objInfo","lines","split","currentElement","make_ply_element_property","propertValues","property","type","name","countType","itemType","i","length","line","trim","lineValues","lineType","shift","join","format","version","push","count","parseInt","properties","log","parseASCIINumber","n","parseFloat","parseASCIIElement","values","element","list","j","parseASCII","buffer","indices","vertices","normals","uvs","faceVertexUvs","colors","patternBody","body","currentElementCount","handleElement","postProcess","geometry2","setIndex","setAttribute","toNonIndexed","computeBoundingSphere","elementName","x","y","z","nx","ny","nz","s","t","red","green","blue","vertex_indices","vertex_index","texcoord","binaryRead","dataview","at","little_endian","getInt8","getUint8","getInt16","getUint16","getInt32","getUint32","getFloat32","getFloat64","binaryReadElement","read","parseBinary","DataView","loc","geometry","ArrayBuffer","decodeText","Uint8Array"],"mappings":"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","sourcesContent":["import { Loader, FileLoader, BufferGeometry, Float32BufferAttribute, LoaderUtils } from \"three\";\nclass PLYLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.propertyNameMapping = {};\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType(\"arraybuffer\");\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(\n      url,\n      function(text) {\n        try {\n          onLoad(scope.parse(text));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n          scope.manager.itemError(url);\n        }\n      },\n      onProgress,\n      onError\n    );\n  }\n  setPropertyNameMapping(mapping) {\n    this.propertyNameMapping = mapping;\n  }\n  parse(data) {\n    function parseHeader(data2) {\n      const patternHeader = /ply([\\s\\S]*)end_header\\r?\\n/;\n      let headerText = \"\";\n      let headerLength = 0;\n      const result = patternHeader.exec(data2);\n      if (result !== null) {\n        headerText = result[1];\n        headerLength = new Blob([result[0]]).size;\n      }\n      const header = {\n        comments: [],\n        elements: [],\n        headerLength,\n        objInfo: \"\"\n      };\n      const lines = headerText.split(\"\\n\");\n      let currentElement;\n      function make_ply_element_property(propertValues, propertyNameMapping) {\n        const property = { type: propertValues[0] };\n        if (property.type === \"list\") {\n          property.name = propertValues[3];\n          property.countType = propertValues[1];\n          property.itemType = propertValues[2];\n        } else {\n          property.name = propertValues[1];\n        }\n        if (property.name in propertyNameMapping) {\n          property.name = propertyNameMapping[property.name];\n        }\n        return property;\n      }\n      for (let i = 0; i < lines.length; i++) {\n        let line = lines[i];\n        line = line.trim();\n        if (line === \"\")\n          continue;\n        const lineValues = line.split(/\\s+/);\n        const lineType = lineValues.shift();\n        line = lineValues.join(\" \");\n        switch (lineType) {\n          case \"format\":\n            header.format = lineValues[0];\n            header.version = lineValues[1];\n            break;\n          case \"comment\":\n            header.comments.push(line);\n            break;\n          case \"element\":\n            if (currentElement !== void 0) {\n              header.elements.push(currentElement);\n            }\n            currentElement = {};\n            currentElement.name = lineValues[0];\n            currentElement.count = parseInt(lineValues[1]);\n            currentElement.properties = [];\n            break;\n          case \"property\":\n            currentElement.properties.push(make_ply_element_property(lineValues, scope.propertyNameMapping));\n            break;\n          case \"obj_info\":\n            header.objInfo = line;\n            break;\n          default:\n            console.log(\"unhandled\", lineType, lineValues);\n        }\n      }\n      if (currentElement !== void 0) {\n        header.elements.push(currentElement);\n      }\n      return header;\n    }\n    function parseASCIINumber(n, type) {\n      switch (type) {\n        case \"char\":\n        case \"uchar\":\n        case \"short\":\n        case \"ushort\":\n        case \"int\":\n        case \"uint\":\n        case \"int8\":\n        case \"uint8\":\n        case \"int16\":\n        case \"uint16\":\n        case \"int32\":\n        case \"uint32\":\n          return parseInt(n);\n        case \"float\":\n        case \"double\":\n        case \"float32\":\n        case \"float64\":\n          return parseFloat(n);\n      }\n    }\n    function parseASCIIElement(properties, line) {\n      const values = line.split(/\\s+/);\n      const element = {};\n      for (let i = 0; i < properties.length; i++) {\n        if (properties[i].type === \"list\") {\n          const list = [];\n          const n = parseASCIINumber(values.shift(), properties[i].countType);\n          for (let j = 0; j < n; j++) {\n            list.push(parseASCIINumber(values.shift(), properties[i].itemType));\n          }\n          element[properties[i].name] = list;\n        } else {\n          element[properties[i].name] = parseASCIINumber(values.shift(), properties[i].type);\n        }\n      }\n      return element;\n    }\n    function parseASCII(data2, header) {\n      const buffer = {\n        indices: [],\n        vertices: [],\n        normals: [],\n        uvs: [],\n        faceVertexUvs: [],\n        colors: []\n      };\n      let result;\n      const patternBody = /end_header\\s([\\s\\S]*)$/;\n      let body = \"\";\n      if ((result = patternBody.exec(data2)) !== null) {\n        body = result[1];\n      }\n      const lines = body.split(\"\\n\");\n      let currentElement = 0;\n      let currentElementCount = 0;\n      for (let i = 0; i < lines.length; i++) {\n        let line = lines[i];\n        line = line.trim();\n        if (line === \"\") {\n          continue;\n        }\n        if (currentElementCount >= header.elements[currentElement].count) {\n          currentElement++;\n          currentElementCount = 0;\n        }\n        const element = parseASCIIElement(header.elements[currentElement].properties, line);\n        handleElement(buffer, header.elements[currentElement].name, element);\n        currentElementCount++;\n      }\n      return postProcess(buffer);\n    }\n    function postProcess(buffer) {\n      let geometry2 = new BufferGeometry();\n      if (buffer.indices.length > 0) {\n        geometry2.setIndex(buffer.indices);\n      }\n      geometry2.setAttribute(\"position\", new Float32BufferAttribute(buffer.vertices, 3));\n      if (buffer.normals.length > 0) {\n        geometry2.setAttribute(\"normal\", new Float32BufferAttribute(buffer.normals, 3));\n      }\n      if (buffer.uvs.length > 0) {\n        geometry2.setAttribute(\"uv\", new Float32BufferAttribute(buffer.uvs, 2));\n      }\n      if (buffer.colors.length > 0) {\n        geometry2.setAttribute(\"color\", new Float32BufferAttribute(buffer.colors, 3));\n      }\n      if (buffer.faceVertexUvs.length > 0) {\n        geometry2 = geometry2.toNonIndexed();\n        geometry2.setAttribute(\"uv\", new Float32BufferAttribute(buffer.faceVertexUvs, 2));\n      }\n      geometry2.computeBoundingSphere();\n      return geometry2;\n    }\n    function handleElement(buffer, elementName, element) {\n      if (elementName === \"vertex\") {\n        buffer.vertices.push(element.x, element.y, element.z);\n        if (\"nx\" in element && \"ny\" in element && \"nz\" in element) {\n          buffer.normals.push(element.nx, element.ny, element.nz);\n        }\n        if (\"s\" in element && \"t\" in element) {\n          buffer.uvs.push(element.s, element.t);\n        }\n        if (\"red\" in element && \"green\" in element && \"blue\" in element) {\n          buffer.colors.push(element.red / 255, element.green / 255, element.blue / 255);\n        }\n      } else if (elementName === \"face\") {\n        const vertex_indices = element.vertex_indices || element.vertex_index;\n        const texcoord = element.texcoord;\n        if (vertex_indices.length === 3) {\n          buffer.indices.push(vertex_indices[0], vertex_indices[1], vertex_indices[2]);\n          if (texcoord && texcoord.length === 6) {\n            buffer.faceVertexUvs.push(texcoord[0], texcoord[1]);\n            buffer.faceVertexUvs.push(texcoord[2], texcoord[3]);\n            buffer.faceVertexUvs.push(texcoord[4], texcoord[5]);\n          }\n        } else if (vertex_indices.length === 4) {\n          buffer.indices.push(vertex_indices[0], vertex_indices[1], vertex_indices[3]);\n          buffer.indices.push(vertex_indices[1], vertex_indices[2], vertex_indices[3]);\n        }\n      }\n    }\n    function binaryRead(dataview, at, type, little_endian) {\n      switch (type) {\n        case \"int8\":\n        case \"char\":\n          return [dataview.getInt8(at), 1];\n        case \"uint8\":\n        case \"uchar\":\n          return [dataview.getUint8(at), 1];\n        case \"int16\":\n        case \"short\":\n          return [dataview.getInt16(at, little_endian), 2];\n        case \"uint16\":\n        case \"ushort\":\n          return [dataview.getUint16(at, little_endian), 2];\n        case \"int32\":\n        case \"int\":\n          return [dataview.getInt32(at, little_endian), 4];\n        case \"uint32\":\n        case \"uint\":\n          return [dataview.getUint32(at, little_endian), 4];\n        case \"float32\":\n        case \"float\":\n          return [dataview.getFloat32(at, little_endian), 4];\n        case \"float64\":\n        case \"double\":\n          return [dataview.getFloat64(at, little_endian), 8];\n      }\n    }\n    function binaryReadElement(dataview, at, properties, little_endian) {\n      const element = {};\n      let result, read = 0;\n      for (let i = 0; i < properties.length; i++) {\n        if (properties[i].type === \"list\") {\n          const list = [];\n          result = binaryRead(dataview, at + read, properties[i].countType, little_endian);\n          const n = result[0];\n          read += result[1];\n          for (let j = 0; j < n; j++) {\n            result = binaryRead(dataview, at + read, properties[i].itemType, little_endian);\n            list.push(result[0]);\n            read += result[1];\n          }\n          element[properties[i].name] = list;\n        } else {\n          result = binaryRead(dataview, at + read, properties[i].type, little_endian);\n          element[properties[i].name] = result[0];\n          read += result[1];\n        }\n      }\n      return [element, read];\n    }\n    function parseBinary(data2, header) {\n      const buffer = {\n        indices: [],\n        vertices: [],\n        normals: [],\n        uvs: [],\n        faceVertexUvs: [],\n        colors: []\n      };\n      const little_endian = header.format === \"binary_little_endian\";\n      const body = new DataView(data2, header.headerLength);\n      let result, loc = 0;\n      for (let currentElement = 0; currentElement < header.elements.length; currentElement++) {\n        for (let currentElementCount = 0; currentElementCount < header.elements[currentElement].count; currentElementCount++) {\n          result = binaryReadElement(body, loc, header.elements[currentElement].properties, little_endian);\n          loc += result[1];\n          const element = result[0];\n          handleElement(buffer, header.elements[currentElement].name, element);\n        }\n      }\n      return postProcess(buffer);\n    }\n    let geometry;\n    const scope = this;\n    if (data instanceof ArrayBuffer) {\n      const text = LoaderUtils.decodeText(new Uint8Array(data));\n      const header = parseHeader(text);\n      geometry = header.format === \"ascii\" ? parseASCII(text, header) : parseBinary(data, header);\n    } else {\n      geometry = parseASCII(data, parseHeader(data));\n    }\n    return geometry;\n  }\n}\nexport {\n  PLYLoader\n};\n"]},"metadata":{},"sourceType":"module"}