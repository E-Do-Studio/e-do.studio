{"ast":null,"code":"import _classCallCheck from \"/Users/theodaguier/Repositories/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/theodaguier/Repositories/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { LWO2Parser } from \"./LWO2Parser.js\";\nimport { LWO3Parser } from \"./LWO3Parser.js\";\n\nvar IFFParser = /*#__PURE__*/function () {\n  function IFFParser() {\n    _classCallCheck(this, IFFParser);\n\n    this.debugger = new Debugger();\n  }\n\n  _createClass(IFFParser, [{\n    key: \"parse\",\n    value: function parse(buffer) {\n      this.reader = new DataViewReader(buffer);\n      this.tree = {\n        materials: {},\n        layers: [],\n        tags: [],\n        textures: []\n      };\n      this.currentLayer = this.tree;\n      this.currentForm = this.tree;\n      this.parseTopForm();\n      if (this.tree.format === void 0) return;\n\n      if (this.tree.format === \"LWO2\") {\n        this.parser = new LWO2Parser(this);\n\n        while (!this.reader.endOfFile()) {\n          this.parser.parseBlock();\n        }\n      } else if (this.tree.format === \"LWO3\") {\n        this.parser = new LWO3Parser(this);\n\n        while (!this.reader.endOfFile()) {\n          this.parser.parseBlock();\n        }\n      }\n\n      this.debugger.offset = this.reader.offset;\n      this.debugger.closeForms();\n      return this.tree;\n    }\n  }, {\n    key: \"parseTopForm\",\n    value: function parseTopForm() {\n      this.debugger.offset = this.reader.offset;\n      var topForm = this.reader.getIDTag();\n\n      if (topForm !== \"FORM\") {\n        console.warn(\"LWOLoader: Top-level FORM missing.\");\n        return;\n      }\n\n      var length = this.reader.getUint32();\n      this.debugger.dataOffset = this.reader.offset;\n      this.debugger.length = length;\n      var type = this.reader.getIDTag();\n\n      if (type === \"LWO2\") {\n        this.tree.format = type;\n      } else if (type === \"LWO3\") {\n        this.tree.format = type;\n      }\n\n      this.debugger.node = 0;\n      this.debugger.nodeID = type;\n      this.debugger.log();\n      return;\n    } ///\n    // FORM PARSING METHODS\n    ///\n    // Forms are organisational and can contain any number of sub chunks and sub forms\n    // FORM ::= 'FORM'[ID4], length[U4], type[ID4], ( chunk[CHUNK] | form[FORM] ) * }\n\n  }, {\n    key: \"parseForm\",\n    value: function parseForm(length) {\n      var type = this.reader.getIDTag();\n\n      switch (type) {\n        case \"ISEQ\":\n        case \"ANIM\":\n        case \"STCC\":\n        case \"VPVL\":\n        case \"VPRM\":\n        case \"NROT\":\n        case \"WRPW\":\n        case \"WRPH\":\n        case \"FUNC\":\n        case \"FALL\":\n        case \"OPAC\":\n        case \"GRAD\":\n        case \"ENVS\":\n        case \"VMOP\":\n        case \"VMBG\":\n        case \"OMAX\":\n        case \"STEX\":\n        case \"CKBG\":\n        case \"CKEY\":\n        case \"VMLA\":\n        case \"VMLB\":\n          this.debugger.skipped = true;\n          this.skipForm(length);\n          break;\n\n        case \"META\":\n        case \"NNDS\":\n        case \"NODS\":\n        case \"NDTA\":\n        case \"ADAT\":\n        case \"AOVS\":\n        case \"BLOK\":\n        case \"IBGC\":\n        case \"IOPC\":\n        case \"IIMG\":\n        case \"TXTR\":\n          this.debugger.length = 4;\n          this.debugger.skipped = true;\n          break;\n\n        case \"IFAL\":\n        case \"ISCL\":\n        case \"IPOS\":\n        case \"IROT\":\n        case \"IBMP\":\n        case \"IUTD\":\n        case \"IVTD\":\n          this.parseTextureNodeAttribute(type);\n          break;\n\n        case \"ENVL\":\n          this.parseEnvelope(length);\n          break;\n\n        case \"CLIP\":\n          if (this.tree.format === \"LWO2\") {\n            this.parseForm(length);\n          } else {\n            this.parseClip(length);\n          }\n\n          break;\n\n        case \"STIL\":\n          this.parseImage();\n          break;\n\n        case \"XREF\":\n          this.reader.skip(8);\n          this.currentForm.referenceTexture = {\n            index: this.reader.getUint32(),\n            refName: this.reader.getString() // internal unique ref\n\n          };\n          break;\n\n        case \"IMST\":\n          this.parseImageStateForm(length);\n          break;\n\n        case \"SURF\":\n          this.parseSurfaceForm(length);\n          break;\n\n        case \"VALU\":\n          this.parseValueForm(length);\n          break;\n\n        case \"NTAG\":\n          this.parseSubNode(length);\n          break;\n\n        case \"ATTR\":\n        case \"SATR\":\n          this.setupForm(\"attributes\", length);\n          break;\n\n        case \"NCON\":\n          this.parseConnections(length);\n          break;\n\n        case \"SSHA\":\n          this.parentForm = this.currentForm;\n          this.currentForm = this.currentSurface;\n          this.setupForm(\"surfaceShader\", length);\n          break;\n\n        case \"SSHD\":\n          this.setupForm(\"surfaceShaderData\", length);\n          break;\n\n        case \"ENTR\":\n          this.parseEntryForm(length);\n          break;\n\n        case \"IMAP\":\n          this.parseImageMap(length);\n          break;\n\n        case \"TAMP\":\n          this.parseXVAL(\"amplitude\", length);\n          break;\n\n        case \"TMAP\":\n          this.setupForm(\"textureMap\", length);\n          break;\n\n        case \"CNTR\":\n          this.parseXVAL3(\"center\", length);\n          break;\n\n        case \"SIZE\":\n          this.parseXVAL3(\"scale\", length);\n          break;\n\n        case \"ROTA\":\n          this.parseXVAL3(\"rotation\", length);\n          break;\n\n        default:\n          this.parseUnknownForm(type, length);\n      }\n\n      this.debugger.node = 0;\n      this.debugger.nodeID = type;\n      this.debugger.log();\n    }\n  }, {\n    key: \"setupForm\",\n    value: function setupForm(type, length) {\n      if (!this.currentForm) this.currentForm = this.currentNode;\n      this.currentFormEnd = this.reader.offset + length;\n      this.parentForm = this.currentForm;\n\n      if (!this.currentForm[type]) {\n        this.currentForm[type] = {};\n        this.currentForm = this.currentForm[type];\n      } else {\n        console.warn(\"LWOLoader: form already exists on parent: \", type, this.currentForm);\n        this.currentForm = this.currentForm[type];\n      }\n    }\n  }, {\n    key: \"skipForm\",\n    value: function skipForm(length) {\n      this.reader.skip(length - 4);\n    }\n  }, {\n    key: \"parseUnknownForm\",\n    value: function parseUnknownForm(type, length) {\n      console.warn(\"LWOLoader: unknown FORM encountered: \" + type, length);\n      printBuffer(this.reader.dv.buffer, this.reader.offset, length - 4);\n      this.reader.skip(length - 4);\n    }\n  }, {\n    key: \"parseSurfaceForm\",\n    value: function parseSurfaceForm(length) {\n      this.reader.skip(8);\n      var name = this.reader.getString();\n      var surface = {\n        attributes: {},\n        // LWO2 style non-node attributes will go here\n        connections: {},\n        name: name,\n        inputName: name,\n        nodes: {},\n        source: this.reader.getString()\n      };\n      this.tree.materials[name] = surface;\n      this.currentSurface = surface;\n      this.parentForm = this.tree.materials;\n      this.currentForm = surface;\n      this.currentFormEnd = this.reader.offset + length;\n    }\n  }, {\n    key: \"parseSurfaceLwo2\",\n    value: function parseSurfaceLwo2(length) {\n      var name = this.reader.getString();\n      var surface = {\n        attributes: {},\n        // LWO2 style non-node attributes will go here\n        connections: {},\n        name: name,\n        nodes: {},\n        source: this.reader.getString()\n      };\n      this.tree.materials[name] = surface;\n      this.currentSurface = surface;\n      this.parentForm = this.tree.materials;\n      this.currentForm = surface;\n      this.currentFormEnd = this.reader.offset + length;\n    }\n  }, {\n    key: \"parseSubNode\",\n    value: function parseSubNode(length) {\n      this.reader.skip(8);\n      var name = this.reader.getString();\n      var node = {\n        name: name\n      };\n      this.currentForm = node;\n      this.currentNode = node;\n      this.currentFormEnd = this.reader.offset + length;\n    } // collect attributes from all nodes at the top level of a surface\n\n  }, {\n    key: \"parseConnections\",\n    value: function parseConnections(length) {\n      this.currentFormEnd = this.reader.offset + length;\n      this.parentForm = this.currentForm;\n      this.currentForm = this.currentSurface.connections;\n    } // surface node attribute data, e.g. specular, roughness etc\n\n  }, {\n    key: \"parseEntryForm\",\n    value: function parseEntryForm(length) {\n      this.reader.skip(8);\n      var name = this.reader.getString();\n      this.currentForm = this.currentNode.attributes;\n      this.setupForm(name, length);\n    } // parse values from material - doesn't match up to other LWO3 data types\n    // sub form of entry form\n\n  }, {\n    key: \"parseValueForm\",\n    value: function parseValueForm() {\n      this.reader.skip(8);\n      var valueType = this.reader.getString();\n\n      if (valueType === \"double\") {\n        this.currentForm.value = this.reader.getUint64();\n      } else if (valueType === \"int\") {\n        this.currentForm.value = this.reader.getUint32();\n      } else if (valueType === \"vparam\") {\n        this.reader.skip(24);\n        this.currentForm.value = this.reader.getFloat64();\n      } else if (valueType === \"vparam3\") {\n        this.reader.skip(24);\n        this.currentForm.value = this.reader.getFloat64Array(3);\n      }\n    } // holds various data about texture node image state\n    // Data other thanmipMapLevel unknown\n\n  }, {\n    key: \"parseImageStateForm\",\n    value: function parseImageStateForm() {\n      this.reader.skip(8);\n      this.currentForm.mipMapLevel = this.reader.getFloat32();\n    } // LWO2 style image data node OR LWO3 textures defined at top level in editor (not as SURF node)\n\n  }, {\n    key: \"parseImageMap\",\n    value: function parseImageMap(length) {\n      this.currentFormEnd = this.reader.offset + length;\n      this.parentForm = this.currentForm;\n      if (!this.currentForm.maps) this.currentForm.maps = [];\n      var map = {};\n      this.currentForm.maps.push(map);\n      this.currentForm = map;\n      this.reader.skip(10);\n    }\n  }, {\n    key: \"parseTextureNodeAttribute\",\n    value: function parseTextureNodeAttribute(type) {\n      this.reader.skip(28);\n      this.reader.skip(20);\n\n      switch (type) {\n        case \"ISCL\":\n          this.currentNode.scale = this.reader.getFloat32Array(3);\n          break;\n\n        case \"IPOS\":\n          this.currentNode.position = this.reader.getFloat32Array(3);\n          break;\n\n        case \"IROT\":\n          this.currentNode.rotation = this.reader.getFloat32Array(3);\n          break;\n\n        case \"IFAL\":\n          this.currentNode.falloff = this.reader.getFloat32Array(3);\n          break;\n\n        case \"IBMP\":\n          this.currentNode.amplitude = this.reader.getFloat32();\n          break;\n\n        case \"IUTD\":\n          this.currentNode.uTiles = this.reader.getFloat32();\n          break;\n\n        case \"IVTD\":\n          this.currentNode.vTiles = this.reader.getFloat32();\n          break;\n      }\n\n      this.reader.skip(2);\n    } // ENVL forms are currently ignored\n\n  }, {\n    key: \"parseEnvelope\",\n    value: function parseEnvelope(length) {\n      this.reader.skip(length - 4);\n    } ///\n    // CHUNK PARSING METHODS\n    ///\n    // clips can either be defined inside a surface node, or at the top\n    // level and they have a different format in each case\n\n  }, {\n    key: \"parseClip\",\n    value: function parseClip(length) {\n      var tag = this.reader.getIDTag();\n\n      if (tag === \"FORM\") {\n        this.reader.skip(16);\n        this.currentNode.fileName = this.reader.getString();\n        return;\n      }\n\n      this.reader.setOffset(this.reader.offset - 4);\n      this.currentFormEnd = this.reader.offset + length;\n      this.parentForm = this.currentForm;\n      this.reader.skip(8);\n      var texture = {\n        index: this.reader.getUint32()\n      };\n      this.tree.textures.push(texture);\n      this.currentForm = texture;\n    }\n  }, {\n    key: \"parseClipLwo2\",\n    value: function parseClipLwo2(length) {\n      var texture = {\n        index: this.reader.getUint32(),\n        fileName: \"\"\n      };\n\n      while (true) {\n        var tag = this.reader.getIDTag();\n        var n_length = this.reader.getUint16();\n\n        if (tag === \"STIL\") {\n          texture.fileName = this.reader.getString();\n          break;\n        }\n\n        if (n_length >= length) {\n          break;\n        }\n      }\n\n      this.tree.textures.push(texture);\n      this.currentForm = texture;\n    }\n  }, {\n    key: \"parseImage\",\n    value: function parseImage() {\n      this.reader.skip(8);\n      this.currentForm.fileName = this.reader.getString();\n    }\n  }, {\n    key: \"parseXVAL\",\n    value: function parseXVAL(type, length) {\n      var endOffset = this.reader.offset + length - 4;\n      this.reader.skip(8);\n      this.currentForm[type] = this.reader.getFloat32();\n      this.reader.setOffset(endOffset);\n    }\n  }, {\n    key: \"parseXVAL3\",\n    value: function parseXVAL3(type, length) {\n      var endOffset = this.reader.offset + length - 4;\n      this.reader.skip(8);\n      this.currentForm[type] = {\n        x: this.reader.getFloat32(),\n        y: this.reader.getFloat32(),\n        z: this.reader.getFloat32()\n      };\n      this.reader.setOffset(endOffset);\n    } // Tags associated with an object\n    // OTAG { type[ID4], tag-string[S0] }\n\n  }, {\n    key: \"parseObjectTag\",\n    value: function parseObjectTag() {\n      if (!this.tree.objectTags) this.tree.objectTags = {};\n      this.tree.objectTags[this.reader.getIDTag()] = {\n        tagString: this.reader.getString()\n      };\n    } // Signals the start of a new layer. All the data chunks which follow will be included in this layer until another layer chunk is encountered.\n    // LAYR: number[U2], flags[U2], pivot[VEC12], name[S0], parent[U2]\n\n  }, {\n    key: \"parseLayer\",\n    value: function parseLayer(length) {\n      var layer = {\n        number: this.reader.getUint16(),\n        flags: this.reader.getUint16(),\n        // If the least significant bit of flags is set, the layer is hidden.\n        pivot: this.reader.getFloat32Array(3),\n        // Note: this seems to be superflous, as the geometry is translated when pivot is present\n        name: this.reader.getString()\n      };\n      this.tree.layers.push(layer);\n      this.currentLayer = layer;\n      var parsedLength = 16 + stringOffset(this.currentLayer.name);\n      this.currentLayer.parent = parsedLength < length ? this.reader.getUint16() : -1;\n    } // VEC12 * ( F4 + F4 + F4 ) array of x,y,z vectors\n    // Converting from left to right handed coordinate system:\n    // x -> -x and switch material FrontSide -> BackSide\n\n  }, {\n    key: \"parsePoints\",\n    value: function parsePoints(length) {\n      this.currentPoints = [];\n\n      for (var i = 0; i < length / 4; i += 3) {\n        this.currentPoints.push(this.reader.getFloat32(), this.reader.getFloat32(), -this.reader.getFloat32());\n      }\n    } // parse VMAP or VMAD\n    // Associates a set of floating-point vectors with a set of points.\n    // VMAP: { type[ID4], dimension[U2], name[S0], ( vert[VX], value[F4] # dimension ) * }\n    // VMAD Associates a set of floating-point vectors with the vertices of specific polygons.\n    // Similar to VMAP UVs, but associates with polygon vertices rather than points\n    // to solve to problem of UV seams:  VMAD chunks are paired with VMAPs of the same name,\n    // if they exist. The vector values in the VMAD will then replace those in the\n    // corresponding VMAP, but only for calculations involving the specified polygons.\n    // VMAD { type[ID4], dimension[U2], name[S0], ( vert[VX], poly[VX], value[F4] # dimension ) * }\n\n  }, {\n    key: \"parseVertexMapping\",\n    value: function parseVertexMapping(length, discontinuous) {\n      var finalOffset = this.reader.offset + length;\n      var channelName = this.reader.getString();\n\n      if (this.reader.offset === finalOffset) {\n        this.currentForm.UVChannel = channelName;\n        return;\n      }\n\n      this.reader.setOffset(this.reader.offset - stringOffset(channelName));\n      var type = this.reader.getIDTag();\n      this.reader.getUint16();\n      var name = this.reader.getString();\n      var remainingLength = length - 6 - stringOffset(name);\n\n      switch (type) {\n        case \"TXUV\":\n          this.parseUVMapping(name, finalOffset, discontinuous);\n          break;\n\n        case \"MORF\":\n        case \"SPOT\":\n          this.parseMorphTargets(name, finalOffset, type);\n          break;\n\n        case \"APSL\":\n        case \"NORM\":\n        case \"WGHT\":\n        case \"MNVW\":\n        case \"PICK\":\n        case \"RGB \":\n        case \"RGBA\":\n          this.reader.skip(remainingLength);\n          break;\n\n        default:\n          console.warn(\"LWOLoader: unknown vertex map type: \" + type);\n          this.reader.skip(remainingLength);\n      }\n    }\n  }, {\n    key: \"parseUVMapping\",\n    value: function parseUVMapping(name, finalOffset, discontinuous) {\n      var uvIndices = [];\n      var polyIndices = [];\n      var uvs = [];\n\n      while (this.reader.offset < finalOffset) {\n        uvIndices.push(this.reader.getVariableLengthIndex());\n        if (discontinuous) polyIndices.push(this.reader.getVariableLengthIndex());\n        uvs.push(this.reader.getFloat32(), this.reader.getFloat32());\n      }\n\n      if (discontinuous) {\n        if (!this.currentLayer.discontinuousUVs) this.currentLayer.discontinuousUVs = {};\n        this.currentLayer.discontinuousUVs[name] = {\n          uvIndices: uvIndices,\n          polyIndices: polyIndices,\n          uvs: uvs\n        };\n      } else {\n        if (!this.currentLayer.uvs) this.currentLayer.uvs = {};\n        this.currentLayer.uvs[name] = {\n          uvIndices: uvIndices,\n          uvs: uvs\n        };\n      }\n    }\n  }, {\n    key: \"parseMorphTargets\",\n    value: function parseMorphTargets(name, finalOffset, type) {\n      var indices = [];\n      var points = [];\n      type = type === \"MORF\" ? \"relative\" : \"absolute\";\n\n      while (this.reader.offset < finalOffset) {\n        indices.push(this.reader.getVariableLengthIndex());\n        points.push(this.reader.getFloat32(), this.reader.getFloat32(), -this.reader.getFloat32());\n      }\n\n      if (!this.currentLayer.morphTargets) this.currentLayer.morphTargets = {};\n      this.currentLayer.morphTargets[name] = {\n        indices: indices,\n        points: points,\n        type: type\n      };\n    } // A list of polygons for the current layer.\n    // POLS { type[ID4], ( numvert+flags[U2], vert[VX] # numvert ) * }\n\n  }, {\n    key: \"parsePolygonList\",\n    value: function parsePolygonList(length) {\n      var finalOffset = this.reader.offset + length;\n      var type = this.reader.getIDTag();\n      var indices = [];\n      var polygonDimensions = [];\n\n      while (this.reader.offset < finalOffset) {\n        var numverts = this.reader.getUint16();\n        numverts = numverts & 1023;\n        polygonDimensions.push(numverts);\n\n        for (var j = 0; j < numverts; j++) {\n          indices.push(this.reader.getVariableLengthIndex());\n        }\n      }\n\n      var geometryData = {\n        type: type,\n        vertexIndices: indices,\n        polygonDimensions: polygonDimensions,\n        points: this.currentPoints\n      };\n      if (polygonDimensions[0] === 1) geometryData.type = \"points\";else if (polygonDimensions[0] === 2) geometryData.type = \"lines\";\n      this.currentLayer.geometry = geometryData;\n    } // Lists the tag strings that can be associated with polygons by the PTAG chunk.\n    // TAGS { tag-string[S0] * }\n\n  }, {\n    key: \"parseTagStrings\",\n    value: function parseTagStrings(length) {\n      this.tree.tags = this.reader.getStringArray(length);\n    } // Associates tags of a given type with polygons in the most recent POLS chunk.\n    // PTAG { type[ID4], ( poly[VX], tag[U2] ) * }\n\n  }, {\n    key: \"parsePolygonTagMapping\",\n    value: function parsePolygonTagMapping(length) {\n      var finalOffset = this.reader.offset + length;\n      var type = this.reader.getIDTag();\n      if (type === \"SURF\") this.parseMaterialIndices(finalOffset);else {\n        this.reader.skip(length - 4);\n      }\n    }\n  }, {\n    key: \"parseMaterialIndices\",\n    value: function parseMaterialIndices(finalOffset) {\n      this.currentLayer.geometry.materialIndices = [];\n\n      while (this.reader.offset < finalOffset) {\n        var polygonIndex = this.reader.getVariableLengthIndex();\n        var materialIndex = this.reader.getUint16();\n        this.currentLayer.geometry.materialIndices.push(polygonIndex, materialIndex);\n      }\n    }\n  }, {\n    key: \"parseUnknownCHUNK\",\n    value: function parseUnknownCHUNK(blockID, length) {\n      console.warn(\"LWOLoader: unknown chunk type: \" + blockID + \" length: \" + length);\n      var data = this.reader.getString(length);\n      this.currentForm[blockID] = data;\n    }\n  }]);\n\n  return IFFParser;\n}();\n\nvar DataViewReader = /*#__PURE__*/function () {\n  function DataViewReader(buffer) {\n    _classCallCheck(this, DataViewReader);\n\n    this.dv = new DataView(buffer);\n    this.offset = 0;\n    this._textDecoder = new TextDecoder();\n    this._bytes = new Uint8Array(buffer);\n  }\n\n  _createClass(DataViewReader, [{\n    key: \"size\",\n    value: function size() {\n      return this.dv.buffer.byteLength;\n    }\n  }, {\n    key: \"setOffset\",\n    value: function setOffset(offset) {\n      if (offset > 0 && offset < this.dv.buffer.byteLength) {\n        this.offset = offset;\n      } else {\n        console.error(\"LWOLoader: invalid buffer offset\");\n      }\n    }\n  }, {\n    key: \"endOfFile\",\n    value: function endOfFile() {\n      if (this.offset >= this.size()) return true;\n      return false;\n    }\n  }, {\n    key: \"skip\",\n    value: function skip(length) {\n      this.offset += length;\n    }\n  }, {\n    key: \"getUint8\",\n    value: function getUint8() {\n      var value = this.dv.getUint8(this.offset);\n      this.offset += 1;\n      return value;\n    }\n  }, {\n    key: \"getUint16\",\n    value: function getUint16() {\n      var value = this.dv.getUint16(this.offset);\n      this.offset += 2;\n      return value;\n    }\n  }, {\n    key: \"getInt32\",\n    value: function getInt32() {\n      var value = this.dv.getInt32(this.offset, false);\n      this.offset += 4;\n      return value;\n    }\n  }, {\n    key: \"getUint32\",\n    value: function getUint32() {\n      var value = this.dv.getUint32(this.offset, false);\n      this.offset += 4;\n      return value;\n    }\n  }, {\n    key: \"getUint64\",\n    value: function getUint64() {\n      var low, high;\n      high = this.getUint32();\n      low = this.getUint32();\n      return high * 4294967296 + low;\n    }\n  }, {\n    key: \"getFloat32\",\n    value: function getFloat32() {\n      var value = this.dv.getFloat32(this.offset, false);\n      this.offset += 4;\n      return value;\n    }\n  }, {\n    key: \"getFloat32Array\",\n    value: function getFloat32Array(size) {\n      var a = [];\n\n      for (var i = 0; i < size; i++) {\n        a.push(this.getFloat32());\n      }\n\n      return a;\n    }\n  }, {\n    key: \"getFloat64\",\n    value: function getFloat64() {\n      var value = this.dv.getFloat64(this.offset, this.littleEndian);\n      this.offset += 8;\n      return value;\n    }\n  }, {\n    key: \"getFloat64Array\",\n    value: function getFloat64Array(size) {\n      var a = [];\n\n      for (var i = 0; i < size; i++) {\n        a.push(this.getFloat64());\n      }\n\n      return a;\n    } // get variable-length index data type\n    // VX ::= index[U2] | (index + 0xFF000000)[U4]\n    // If the index value is less than 65,280 (0xFF00),then VX === U2\n    // otherwise VX === U4 with bits 24-31 set\n    // When reading an index, if the first byte encountered is 255 (0xFF), then\n    // the four-byte form is being used and the first byte should be discarded or masked out.\n\n  }, {\n    key: \"getVariableLengthIndex\",\n    value: function getVariableLengthIndex() {\n      var firstByte = this.getUint8();\n\n      if (firstByte === 255) {\n        return this.getUint8() * 65536 + this.getUint8() * 256 + this.getUint8();\n      }\n\n      return firstByte * 256 + this.getUint8();\n    } // An ID tag is a sequence of 4 bytes containing 7-bit ASCII values\n\n  }, {\n    key: \"getIDTag\",\n    value: function getIDTag() {\n      return this.getString(4);\n    }\n  }, {\n    key: \"getString\",\n    value: function getString(size) {\n      if (size === 0) return;\n      var start = this.offset;\n      var result;\n      var length;\n\n      if (size) {\n        length = size;\n        result = this._textDecoder.decode(new Uint8Array(this.dv.buffer, start, size));\n      } else {\n        length = this._bytes.indexOf(0, start) - start;\n        result = this._textDecoder.decode(new Uint8Array(this.dv.buffer, start, length));\n        length++;\n        length += length % 2;\n      }\n\n      this.skip(length);\n      return result;\n    }\n  }, {\n    key: \"getStringArray\",\n    value: function getStringArray(size) {\n      var a = this.getString(size);\n      a = a.split(\"\\0\");\n      return a.filter(Boolean);\n    }\n  }]);\n\n  return DataViewReader;\n}();\n\nvar Debugger = /*#__PURE__*/function () {\n  function Debugger() {\n    _classCallCheck(this, Debugger);\n\n    this.active = false;\n    this.depth = 0;\n    this.formList = [];\n  }\n\n  _createClass(Debugger, [{\n    key: \"enable\",\n    value: function enable() {\n      this.active = true;\n    }\n  }, {\n    key: \"log\",\n    value: function log() {\n      if (!this.active) return;\n      var nodeType;\n\n      switch (this.node) {\n        case 0:\n          nodeType = \"FORM\";\n          break;\n\n        case 1:\n          nodeType = \"CHK\";\n          break;\n\n        case 2:\n          nodeType = \"S-CHK\";\n          break;\n      }\n\n      console.log(\"| \".repeat(this.depth) + nodeType, this.nodeID, \"( \".concat(this.offset, \" ) -> ( \").concat(this.dataOffset + this.length, \" )\"), this.node == 0 ? \" {\" : \"\", this.skipped ? \"SKIPPED\" : \"\", this.node == 0 && this.skipped ? \"}\" : \"\");\n\n      if (this.node == 0 && !this.skipped) {\n        this.depth += 1;\n        this.formList.push(this.dataOffset + this.length);\n      }\n\n      this.skipped = false;\n    }\n  }, {\n    key: \"closeForms\",\n    value: function closeForms() {\n      if (!this.active) return;\n\n      for (var i = this.formList.length - 1; i >= 0; i--) {\n        if (this.offset >= this.formList[i]) {\n          this.depth -= 1;\n          console.log(\"| \".repeat(this.depth) + \"}\");\n          this.formList.splice(-1, 1);\n        }\n      }\n    }\n  }]);\n\n  return Debugger;\n}();\n\nfunction isEven(num) {\n  return num % 2;\n}\n\nfunction stringOffset(string) {\n  return string.length + 1 + (isEven(string.length + 1) ? 1 : 0);\n}\n\nfunction printBuffer(buffer, from, to) {\n  console.log(new TextDecoder().decode(new Uint8Array(buffer, from, to)));\n}\n\nexport { IFFParser };","map":{"version":3,"sources":["/Users/theodaguier/Repositories/E-Do-Studio/node_modules/three-stdlib/loaders/lwo/IFFParser.js"],"names":["LWO2Parser","LWO3Parser","IFFParser","debugger","Debugger","buffer","reader","DataViewReader","tree","materials","layers","tags","textures","currentLayer","currentForm","parseTopForm","format","parser","endOfFile","parseBlock","offset","closeForms","topForm","getIDTag","console","warn","length","getUint32","dataOffset","type","node","nodeID","log","skipped","skipForm","parseTextureNodeAttribute","parseEnvelope","parseForm","parseClip","parseImage","skip","referenceTexture","index","refName","getString","parseImageStateForm","parseSurfaceForm","parseValueForm","parseSubNode","setupForm","parseConnections","parentForm","currentSurface","parseEntryForm","parseImageMap","parseXVAL","parseXVAL3","parseUnknownForm","currentNode","currentFormEnd","printBuffer","dv","name","surface","attributes","connections","inputName","nodes","source","valueType","value","getUint64","getFloat64","getFloat64Array","mipMapLevel","getFloat32","maps","map","push","scale","getFloat32Array","position","rotation","falloff","amplitude","uTiles","vTiles","tag","fileName","setOffset","texture","n_length","getUint16","endOffset","x","y","z","objectTags","tagString","layer","number","flags","pivot","parsedLength","stringOffset","parent","currentPoints","i","discontinuous","finalOffset","channelName","UVChannel","remainingLength","parseUVMapping","parseMorphTargets","uvIndices","polyIndices","uvs","getVariableLengthIndex","discontinuousUVs","indices","points","morphTargets","polygonDimensions","numverts","j","geometryData","vertexIndices","geometry","getStringArray","parseMaterialIndices","materialIndices","polygonIndex","materialIndex","blockID","data","DataView","_textDecoder","TextDecoder","_bytes","Uint8Array","byteLength","error","size","getUint8","getInt32","low","high","a","littleEndian","firstByte","start","result","decode","indexOf","split","filter","Boolean","active","depth","formList","nodeType","repeat","splice","isEven","num","string","from","to"],"mappings":";;AAAA,SAASA,UAAT,QAA2B,iBAA3B;AACA,SAASC,UAAT,QAA2B,iBAA3B;;IACMC,S;AACJ,uBAAc;AAAA;;AACZ,SAAKC,QAAL,GAAgB,IAAIC,QAAJ,EAAhB;AACD;;;;WACD,eAAMC,MAAN,EAAc;AACZ,WAAKC,MAAL,GAAc,IAAIC,cAAJ,CAAmBF,MAAnB,CAAd;AACA,WAAKG,IAAL,GAAY;AACVC,QAAAA,SAAS,EAAE,EADD;AAEVC,QAAAA,MAAM,EAAE,EAFE;AAGVC,QAAAA,IAAI,EAAE,EAHI;AAIVC,QAAAA,QAAQ,EAAE;AAJA,OAAZ;AAMA,WAAKC,YAAL,GAAoB,KAAKL,IAAzB;AACA,WAAKM,WAAL,GAAmB,KAAKN,IAAxB;AACA,WAAKO,YAAL;AACA,UAAI,KAAKP,IAAL,CAAUQ,MAAV,KAAqB,KAAK,CAA9B,EACE;;AACF,UAAI,KAAKR,IAAL,CAAUQ,MAAV,KAAqB,MAAzB,EAAiC;AAC/B,aAAKC,MAAL,GAAc,IAAIjB,UAAJ,CAAe,IAAf,CAAd;;AACA,eAAO,CAAC,KAAKM,MAAL,CAAYY,SAAZ,EAAR;AACE,eAAKD,MAAL,CAAYE,UAAZ;AADF;AAED,OAJD,MAIO,IAAI,KAAKX,IAAL,CAAUQ,MAAV,KAAqB,MAAzB,EAAiC;AACtC,aAAKC,MAAL,GAAc,IAAIhB,UAAJ,CAAe,IAAf,CAAd;;AACA,eAAO,CAAC,KAAKK,MAAL,CAAYY,SAAZ,EAAR;AACE,eAAKD,MAAL,CAAYE,UAAZ;AADF;AAED;;AACD,WAAKhB,QAAL,CAAciB,MAAd,GAAuB,KAAKd,MAAL,CAAYc,MAAnC;AACA,WAAKjB,QAAL,CAAckB,UAAd;AACA,aAAO,KAAKb,IAAZ;AACD;;;WACD,wBAAe;AACb,WAAKL,QAAL,CAAciB,MAAd,GAAuB,KAAKd,MAAL,CAAYc,MAAnC;AACA,UAAIE,OAAO,GAAG,KAAKhB,MAAL,CAAYiB,QAAZ,EAAd;;AACA,UAAID,OAAO,KAAK,MAAhB,EAAwB;AACtBE,QAAAA,OAAO,CAACC,IAAR,CAAa,oCAAb;AACA;AACD;;AACD,UAAIC,MAAM,GAAG,KAAKpB,MAAL,CAAYqB,SAAZ,EAAb;AACA,WAAKxB,QAAL,CAAcyB,UAAd,GAA2B,KAAKtB,MAAL,CAAYc,MAAvC;AACA,WAAKjB,QAAL,CAAcuB,MAAd,GAAuBA,MAAvB;AACA,UAAIG,IAAI,GAAG,KAAKvB,MAAL,CAAYiB,QAAZ,EAAX;;AACA,UAAIM,IAAI,KAAK,MAAb,EAAqB;AACnB,aAAKrB,IAAL,CAAUQ,MAAV,GAAmBa,IAAnB;AACD,OAFD,MAEO,IAAIA,IAAI,KAAK,MAAb,EAAqB;AAC1B,aAAKrB,IAAL,CAAUQ,MAAV,GAAmBa,IAAnB;AACD;;AACD,WAAK1B,QAAL,CAAc2B,IAAd,GAAqB,CAArB;AACA,WAAK3B,QAAL,CAAc4B,MAAd,GAAuBF,IAAvB;AACA,WAAK1B,QAAL,CAAc6B,GAAd;AACA;AACD,K,CACD;AACA;AACA;AACA;AACA;;;;WACA,mBAAUN,MAAV,EAAkB;AAChB,UAAIG,IAAI,GAAG,KAAKvB,MAAL,CAAYiB,QAAZ,EAAX;;AACA,cAAQM,IAAR;AACE,aAAK,MAAL;AACA,aAAK,MAAL;AACA,aAAK,MAAL;AACA,aAAK,MAAL;AACA,aAAK,MAAL;AACA,aAAK,MAAL;AACA,aAAK,MAAL;AACA,aAAK,MAAL;AACA,aAAK,MAAL;AACA,aAAK,MAAL;AACA,aAAK,MAAL;AACA,aAAK,MAAL;AACA,aAAK,MAAL;AACA,aAAK,MAAL;AACA,aAAK,MAAL;AACA,aAAK,MAAL;AACA,aAAK,MAAL;AACA,aAAK,MAAL;AACA,aAAK,MAAL;AACA,aAAK,MAAL;AACA,aAAK,MAAL;AACE,eAAK1B,QAAL,CAAc8B,OAAd,GAAwB,IAAxB;AACA,eAAKC,QAAL,CAAcR,MAAd;AACA;;AACF,aAAK,MAAL;AACA,aAAK,MAAL;AACA,aAAK,MAAL;AACA,aAAK,MAAL;AACA,aAAK,MAAL;AACA,aAAK,MAAL;AACA,aAAK,MAAL;AACA,aAAK,MAAL;AACA,aAAK,MAAL;AACA,aAAK,MAAL;AACA,aAAK,MAAL;AACE,eAAKvB,QAAL,CAAcuB,MAAd,GAAuB,CAAvB;AACA,eAAKvB,QAAL,CAAc8B,OAAd,GAAwB,IAAxB;AACA;;AACF,aAAK,MAAL;AACA,aAAK,MAAL;AACA,aAAK,MAAL;AACA,aAAK,MAAL;AACA,aAAK,MAAL;AACA,aAAK,MAAL;AACA,aAAK,MAAL;AACE,eAAKE,yBAAL,CAA+BN,IAA/B;AACA;;AACF,aAAK,MAAL;AACE,eAAKO,aAAL,CAAmBV,MAAnB;AACA;;AACF,aAAK,MAAL;AACE,cAAI,KAAKlB,IAAL,CAAUQ,MAAV,KAAqB,MAAzB,EAAiC;AAC/B,iBAAKqB,SAAL,CAAeX,MAAf;AACD,WAFD,MAEO;AACL,iBAAKY,SAAL,CAAeZ,MAAf;AACD;;AACD;;AACF,aAAK,MAAL;AACE,eAAKa,UAAL;AACA;;AACF,aAAK,MAAL;AACE,eAAKjC,MAAL,CAAYkC,IAAZ,CAAiB,CAAjB;AACA,eAAK1B,WAAL,CAAiB2B,gBAAjB,GAAoC;AAClCC,YAAAA,KAAK,EAAE,KAAKpC,MAAL,CAAYqB,SAAZ,EAD2B;AAElCgB,YAAAA,OAAO,EAAE,KAAKrC,MAAL,CAAYsC,SAAZ,EAFyB,CAGlC;;AAHkC,WAApC;AAKA;;AACF,aAAK,MAAL;AACE,eAAKC,mBAAL,CAAyBnB,MAAzB;AACA;;AACF,aAAK,MAAL;AACE,eAAKoB,gBAAL,CAAsBpB,MAAtB;AACA;;AACF,aAAK,MAAL;AACE,eAAKqB,cAAL,CAAoBrB,MAApB;AACA;;AACF,aAAK,MAAL;AACE,eAAKsB,YAAL,CAAkBtB,MAAlB;AACA;;AACF,aAAK,MAAL;AACA,aAAK,MAAL;AACE,eAAKuB,SAAL,CAAe,YAAf,EAA6BvB,MAA7B;AACA;;AACF,aAAK,MAAL;AACE,eAAKwB,gBAAL,CAAsBxB,MAAtB;AACA;;AACF,aAAK,MAAL;AACE,eAAKyB,UAAL,GAAkB,KAAKrC,WAAvB;AACA,eAAKA,WAAL,GAAmB,KAAKsC,cAAxB;AACA,eAAKH,SAAL,CAAe,eAAf,EAAgCvB,MAAhC;AACA;;AACF,aAAK,MAAL;AACE,eAAKuB,SAAL,CAAe,mBAAf,EAAoCvB,MAApC;AACA;;AACF,aAAK,MAAL;AACE,eAAK2B,cAAL,CAAoB3B,MAApB;AACA;;AACF,aAAK,MAAL;AACE,eAAK4B,aAAL,CAAmB5B,MAAnB;AACA;;AACF,aAAK,MAAL;AACE,eAAK6B,SAAL,CAAe,WAAf,EAA4B7B,MAA5B;AACA;;AACF,aAAK,MAAL;AACE,eAAKuB,SAAL,CAAe,YAAf,EAA6BvB,MAA7B;AACA;;AACF,aAAK,MAAL;AACE,eAAK8B,UAAL,CAAgB,QAAhB,EAA0B9B,MAA1B;AACA;;AACF,aAAK,MAAL;AACE,eAAK8B,UAAL,CAAgB,OAAhB,EAAyB9B,MAAzB;AACA;;AACF,aAAK,MAAL;AACE,eAAK8B,UAAL,CAAgB,UAAhB,EAA4B9B,MAA5B;AACA;;AACF;AACE,eAAK+B,gBAAL,CAAsB5B,IAAtB,EAA4BH,MAA5B;AAtHJ;;AAwHA,WAAKvB,QAAL,CAAc2B,IAAd,GAAqB,CAArB;AACA,WAAK3B,QAAL,CAAc4B,MAAd,GAAuBF,IAAvB;AACA,WAAK1B,QAAL,CAAc6B,GAAd;AACD;;;WACD,mBAAUH,IAAV,EAAgBH,MAAhB,EAAwB;AACtB,UAAI,CAAC,KAAKZ,WAAV,EACE,KAAKA,WAAL,GAAmB,KAAK4C,WAAxB;AACF,WAAKC,cAAL,GAAsB,KAAKrD,MAAL,CAAYc,MAAZ,GAAqBM,MAA3C;AACA,WAAKyB,UAAL,GAAkB,KAAKrC,WAAvB;;AACA,UAAI,CAAC,KAAKA,WAAL,CAAiBe,IAAjB,CAAL,EAA6B;AAC3B,aAAKf,WAAL,CAAiBe,IAAjB,IAAyB,EAAzB;AACA,aAAKf,WAAL,GAAmB,KAAKA,WAAL,CAAiBe,IAAjB,CAAnB;AACD,OAHD,MAGO;AACLL,QAAAA,OAAO,CAACC,IAAR,CAAa,4CAAb,EAA2DI,IAA3D,EAAiE,KAAKf,WAAtE;AACA,aAAKA,WAAL,GAAmB,KAAKA,WAAL,CAAiBe,IAAjB,CAAnB;AACD;AACF;;;WACD,kBAASH,MAAT,EAAiB;AACf,WAAKpB,MAAL,CAAYkC,IAAZ,CAAiBd,MAAM,GAAG,CAA1B;AACD;;;WACD,0BAAiBG,IAAjB,EAAuBH,MAAvB,EAA+B;AAC7BF,MAAAA,OAAO,CAACC,IAAR,CAAa,0CAA0CI,IAAvD,EAA6DH,MAA7D;AACAkC,MAAAA,WAAW,CAAC,KAAKtD,MAAL,CAAYuD,EAAZ,CAAexD,MAAhB,EAAwB,KAAKC,MAAL,CAAYc,MAApC,EAA4CM,MAAM,GAAG,CAArD,CAAX;AACA,WAAKpB,MAAL,CAAYkC,IAAZ,CAAiBd,MAAM,GAAG,CAA1B;AACD;;;WACD,0BAAiBA,MAAjB,EAAyB;AACvB,WAAKpB,MAAL,CAAYkC,IAAZ,CAAiB,CAAjB;AACA,UAAIsB,IAAI,GAAG,KAAKxD,MAAL,CAAYsC,SAAZ,EAAX;AACA,UAAImB,OAAO,GAAG;AACZC,QAAAA,UAAU,EAAE,EADA;AAEZ;AACAC,QAAAA,WAAW,EAAE,EAHD;AAIZH,QAAAA,IAAI,EAAJA,IAJY;AAKZI,QAAAA,SAAS,EAAEJ,IALC;AAMZK,QAAAA,KAAK,EAAE,EANK;AAOZC,QAAAA,MAAM,EAAE,KAAK9D,MAAL,CAAYsC,SAAZ;AAPI,OAAd;AASA,WAAKpC,IAAL,CAAUC,SAAV,CAAoBqD,IAApB,IAA4BC,OAA5B;AACA,WAAKX,cAAL,GAAsBW,OAAtB;AACA,WAAKZ,UAAL,GAAkB,KAAK3C,IAAL,CAAUC,SAA5B;AACA,WAAKK,WAAL,GAAmBiD,OAAnB;AACA,WAAKJ,cAAL,GAAsB,KAAKrD,MAAL,CAAYc,MAAZ,GAAqBM,MAA3C;AACD;;;WACD,0BAAiBA,MAAjB,EAAyB;AACvB,UAAIoC,IAAI,GAAG,KAAKxD,MAAL,CAAYsC,SAAZ,EAAX;AACA,UAAImB,OAAO,GAAG;AACZC,QAAAA,UAAU,EAAE,EADA;AAEZ;AACAC,QAAAA,WAAW,EAAE,EAHD;AAIZH,QAAAA,IAAI,EAAJA,IAJY;AAKZK,QAAAA,KAAK,EAAE,EALK;AAMZC,QAAAA,MAAM,EAAE,KAAK9D,MAAL,CAAYsC,SAAZ;AANI,OAAd;AAQA,WAAKpC,IAAL,CAAUC,SAAV,CAAoBqD,IAApB,IAA4BC,OAA5B;AACA,WAAKX,cAAL,GAAsBW,OAAtB;AACA,WAAKZ,UAAL,GAAkB,KAAK3C,IAAL,CAAUC,SAA5B;AACA,WAAKK,WAAL,GAAmBiD,OAAnB;AACA,WAAKJ,cAAL,GAAsB,KAAKrD,MAAL,CAAYc,MAAZ,GAAqBM,MAA3C;AACD;;;WACD,sBAAaA,MAAb,EAAqB;AACnB,WAAKpB,MAAL,CAAYkC,IAAZ,CAAiB,CAAjB;AACA,UAAIsB,IAAI,GAAG,KAAKxD,MAAL,CAAYsC,SAAZ,EAAX;AACA,UAAId,IAAI,GAAG;AACTgC,QAAAA,IAAI,EAAJA;AADS,OAAX;AAGA,WAAKhD,WAAL,GAAmBgB,IAAnB;AACA,WAAK4B,WAAL,GAAmB5B,IAAnB;AACA,WAAK6B,cAAL,GAAsB,KAAKrD,MAAL,CAAYc,MAAZ,GAAqBM,MAA3C;AACD,K,CACD;;;;WACA,0BAAiBA,MAAjB,EAAyB;AACvB,WAAKiC,cAAL,GAAsB,KAAKrD,MAAL,CAAYc,MAAZ,GAAqBM,MAA3C;AACA,WAAKyB,UAAL,GAAkB,KAAKrC,WAAvB;AACA,WAAKA,WAAL,GAAmB,KAAKsC,cAAL,CAAoBa,WAAvC;AACD,K,CACD;;;;WACA,wBAAevC,MAAf,EAAuB;AACrB,WAAKpB,MAAL,CAAYkC,IAAZ,CAAiB,CAAjB;AACA,UAAIsB,IAAI,GAAG,KAAKxD,MAAL,CAAYsC,SAAZ,EAAX;AACA,WAAK9B,WAAL,GAAmB,KAAK4C,WAAL,CAAiBM,UAApC;AACA,WAAKf,SAAL,CAAea,IAAf,EAAqBpC,MAArB;AACD,K,CACD;AACA;;;;WACA,0BAAiB;AACf,WAAKpB,MAAL,CAAYkC,IAAZ,CAAiB,CAAjB;AACA,UAAI6B,SAAS,GAAG,KAAK/D,MAAL,CAAYsC,SAAZ,EAAhB;;AACA,UAAIyB,SAAS,KAAK,QAAlB,EAA4B;AAC1B,aAAKvD,WAAL,CAAiBwD,KAAjB,GAAyB,KAAKhE,MAAL,CAAYiE,SAAZ,EAAzB;AACD,OAFD,MAEO,IAAIF,SAAS,KAAK,KAAlB,EAAyB;AAC9B,aAAKvD,WAAL,CAAiBwD,KAAjB,GAAyB,KAAKhE,MAAL,CAAYqB,SAAZ,EAAzB;AACD,OAFM,MAEA,IAAI0C,SAAS,KAAK,QAAlB,EAA4B;AACjC,aAAK/D,MAAL,CAAYkC,IAAZ,CAAiB,EAAjB;AACA,aAAK1B,WAAL,CAAiBwD,KAAjB,GAAyB,KAAKhE,MAAL,CAAYkE,UAAZ,EAAzB;AACD,OAHM,MAGA,IAAIH,SAAS,KAAK,SAAlB,EAA6B;AAClC,aAAK/D,MAAL,CAAYkC,IAAZ,CAAiB,EAAjB;AACA,aAAK1B,WAAL,CAAiBwD,KAAjB,GAAyB,KAAKhE,MAAL,CAAYmE,eAAZ,CAA4B,CAA5B,CAAzB;AACD;AACF,K,CACD;AACA;;;;WACA,+BAAsB;AACpB,WAAKnE,MAAL,CAAYkC,IAAZ,CAAiB,CAAjB;AACA,WAAK1B,WAAL,CAAiB4D,WAAjB,GAA+B,KAAKpE,MAAL,CAAYqE,UAAZ,EAA/B;AACD,K,CACD;;;;WACA,uBAAcjD,MAAd,EAAsB;AACpB,WAAKiC,cAAL,GAAsB,KAAKrD,MAAL,CAAYc,MAAZ,GAAqBM,MAA3C;AACA,WAAKyB,UAAL,GAAkB,KAAKrC,WAAvB;AACA,UAAI,CAAC,KAAKA,WAAL,CAAiB8D,IAAtB,EACE,KAAK9D,WAAL,CAAiB8D,IAAjB,GAAwB,EAAxB;AACF,UAAIC,GAAG,GAAG,EAAV;AACA,WAAK/D,WAAL,CAAiB8D,IAAjB,CAAsBE,IAAtB,CAA2BD,GAA3B;AACA,WAAK/D,WAAL,GAAmB+D,GAAnB;AACA,WAAKvE,MAAL,CAAYkC,IAAZ,CAAiB,EAAjB;AACD;;;WACD,mCAA0BX,IAA1B,EAAgC;AAC9B,WAAKvB,MAAL,CAAYkC,IAAZ,CAAiB,EAAjB;AACA,WAAKlC,MAAL,CAAYkC,IAAZ,CAAiB,EAAjB;;AACA,cAAQX,IAAR;AACE,aAAK,MAAL;AACE,eAAK6B,WAAL,CAAiBqB,KAAjB,GAAyB,KAAKzE,MAAL,CAAY0E,eAAZ,CAA4B,CAA5B,CAAzB;AACA;;AACF,aAAK,MAAL;AACE,eAAKtB,WAAL,CAAiBuB,QAAjB,GAA4B,KAAK3E,MAAL,CAAY0E,eAAZ,CAA4B,CAA5B,CAA5B;AACA;;AACF,aAAK,MAAL;AACE,eAAKtB,WAAL,CAAiBwB,QAAjB,GAA4B,KAAK5E,MAAL,CAAY0E,eAAZ,CAA4B,CAA5B,CAA5B;AACA;;AACF,aAAK,MAAL;AACE,eAAKtB,WAAL,CAAiByB,OAAjB,GAA2B,KAAK7E,MAAL,CAAY0E,eAAZ,CAA4B,CAA5B,CAA3B;AACA;;AACF,aAAK,MAAL;AACE,eAAKtB,WAAL,CAAiB0B,SAAjB,GAA6B,KAAK9E,MAAL,CAAYqE,UAAZ,EAA7B;AACA;;AACF,aAAK,MAAL;AACE,eAAKjB,WAAL,CAAiB2B,MAAjB,GAA0B,KAAK/E,MAAL,CAAYqE,UAAZ,EAA1B;AACA;;AACF,aAAK,MAAL;AACE,eAAKjB,WAAL,CAAiB4B,MAAjB,GAA0B,KAAKhF,MAAL,CAAYqE,UAAZ,EAA1B;AACA;AArBJ;;AAuBA,WAAKrE,MAAL,CAAYkC,IAAZ,CAAiB,CAAjB;AACD,K,CACD;;;;WACA,uBAAcd,MAAd,EAAsB;AACpB,WAAKpB,MAAL,CAAYkC,IAAZ,CAAiBd,MAAM,GAAG,CAA1B;AACD,K,CACD;AACA;AACA;AACA;AACA;;;;WACA,mBAAUA,MAAV,EAAkB;AAChB,UAAI6D,GAAG,GAAG,KAAKjF,MAAL,CAAYiB,QAAZ,EAAV;;AACA,UAAIgE,GAAG,KAAK,MAAZ,EAAoB;AAClB,aAAKjF,MAAL,CAAYkC,IAAZ,CAAiB,EAAjB;AACA,aAAKkB,WAAL,CAAiB8B,QAAjB,GAA4B,KAAKlF,MAAL,CAAYsC,SAAZ,EAA5B;AACA;AACD;;AACD,WAAKtC,MAAL,CAAYmF,SAAZ,CAAsB,KAAKnF,MAAL,CAAYc,MAAZ,GAAqB,CAA3C;AACA,WAAKuC,cAAL,GAAsB,KAAKrD,MAAL,CAAYc,MAAZ,GAAqBM,MAA3C;AACA,WAAKyB,UAAL,GAAkB,KAAKrC,WAAvB;AACA,WAAKR,MAAL,CAAYkC,IAAZ,CAAiB,CAAjB;AACA,UAAIkD,OAAO,GAAG;AACZhD,QAAAA,KAAK,EAAE,KAAKpC,MAAL,CAAYqB,SAAZ;AADK,OAAd;AAGA,WAAKnB,IAAL,CAAUI,QAAV,CAAmBkE,IAAnB,CAAwBY,OAAxB;AACA,WAAK5E,WAAL,GAAmB4E,OAAnB;AACD;;;WACD,uBAAchE,MAAd,EAAsB;AACpB,UAAIgE,OAAO,GAAG;AACZhD,QAAAA,KAAK,EAAE,KAAKpC,MAAL,CAAYqB,SAAZ,EADK;AAEZ6D,QAAAA,QAAQ,EAAE;AAFE,OAAd;;AAIA,aAAO,IAAP,EAAa;AACX,YAAID,GAAG,GAAG,KAAKjF,MAAL,CAAYiB,QAAZ,EAAV;AACA,YAAIoE,QAAQ,GAAG,KAAKrF,MAAL,CAAYsF,SAAZ,EAAf;;AACA,YAAIL,GAAG,KAAK,MAAZ,EAAoB;AAClBG,UAAAA,OAAO,CAACF,QAAR,GAAmB,KAAKlF,MAAL,CAAYsC,SAAZ,EAAnB;AACA;AACD;;AACD,YAAI+C,QAAQ,IAAIjE,MAAhB,EAAwB;AACtB;AACD;AACF;;AACD,WAAKlB,IAAL,CAAUI,QAAV,CAAmBkE,IAAnB,CAAwBY,OAAxB;AACA,WAAK5E,WAAL,GAAmB4E,OAAnB;AACD;;;WACD,sBAAa;AACX,WAAKpF,MAAL,CAAYkC,IAAZ,CAAiB,CAAjB;AACA,WAAK1B,WAAL,CAAiB0E,QAAjB,GAA4B,KAAKlF,MAAL,CAAYsC,SAAZ,EAA5B;AACD;;;WACD,mBAAUf,IAAV,EAAgBH,MAAhB,EAAwB;AACtB,UAAImE,SAAS,GAAG,KAAKvF,MAAL,CAAYc,MAAZ,GAAqBM,MAArB,GAA8B,CAA9C;AACA,WAAKpB,MAAL,CAAYkC,IAAZ,CAAiB,CAAjB;AACA,WAAK1B,WAAL,CAAiBe,IAAjB,IAAyB,KAAKvB,MAAL,CAAYqE,UAAZ,EAAzB;AACA,WAAKrE,MAAL,CAAYmF,SAAZ,CAAsBI,SAAtB;AACD;;;WACD,oBAAWhE,IAAX,EAAiBH,MAAjB,EAAyB;AACvB,UAAImE,SAAS,GAAG,KAAKvF,MAAL,CAAYc,MAAZ,GAAqBM,MAArB,GAA8B,CAA9C;AACA,WAAKpB,MAAL,CAAYkC,IAAZ,CAAiB,CAAjB;AACA,WAAK1B,WAAL,CAAiBe,IAAjB,IAAyB;AACvBiE,QAAAA,CAAC,EAAE,KAAKxF,MAAL,CAAYqE,UAAZ,EADoB;AAEvBoB,QAAAA,CAAC,EAAE,KAAKzF,MAAL,CAAYqE,UAAZ,EAFoB;AAGvBqB,QAAAA,CAAC,EAAE,KAAK1F,MAAL,CAAYqE,UAAZ;AAHoB,OAAzB;AAKA,WAAKrE,MAAL,CAAYmF,SAAZ,CAAsBI,SAAtB;AACD,K,CACD;AACA;;;;WACA,0BAAiB;AACf,UAAI,CAAC,KAAKrF,IAAL,CAAUyF,UAAf,EACE,KAAKzF,IAAL,CAAUyF,UAAV,GAAuB,EAAvB;AACF,WAAKzF,IAAL,CAAUyF,UAAV,CAAqB,KAAK3F,MAAL,CAAYiB,QAAZ,EAArB,IAA+C;AAC7C2E,QAAAA,SAAS,EAAE,KAAK5F,MAAL,CAAYsC,SAAZ;AADkC,OAA/C;AAGD,K,CACD;AACA;;;;WACA,oBAAWlB,MAAX,EAAmB;AACjB,UAAIyE,KAAK,GAAG;AACVC,QAAAA,MAAM,EAAE,KAAK9F,MAAL,CAAYsF,SAAZ,EADE;AAEVS,QAAAA,KAAK,EAAE,KAAK/F,MAAL,CAAYsF,SAAZ,EAFG;AAGV;AACAU,QAAAA,KAAK,EAAE,KAAKhG,MAAL,CAAY0E,eAAZ,CAA4B,CAA5B,CAJG;AAKV;AACAlB,QAAAA,IAAI,EAAE,KAAKxD,MAAL,CAAYsC,SAAZ;AANI,OAAZ;AAQA,WAAKpC,IAAL,CAAUE,MAAV,CAAiBoE,IAAjB,CAAsBqB,KAAtB;AACA,WAAKtF,YAAL,GAAoBsF,KAApB;AACA,UAAII,YAAY,GAAG,KAAKC,YAAY,CAAC,KAAK3F,YAAL,CAAkBiD,IAAnB,CAApC;AACA,WAAKjD,YAAL,CAAkB4F,MAAlB,GAA2BF,YAAY,GAAG7E,MAAf,GAAwB,KAAKpB,MAAL,CAAYsF,SAAZ,EAAxB,GAAkD,CAAC,CAA9E;AACD,K,CACD;AACA;AACA;;;;WACA,qBAAYlE,MAAZ,EAAoB;AAClB,WAAKgF,aAAL,GAAqB,EAArB;;AACA,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGjF,MAAM,GAAG,CAA7B,EAAgCiF,CAAC,IAAI,CAArC,EAAwC;AACtC,aAAKD,aAAL,CAAmB5B,IAAnB,CAAwB,KAAKxE,MAAL,CAAYqE,UAAZ,EAAxB,EAAkD,KAAKrE,MAAL,CAAYqE,UAAZ,EAAlD,EAA4E,CAAC,KAAKrE,MAAL,CAAYqE,UAAZ,EAA7E;AACD;AACF,K,CACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACA,4BAAmBjD,MAAnB,EAA2BkF,aAA3B,EAA0C;AACxC,UAAIC,WAAW,GAAG,KAAKvG,MAAL,CAAYc,MAAZ,GAAqBM,MAAvC;AACA,UAAIoF,WAAW,GAAG,KAAKxG,MAAL,CAAYsC,SAAZ,EAAlB;;AACA,UAAI,KAAKtC,MAAL,CAAYc,MAAZ,KAAuByF,WAA3B,EAAwC;AACtC,aAAK/F,WAAL,CAAiBiG,SAAjB,GAA6BD,WAA7B;AACA;AACD;;AACD,WAAKxG,MAAL,CAAYmF,SAAZ,CAAsB,KAAKnF,MAAL,CAAYc,MAAZ,GAAqBoF,YAAY,CAACM,WAAD,CAAvD;AACA,UAAIjF,IAAI,GAAG,KAAKvB,MAAL,CAAYiB,QAAZ,EAAX;AACA,WAAKjB,MAAL,CAAYsF,SAAZ;AACA,UAAI9B,IAAI,GAAG,KAAKxD,MAAL,CAAYsC,SAAZ,EAAX;AACA,UAAIoE,eAAe,GAAGtF,MAAM,GAAG,CAAT,GAAa8E,YAAY,CAAC1C,IAAD,CAA/C;;AACA,cAAQjC,IAAR;AACE,aAAK,MAAL;AACE,eAAKoF,cAAL,CAAoBnD,IAApB,EAA0B+C,WAA1B,EAAuCD,aAAvC;AACA;;AACF,aAAK,MAAL;AACA,aAAK,MAAL;AACE,eAAKM,iBAAL,CAAuBpD,IAAvB,EAA6B+C,WAA7B,EAA0ChF,IAA1C;AACA;;AACF,aAAK,MAAL;AACA,aAAK,MAAL;AACA,aAAK,MAAL;AACA,aAAK,MAAL;AACA,aAAK,MAAL;AACA,aAAK,MAAL;AACA,aAAK,MAAL;AACE,eAAKvB,MAAL,CAAYkC,IAAZ,CAAiBwE,eAAjB;AACA;;AACF;AACExF,UAAAA,OAAO,CAACC,IAAR,CAAa,yCAAyCI,IAAtD;AACA,eAAKvB,MAAL,CAAYkC,IAAZ,CAAiBwE,eAAjB;AAnBJ;AAqBD;;;WACD,wBAAelD,IAAf,EAAqB+C,WAArB,EAAkCD,aAAlC,EAAiD;AAC/C,UAAIO,SAAS,GAAG,EAAhB;AACA,UAAIC,WAAW,GAAG,EAAlB;AACA,UAAIC,GAAG,GAAG,EAAV;;AACA,aAAO,KAAK/G,MAAL,CAAYc,MAAZ,GAAqByF,WAA5B,EAAyC;AACvCM,QAAAA,SAAS,CAACrC,IAAV,CAAe,KAAKxE,MAAL,CAAYgH,sBAAZ,EAAf;AACA,YAAIV,aAAJ,EACEQ,WAAW,CAACtC,IAAZ,CAAiB,KAAKxE,MAAL,CAAYgH,sBAAZ,EAAjB;AACFD,QAAAA,GAAG,CAACvC,IAAJ,CAAS,KAAKxE,MAAL,CAAYqE,UAAZ,EAAT,EAAmC,KAAKrE,MAAL,CAAYqE,UAAZ,EAAnC;AACD;;AACD,UAAIiC,aAAJ,EAAmB;AACjB,YAAI,CAAC,KAAK/F,YAAL,CAAkB0G,gBAAvB,EACE,KAAK1G,YAAL,CAAkB0G,gBAAlB,GAAqC,EAArC;AACF,aAAK1G,YAAL,CAAkB0G,gBAAlB,CAAmCzD,IAAnC,IAA2C;AACzCqD,UAAAA,SAAS,EAATA,SADyC;AAEzCC,UAAAA,WAAW,EAAXA,WAFyC;AAGzCC,UAAAA,GAAG,EAAHA;AAHyC,SAA3C;AAKD,OARD,MAQO;AACL,YAAI,CAAC,KAAKxG,YAAL,CAAkBwG,GAAvB,EACE,KAAKxG,YAAL,CAAkBwG,GAAlB,GAAwB,EAAxB;AACF,aAAKxG,YAAL,CAAkBwG,GAAlB,CAAsBvD,IAAtB,IAA8B;AAC5BqD,UAAAA,SAAS,EAATA,SAD4B;AAE5BE,UAAAA,GAAG,EAAHA;AAF4B,SAA9B;AAID;AACF;;;WACD,2BAAkBvD,IAAlB,EAAwB+C,WAAxB,EAAqChF,IAArC,EAA2C;AACzC,UAAI2F,OAAO,GAAG,EAAd;AACA,UAAIC,MAAM,GAAG,EAAb;AACA5F,MAAAA,IAAI,GAAGA,IAAI,KAAK,MAAT,GAAkB,UAAlB,GAA+B,UAAtC;;AACA,aAAO,KAAKvB,MAAL,CAAYc,MAAZ,GAAqByF,WAA5B,EAAyC;AACvCW,QAAAA,OAAO,CAAC1C,IAAR,CAAa,KAAKxE,MAAL,CAAYgH,sBAAZ,EAAb;AACAG,QAAAA,MAAM,CAAC3C,IAAP,CAAY,KAAKxE,MAAL,CAAYqE,UAAZ,EAAZ,EAAsC,KAAKrE,MAAL,CAAYqE,UAAZ,EAAtC,EAAgE,CAAC,KAAKrE,MAAL,CAAYqE,UAAZ,EAAjE;AACD;;AACD,UAAI,CAAC,KAAK9D,YAAL,CAAkB6G,YAAvB,EACE,KAAK7G,YAAL,CAAkB6G,YAAlB,GAAiC,EAAjC;AACF,WAAK7G,YAAL,CAAkB6G,YAAlB,CAA+B5D,IAA/B,IAAuC;AACrC0D,QAAAA,OAAO,EAAPA,OADqC;AAErCC,QAAAA,MAAM,EAANA,MAFqC;AAGrC5F,QAAAA,IAAI,EAAJA;AAHqC,OAAvC;AAKD,K,CACD;AACA;;;;WACA,0BAAiBH,MAAjB,EAAyB;AACvB,UAAImF,WAAW,GAAG,KAAKvG,MAAL,CAAYc,MAAZ,GAAqBM,MAAvC;AACA,UAAIG,IAAI,GAAG,KAAKvB,MAAL,CAAYiB,QAAZ,EAAX;AACA,UAAIiG,OAAO,GAAG,EAAd;AACA,UAAIG,iBAAiB,GAAG,EAAxB;;AACA,aAAO,KAAKrH,MAAL,CAAYc,MAAZ,GAAqByF,WAA5B,EAAyC;AACvC,YAAIe,QAAQ,GAAG,KAAKtH,MAAL,CAAYsF,SAAZ,EAAf;AACAgC,QAAAA,QAAQ,GAAGA,QAAQ,GAAG,IAAtB;AACAD,QAAAA,iBAAiB,CAAC7C,IAAlB,CAAuB8C,QAAvB;;AACA,aAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,QAApB,EAA8BC,CAAC,EAA/B;AACEL,UAAAA,OAAO,CAAC1C,IAAR,CAAa,KAAKxE,MAAL,CAAYgH,sBAAZ,EAAb;AADF;AAED;;AACD,UAAIQ,YAAY,GAAG;AACjBjG,QAAAA,IAAI,EAAJA,IADiB;AAEjBkG,QAAAA,aAAa,EAAEP,OAFE;AAGjBG,QAAAA,iBAAiB,EAAjBA,iBAHiB;AAIjBF,QAAAA,MAAM,EAAE,KAAKf;AAJI,OAAnB;AAMA,UAAIiB,iBAAiB,CAAC,CAAD,CAAjB,KAAyB,CAA7B,EACEG,YAAY,CAACjG,IAAb,GAAoB,QAApB,CADF,KAEK,IAAI8F,iBAAiB,CAAC,CAAD,CAAjB,KAAyB,CAA7B,EACHG,YAAY,CAACjG,IAAb,GAAoB,OAApB;AACF,WAAKhB,YAAL,CAAkBmH,QAAlB,GAA6BF,YAA7B;AACD,K,CACD;AACA;;;;WACA,yBAAgBpG,MAAhB,EAAwB;AACtB,WAAKlB,IAAL,CAAUG,IAAV,GAAiB,KAAKL,MAAL,CAAY2H,cAAZ,CAA2BvG,MAA3B,CAAjB;AACD,K,CACD;AACA;;;;WACA,gCAAuBA,MAAvB,EAA+B;AAC7B,UAAImF,WAAW,GAAG,KAAKvG,MAAL,CAAYc,MAAZ,GAAqBM,MAAvC;AACA,UAAIG,IAAI,GAAG,KAAKvB,MAAL,CAAYiB,QAAZ,EAAX;AACA,UAAIM,IAAI,KAAK,MAAb,EACE,KAAKqG,oBAAL,CAA0BrB,WAA1B,EADF,KAEK;AACH,aAAKvG,MAAL,CAAYkC,IAAZ,CAAiBd,MAAM,GAAG,CAA1B;AACD;AACF;;;WACD,8BAAqBmF,WAArB,EAAkC;AAChC,WAAKhG,YAAL,CAAkBmH,QAAlB,CAA2BG,eAA3B,GAA6C,EAA7C;;AACA,aAAO,KAAK7H,MAAL,CAAYc,MAAZ,GAAqByF,WAA5B,EAAyC;AACvC,YAAIuB,YAAY,GAAG,KAAK9H,MAAL,CAAYgH,sBAAZ,EAAnB;AACA,YAAIe,aAAa,GAAG,KAAK/H,MAAL,CAAYsF,SAAZ,EAApB;AACA,aAAK/E,YAAL,CAAkBmH,QAAlB,CAA2BG,eAA3B,CAA2CrD,IAA3C,CAAgDsD,YAAhD,EAA8DC,aAA9D;AACD;AACF;;;WACD,2BAAkBC,OAAlB,EAA2B5G,MAA3B,EAAmC;AACjCF,MAAAA,OAAO,CAACC,IAAR,CAAa,oCAAoC6G,OAApC,GAA8C,WAA9C,GAA4D5G,MAAzE;AACA,UAAI6G,IAAI,GAAG,KAAKjI,MAAL,CAAYsC,SAAZ,CAAsBlB,MAAtB,CAAX;AACA,WAAKZ,WAAL,CAAiBwH,OAAjB,IAA4BC,IAA5B;AACD;;;;;;IAEGhI,c;AACJ,0BAAYF,MAAZ,EAAoB;AAAA;;AAClB,SAAKwD,EAAL,GAAU,IAAI2E,QAAJ,CAAanI,MAAb,CAAV;AACA,SAAKe,MAAL,GAAc,CAAd;AACA,SAAKqH,YAAL,GAAoB,IAAIC,WAAJ,EAApB;AACA,SAAKC,MAAL,GAAc,IAAIC,UAAJ,CAAevI,MAAf,CAAd;AACD;;;;WACD,gBAAO;AACL,aAAO,KAAKwD,EAAL,CAAQxD,MAAR,CAAewI,UAAtB;AACD;;;WACD,mBAAUzH,MAAV,EAAkB;AAChB,UAAIA,MAAM,GAAG,CAAT,IAAcA,MAAM,GAAG,KAAKyC,EAAL,CAAQxD,MAAR,CAAewI,UAA1C,EAAsD;AACpD,aAAKzH,MAAL,GAAcA,MAAd;AACD,OAFD,MAEO;AACLI,QAAAA,OAAO,CAACsH,KAAR,CAAc,kCAAd;AACD;AACF;;;WACD,qBAAY;AACV,UAAI,KAAK1H,MAAL,IAAe,KAAK2H,IAAL,EAAnB,EACE,OAAO,IAAP;AACF,aAAO,KAAP;AACD;;;WACD,cAAKrH,MAAL,EAAa;AACX,WAAKN,MAAL,IAAeM,MAAf;AACD;;;WACD,oBAAW;AACT,UAAI4C,KAAK,GAAG,KAAKT,EAAL,CAAQmF,QAAR,CAAiB,KAAK5H,MAAtB,CAAZ;AACA,WAAKA,MAAL,IAAe,CAAf;AACA,aAAOkD,KAAP;AACD;;;WACD,qBAAY;AACV,UAAIA,KAAK,GAAG,KAAKT,EAAL,CAAQ+B,SAAR,CAAkB,KAAKxE,MAAvB,CAAZ;AACA,WAAKA,MAAL,IAAe,CAAf;AACA,aAAOkD,KAAP;AACD;;;WACD,oBAAW;AACT,UAAIA,KAAK,GAAG,KAAKT,EAAL,CAAQoF,QAAR,CAAiB,KAAK7H,MAAtB,EAA8B,KAA9B,CAAZ;AACA,WAAKA,MAAL,IAAe,CAAf;AACA,aAAOkD,KAAP;AACD;;;WACD,qBAAY;AACV,UAAIA,KAAK,GAAG,KAAKT,EAAL,CAAQlC,SAAR,CAAkB,KAAKP,MAAvB,EAA+B,KAA/B,CAAZ;AACA,WAAKA,MAAL,IAAe,CAAf;AACA,aAAOkD,KAAP;AACD;;;WACD,qBAAY;AACV,UAAI4E,GAAJ,EAASC,IAAT;AACAA,MAAAA,IAAI,GAAG,KAAKxH,SAAL,EAAP;AACAuH,MAAAA,GAAG,GAAG,KAAKvH,SAAL,EAAN;AACA,aAAOwH,IAAI,GAAG,UAAP,GAAoBD,GAA3B;AACD;;;WACD,sBAAa;AACX,UAAI5E,KAAK,GAAG,KAAKT,EAAL,CAAQc,UAAR,CAAmB,KAAKvD,MAAxB,EAAgC,KAAhC,CAAZ;AACA,WAAKA,MAAL,IAAe,CAAf;AACA,aAAOkD,KAAP;AACD;;;WACD,yBAAgByE,IAAhB,EAAsB;AACpB,UAAIK,CAAC,GAAG,EAAR;;AACA,WAAK,IAAIzC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGoC,IAApB,EAA0BpC,CAAC,EAA3B,EAA+B;AAC7ByC,QAAAA,CAAC,CAACtE,IAAF,CAAO,KAAKH,UAAL,EAAP;AACD;;AACD,aAAOyE,CAAP;AACD;;;WACD,sBAAa;AACX,UAAI9E,KAAK,GAAG,KAAKT,EAAL,CAAQW,UAAR,CAAmB,KAAKpD,MAAxB,EAAgC,KAAKiI,YAArC,CAAZ;AACA,WAAKjI,MAAL,IAAe,CAAf;AACA,aAAOkD,KAAP;AACD;;;WACD,yBAAgByE,IAAhB,EAAsB;AACpB,UAAIK,CAAC,GAAG,EAAR;;AACA,WAAK,IAAIzC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGoC,IAApB,EAA0BpC,CAAC,EAA3B,EAA+B;AAC7ByC,QAAAA,CAAC,CAACtE,IAAF,CAAO,KAAKN,UAAL,EAAP;AACD;;AACD,aAAO4E,CAAP;AACD,K,CACD;AACA;AACA;AACA;AACA;AACA;;;;WACA,kCAAyB;AACvB,UAAIE,SAAS,GAAG,KAAKN,QAAL,EAAhB;;AACA,UAAIM,SAAS,KAAK,GAAlB,EAAuB;AACrB,eAAO,KAAKN,QAAL,KAAkB,KAAlB,GAA0B,KAAKA,QAAL,KAAkB,GAA5C,GAAkD,KAAKA,QAAL,EAAzD;AACD;;AACD,aAAOM,SAAS,GAAG,GAAZ,GAAkB,KAAKN,QAAL,EAAzB;AACD,K,CACD;;;;WACA,oBAAW;AACT,aAAO,KAAKpG,SAAL,CAAe,CAAf,CAAP;AACD;;;WACD,mBAAUmG,IAAV,EAAgB;AACd,UAAIA,IAAI,KAAK,CAAb,EACE;AACF,UAAMQ,KAAK,GAAG,KAAKnI,MAAnB;AACA,UAAIoI,MAAJ;AACA,UAAI9H,MAAJ;;AACA,UAAIqH,IAAJ,EAAU;AACRrH,QAAAA,MAAM,GAAGqH,IAAT;AACAS,QAAAA,MAAM,GAAG,KAAKf,YAAL,CAAkBgB,MAAlB,CAAyB,IAAIb,UAAJ,CAAe,KAAK/E,EAAL,CAAQxD,MAAvB,EAA+BkJ,KAA/B,EAAsCR,IAAtC,CAAzB,CAAT;AACD,OAHD,MAGO;AACLrH,QAAAA,MAAM,GAAG,KAAKiH,MAAL,CAAYe,OAAZ,CAAoB,CAApB,EAAuBH,KAAvB,IAAgCA,KAAzC;AACAC,QAAAA,MAAM,GAAG,KAAKf,YAAL,CAAkBgB,MAAlB,CAAyB,IAAIb,UAAJ,CAAe,KAAK/E,EAAL,CAAQxD,MAAvB,EAA+BkJ,KAA/B,EAAsC7H,MAAtC,CAAzB,CAAT;AACAA,QAAAA,MAAM;AACNA,QAAAA,MAAM,IAAIA,MAAM,GAAG,CAAnB;AACD;;AACD,WAAKc,IAAL,CAAUd,MAAV;AACA,aAAO8H,MAAP;AACD;;;WACD,wBAAeT,IAAf,EAAqB;AACnB,UAAIK,CAAC,GAAG,KAAKxG,SAAL,CAAemG,IAAf,CAAR;AACAK,MAAAA,CAAC,GAAGA,CAAC,CAACO,KAAF,CAAQ,IAAR,CAAJ;AACA,aAAOP,CAAC,CAACQ,MAAF,CAASC,OAAT,CAAP;AACD;;;;;;IAEGzJ,Q;AACJ,sBAAc;AAAA;;AACZ,SAAK0J,MAAL,GAAc,KAAd;AACA,SAAKC,KAAL,GAAa,CAAb;AACA,SAAKC,QAAL,GAAgB,EAAhB;AACD;;;;WACD,kBAAS;AACP,WAAKF,MAAL,GAAc,IAAd;AACD;;;WACD,eAAM;AACJ,UAAI,CAAC,KAAKA,MAAV,EACE;AACF,UAAIG,QAAJ;;AACA,cAAQ,KAAKnI,IAAb;AACE,aAAK,CAAL;AACEmI,UAAAA,QAAQ,GAAG,MAAX;AACA;;AACF,aAAK,CAAL;AACEA,UAAAA,QAAQ,GAAG,KAAX;AACA;;AACF,aAAK,CAAL;AACEA,UAAAA,QAAQ,GAAG,OAAX;AACA;AATJ;;AAWAzI,MAAAA,OAAO,CAACQ,GAAR,CACE,KAAKkI,MAAL,CAAY,KAAKH,KAAjB,IAA0BE,QAD5B,EAEE,KAAKlI,MAFP,cAGO,KAAKX,MAHZ,qBAG6B,KAAKQ,UAAL,GAAkB,KAAKF,MAHpD,SAIE,KAAKI,IAAL,IAAa,CAAb,GAAiB,IAAjB,GAAwB,EAJ1B,EAKE,KAAKG,OAAL,GAAe,SAAf,GAA2B,EAL7B,EAME,KAAKH,IAAL,IAAa,CAAb,IAAkB,KAAKG,OAAvB,GAAiC,GAAjC,GAAuC,EANzC;;AAQA,UAAI,KAAKH,IAAL,IAAa,CAAb,IAAkB,CAAC,KAAKG,OAA5B,EAAqC;AACnC,aAAK8H,KAAL,IAAc,CAAd;AACA,aAAKC,QAAL,CAAclF,IAAd,CAAmB,KAAKlD,UAAL,GAAkB,KAAKF,MAA1C;AACD;;AACD,WAAKO,OAAL,GAAe,KAAf;AACD;;;WACD,sBAAa;AACX,UAAI,CAAC,KAAK6H,MAAV,EACE;;AACF,WAAK,IAAInD,CAAC,GAAG,KAAKqD,QAAL,CAActI,MAAd,GAAuB,CAApC,EAAuCiF,CAAC,IAAI,CAA5C,EAA+CA,CAAC,EAAhD,EAAoD;AAClD,YAAI,KAAKvF,MAAL,IAAe,KAAK4I,QAAL,CAAcrD,CAAd,CAAnB,EAAqC;AACnC,eAAKoD,KAAL,IAAc,CAAd;AACAvI,UAAAA,OAAO,CAACQ,GAAR,CAAY,KAAKkI,MAAL,CAAY,KAAKH,KAAjB,IAA0B,GAAtC;AACA,eAAKC,QAAL,CAAcG,MAAd,CAAqB,CAAC,CAAtB,EAAyB,CAAzB;AACD;AACF;AACF;;;;;;AAEH,SAASC,MAAT,CAAgBC,GAAhB,EAAqB;AACnB,SAAOA,GAAG,GAAG,CAAb;AACD;;AACD,SAAS7D,YAAT,CAAsB8D,MAAtB,EAA8B;AAC5B,SAAOA,MAAM,CAAC5I,MAAP,GAAgB,CAAhB,IAAqB0I,MAAM,CAACE,MAAM,CAAC5I,MAAP,GAAgB,CAAjB,CAAN,GAA4B,CAA5B,GAAgC,CAArD,CAAP;AACD;;AACD,SAASkC,WAAT,CAAqBvD,MAArB,EAA6BkK,IAA7B,EAAmCC,EAAnC,EAAuC;AACrChJ,EAAAA,OAAO,CAACQ,GAAR,CAAY,IAAI0G,WAAJ,GAAkBe,MAAlB,CAAyB,IAAIb,UAAJ,CAAevI,MAAf,EAAuBkK,IAAvB,EAA6BC,EAA7B,CAAzB,CAAZ;AACD;;AACD,SACEtK,SADF","sourcesContent":["import { LWO2Parser } from \"./LWO2Parser.js\";\nimport { LWO3Parser } from \"./LWO3Parser.js\";\nclass IFFParser {\n  constructor() {\n    this.debugger = new Debugger();\n  }\n  parse(buffer) {\n    this.reader = new DataViewReader(buffer);\n    this.tree = {\n      materials: {},\n      layers: [],\n      tags: [],\n      textures: []\n    };\n    this.currentLayer = this.tree;\n    this.currentForm = this.tree;\n    this.parseTopForm();\n    if (this.tree.format === void 0)\n      return;\n    if (this.tree.format === \"LWO2\") {\n      this.parser = new LWO2Parser(this);\n      while (!this.reader.endOfFile())\n        this.parser.parseBlock();\n    } else if (this.tree.format === \"LWO3\") {\n      this.parser = new LWO3Parser(this);\n      while (!this.reader.endOfFile())\n        this.parser.parseBlock();\n    }\n    this.debugger.offset = this.reader.offset;\n    this.debugger.closeForms();\n    return this.tree;\n  }\n  parseTopForm() {\n    this.debugger.offset = this.reader.offset;\n    var topForm = this.reader.getIDTag();\n    if (topForm !== \"FORM\") {\n      console.warn(\"LWOLoader: Top-level FORM missing.\");\n      return;\n    }\n    var length = this.reader.getUint32();\n    this.debugger.dataOffset = this.reader.offset;\n    this.debugger.length = length;\n    var type = this.reader.getIDTag();\n    if (type === \"LWO2\") {\n      this.tree.format = type;\n    } else if (type === \"LWO3\") {\n      this.tree.format = type;\n    }\n    this.debugger.node = 0;\n    this.debugger.nodeID = type;\n    this.debugger.log();\n    return;\n  }\n  ///\n  // FORM PARSING METHODS\n  ///\n  // Forms are organisational and can contain any number of sub chunks and sub forms\n  // FORM ::= 'FORM'[ID4], length[U4], type[ID4], ( chunk[CHUNK] | form[FORM] ) * }\n  parseForm(length) {\n    var type = this.reader.getIDTag();\n    switch (type) {\n      case \"ISEQ\":\n      case \"ANIM\":\n      case \"STCC\":\n      case \"VPVL\":\n      case \"VPRM\":\n      case \"NROT\":\n      case \"WRPW\":\n      case \"WRPH\":\n      case \"FUNC\":\n      case \"FALL\":\n      case \"OPAC\":\n      case \"GRAD\":\n      case \"ENVS\":\n      case \"VMOP\":\n      case \"VMBG\":\n      case \"OMAX\":\n      case \"STEX\":\n      case \"CKBG\":\n      case \"CKEY\":\n      case \"VMLA\":\n      case \"VMLB\":\n        this.debugger.skipped = true;\n        this.skipForm(length);\n        break;\n      case \"META\":\n      case \"NNDS\":\n      case \"NODS\":\n      case \"NDTA\":\n      case \"ADAT\":\n      case \"AOVS\":\n      case \"BLOK\":\n      case \"IBGC\":\n      case \"IOPC\":\n      case \"IIMG\":\n      case \"TXTR\":\n        this.debugger.length = 4;\n        this.debugger.skipped = true;\n        break;\n      case \"IFAL\":\n      case \"ISCL\":\n      case \"IPOS\":\n      case \"IROT\":\n      case \"IBMP\":\n      case \"IUTD\":\n      case \"IVTD\":\n        this.parseTextureNodeAttribute(type);\n        break;\n      case \"ENVL\":\n        this.parseEnvelope(length);\n        break;\n      case \"CLIP\":\n        if (this.tree.format === \"LWO2\") {\n          this.parseForm(length);\n        } else {\n          this.parseClip(length);\n        }\n        break;\n      case \"STIL\":\n        this.parseImage();\n        break;\n      case \"XREF\":\n        this.reader.skip(8);\n        this.currentForm.referenceTexture = {\n          index: this.reader.getUint32(),\n          refName: this.reader.getString()\n          // internal unique ref\n        };\n        break;\n      case \"IMST\":\n        this.parseImageStateForm(length);\n        break;\n      case \"SURF\":\n        this.parseSurfaceForm(length);\n        break;\n      case \"VALU\":\n        this.parseValueForm(length);\n        break;\n      case \"NTAG\":\n        this.parseSubNode(length);\n        break;\n      case \"ATTR\":\n      case \"SATR\":\n        this.setupForm(\"attributes\", length);\n        break;\n      case \"NCON\":\n        this.parseConnections(length);\n        break;\n      case \"SSHA\":\n        this.parentForm = this.currentForm;\n        this.currentForm = this.currentSurface;\n        this.setupForm(\"surfaceShader\", length);\n        break;\n      case \"SSHD\":\n        this.setupForm(\"surfaceShaderData\", length);\n        break;\n      case \"ENTR\":\n        this.parseEntryForm(length);\n        break;\n      case \"IMAP\":\n        this.parseImageMap(length);\n        break;\n      case \"TAMP\":\n        this.parseXVAL(\"amplitude\", length);\n        break;\n      case \"TMAP\":\n        this.setupForm(\"textureMap\", length);\n        break;\n      case \"CNTR\":\n        this.parseXVAL3(\"center\", length);\n        break;\n      case \"SIZE\":\n        this.parseXVAL3(\"scale\", length);\n        break;\n      case \"ROTA\":\n        this.parseXVAL3(\"rotation\", length);\n        break;\n      default:\n        this.parseUnknownForm(type, length);\n    }\n    this.debugger.node = 0;\n    this.debugger.nodeID = type;\n    this.debugger.log();\n  }\n  setupForm(type, length) {\n    if (!this.currentForm)\n      this.currentForm = this.currentNode;\n    this.currentFormEnd = this.reader.offset + length;\n    this.parentForm = this.currentForm;\n    if (!this.currentForm[type]) {\n      this.currentForm[type] = {};\n      this.currentForm = this.currentForm[type];\n    } else {\n      console.warn(\"LWOLoader: form already exists on parent: \", type, this.currentForm);\n      this.currentForm = this.currentForm[type];\n    }\n  }\n  skipForm(length) {\n    this.reader.skip(length - 4);\n  }\n  parseUnknownForm(type, length) {\n    console.warn(\"LWOLoader: unknown FORM encountered: \" + type, length);\n    printBuffer(this.reader.dv.buffer, this.reader.offset, length - 4);\n    this.reader.skip(length - 4);\n  }\n  parseSurfaceForm(length) {\n    this.reader.skip(8);\n    var name = this.reader.getString();\n    var surface = {\n      attributes: {},\n      // LWO2 style non-node attributes will go here\n      connections: {},\n      name,\n      inputName: name,\n      nodes: {},\n      source: this.reader.getString()\n    };\n    this.tree.materials[name] = surface;\n    this.currentSurface = surface;\n    this.parentForm = this.tree.materials;\n    this.currentForm = surface;\n    this.currentFormEnd = this.reader.offset + length;\n  }\n  parseSurfaceLwo2(length) {\n    var name = this.reader.getString();\n    var surface = {\n      attributes: {},\n      // LWO2 style non-node attributes will go here\n      connections: {},\n      name,\n      nodes: {},\n      source: this.reader.getString()\n    };\n    this.tree.materials[name] = surface;\n    this.currentSurface = surface;\n    this.parentForm = this.tree.materials;\n    this.currentForm = surface;\n    this.currentFormEnd = this.reader.offset + length;\n  }\n  parseSubNode(length) {\n    this.reader.skip(8);\n    var name = this.reader.getString();\n    var node = {\n      name\n    };\n    this.currentForm = node;\n    this.currentNode = node;\n    this.currentFormEnd = this.reader.offset + length;\n  }\n  // collect attributes from all nodes at the top level of a surface\n  parseConnections(length) {\n    this.currentFormEnd = this.reader.offset + length;\n    this.parentForm = this.currentForm;\n    this.currentForm = this.currentSurface.connections;\n  }\n  // surface node attribute data, e.g. specular, roughness etc\n  parseEntryForm(length) {\n    this.reader.skip(8);\n    var name = this.reader.getString();\n    this.currentForm = this.currentNode.attributes;\n    this.setupForm(name, length);\n  }\n  // parse values from material - doesn't match up to other LWO3 data types\n  // sub form of entry form\n  parseValueForm() {\n    this.reader.skip(8);\n    var valueType = this.reader.getString();\n    if (valueType === \"double\") {\n      this.currentForm.value = this.reader.getUint64();\n    } else if (valueType === \"int\") {\n      this.currentForm.value = this.reader.getUint32();\n    } else if (valueType === \"vparam\") {\n      this.reader.skip(24);\n      this.currentForm.value = this.reader.getFloat64();\n    } else if (valueType === \"vparam3\") {\n      this.reader.skip(24);\n      this.currentForm.value = this.reader.getFloat64Array(3);\n    }\n  }\n  // holds various data about texture node image state\n  // Data other thanmipMapLevel unknown\n  parseImageStateForm() {\n    this.reader.skip(8);\n    this.currentForm.mipMapLevel = this.reader.getFloat32();\n  }\n  // LWO2 style image data node OR LWO3 textures defined at top level in editor (not as SURF node)\n  parseImageMap(length) {\n    this.currentFormEnd = this.reader.offset + length;\n    this.parentForm = this.currentForm;\n    if (!this.currentForm.maps)\n      this.currentForm.maps = [];\n    var map = {};\n    this.currentForm.maps.push(map);\n    this.currentForm = map;\n    this.reader.skip(10);\n  }\n  parseTextureNodeAttribute(type) {\n    this.reader.skip(28);\n    this.reader.skip(20);\n    switch (type) {\n      case \"ISCL\":\n        this.currentNode.scale = this.reader.getFloat32Array(3);\n        break;\n      case \"IPOS\":\n        this.currentNode.position = this.reader.getFloat32Array(3);\n        break;\n      case \"IROT\":\n        this.currentNode.rotation = this.reader.getFloat32Array(3);\n        break;\n      case \"IFAL\":\n        this.currentNode.falloff = this.reader.getFloat32Array(3);\n        break;\n      case \"IBMP\":\n        this.currentNode.amplitude = this.reader.getFloat32();\n        break;\n      case \"IUTD\":\n        this.currentNode.uTiles = this.reader.getFloat32();\n        break;\n      case \"IVTD\":\n        this.currentNode.vTiles = this.reader.getFloat32();\n        break;\n    }\n    this.reader.skip(2);\n  }\n  // ENVL forms are currently ignored\n  parseEnvelope(length) {\n    this.reader.skip(length - 4);\n  }\n  ///\n  // CHUNK PARSING METHODS\n  ///\n  // clips can either be defined inside a surface node, or at the top\n  // level and they have a different format in each case\n  parseClip(length) {\n    var tag = this.reader.getIDTag();\n    if (tag === \"FORM\") {\n      this.reader.skip(16);\n      this.currentNode.fileName = this.reader.getString();\n      return;\n    }\n    this.reader.setOffset(this.reader.offset - 4);\n    this.currentFormEnd = this.reader.offset + length;\n    this.parentForm = this.currentForm;\n    this.reader.skip(8);\n    var texture = {\n      index: this.reader.getUint32()\n    };\n    this.tree.textures.push(texture);\n    this.currentForm = texture;\n  }\n  parseClipLwo2(length) {\n    var texture = {\n      index: this.reader.getUint32(),\n      fileName: \"\"\n    };\n    while (true) {\n      var tag = this.reader.getIDTag();\n      var n_length = this.reader.getUint16();\n      if (tag === \"STIL\") {\n        texture.fileName = this.reader.getString();\n        break;\n      }\n      if (n_length >= length) {\n        break;\n      }\n    }\n    this.tree.textures.push(texture);\n    this.currentForm = texture;\n  }\n  parseImage() {\n    this.reader.skip(8);\n    this.currentForm.fileName = this.reader.getString();\n  }\n  parseXVAL(type, length) {\n    var endOffset = this.reader.offset + length - 4;\n    this.reader.skip(8);\n    this.currentForm[type] = this.reader.getFloat32();\n    this.reader.setOffset(endOffset);\n  }\n  parseXVAL3(type, length) {\n    var endOffset = this.reader.offset + length - 4;\n    this.reader.skip(8);\n    this.currentForm[type] = {\n      x: this.reader.getFloat32(),\n      y: this.reader.getFloat32(),\n      z: this.reader.getFloat32()\n    };\n    this.reader.setOffset(endOffset);\n  }\n  // Tags associated with an object\n  // OTAG { type[ID4], tag-string[S0] }\n  parseObjectTag() {\n    if (!this.tree.objectTags)\n      this.tree.objectTags = {};\n    this.tree.objectTags[this.reader.getIDTag()] = {\n      tagString: this.reader.getString()\n    };\n  }\n  // Signals the start of a new layer. All the data chunks which follow will be included in this layer until another layer chunk is encountered.\n  // LAYR: number[U2], flags[U2], pivot[VEC12], name[S0], parent[U2]\n  parseLayer(length) {\n    var layer = {\n      number: this.reader.getUint16(),\n      flags: this.reader.getUint16(),\n      // If the least significant bit of flags is set, the layer is hidden.\n      pivot: this.reader.getFloat32Array(3),\n      // Note: this seems to be superflous, as the geometry is translated when pivot is present\n      name: this.reader.getString()\n    };\n    this.tree.layers.push(layer);\n    this.currentLayer = layer;\n    var parsedLength = 16 + stringOffset(this.currentLayer.name);\n    this.currentLayer.parent = parsedLength < length ? this.reader.getUint16() : -1;\n  }\n  // VEC12 * ( F4 + F4 + F4 ) array of x,y,z vectors\n  // Converting from left to right handed coordinate system:\n  // x -> -x and switch material FrontSide -> BackSide\n  parsePoints(length) {\n    this.currentPoints = [];\n    for (var i = 0; i < length / 4; i += 3) {\n      this.currentPoints.push(this.reader.getFloat32(), this.reader.getFloat32(), -this.reader.getFloat32());\n    }\n  }\n  // parse VMAP or VMAD\n  // Associates a set of floating-point vectors with a set of points.\n  // VMAP: { type[ID4], dimension[U2], name[S0], ( vert[VX], value[F4] # dimension ) * }\n  // VMAD Associates a set of floating-point vectors with the vertices of specific polygons.\n  // Similar to VMAP UVs, but associates with polygon vertices rather than points\n  // to solve to problem of UV seams:  VMAD chunks are paired with VMAPs of the same name,\n  // if they exist. The vector values in the VMAD will then replace those in the\n  // corresponding VMAP, but only for calculations involving the specified polygons.\n  // VMAD { type[ID4], dimension[U2], name[S0], ( vert[VX], poly[VX], value[F4] # dimension ) * }\n  parseVertexMapping(length, discontinuous) {\n    var finalOffset = this.reader.offset + length;\n    var channelName = this.reader.getString();\n    if (this.reader.offset === finalOffset) {\n      this.currentForm.UVChannel = channelName;\n      return;\n    }\n    this.reader.setOffset(this.reader.offset - stringOffset(channelName));\n    var type = this.reader.getIDTag();\n    this.reader.getUint16();\n    var name = this.reader.getString();\n    var remainingLength = length - 6 - stringOffset(name);\n    switch (type) {\n      case \"TXUV\":\n        this.parseUVMapping(name, finalOffset, discontinuous);\n        break;\n      case \"MORF\":\n      case \"SPOT\":\n        this.parseMorphTargets(name, finalOffset, type);\n        break;\n      case \"APSL\":\n      case \"NORM\":\n      case \"WGHT\":\n      case \"MNVW\":\n      case \"PICK\":\n      case \"RGB \":\n      case \"RGBA\":\n        this.reader.skip(remainingLength);\n        break;\n      default:\n        console.warn(\"LWOLoader: unknown vertex map type: \" + type);\n        this.reader.skip(remainingLength);\n    }\n  }\n  parseUVMapping(name, finalOffset, discontinuous) {\n    var uvIndices = [];\n    var polyIndices = [];\n    var uvs = [];\n    while (this.reader.offset < finalOffset) {\n      uvIndices.push(this.reader.getVariableLengthIndex());\n      if (discontinuous)\n        polyIndices.push(this.reader.getVariableLengthIndex());\n      uvs.push(this.reader.getFloat32(), this.reader.getFloat32());\n    }\n    if (discontinuous) {\n      if (!this.currentLayer.discontinuousUVs)\n        this.currentLayer.discontinuousUVs = {};\n      this.currentLayer.discontinuousUVs[name] = {\n        uvIndices,\n        polyIndices,\n        uvs\n      };\n    } else {\n      if (!this.currentLayer.uvs)\n        this.currentLayer.uvs = {};\n      this.currentLayer.uvs[name] = {\n        uvIndices,\n        uvs\n      };\n    }\n  }\n  parseMorphTargets(name, finalOffset, type) {\n    var indices = [];\n    var points = [];\n    type = type === \"MORF\" ? \"relative\" : \"absolute\";\n    while (this.reader.offset < finalOffset) {\n      indices.push(this.reader.getVariableLengthIndex());\n      points.push(this.reader.getFloat32(), this.reader.getFloat32(), -this.reader.getFloat32());\n    }\n    if (!this.currentLayer.morphTargets)\n      this.currentLayer.morphTargets = {};\n    this.currentLayer.morphTargets[name] = {\n      indices,\n      points,\n      type\n    };\n  }\n  // A list of polygons for the current layer.\n  // POLS { type[ID4], ( numvert+flags[U2], vert[VX] # numvert ) * }\n  parsePolygonList(length) {\n    var finalOffset = this.reader.offset + length;\n    var type = this.reader.getIDTag();\n    var indices = [];\n    var polygonDimensions = [];\n    while (this.reader.offset < finalOffset) {\n      var numverts = this.reader.getUint16();\n      numverts = numverts & 1023;\n      polygonDimensions.push(numverts);\n      for (var j = 0; j < numverts; j++)\n        indices.push(this.reader.getVariableLengthIndex());\n    }\n    var geometryData = {\n      type,\n      vertexIndices: indices,\n      polygonDimensions,\n      points: this.currentPoints\n    };\n    if (polygonDimensions[0] === 1)\n      geometryData.type = \"points\";\n    else if (polygonDimensions[0] === 2)\n      geometryData.type = \"lines\";\n    this.currentLayer.geometry = geometryData;\n  }\n  // Lists the tag strings that can be associated with polygons by the PTAG chunk.\n  // TAGS { tag-string[S0] * }\n  parseTagStrings(length) {\n    this.tree.tags = this.reader.getStringArray(length);\n  }\n  // Associates tags of a given type with polygons in the most recent POLS chunk.\n  // PTAG { type[ID4], ( poly[VX], tag[U2] ) * }\n  parsePolygonTagMapping(length) {\n    var finalOffset = this.reader.offset + length;\n    var type = this.reader.getIDTag();\n    if (type === \"SURF\")\n      this.parseMaterialIndices(finalOffset);\n    else {\n      this.reader.skip(length - 4);\n    }\n  }\n  parseMaterialIndices(finalOffset) {\n    this.currentLayer.geometry.materialIndices = [];\n    while (this.reader.offset < finalOffset) {\n      var polygonIndex = this.reader.getVariableLengthIndex();\n      var materialIndex = this.reader.getUint16();\n      this.currentLayer.geometry.materialIndices.push(polygonIndex, materialIndex);\n    }\n  }\n  parseUnknownCHUNK(blockID, length) {\n    console.warn(\"LWOLoader: unknown chunk type: \" + blockID + \" length: \" + length);\n    var data = this.reader.getString(length);\n    this.currentForm[blockID] = data;\n  }\n}\nclass DataViewReader {\n  constructor(buffer) {\n    this.dv = new DataView(buffer);\n    this.offset = 0;\n    this._textDecoder = new TextDecoder();\n    this._bytes = new Uint8Array(buffer);\n  }\n  size() {\n    return this.dv.buffer.byteLength;\n  }\n  setOffset(offset) {\n    if (offset > 0 && offset < this.dv.buffer.byteLength) {\n      this.offset = offset;\n    } else {\n      console.error(\"LWOLoader: invalid buffer offset\");\n    }\n  }\n  endOfFile() {\n    if (this.offset >= this.size())\n      return true;\n    return false;\n  }\n  skip(length) {\n    this.offset += length;\n  }\n  getUint8() {\n    var value = this.dv.getUint8(this.offset);\n    this.offset += 1;\n    return value;\n  }\n  getUint16() {\n    var value = this.dv.getUint16(this.offset);\n    this.offset += 2;\n    return value;\n  }\n  getInt32() {\n    var value = this.dv.getInt32(this.offset, false);\n    this.offset += 4;\n    return value;\n  }\n  getUint32() {\n    var value = this.dv.getUint32(this.offset, false);\n    this.offset += 4;\n    return value;\n  }\n  getUint64() {\n    var low, high;\n    high = this.getUint32();\n    low = this.getUint32();\n    return high * 4294967296 + low;\n  }\n  getFloat32() {\n    var value = this.dv.getFloat32(this.offset, false);\n    this.offset += 4;\n    return value;\n  }\n  getFloat32Array(size) {\n    var a = [];\n    for (var i = 0; i < size; i++) {\n      a.push(this.getFloat32());\n    }\n    return a;\n  }\n  getFloat64() {\n    var value = this.dv.getFloat64(this.offset, this.littleEndian);\n    this.offset += 8;\n    return value;\n  }\n  getFloat64Array(size) {\n    var a = [];\n    for (var i = 0; i < size; i++) {\n      a.push(this.getFloat64());\n    }\n    return a;\n  }\n  // get variable-length index data type\n  // VX ::= index[U2] | (index + 0xFF000000)[U4]\n  // If the index value is less than 65,280 (0xFF00),then VX === U2\n  // otherwise VX === U4 with bits 24-31 set\n  // When reading an index, if the first byte encountered is 255 (0xFF), then\n  // the four-byte form is being used and the first byte should be discarded or masked out.\n  getVariableLengthIndex() {\n    var firstByte = this.getUint8();\n    if (firstByte === 255) {\n      return this.getUint8() * 65536 + this.getUint8() * 256 + this.getUint8();\n    }\n    return firstByte * 256 + this.getUint8();\n  }\n  // An ID tag is a sequence of 4 bytes containing 7-bit ASCII values\n  getIDTag() {\n    return this.getString(4);\n  }\n  getString(size) {\n    if (size === 0)\n      return;\n    const start = this.offset;\n    let result;\n    let length;\n    if (size) {\n      length = size;\n      result = this._textDecoder.decode(new Uint8Array(this.dv.buffer, start, size));\n    } else {\n      length = this._bytes.indexOf(0, start) - start;\n      result = this._textDecoder.decode(new Uint8Array(this.dv.buffer, start, length));\n      length++;\n      length += length % 2;\n    }\n    this.skip(length);\n    return result;\n  }\n  getStringArray(size) {\n    var a = this.getString(size);\n    a = a.split(\"\\0\");\n    return a.filter(Boolean);\n  }\n}\nclass Debugger {\n  constructor() {\n    this.active = false;\n    this.depth = 0;\n    this.formList = [];\n  }\n  enable() {\n    this.active = true;\n  }\n  log() {\n    if (!this.active)\n      return;\n    var nodeType;\n    switch (this.node) {\n      case 0:\n        nodeType = \"FORM\";\n        break;\n      case 1:\n        nodeType = \"CHK\";\n        break;\n      case 2:\n        nodeType = \"S-CHK\";\n        break;\n    }\n    console.log(\n      \"| \".repeat(this.depth) + nodeType,\n      this.nodeID,\n      `( ${this.offset} ) -> ( ${this.dataOffset + this.length} )`,\n      this.node == 0 ? \" {\" : \"\",\n      this.skipped ? \"SKIPPED\" : \"\",\n      this.node == 0 && this.skipped ? \"}\" : \"\"\n    );\n    if (this.node == 0 && !this.skipped) {\n      this.depth += 1;\n      this.formList.push(this.dataOffset + this.length);\n    }\n    this.skipped = false;\n  }\n  closeForms() {\n    if (!this.active)\n      return;\n    for (var i = this.formList.length - 1; i >= 0; i--) {\n      if (this.offset >= this.formList[i]) {\n        this.depth -= 1;\n        console.log(\"| \".repeat(this.depth) + \"}\");\n        this.formList.splice(-1, 1);\n      }\n    }\n  }\n}\nfunction isEven(num) {\n  return num % 2;\n}\nfunction stringOffset(string) {\n  return string.length + 1 + (isEven(string.length + 1) ? 1 : 0);\n}\nfunction printBuffer(buffer, from, to) {\n  console.log(new TextDecoder().decode(new Uint8Array(buffer, from, to)));\n}\nexport {\n  IFFParser\n};\n"]},"metadata":{},"sourceType":"module"}