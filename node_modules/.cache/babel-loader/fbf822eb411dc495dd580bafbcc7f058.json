{"ast":null,"code":"import _classCallCheck from \"/Users/theodaguier/Repositories/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/theodaguier/Repositories/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { Matrix4, Vector3, Box3, DirectionalLight, MathUtils, ShaderChunk, Vector2 } from \"three\";\nimport { CSMFrustum } from \"./CSMFrustum.js\";\nimport { CSMShader } from \"./CSMShader.js\";\n\nvar _cameraToLightMatrix = /* @__PURE__ */new Matrix4();\n\nvar _lightSpaceFrustum = /* @__PURE__ */new CSMFrustum();\n\nvar _center = /* @__PURE__ */new Vector3();\n\nvar _bbox = /* @__PURE__ */new Box3();\n\nvar _uniformArray = [];\nvar _logArray = [];\n\nvar CSM = /*#__PURE__*/function () {\n  function CSM(data) {\n    _classCallCheck(this, CSM);\n\n    data = data || {};\n    this.camera = data.camera;\n    this.parent = data.parent;\n    this.cascades = data.cascades || 3;\n    this.maxFar = data.maxFar || 1e5;\n    this.mode = data.mode || \"practical\";\n    this.shadowMapSize = data.shadowMapSize || 2048;\n    this.shadowBias = data.shadowBias || 1e-6;\n    this.lightDirection = data.lightDirection || new Vector3(1, -1, 1).normalize();\n    this.lightIntensity = data.lightIntensity || 1;\n    this.lightNear = data.lightNear || 1;\n    this.lightFar = data.lightFar || 2e3;\n    this.lightMargin = data.lightMargin || 200;\n    this.customSplitsCallback = data.customSplitsCallback;\n    this.fade = false;\n    this.mainFrustum = new CSMFrustum();\n    this.frustums = [];\n    this.breaks = [];\n    this.lights = [];\n    this.shaders = /* @__PURE__ */new Map();\n    this.createLights();\n    this.updateFrustums();\n    this.injectInclude();\n  }\n\n  _createClass(CSM, [{\n    key: \"createLights\",\n    value: function createLights() {\n      for (var i = 0; i < this.cascades; i++) {\n        var light = new DirectionalLight(16777215, this.lightIntensity);\n        light.castShadow = true;\n        light.shadow.mapSize.width = this.shadowMapSize;\n        light.shadow.mapSize.height = this.shadowMapSize;\n        light.shadow.camera.near = this.lightNear;\n        light.shadow.camera.far = this.lightFar;\n        light.shadow.bias = this.shadowBias;\n        this.parent.add(light);\n        this.parent.add(light.target);\n        this.lights.push(light);\n      }\n    }\n  }, {\n    key: \"initCascades\",\n    value: function initCascades() {\n      var camera = this.camera;\n      camera.updateProjectionMatrix();\n      this.mainFrustum.setFromProjectionMatrix(camera.projectionMatrix, this.maxFar);\n      this.mainFrustum.split(this.breaks, this.frustums);\n    }\n  }, {\n    key: \"updateShadowBounds\",\n    value: function updateShadowBounds() {\n      var frustums = this.frustums;\n\n      for (var i = 0; i < frustums.length; i++) {\n        var light = this.lights[i];\n        var shadowCam = light.shadow.camera;\n        var frustum = this.frustums[i];\n        var nearVerts = frustum.vertices.near;\n        var farVerts = frustum.vertices.far;\n        var point1 = farVerts[0];\n        var point2 = void 0;\n\n        if (point1.distanceTo(farVerts[2]) > point1.distanceTo(nearVerts[2])) {\n          point2 = farVerts[2];\n        } else {\n          point2 = nearVerts[2];\n        }\n\n        var squaredBBWidth = point1.distanceTo(point2);\n\n        if (this.fade) {\n          var camera = this.camera;\n          var far = Math.max(camera.far, this.maxFar);\n          var linearDepth = frustum.vertices.far[0].z / (far - camera.near);\n          var margin = 0.25 * Math.pow(linearDepth, 2) * (far - camera.near);\n          squaredBBWidth += margin;\n        }\n\n        shadowCam.left = -squaredBBWidth / 2;\n        shadowCam.right = squaredBBWidth / 2;\n        shadowCam.top = squaredBBWidth / 2;\n        shadowCam.bottom = -squaredBBWidth / 2;\n        shadowCam.updateProjectionMatrix();\n      }\n    }\n  }, {\n    key: \"getBreaks\",\n    value: function getBreaks() {\n      var camera = this.camera;\n      var far = Math.min(camera.far, this.maxFar);\n      this.breaks.length = 0;\n\n      switch (this.mode) {\n        case \"uniform\":\n          uniformSplit(this.cascades, camera.near, far, this.breaks);\n          break;\n\n        case \"logarithmic\":\n          logarithmicSplit(this.cascades, camera.near, far, this.breaks);\n          break;\n\n        case \"practical\":\n          practicalSplit(this.cascades, camera.near, far, 0.5, this.breaks);\n          break;\n\n        case \"custom\":\n          if (this.customSplitsCallback === void 0) console.error(\"CSM: Custom split scheme callback not defined.\");\n          this.customSplitsCallback(this.cascades, camera.near, far, this.breaks);\n          break;\n      }\n\n      function uniformSplit(amount, near, far2, target) {\n        for (var i = 1; i < amount; i++) {\n          target.push((near + (far2 - near) * i / amount) / far2);\n        }\n\n        target.push(1);\n      }\n\n      function logarithmicSplit(amount, near, far2, target) {\n        for (var i = 1; i < amount; i++) {\n          target.push(near * Math.pow(far2 / near, i / amount) / far2);\n        }\n\n        target.push(1);\n      }\n\n      function practicalSplit(amount, near, far2, lambda, target) {\n        _uniformArray.length = 0;\n        _logArray.length = 0;\n        logarithmicSplit(amount, near, far2, _logArray);\n        uniformSplit(amount, near, far2, _uniformArray);\n\n        for (var i = 1; i < amount; i++) {\n          target.push(MathUtils.lerp(_uniformArray[i - 1], _logArray[i - 1], lambda));\n        }\n\n        target.push(1);\n      }\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      var camera = this.camera;\n      var frustums = this.frustums;\n\n      for (var i = 0; i < frustums.length; i++) {\n        var light = this.lights[i];\n        var shadowCam = light.shadow.camera;\n        var texelWidth = (shadowCam.right - shadowCam.left) / this.shadowMapSize;\n        var texelHeight = (shadowCam.top - shadowCam.bottom) / this.shadowMapSize;\n        light.shadow.camera.updateMatrixWorld(true);\n\n        _cameraToLightMatrix.multiplyMatrices(light.shadow.camera.matrixWorldInverse, camera.matrixWorld);\n\n        frustums[i].toSpace(_cameraToLightMatrix, _lightSpaceFrustum);\n        var nearVerts = _lightSpaceFrustum.vertices.near;\n        var farVerts = _lightSpaceFrustum.vertices.far;\n\n        _bbox.makeEmpty();\n\n        for (var j = 0; j < 4; j++) {\n          _bbox.expandByPoint(nearVerts[j]);\n\n          _bbox.expandByPoint(farVerts[j]);\n        }\n\n        _bbox.getCenter(_center);\n\n        _center.z = _bbox.max.z + this.lightMargin;\n        _center.x = Math.floor(_center.x / texelWidth) * texelWidth;\n        _center.y = Math.floor(_center.y / texelHeight) * texelHeight;\n\n        _center.applyMatrix4(light.shadow.camera.matrixWorld);\n\n        light.position.copy(_center);\n        light.target.position.copy(_center);\n        light.target.position.x += this.lightDirection.x;\n        light.target.position.y += this.lightDirection.y;\n        light.target.position.z += this.lightDirection.z;\n      }\n    }\n  }, {\n    key: \"injectInclude\",\n    value: function injectInclude() {\n      ShaderChunk.lights_fragment_begin = CSMShader.lights_fragment_begin;\n      ShaderChunk.lights_pars_begin = CSMShader.lights_pars_begin;\n    }\n  }, {\n    key: \"setupMaterial\",\n    value: function setupMaterial(material) {\n      material.defines = material.defines || {};\n      material.defines.USE_CSM = 1;\n      material.defines.CSM_CASCADES = this.cascades;\n\n      if (this.fade) {\n        material.defines.CSM_FADE = \"\";\n      }\n\n      var breaksVec2 = [];\n      var scope = this;\n      var shaders = this.shaders;\n\n      material.onBeforeCompile = function (shader) {\n        var far = Math.min(scope.camera.far, scope.maxFar);\n        scope.getExtendedBreaks(breaksVec2);\n        shader.uniforms.CSM_cascades = {\n          value: breaksVec2\n        };\n        shader.uniforms.cameraNear = {\n          value: scope.camera.near\n        };\n        shader.uniforms.shadowFar = {\n          value: far\n        };\n        shaders.set(material, shader);\n      };\n\n      shaders.set(material, null);\n    }\n  }, {\n    key: \"updateUniforms\",\n    value: function updateUniforms() {\n      var far = Math.min(this.camera.far, this.maxFar);\n      var shaders = this.shaders;\n      shaders.forEach(function (shader, material) {\n        if (shader !== null) {\n          var uniforms = shader.uniforms;\n          this.getExtendedBreaks(uniforms.CSM_cascades.value);\n          uniforms.cameraNear.value = this.camera.near;\n          uniforms.shadowFar.value = far;\n        }\n\n        if (!this.fade && \"CSM_FADE\" in material.defines) {\n          delete material.defines.CSM_FADE;\n          material.needsUpdate = true;\n        } else if (this.fade && !(\"CSM_FADE\" in material.defines)) {\n          material.defines.CSM_FADE = \"\";\n          material.needsUpdate = true;\n        }\n      }, this);\n    }\n  }, {\n    key: \"getExtendedBreaks\",\n    value: function getExtendedBreaks(target) {\n      while (target.length < this.breaks.length) {\n        target.push(new Vector2());\n      }\n\n      target.length = this.breaks.length;\n\n      for (var i = 0; i < this.cascades; i++) {\n        var amount = this.breaks[i];\n        var prev = this.breaks[i - 1] || 0;\n        target[i].x = prev;\n        target[i].y = amount;\n      }\n    }\n  }, {\n    key: \"updateFrustums\",\n    value: function updateFrustums() {\n      this.getBreaks();\n      this.initCascades();\n      this.updateShadowBounds();\n      this.updateUniforms();\n    }\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      for (var i = 0; i < this.lights.length; i++) {\n        this.parent.remove(this.lights[i]);\n      }\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      var shaders = this.shaders;\n      shaders.forEach(function (shader, material) {\n        delete material.onBeforeCompile;\n        delete material.defines.USE_CSM;\n        delete material.defines.CSM_CASCADES;\n        delete material.defines.CSM_FADE;\n\n        if (shader !== null) {\n          delete shader.uniforms.CSM_cascades;\n          delete shader.uniforms.cameraNear;\n          delete shader.uniforms.shadowFar;\n        }\n\n        material.needsUpdate = true;\n      });\n      shaders.clear();\n    }\n  }]);\n\n  return CSM;\n}();\n\nexport { CSM };","map":{"version":3,"sources":["/Users/theodaguier/Repositories/E-Do-Studio/node_modules/three-stdlib/csm/CSM.js"],"names":["Matrix4","Vector3","Box3","DirectionalLight","MathUtils","ShaderChunk","Vector2","CSMFrustum","CSMShader","_cameraToLightMatrix","_lightSpaceFrustum","_center","_bbox","_uniformArray","_logArray","CSM","data","camera","parent","cascades","maxFar","mode","shadowMapSize","shadowBias","lightDirection","normalize","lightIntensity","lightNear","lightFar","lightMargin","customSplitsCallback","fade","mainFrustum","frustums","breaks","lights","shaders","Map","createLights","updateFrustums","injectInclude","i","light","castShadow","shadow","mapSize","width","height","near","far","bias","add","target","push","updateProjectionMatrix","setFromProjectionMatrix","projectionMatrix","split","length","shadowCam","frustum","nearVerts","vertices","farVerts","point1","point2","distanceTo","squaredBBWidth","Math","max","linearDepth","z","margin","pow","left","right","top","bottom","min","uniformSplit","logarithmicSplit","practicalSplit","console","error","amount","far2","lambda","lerp","texelWidth","texelHeight","updateMatrixWorld","multiplyMatrices","matrixWorldInverse","matrixWorld","toSpace","makeEmpty","j","expandByPoint","getCenter","x","floor","y","applyMatrix4","position","copy","lights_fragment_begin","lights_pars_begin","material","defines","USE_CSM","CSM_CASCADES","CSM_FADE","breaksVec2","scope","onBeforeCompile","shader","getExtendedBreaks","uniforms","CSM_cascades","value","cameraNear","shadowFar","set","forEach","needsUpdate","prev","getBreaks","initCascades","updateShadowBounds","updateUniforms","remove","clear"],"mappings":"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","sourcesContent":["import { Matrix4, Vector3, Box3, DirectionalLight, MathUtils, ShaderChunk, Vector2 } from \"three\";\nimport { CSMFrustum } from \"./CSMFrustum.js\";\nimport { CSMShader } from \"./CSMShader.js\";\nconst _cameraToLightMatrix = /* @__PURE__ */ new Matrix4();\nconst _lightSpaceFrustum = /* @__PURE__ */ new CSMFrustum();\nconst _center = /* @__PURE__ */ new Vector3();\nconst _bbox = /* @__PURE__ */ new Box3();\nconst _uniformArray = [];\nconst _logArray = [];\nclass CSM {\n  constructor(data) {\n    data = data || {};\n    this.camera = data.camera;\n    this.parent = data.parent;\n    this.cascades = data.cascades || 3;\n    this.maxFar = data.maxFar || 1e5;\n    this.mode = data.mode || \"practical\";\n    this.shadowMapSize = data.shadowMapSize || 2048;\n    this.shadowBias = data.shadowBias || 1e-6;\n    this.lightDirection = data.lightDirection || new Vector3(1, -1, 1).normalize();\n    this.lightIntensity = data.lightIntensity || 1;\n    this.lightNear = data.lightNear || 1;\n    this.lightFar = data.lightFar || 2e3;\n    this.lightMargin = data.lightMargin || 200;\n    this.customSplitsCallback = data.customSplitsCallback;\n    this.fade = false;\n    this.mainFrustum = new CSMFrustum();\n    this.frustums = [];\n    this.breaks = [];\n    this.lights = [];\n    this.shaders = /* @__PURE__ */ new Map();\n    this.createLights();\n    this.updateFrustums();\n    this.injectInclude();\n  }\n  createLights() {\n    for (let i = 0; i < this.cascades; i++) {\n      const light = new DirectionalLight(16777215, this.lightIntensity);\n      light.castShadow = true;\n      light.shadow.mapSize.width = this.shadowMapSize;\n      light.shadow.mapSize.height = this.shadowMapSize;\n      light.shadow.camera.near = this.lightNear;\n      light.shadow.camera.far = this.lightFar;\n      light.shadow.bias = this.shadowBias;\n      this.parent.add(light);\n      this.parent.add(light.target);\n      this.lights.push(light);\n    }\n  }\n  initCascades() {\n    const camera = this.camera;\n    camera.updateProjectionMatrix();\n    this.mainFrustum.setFromProjectionMatrix(camera.projectionMatrix, this.maxFar);\n    this.mainFrustum.split(this.breaks, this.frustums);\n  }\n  updateShadowBounds() {\n    const frustums = this.frustums;\n    for (let i = 0; i < frustums.length; i++) {\n      const light = this.lights[i];\n      const shadowCam = light.shadow.camera;\n      const frustum = this.frustums[i];\n      const nearVerts = frustum.vertices.near;\n      const farVerts = frustum.vertices.far;\n      const point1 = farVerts[0];\n      let point2;\n      if (point1.distanceTo(farVerts[2]) > point1.distanceTo(nearVerts[2])) {\n        point2 = farVerts[2];\n      } else {\n        point2 = nearVerts[2];\n      }\n      let squaredBBWidth = point1.distanceTo(point2);\n      if (this.fade) {\n        const camera = this.camera;\n        const far = Math.max(camera.far, this.maxFar);\n        const linearDepth = frustum.vertices.far[0].z / (far - camera.near);\n        const margin = 0.25 * Math.pow(linearDepth, 2) * (far - camera.near);\n        squaredBBWidth += margin;\n      }\n      shadowCam.left = -squaredBBWidth / 2;\n      shadowCam.right = squaredBBWidth / 2;\n      shadowCam.top = squaredBBWidth / 2;\n      shadowCam.bottom = -squaredBBWidth / 2;\n      shadowCam.updateProjectionMatrix();\n    }\n  }\n  getBreaks() {\n    const camera = this.camera;\n    const far = Math.min(camera.far, this.maxFar);\n    this.breaks.length = 0;\n    switch (this.mode) {\n      case \"uniform\":\n        uniformSplit(this.cascades, camera.near, far, this.breaks);\n        break;\n      case \"logarithmic\":\n        logarithmicSplit(this.cascades, camera.near, far, this.breaks);\n        break;\n      case \"practical\":\n        practicalSplit(this.cascades, camera.near, far, 0.5, this.breaks);\n        break;\n      case \"custom\":\n        if (this.customSplitsCallback === void 0)\n          console.error(\"CSM: Custom split scheme callback not defined.\");\n        this.customSplitsCallback(this.cascades, camera.near, far, this.breaks);\n        break;\n    }\n    function uniformSplit(amount, near, far2, target) {\n      for (let i = 1; i < amount; i++) {\n        target.push((near + (far2 - near) * i / amount) / far2);\n      }\n      target.push(1);\n    }\n    function logarithmicSplit(amount, near, far2, target) {\n      for (let i = 1; i < amount; i++) {\n        target.push(near * (far2 / near) ** (i / amount) / far2);\n      }\n      target.push(1);\n    }\n    function practicalSplit(amount, near, far2, lambda, target) {\n      _uniformArray.length = 0;\n      _logArray.length = 0;\n      logarithmicSplit(amount, near, far2, _logArray);\n      uniformSplit(amount, near, far2, _uniformArray);\n      for (let i = 1; i < amount; i++) {\n        target.push(MathUtils.lerp(_uniformArray[i - 1], _logArray[i - 1], lambda));\n      }\n      target.push(1);\n    }\n  }\n  update() {\n    const camera = this.camera;\n    const frustums = this.frustums;\n    for (let i = 0; i < frustums.length; i++) {\n      const light = this.lights[i];\n      const shadowCam = light.shadow.camera;\n      const texelWidth = (shadowCam.right - shadowCam.left) / this.shadowMapSize;\n      const texelHeight = (shadowCam.top - shadowCam.bottom) / this.shadowMapSize;\n      light.shadow.camera.updateMatrixWorld(true);\n      _cameraToLightMatrix.multiplyMatrices(light.shadow.camera.matrixWorldInverse, camera.matrixWorld);\n      frustums[i].toSpace(_cameraToLightMatrix, _lightSpaceFrustum);\n      const nearVerts = _lightSpaceFrustum.vertices.near;\n      const farVerts = _lightSpaceFrustum.vertices.far;\n      _bbox.makeEmpty();\n      for (let j = 0; j < 4; j++) {\n        _bbox.expandByPoint(nearVerts[j]);\n        _bbox.expandByPoint(farVerts[j]);\n      }\n      _bbox.getCenter(_center);\n      _center.z = _bbox.max.z + this.lightMargin;\n      _center.x = Math.floor(_center.x / texelWidth) * texelWidth;\n      _center.y = Math.floor(_center.y / texelHeight) * texelHeight;\n      _center.applyMatrix4(light.shadow.camera.matrixWorld);\n      light.position.copy(_center);\n      light.target.position.copy(_center);\n      light.target.position.x += this.lightDirection.x;\n      light.target.position.y += this.lightDirection.y;\n      light.target.position.z += this.lightDirection.z;\n    }\n  }\n  injectInclude() {\n    ShaderChunk.lights_fragment_begin = CSMShader.lights_fragment_begin;\n    ShaderChunk.lights_pars_begin = CSMShader.lights_pars_begin;\n  }\n  setupMaterial(material) {\n    material.defines = material.defines || {};\n    material.defines.USE_CSM = 1;\n    material.defines.CSM_CASCADES = this.cascades;\n    if (this.fade) {\n      material.defines.CSM_FADE = \"\";\n    }\n    const breaksVec2 = [];\n    const scope = this;\n    const shaders = this.shaders;\n    material.onBeforeCompile = function(shader) {\n      const far = Math.min(scope.camera.far, scope.maxFar);\n      scope.getExtendedBreaks(breaksVec2);\n      shader.uniforms.CSM_cascades = { value: breaksVec2 };\n      shader.uniforms.cameraNear = { value: scope.camera.near };\n      shader.uniforms.shadowFar = { value: far };\n      shaders.set(material, shader);\n    };\n    shaders.set(material, null);\n  }\n  updateUniforms() {\n    const far = Math.min(this.camera.far, this.maxFar);\n    const shaders = this.shaders;\n    shaders.forEach(function(shader, material) {\n      if (shader !== null) {\n        const uniforms = shader.uniforms;\n        this.getExtendedBreaks(uniforms.CSM_cascades.value);\n        uniforms.cameraNear.value = this.camera.near;\n        uniforms.shadowFar.value = far;\n      }\n      if (!this.fade && \"CSM_FADE\" in material.defines) {\n        delete material.defines.CSM_FADE;\n        material.needsUpdate = true;\n      } else if (this.fade && !(\"CSM_FADE\" in material.defines)) {\n        material.defines.CSM_FADE = \"\";\n        material.needsUpdate = true;\n      }\n    }, this);\n  }\n  getExtendedBreaks(target) {\n    while (target.length < this.breaks.length) {\n      target.push(new Vector2());\n    }\n    target.length = this.breaks.length;\n    for (let i = 0; i < this.cascades; i++) {\n      const amount = this.breaks[i];\n      const prev = this.breaks[i - 1] || 0;\n      target[i].x = prev;\n      target[i].y = amount;\n    }\n  }\n  updateFrustums() {\n    this.getBreaks();\n    this.initCascades();\n    this.updateShadowBounds();\n    this.updateUniforms();\n  }\n  remove() {\n    for (let i = 0; i < this.lights.length; i++) {\n      this.parent.remove(this.lights[i]);\n    }\n  }\n  dispose() {\n    const shaders = this.shaders;\n    shaders.forEach(function(shader, material) {\n      delete material.onBeforeCompile;\n      delete material.defines.USE_CSM;\n      delete material.defines.CSM_CASCADES;\n      delete material.defines.CSM_FADE;\n      if (shader !== null) {\n        delete shader.uniforms.CSM_cascades;\n        delete shader.uniforms.cameraNear;\n        delete shader.uniforms.shadowFar;\n      }\n      material.needsUpdate = true;\n    });\n    shaders.clear();\n  }\n}\nexport {\n  CSM\n};\n"]},"metadata":{},"sourceType":"module"}