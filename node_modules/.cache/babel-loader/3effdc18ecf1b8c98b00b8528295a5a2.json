{"ast":null,"code":"import _classCallCheck from \"/Users/theodaguier/_workdir/dev/pro/e-do/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/theodaguier/_workdir/dev/pro/e-do/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { Vector3, Line3, Plane, Mesh } from \"three\";\nimport { ConvexGeometry } from \"../geometries/ConvexGeometry.js\";\n\nvar _v1 = /* @__PURE__ */new Vector3();\n\nvar ConvexObjectBreaker = /*#__PURE__*/function () {\n  function ConvexObjectBreaker() {\n    var minSizeForBreak = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1.4;\n    var smallDelta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1e-4;\n\n    _classCallCheck(this, ConvexObjectBreaker);\n\n    this.minSizeForBreak = minSizeForBreak;\n    this.smallDelta = smallDelta;\n    this.tempLine1 = new Line3();\n    this.tempPlane1 = new Plane();\n    this.tempPlane2 = new Plane();\n    this.tempPlane_Cut = new Plane();\n    this.tempCM1 = new Vector3();\n    this.tempCM2 = new Vector3();\n    this.tempVector3 = new Vector3();\n    this.tempVector3_2 = new Vector3();\n    this.tempVector3_3 = new Vector3();\n    this.tempVector3_P0 = new Vector3();\n    this.tempVector3_P1 = new Vector3();\n    this.tempVector3_P2 = new Vector3();\n    this.tempVector3_N0 = new Vector3();\n    this.tempVector3_N1 = new Vector3();\n    this.tempVector3_AB = new Vector3();\n    this.tempVector3_CB = new Vector3();\n    this.tempResultObjects = {\n      object1: null,\n      object2: null\n    };\n    this.segments = [];\n    var n = 30 * 30;\n\n    for (var i = 0; i < n; i++) {\n      this.segments[i] = false;\n    }\n  }\n\n  _createClass(ConvexObjectBreaker, [{\n    key: \"prepareBreakableObject\",\n    value: function prepareBreakableObject(object, mass, velocity, angularVelocity, breakable) {\n      var userData = object.userData;\n      userData.mass = mass;\n      userData.velocity = velocity.clone();\n      userData.angularVelocity = angularVelocity.clone();\n      userData.breakable = breakable;\n    }\n    /*\n     * @param {int} maxRadialIterations Iterations for radial cuts.\n     * @param {int} maxRandomIterations Max random iterations for not-radial cuts\n     *\n     * Returns the array of pieces\n     */\n\n  }, {\n    key: \"subdivideByImpact\",\n    value: function subdivideByImpact(object, pointOfImpact, normal, maxRadialIterations, maxRandomIterations) {\n      var debris = [];\n      var tempPlane1 = this.tempPlane1;\n      var tempPlane2 = this.tempPlane2;\n      this.tempVector3.addVectors(pointOfImpact, normal);\n      tempPlane1.setFromCoplanarPoints(pointOfImpact, object.position, this.tempVector3);\n      var maxTotalIterations = maxRandomIterations + maxRadialIterations;\n      var scope = this;\n\n      function subdivideRadial(subObject, startAngle, endAngle, numIterations) {\n        if (Math.random() < numIterations * 0.05 || numIterations > maxTotalIterations) {\n          debris.push(subObject);\n          return;\n        }\n\n        var angle = Math.PI;\n\n        if (numIterations === 0) {\n          tempPlane2.normal.copy(tempPlane1.normal);\n          tempPlane2.constant = tempPlane1.constant;\n        } else {\n          if (numIterations <= maxRadialIterations) {\n            angle = (endAngle - startAngle) * (0.2 + 0.6 * Math.random()) + startAngle;\n            scope.tempVector3_2.copy(object.position).sub(pointOfImpact).applyAxisAngle(normal, angle).add(pointOfImpact);\n            tempPlane2.setFromCoplanarPoints(pointOfImpact, scope.tempVector3, scope.tempVector3_2);\n          } else {\n            angle = (0.5 * (numIterations & 1) + 0.2 * (2 - Math.random())) * Math.PI;\n            scope.tempVector3_2.copy(pointOfImpact).sub(subObject.position).applyAxisAngle(normal, angle).add(subObject.position);\n            scope.tempVector3_3.copy(normal).add(subObject.position);\n            tempPlane2.setFromCoplanarPoints(subObject.position, scope.tempVector3_3, scope.tempVector3_2);\n          }\n        }\n\n        scope.cutByPlane(subObject, tempPlane2, scope.tempResultObjects);\n        var obj1 = scope.tempResultObjects.object1;\n        var obj2 = scope.tempResultObjects.object2;\n\n        if (obj1) {\n          subdivideRadial(obj1, startAngle, angle, numIterations + 1);\n        }\n\n        if (obj2) {\n          subdivideRadial(obj2, angle, endAngle, numIterations + 1);\n        }\n      }\n\n      subdivideRadial(object, 0, 2 * Math.PI, 0);\n      return debris;\n    }\n  }, {\n    key: \"cutByPlane\",\n    value: function cutByPlane(object, plane, output) {\n      var geometry = object.geometry;\n      var coords = geometry.attributes.position.array;\n      var normals = geometry.attributes.normal.array;\n      var numPoints = coords.length / 3;\n      var numFaces = numPoints / 3;\n      var indices = geometry.getIndex();\n\n      if (indices) {\n        indices = indices.array;\n        numFaces = indices.length / 3;\n      }\n\n      function getVertexIndex(faceIdx, vert) {\n        var idx = faceIdx * 3 + vert;\n        return indices ? indices[idx] : idx;\n      }\n\n      var points1 = [];\n      var points2 = [];\n      var delta = this.smallDelta;\n      var numPointPairs = numPoints * numPoints;\n\n      for (var i = 0; i < numPointPairs; i++) {\n        this.segments[i] = false;\n      }\n\n      var p0 = this.tempVector3_P0;\n      var p1 = this.tempVector3_P1;\n      var n0 = this.tempVector3_N0;\n      var n1 = this.tempVector3_N1;\n\n      for (var _i = 0; _i < numFaces - 1; _i++) {\n        var a1 = getVertexIndex(_i, 0);\n        var b1 = getVertexIndex(_i, 1);\n        var c1 = getVertexIndex(_i, 2);\n        n0.set(normals[a1], normals[a1] + 1, normals[a1] + 2);\n\n        for (var j = _i + 1; j < numFaces; j++) {\n          var a2 = getVertexIndex(j, 0);\n          var b2 = getVertexIndex(j, 1);\n          var c2 = getVertexIndex(j, 2);\n          n1.set(normals[a2], normals[a2] + 1, normals[a2] + 2);\n          var coplanar = 1 - n0.dot(n1) < delta;\n\n          if (coplanar) {\n            if (a1 === a2 || a1 === b2 || a1 === c2) {\n              if (b1 === a2 || b1 === b2 || b1 === c2) {\n                this.segments[a1 * numPoints + b1] = true;\n                this.segments[b1 * numPoints + a1] = true;\n              } else {\n                this.segments[c1 * numPoints + a1] = true;\n                this.segments[a1 * numPoints + c1] = true;\n              }\n            } else if (b1 === a2 || b1 === b2 || b1 === c2) {\n              this.segments[c1 * numPoints + b1] = true;\n              this.segments[b1 * numPoints + c1] = true;\n            }\n          }\n        }\n      }\n\n      var localPlane = this.tempPlane_Cut;\n      object.updateMatrix();\n      ConvexObjectBreaker.transformPlaneToLocalSpace(plane, object.matrix, localPlane);\n\n      for (var _i2 = 0; _i2 < numFaces; _i2++) {\n        var va = getVertexIndex(_i2, 0);\n        var vb = getVertexIndex(_i2, 1);\n        var vc = getVertexIndex(_i2, 2);\n\n        for (var segment = 0; segment < 3; segment++) {\n          var i0 = segment === 0 ? va : segment === 1 ? vb : vc;\n          var i1 = segment === 0 ? vb : segment === 1 ? vc : va;\n          var segmentState = this.segments[i0 * numPoints + i1];\n          if (segmentState) continue;\n          this.segments[i0 * numPoints + i1] = true;\n          this.segments[i1 * numPoints + i0] = true;\n          p0.set(coords[3 * i0], coords[3 * i0 + 1], coords[3 * i0 + 2]);\n          p1.set(coords[3 * i1], coords[3 * i1 + 1], coords[3 * i1 + 2]);\n          var mark0 = 0;\n          var d = localPlane.distanceToPoint(p0);\n\n          if (d > delta) {\n            mark0 = 2;\n            points2.push(p0.clone());\n          } else if (d < -delta) {\n            mark0 = 1;\n            points1.push(p0.clone());\n          } else {\n            mark0 = 3;\n            points1.push(p0.clone());\n            points2.push(p0.clone());\n          }\n\n          var mark1 = 0;\n          d = localPlane.distanceToPoint(p1);\n\n          if (d > delta) {\n            mark1 = 2;\n            points2.push(p1.clone());\n          } else if (d < -delta) {\n            mark1 = 1;\n            points1.push(p1.clone());\n          } else {\n            mark1 = 3;\n            points1.push(p1.clone());\n            points2.push(p1.clone());\n          }\n\n          if (mark0 === 1 && mark1 === 2 || mark0 === 2 && mark1 === 1) {\n            this.tempLine1.start.copy(p0);\n            this.tempLine1.end.copy(p1);\n            var intersection = new Vector3();\n            intersection = localPlane.intersectLine(this.tempLine1, intersection);\n\n            if (intersection === null) {\n              console.error(\"Internal error: segment does not intersect plane.\");\n              output.segmentedObject1 = null;\n              output.segmentedObject2 = null;\n              return 0;\n            }\n\n            points1.push(intersection);\n            points2.push(intersection.clone());\n          }\n        }\n      }\n\n      var newMass = object.userData.mass * 0.5;\n      this.tempCM1.set(0, 0, 0);\n      var radius1 = 0;\n      var numPoints1 = points1.length;\n\n      if (numPoints1 > 0) {\n        for (var _i3 = 0; _i3 < numPoints1; _i3++) {\n          this.tempCM1.add(points1[_i3]);\n        }\n\n        this.tempCM1.divideScalar(numPoints1);\n\n        for (var _i4 = 0; _i4 < numPoints1; _i4++) {\n          var p = points1[_i4];\n          p.sub(this.tempCM1);\n          radius1 = Math.max(radius1, p.x, p.y, p.z);\n        }\n\n        this.tempCM1.add(object.position);\n      }\n\n      this.tempCM2.set(0, 0, 0);\n      var radius2 = 0;\n      var numPoints2 = points2.length;\n\n      if (numPoints2 > 0) {\n        for (var _i5 = 0; _i5 < numPoints2; _i5++) {\n          this.tempCM2.add(points2[_i5]);\n        }\n\n        this.tempCM2.divideScalar(numPoints2);\n\n        for (var _i6 = 0; _i6 < numPoints2; _i6++) {\n          var _p = points2[_i6];\n\n          _p.sub(this.tempCM2);\n\n          radius2 = Math.max(radius2, _p.x, _p.y, _p.z);\n        }\n\n        this.tempCM2.add(object.position);\n      }\n\n      var object1 = null;\n      var object2 = null;\n      var numObjects = 0;\n\n      if (numPoints1 > 4) {\n        object1 = new Mesh(new ConvexGeometry(points1), object.material);\n        object1.position.copy(this.tempCM1);\n        object1.quaternion.copy(object.quaternion);\n        this.prepareBreakableObject(object1, newMass, object.userData.velocity, object.userData.angularVelocity, 2 * radius1 > this.minSizeForBreak);\n        numObjects++;\n      }\n\n      if (numPoints2 > 4) {\n        object2 = new Mesh(new ConvexGeometry(points2), object.material);\n        object2.position.copy(this.tempCM2);\n        object2.quaternion.copy(object.quaternion);\n        this.prepareBreakableObject(object2, newMass, object.userData.velocity, object.userData.angularVelocity, 2 * radius2 > this.minSizeForBreak);\n        numObjects++;\n      }\n\n      output.object1 = object1;\n      output.object2 = object2;\n      return numObjects;\n    }\n  }], [{\n    key: \"transformFreeVector\",\n    value: function transformFreeVector(v, m) {\n      var x = v.x,\n          y = v.y,\n          z = v.z;\n      var e = m.elements;\n      v.x = e[0] * x + e[4] * y + e[8] * z;\n      v.y = e[1] * x + e[5] * y + e[9] * z;\n      v.z = e[2] * x + e[6] * y + e[10] * z;\n      return v;\n    }\n  }, {\n    key: \"transformFreeVectorInverse\",\n    value: function transformFreeVectorInverse(v, m) {\n      var x = v.x,\n          y = v.y,\n          z = v.z;\n      var e = m.elements;\n      v.x = e[0] * x + e[1] * y + e[2] * z;\n      v.y = e[4] * x + e[5] * y + e[6] * z;\n      v.z = e[8] * x + e[9] * y + e[10] * z;\n      return v;\n    }\n  }, {\n    key: \"transformTiedVectorInverse\",\n    value: function transformTiedVectorInverse(v, m) {\n      var x = v.x,\n          y = v.y,\n          z = v.z;\n      var e = m.elements;\n      v.x = e[0] * x + e[1] * y + e[2] * z - e[12];\n      v.y = e[4] * x + e[5] * y + e[6] * z - e[13];\n      v.z = e[8] * x + e[9] * y + e[10] * z - e[14];\n      return v;\n    }\n  }, {\n    key: \"transformPlaneToLocalSpace\",\n    value: function transformPlaneToLocalSpace(plane, m, resultPlane) {\n      resultPlane.normal.copy(plane.normal);\n      resultPlane.constant = plane.constant;\n      var referencePoint = ConvexObjectBreaker.transformTiedVectorInverse(plane.coplanarPoint(_v1), m);\n      ConvexObjectBreaker.transformFreeVectorInverse(resultPlane.normal, m);\n      resultPlane.constant = -referencePoint.dot(resultPlane.normal);\n    }\n  }]);\n\n  return ConvexObjectBreaker;\n}();\n\nexport { ConvexObjectBreaker };","map":{"version":3,"sources":["/Users/theodaguier/_workdir/dev/pro/e-do/E-Do-Studio/node_modules/three-stdlib/misc/ConvexObjectBreaker.js"],"names":["Vector3","Line3","Plane","Mesh","ConvexGeometry","_v1","ConvexObjectBreaker","minSizeForBreak","smallDelta","tempLine1","tempPlane1","tempPlane2","tempPlane_Cut","tempCM1","tempCM2","tempVector3","tempVector3_2","tempVector3_3","tempVector3_P0","tempVector3_P1","tempVector3_P2","tempVector3_N0","tempVector3_N1","tempVector3_AB","tempVector3_CB","tempResultObjects","object1","object2","segments","n","i","object","mass","velocity","angularVelocity","breakable","userData","clone","pointOfImpact","normal","maxRadialIterations","maxRandomIterations","debris","addVectors","setFromCoplanarPoints","position","maxTotalIterations","scope","subdivideRadial","subObject","startAngle","endAngle","numIterations","Math","random","push","angle","PI","copy","constant","sub","applyAxisAngle","add","cutByPlane","obj1","obj2","plane","output","geometry","coords","attributes","array","normals","numPoints","length","numFaces","indices","getIndex","getVertexIndex","faceIdx","vert","idx","points1","points2","delta","numPointPairs","p0","p1","n0","n1","a1","b1","c1","set","j","a2","b2","c2","coplanar","dot","localPlane","updateMatrix","transformPlaneToLocalSpace","matrix","va","vb","vc","segment","i0","i1","segmentState","mark0","d","distanceToPoint","mark1","start","end","intersection","intersectLine","console","error","segmentedObject1","segmentedObject2","newMass","radius1","numPoints1","divideScalar","p","max","x","y","z","radius2","numPoints2","numObjects","material","quaternion","prepareBreakableObject","v","m","e","elements","resultPlane","referencePoint","transformTiedVectorInverse","coplanarPoint","transformFreeVectorInverse"],"mappings":"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","sourcesContent":["import { Vector3, Line3, Plane, Mesh } from \"three\";\nimport { ConvexGeometry } from \"../geometries/ConvexGeometry.js\";\nconst _v1 = /* @__PURE__ */ new Vector3();\nclass ConvexObjectBreaker {\n  constructor(minSizeForBreak = 1.4, smallDelta = 1e-4) {\n    this.minSizeForBreak = minSizeForBreak;\n    this.smallDelta = smallDelta;\n    this.tempLine1 = new Line3();\n    this.tempPlane1 = new Plane();\n    this.tempPlane2 = new Plane();\n    this.tempPlane_Cut = new Plane();\n    this.tempCM1 = new Vector3();\n    this.tempCM2 = new Vector3();\n    this.tempVector3 = new Vector3();\n    this.tempVector3_2 = new Vector3();\n    this.tempVector3_3 = new Vector3();\n    this.tempVector3_P0 = new Vector3();\n    this.tempVector3_P1 = new Vector3();\n    this.tempVector3_P2 = new Vector3();\n    this.tempVector3_N0 = new Vector3();\n    this.tempVector3_N1 = new Vector3();\n    this.tempVector3_AB = new Vector3();\n    this.tempVector3_CB = new Vector3();\n    this.tempResultObjects = { object1: null, object2: null };\n    this.segments = [];\n    const n = 30 * 30;\n    for (let i = 0; i < n; i++)\n      this.segments[i] = false;\n  }\n  prepareBreakableObject(object, mass, velocity, angularVelocity, breakable) {\n    const userData = object.userData;\n    userData.mass = mass;\n    userData.velocity = velocity.clone();\n    userData.angularVelocity = angularVelocity.clone();\n    userData.breakable = breakable;\n  }\n  /*\n   * @param {int} maxRadialIterations Iterations for radial cuts.\n   * @param {int} maxRandomIterations Max random iterations for not-radial cuts\n   *\n   * Returns the array of pieces\n   */\n  subdivideByImpact(object, pointOfImpact, normal, maxRadialIterations, maxRandomIterations) {\n    const debris = [];\n    const tempPlane1 = this.tempPlane1;\n    const tempPlane2 = this.tempPlane2;\n    this.tempVector3.addVectors(pointOfImpact, normal);\n    tempPlane1.setFromCoplanarPoints(pointOfImpact, object.position, this.tempVector3);\n    const maxTotalIterations = maxRandomIterations + maxRadialIterations;\n    const scope = this;\n    function subdivideRadial(subObject, startAngle, endAngle, numIterations) {\n      if (Math.random() < numIterations * 0.05 || numIterations > maxTotalIterations) {\n        debris.push(subObject);\n        return;\n      }\n      let angle = Math.PI;\n      if (numIterations === 0) {\n        tempPlane2.normal.copy(tempPlane1.normal);\n        tempPlane2.constant = tempPlane1.constant;\n      } else {\n        if (numIterations <= maxRadialIterations) {\n          angle = (endAngle - startAngle) * (0.2 + 0.6 * Math.random()) + startAngle;\n          scope.tempVector3_2.copy(object.position).sub(pointOfImpact).applyAxisAngle(normal, angle).add(pointOfImpact);\n          tempPlane2.setFromCoplanarPoints(pointOfImpact, scope.tempVector3, scope.tempVector3_2);\n        } else {\n          angle = (0.5 * (numIterations & 1) + 0.2 * (2 - Math.random())) * Math.PI;\n          scope.tempVector3_2.copy(pointOfImpact).sub(subObject.position).applyAxisAngle(normal, angle).add(subObject.position);\n          scope.tempVector3_3.copy(normal).add(subObject.position);\n          tempPlane2.setFromCoplanarPoints(subObject.position, scope.tempVector3_3, scope.tempVector3_2);\n        }\n      }\n      scope.cutByPlane(subObject, tempPlane2, scope.tempResultObjects);\n      const obj1 = scope.tempResultObjects.object1;\n      const obj2 = scope.tempResultObjects.object2;\n      if (obj1) {\n        subdivideRadial(obj1, startAngle, angle, numIterations + 1);\n      }\n      if (obj2) {\n        subdivideRadial(obj2, angle, endAngle, numIterations + 1);\n      }\n    }\n    subdivideRadial(object, 0, 2 * Math.PI, 0);\n    return debris;\n  }\n  cutByPlane(object, plane, output) {\n    const geometry = object.geometry;\n    const coords = geometry.attributes.position.array;\n    const normals = geometry.attributes.normal.array;\n    const numPoints = coords.length / 3;\n    let numFaces = numPoints / 3;\n    let indices = geometry.getIndex();\n    if (indices) {\n      indices = indices.array;\n      numFaces = indices.length / 3;\n    }\n    function getVertexIndex(faceIdx, vert) {\n      const idx = faceIdx * 3 + vert;\n      return indices ? indices[idx] : idx;\n    }\n    const points1 = [];\n    const points2 = [];\n    const delta = this.smallDelta;\n    const numPointPairs = numPoints * numPoints;\n    for (let i = 0; i < numPointPairs; i++)\n      this.segments[i] = false;\n    const p0 = this.tempVector3_P0;\n    const p1 = this.tempVector3_P1;\n    const n0 = this.tempVector3_N0;\n    const n1 = this.tempVector3_N1;\n    for (let i = 0; i < numFaces - 1; i++) {\n      const a1 = getVertexIndex(i, 0);\n      const b1 = getVertexIndex(i, 1);\n      const c1 = getVertexIndex(i, 2);\n      n0.set(normals[a1], normals[a1] + 1, normals[a1] + 2);\n      for (let j = i + 1; j < numFaces; j++) {\n        const a2 = getVertexIndex(j, 0);\n        const b2 = getVertexIndex(j, 1);\n        const c2 = getVertexIndex(j, 2);\n        n1.set(normals[a2], normals[a2] + 1, normals[a2] + 2);\n        const coplanar = 1 - n0.dot(n1) < delta;\n        if (coplanar) {\n          if (a1 === a2 || a1 === b2 || a1 === c2) {\n            if (b1 === a2 || b1 === b2 || b1 === c2) {\n              this.segments[a1 * numPoints + b1] = true;\n              this.segments[b1 * numPoints + a1] = true;\n            } else {\n              this.segments[c1 * numPoints + a1] = true;\n              this.segments[a1 * numPoints + c1] = true;\n            }\n          } else if (b1 === a2 || b1 === b2 || b1 === c2) {\n            this.segments[c1 * numPoints + b1] = true;\n            this.segments[b1 * numPoints + c1] = true;\n          }\n        }\n      }\n    }\n    const localPlane = this.tempPlane_Cut;\n    object.updateMatrix();\n    ConvexObjectBreaker.transformPlaneToLocalSpace(plane, object.matrix, localPlane);\n    for (let i = 0; i < numFaces; i++) {\n      const va = getVertexIndex(i, 0);\n      const vb = getVertexIndex(i, 1);\n      const vc = getVertexIndex(i, 2);\n      for (let segment = 0; segment < 3; segment++) {\n        const i0 = segment === 0 ? va : segment === 1 ? vb : vc;\n        const i1 = segment === 0 ? vb : segment === 1 ? vc : va;\n        const segmentState = this.segments[i0 * numPoints + i1];\n        if (segmentState)\n          continue;\n        this.segments[i0 * numPoints + i1] = true;\n        this.segments[i1 * numPoints + i0] = true;\n        p0.set(coords[3 * i0], coords[3 * i0 + 1], coords[3 * i0 + 2]);\n        p1.set(coords[3 * i1], coords[3 * i1 + 1], coords[3 * i1 + 2]);\n        let mark0 = 0;\n        let d = localPlane.distanceToPoint(p0);\n        if (d > delta) {\n          mark0 = 2;\n          points2.push(p0.clone());\n        } else if (d < -delta) {\n          mark0 = 1;\n          points1.push(p0.clone());\n        } else {\n          mark0 = 3;\n          points1.push(p0.clone());\n          points2.push(p0.clone());\n        }\n        let mark1 = 0;\n        d = localPlane.distanceToPoint(p1);\n        if (d > delta) {\n          mark1 = 2;\n          points2.push(p1.clone());\n        } else if (d < -delta) {\n          mark1 = 1;\n          points1.push(p1.clone());\n        } else {\n          mark1 = 3;\n          points1.push(p1.clone());\n          points2.push(p1.clone());\n        }\n        if (mark0 === 1 && mark1 === 2 || mark0 === 2 && mark1 === 1) {\n          this.tempLine1.start.copy(p0);\n          this.tempLine1.end.copy(p1);\n          let intersection = new Vector3();\n          intersection = localPlane.intersectLine(this.tempLine1, intersection);\n          if (intersection === null) {\n            console.error(\"Internal error: segment does not intersect plane.\");\n            output.segmentedObject1 = null;\n            output.segmentedObject2 = null;\n            return 0;\n          }\n          points1.push(intersection);\n          points2.push(intersection.clone());\n        }\n      }\n    }\n    const newMass = object.userData.mass * 0.5;\n    this.tempCM1.set(0, 0, 0);\n    let radius1 = 0;\n    const numPoints1 = points1.length;\n    if (numPoints1 > 0) {\n      for (let i = 0; i < numPoints1; i++)\n        this.tempCM1.add(points1[i]);\n      this.tempCM1.divideScalar(numPoints1);\n      for (let i = 0; i < numPoints1; i++) {\n        const p = points1[i];\n        p.sub(this.tempCM1);\n        radius1 = Math.max(radius1, p.x, p.y, p.z);\n      }\n      this.tempCM1.add(object.position);\n    }\n    this.tempCM2.set(0, 0, 0);\n    let radius2 = 0;\n    const numPoints2 = points2.length;\n    if (numPoints2 > 0) {\n      for (let i = 0; i < numPoints2; i++)\n        this.tempCM2.add(points2[i]);\n      this.tempCM2.divideScalar(numPoints2);\n      for (let i = 0; i < numPoints2; i++) {\n        const p = points2[i];\n        p.sub(this.tempCM2);\n        radius2 = Math.max(radius2, p.x, p.y, p.z);\n      }\n      this.tempCM2.add(object.position);\n    }\n    let object1 = null;\n    let object2 = null;\n    let numObjects = 0;\n    if (numPoints1 > 4) {\n      object1 = new Mesh(new ConvexGeometry(points1), object.material);\n      object1.position.copy(this.tempCM1);\n      object1.quaternion.copy(object.quaternion);\n      this.prepareBreakableObject(\n        object1,\n        newMass,\n        object.userData.velocity,\n        object.userData.angularVelocity,\n        2 * radius1 > this.minSizeForBreak\n      );\n      numObjects++;\n    }\n    if (numPoints2 > 4) {\n      object2 = new Mesh(new ConvexGeometry(points2), object.material);\n      object2.position.copy(this.tempCM2);\n      object2.quaternion.copy(object.quaternion);\n      this.prepareBreakableObject(\n        object2,\n        newMass,\n        object.userData.velocity,\n        object.userData.angularVelocity,\n        2 * radius2 > this.minSizeForBreak\n      );\n      numObjects++;\n    }\n    output.object1 = object1;\n    output.object2 = object2;\n    return numObjects;\n  }\n  static transformFreeVector(v, m) {\n    const x = v.x, y = v.y, z = v.z;\n    const e = m.elements;\n    v.x = e[0] * x + e[4] * y + e[8] * z;\n    v.y = e[1] * x + e[5] * y + e[9] * z;\n    v.z = e[2] * x + e[6] * y + e[10] * z;\n    return v;\n  }\n  static transformFreeVectorInverse(v, m) {\n    const x = v.x, y = v.y, z = v.z;\n    const e = m.elements;\n    v.x = e[0] * x + e[1] * y + e[2] * z;\n    v.y = e[4] * x + e[5] * y + e[6] * z;\n    v.z = e[8] * x + e[9] * y + e[10] * z;\n    return v;\n  }\n  static transformTiedVectorInverse(v, m) {\n    const x = v.x, y = v.y, z = v.z;\n    const e = m.elements;\n    v.x = e[0] * x + e[1] * y + e[2] * z - e[12];\n    v.y = e[4] * x + e[5] * y + e[6] * z - e[13];\n    v.z = e[8] * x + e[9] * y + e[10] * z - e[14];\n    return v;\n  }\n  static transformPlaneToLocalSpace(plane, m, resultPlane) {\n    resultPlane.normal.copy(plane.normal);\n    resultPlane.constant = plane.constant;\n    const referencePoint = ConvexObjectBreaker.transformTiedVectorInverse(plane.coplanarPoint(_v1), m);\n    ConvexObjectBreaker.transformFreeVectorInverse(resultPlane.normal, m);\n    resultPlane.constant = -referencePoint.dot(resultPlane.normal);\n  }\n}\nexport {\n  ConvexObjectBreaker\n};\n"]},"metadata":{},"sourceType":"module"}