{"ast":null,"code":"import _classCallCheck from \"/Users/theodaguier/Repositories/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/theodaguier/Repositories/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { Scene, WebGLRenderTarget, FloatType, MeshPhongMaterial, MeshBasicMaterial, DoubleSide, PlaneGeometry, Mesh } from \"three\";\nimport potpack from \"potpack\";\n\nvar ProgressiveLightMap = /*#__PURE__*/function () {\n  function ProgressiveLightMap(renderer) {\n    var _this = this;\n\n    var res = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1024;\n\n    _classCallCheck(this, ProgressiveLightMap);\n\n    this.renderer = renderer;\n    this.res = res;\n    this.lightMapContainers = [];\n    this.compiled = false;\n    this.scene = new Scene();\n    this.scene.background = null;\n    this.tinyTarget = new WebGLRenderTarget(1, 1);\n    this.buffer1Active = false;\n    this.firstUpdate = true;\n    this.warned = false;\n    var format = /(Android|iPad|iPhone|iPod)/g.test(navigator.userAgent) ? alfFloatType : FloatType;\n    this.progressiveLightMap1 = new WebGLRenderTarget(this.res, this.res, {\n      type: format\n    });\n    this.progressiveLightMap2 = new WebGLRenderTarget(this.res, this.res, {\n      type: format\n    });\n    this.uvMat = new MeshPhongMaterial();\n    this.uvMat.uniforms = {};\n\n    this.uvMat.onBeforeCompile = function (shader) {\n      shader.vertexShader = \"#define USE_LIGHTMAP\\n\" + shader.vertexShader.slice(0, -1) + \"\tgl_Position = vec4((uv2 - 0.5) * 2.0, 1.0, 1.0); }\";\n      var bodyStart = shader.fragmentShader.indexOf(\"void main() {\");\n      shader.fragmentShader = \"varying vec2 vUv2;\\n\" + shader.fragmentShader.slice(0, bodyStart) + \"\tuniform sampler2D previousShadowMap;\\n\tuniform float averagingWindow;\\n\" + shader.fragmentShader.slice(bodyStart - 1, -1) + \"\\nvec3 texelOld = texture2D(previousShadowMap, vUv2).rgb;\\n\\t\\t\\t\\tgl_FragColor.rgb = mix(texelOld, gl_FragColor.rgb, 1.0/averagingWindow);\\n\\t\\t\\t}\";\n      shader.uniforms.previousShadowMap = {\n        value: _this.progressiveLightMap1.texture\n      };\n      shader.uniforms.averagingWindow = {\n        value: 100\n      };\n      _this.uvMat.uniforms = shader.uniforms;\n      _this.uvMat.userData.shader = shader;\n      _this.compiled = true;\n    };\n  }\n  /**\n   * Sets these objects' materials' lightmaps and modifies their uv2's.\n   * @param {Object3D} objects An array of objects and lights to set up your lightmap.\n   */\n\n\n  _createClass(ProgressiveLightMap, [{\n    key: \"addObjectsToLightMap\",\n    value: function addObjectsToLightMap(objects) {\n      this.uv_boxes = [];\n      var padding = 3 / this.res;\n\n      for (var ob = 0; ob < objects.length; ob++) {\n        var object = objects[ob];\n\n        if (object.isLight) {\n          this.scene.attach(object);\n          continue;\n        }\n\n        if (!object.geometry.hasAttribute(\"uv\")) {\n          console.warn(\"All lightmap objects need UVs!\");\n          continue;\n        }\n\n        if (this.blurringPlane == null) {\n          this._initializeBlurPlane(this.res, this.progressiveLightMap1);\n        }\n\n        object.material.lightMap = this.progressiveLightMap2.texture;\n        object.material.dithering = true;\n        object.castShadow = true;\n        object.receiveShadow = true;\n        object.renderOrder = 1e3 + ob;\n        this.uv_boxes.push({\n          w: 1 + padding * 2,\n          h: 1 + padding * 2,\n          index: ob\n        });\n        this.lightMapContainers.push({\n          basicMat: object.material,\n          object: object\n        });\n        this.compiled = false;\n      }\n\n      var dimensions = potpack(this.uv_boxes);\n      this.uv_boxes.forEach(function (box) {\n        var uv2 = objects[box.index].geometry.getAttribute(\"uv\").clone();\n\n        for (var i = 0; i < uv2.array.length; i += uv2.itemSize) {\n          uv2.array[i] = (uv2.array[i] + box.x + padding) / dimensions.w;\n          uv2.array[i + 1] = (uv2.array[i + 1] + box.y + padding) / dimensions.h;\n        }\n\n        objects[box.index].geometry.setAttribute(\"uv2\", uv2);\n        objects[box.index].geometry.getAttribute(\"uv2\").needsUpdate = true;\n      });\n    }\n    /**\n     * This function renders each mesh one at a time into their respective surface maps\n     * @param {Camera} camera Standard Rendering Camera\n     * @param {number} blendWindow When >1, samples will accumulate over time.\n     * @param {boolean} blurEdges  Whether to fix UV Edges via blurring\n     */\n\n  }, {\n    key: \"update\",\n    value: function update(camera) {\n      var blendWindow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;\n      var blurEdges = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n      if (this.blurringPlane == null) {\n        return;\n      }\n\n      var oldTarget = this.renderer.getRenderTarget();\n      this.blurringPlane.visible = blurEdges;\n\n      for (var l = 0; l < this.lightMapContainers.length; l++) {\n        this.lightMapContainers[l].object.oldScene = this.lightMapContainers[l].object.parent;\n        this.scene.attach(this.lightMapContainers[l].object);\n      }\n\n      if (this.firstUpdate) {\n        this.renderer.setRenderTarget(this.tinyTarget);\n        this.renderer.render(this.scene, camera);\n        this.firstUpdate = false;\n      }\n\n      for (var _l = 0; _l < this.lightMapContainers.length; _l++) {\n        this.uvMat.uniforms.averagingWindow = {\n          value: blendWindow\n        };\n        this.lightMapContainers[_l].object.material = this.uvMat;\n        this.lightMapContainers[_l].object.oldFrustumCulled = this.lightMapContainers[_l].object.frustumCulled;\n        this.lightMapContainers[_l].object.frustumCulled = false;\n      }\n\n      var activeMap = this.buffer1Active ? this.progressiveLightMap1 : this.progressiveLightMap2;\n      var inactiveMap = this.buffer1Active ? this.progressiveLightMap2 : this.progressiveLightMap1;\n      this.renderer.setRenderTarget(activeMap);\n      this.uvMat.uniforms.previousShadowMap = {\n        value: inactiveMap.texture\n      };\n      this.blurringPlane.material.uniforms.previousShadowMap = {\n        value: inactiveMap.texture\n      };\n      this.buffer1Active = !this.buffer1Active;\n      this.renderer.render(this.scene, camera);\n\n      for (var _l2 = 0; _l2 < this.lightMapContainers.length; _l2++) {\n        this.lightMapContainers[_l2].object.frustumCulled = this.lightMapContainers[_l2].object.oldFrustumCulled;\n        this.lightMapContainers[_l2].object.material = this.lightMapContainers[_l2].basicMat;\n\n        this.lightMapContainers[_l2].object.oldScene.attach(this.lightMapContainers[_l2].object);\n      }\n\n      this.renderer.setRenderTarget(oldTarget);\n    }\n    /** DEBUG\n     * Draw the lightmap in the main scene.  Call this after adding the objects to it.\n     * @param {boolean} visible Whether the debug plane should be visible\n     * @param {Vector3} position Where the debug plane should be drawn\n     */\n\n  }, {\n    key: \"showDebugLightmap\",\n    value: function showDebugLightmap(visible) {\n      var position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : void 0;\n\n      if (this.lightMapContainers.length == 0) {\n        if (!this.warned) {\n          console.warn(\"Call this after adding the objects!\");\n          this.warned = true;\n        }\n\n        return;\n      }\n\n      if (this.labelMesh == null) {\n        this.labelMaterial = new MeshBasicMaterial({\n          map: this.progressiveLightMap1.texture,\n          side: DoubleSide\n        });\n        this.labelPlane = new PlaneGeometry(100, 100);\n        this.labelMesh = new Mesh(this.labelPlane, this.labelMaterial);\n        this.labelMesh.position.y = 250;\n        this.lightMapContainers[0].object.parent.add(this.labelMesh);\n      }\n\n      if (position != void 0) {\n        this.labelMesh.position.copy(position);\n      }\n\n      this.labelMesh.visible = visible;\n    }\n    /**\n     * INTERNAL Creates the Blurring Plane\n     * @param {number} res The square resolution of this object's lightMap.\n     * @param {WebGLRenderTexture} lightMap The lightmap to initialize the plane with.\n     */\n\n  }, {\n    key: \"_initializeBlurPlane\",\n    value: function _initializeBlurPlane(res) {\n      var _this2 = this;\n\n      var lightMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var blurMaterial = new MeshBasicMaterial();\n      blurMaterial.uniforms = {\n        previousShadowMap: {\n          value: null\n        },\n        pixelOffset: {\n          value: 1 / res\n        },\n        polygonOffset: true,\n        polygonOffsetFactor: -1,\n        polygonOffsetUnits: 3\n      };\n\n      blurMaterial.onBeforeCompile = function (shader) {\n        shader.vertexShader = \"#define USE_UV\\n\" + shader.vertexShader.slice(0, -1) + \"\tgl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0); }\";\n        var bodyStart = shader.fragmentShader.indexOf(\"void main() {\");\n        shader.fragmentShader = \"#define USE_UV\\n\" + shader.fragmentShader.slice(0, bodyStart) + \"\tuniform sampler2D previousShadowMap;\\n\tuniform float pixelOffset;\\n\" + shader.fragmentShader.slice(bodyStart - 1, -1) + \"\\tgl_FragColor.rgb = (\\n\\t\\t\\t  texture2D(previousShadowMap, vUv + vec2( pixelOffset,  0.0        )).rgb +\\n\\t\\t\\t  texture2D(previousShadowMap, vUv + vec2( 0.0        ,  pixelOffset)).rgb +\\n\\t\\t\\t  texture2D(previousShadowMap, vUv + vec2( 0.0        , -pixelOffset)).rgb +\\n\\t\\t\\t  texture2D(previousShadowMap, vUv + vec2(-pixelOffset,  0.0        )).rgb +\\n\\t\\t\\t  texture2D(previousShadowMap, vUv + vec2( pixelOffset,  pixelOffset)).rgb +\\n\\t\\t\\t  texture2D(previousShadowMap, vUv + vec2(-pixelOffset,  pixelOffset)).rgb +\\n\\t\\t\\t  texture2D(previousShadowMap, vUv + vec2( pixelOffset, -pixelOffset)).rgb +\\n\\t\\t\\t  texture2D(previousShadowMap, vUv + vec2(-pixelOffset, -pixelOffset)).rgb)/8.0;\\n\\t\\t}\";\n        shader.uniforms.previousShadowMap = {\n          value: lightMap.texture\n        };\n        shader.uniforms.pixelOffset = {\n          value: 0.5 / res\n        };\n        blurMaterial.uniforms = shader.uniforms;\n        blurMaterial.userData.shader = shader;\n        _this2.compiled = true;\n      };\n\n      this.blurringPlane = new Mesh(new PlaneGeometry(1, 1), blurMaterial);\n      this.blurringPlane.name = \"Blurring Plane\";\n      this.blurringPlane.frustumCulled = false;\n      this.blurringPlane.renderOrder = 0;\n      this.blurringPlane.material.depthWrite = false;\n      this.scene.add(this.blurringPlane);\n    }\n  }]);\n\n  return ProgressiveLightMap;\n}();\n\nexport { ProgressiveLightMap };","map":{"version":3,"sources":["/Users/theodaguier/Repositories/E-Do-Studio/node_modules/three-stdlib/misc/ProgressiveLightmap.js"],"names":["Scene","WebGLRenderTarget","FloatType","MeshPhongMaterial","MeshBasicMaterial","DoubleSide","PlaneGeometry","Mesh","potpack","ProgressiveLightMap","renderer","res","lightMapContainers","compiled","scene","background","tinyTarget","buffer1Active","firstUpdate","warned","format","test","navigator","userAgent","alfFloatType","progressiveLightMap1","type","progressiveLightMap2","uvMat","uniforms","onBeforeCompile","shader","vertexShader","slice","bodyStart","fragmentShader","indexOf","previousShadowMap","value","texture","averagingWindow","userData","objects","uv_boxes","padding","ob","length","object","isLight","attach","geometry","hasAttribute","console","warn","blurringPlane","_initializeBlurPlane","material","lightMap","dithering","castShadow","receiveShadow","renderOrder","push","w","h","index","basicMat","dimensions","forEach","box","uv2","getAttribute","clone","i","array","itemSize","x","y","setAttribute","needsUpdate","camera","blendWindow","blurEdges","oldTarget","getRenderTarget","visible","l","oldScene","parent","setRenderTarget","render","oldFrustumCulled","frustumCulled","activeMap","inactiveMap","position","labelMesh","labelMaterial","map","side","labelPlane","add","copy","blurMaterial","pixelOffset","polygonOffset","polygonOffsetFactor","polygonOffsetUnits","name","depthWrite"],"mappings":"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","sourcesContent":["import { Scene, WebGLRenderTarget, FloatType, MeshPhongMaterial, MeshBasicMaterial, DoubleSide, PlaneGeometry, Mesh } from \"three\";\nimport potpack from \"potpack\";\nclass ProgressiveLightMap {\n  constructor(renderer, res = 1024) {\n    this.renderer = renderer;\n    this.res = res;\n    this.lightMapContainers = [];\n    this.compiled = false;\n    this.scene = new Scene();\n    this.scene.background = null;\n    this.tinyTarget = new WebGLRenderTarget(1, 1);\n    this.buffer1Active = false;\n    this.firstUpdate = true;\n    this.warned = false;\n    const format = /(Android|iPad|iPhone|iPod)/g.test(navigator.userAgent) ? alfFloatType : FloatType;\n    this.progressiveLightMap1 = new WebGLRenderTarget(this.res, this.res, { type: format });\n    this.progressiveLightMap2 = new WebGLRenderTarget(this.res, this.res, { type: format });\n    this.uvMat = new MeshPhongMaterial();\n    this.uvMat.uniforms = {};\n    this.uvMat.onBeforeCompile = (shader) => {\n      shader.vertexShader = \"#define USE_LIGHTMAP\\n\" + shader.vertexShader.slice(0, -1) + \"\tgl_Position = vec4((uv2 - 0.5) * 2.0, 1.0, 1.0); }\";\n      const bodyStart = shader.fragmentShader.indexOf(\"void main() {\");\n      shader.fragmentShader = \"varying vec2 vUv2;\\n\" + shader.fragmentShader.slice(0, bodyStart) + \"\tuniform sampler2D previousShadowMap;\\n\tuniform float averagingWindow;\\n\" + shader.fragmentShader.slice(bodyStart - 1, -1) + `\nvec3 texelOld = texture2D(previousShadowMap, vUv2).rgb;\n\t\t\t\tgl_FragColor.rgb = mix(texelOld, gl_FragColor.rgb, 1.0/averagingWindow);\n\t\t\t}`;\n      shader.uniforms.previousShadowMap = { value: this.progressiveLightMap1.texture };\n      shader.uniforms.averagingWindow = { value: 100 };\n      this.uvMat.uniforms = shader.uniforms;\n      this.uvMat.userData.shader = shader;\n      this.compiled = true;\n    };\n  }\n  /**\n   * Sets these objects' materials' lightmaps and modifies their uv2's.\n   * @param {Object3D} objects An array of objects and lights to set up your lightmap.\n   */\n  addObjectsToLightMap(objects) {\n    this.uv_boxes = [];\n    const padding = 3 / this.res;\n    for (let ob = 0; ob < objects.length; ob++) {\n      const object = objects[ob];\n      if (object.isLight) {\n        this.scene.attach(object);\n        continue;\n      }\n      if (!object.geometry.hasAttribute(\"uv\")) {\n        console.warn(\"All lightmap objects need UVs!\");\n        continue;\n      }\n      if (this.blurringPlane == null) {\n        this._initializeBlurPlane(this.res, this.progressiveLightMap1);\n      }\n      object.material.lightMap = this.progressiveLightMap2.texture;\n      object.material.dithering = true;\n      object.castShadow = true;\n      object.receiveShadow = true;\n      object.renderOrder = 1e3 + ob;\n      this.uv_boxes.push({ w: 1 + padding * 2, h: 1 + padding * 2, index: ob });\n      this.lightMapContainers.push({ basicMat: object.material, object });\n      this.compiled = false;\n    }\n    const dimensions = potpack(this.uv_boxes);\n    this.uv_boxes.forEach((box) => {\n      const uv2 = objects[box.index].geometry.getAttribute(\"uv\").clone();\n      for (let i = 0; i < uv2.array.length; i += uv2.itemSize) {\n        uv2.array[i] = (uv2.array[i] + box.x + padding) / dimensions.w;\n        uv2.array[i + 1] = (uv2.array[i + 1] + box.y + padding) / dimensions.h;\n      }\n      objects[box.index].geometry.setAttribute(\"uv2\", uv2);\n      objects[box.index].geometry.getAttribute(\"uv2\").needsUpdate = true;\n    });\n  }\n  /**\n   * This function renders each mesh one at a time into their respective surface maps\n   * @param {Camera} camera Standard Rendering Camera\n   * @param {number} blendWindow When >1, samples will accumulate over time.\n   * @param {boolean} blurEdges  Whether to fix UV Edges via blurring\n   */\n  update(camera, blendWindow = 100, blurEdges = true) {\n    if (this.blurringPlane == null) {\n      return;\n    }\n    const oldTarget = this.renderer.getRenderTarget();\n    this.blurringPlane.visible = blurEdges;\n    for (let l = 0; l < this.lightMapContainers.length; l++) {\n      this.lightMapContainers[l].object.oldScene = this.lightMapContainers[l].object.parent;\n      this.scene.attach(this.lightMapContainers[l].object);\n    }\n    if (this.firstUpdate) {\n      this.renderer.setRenderTarget(this.tinyTarget);\n      this.renderer.render(this.scene, camera);\n      this.firstUpdate = false;\n    }\n    for (let l = 0; l < this.lightMapContainers.length; l++) {\n      this.uvMat.uniforms.averagingWindow = { value: blendWindow };\n      this.lightMapContainers[l].object.material = this.uvMat;\n      this.lightMapContainers[l].object.oldFrustumCulled = this.lightMapContainers[l].object.frustumCulled;\n      this.lightMapContainers[l].object.frustumCulled = false;\n    }\n    const activeMap = this.buffer1Active ? this.progressiveLightMap1 : this.progressiveLightMap2;\n    const inactiveMap = this.buffer1Active ? this.progressiveLightMap2 : this.progressiveLightMap1;\n    this.renderer.setRenderTarget(activeMap);\n    this.uvMat.uniforms.previousShadowMap = { value: inactiveMap.texture };\n    this.blurringPlane.material.uniforms.previousShadowMap = { value: inactiveMap.texture };\n    this.buffer1Active = !this.buffer1Active;\n    this.renderer.render(this.scene, camera);\n    for (let l = 0; l < this.lightMapContainers.length; l++) {\n      this.lightMapContainers[l].object.frustumCulled = this.lightMapContainers[l].object.oldFrustumCulled;\n      this.lightMapContainers[l].object.material = this.lightMapContainers[l].basicMat;\n      this.lightMapContainers[l].object.oldScene.attach(this.lightMapContainers[l].object);\n    }\n    this.renderer.setRenderTarget(oldTarget);\n  }\n  /** DEBUG\n   * Draw the lightmap in the main scene.  Call this after adding the objects to it.\n   * @param {boolean} visible Whether the debug plane should be visible\n   * @param {Vector3} position Where the debug plane should be drawn\n   */\n  showDebugLightmap(visible, position = void 0) {\n    if (this.lightMapContainers.length == 0) {\n      if (!this.warned) {\n        console.warn(\"Call this after adding the objects!\");\n        this.warned = true;\n      }\n      return;\n    }\n    if (this.labelMesh == null) {\n      this.labelMaterial = new MeshBasicMaterial({\n        map: this.progressiveLightMap1.texture,\n        side: DoubleSide\n      });\n      this.labelPlane = new PlaneGeometry(100, 100);\n      this.labelMesh = new Mesh(this.labelPlane, this.labelMaterial);\n      this.labelMesh.position.y = 250;\n      this.lightMapContainers[0].object.parent.add(this.labelMesh);\n    }\n    if (position != void 0) {\n      this.labelMesh.position.copy(position);\n    }\n    this.labelMesh.visible = visible;\n  }\n  /**\n   * INTERNAL Creates the Blurring Plane\n   * @param {number} res The square resolution of this object's lightMap.\n   * @param {WebGLRenderTexture} lightMap The lightmap to initialize the plane with.\n   */\n  _initializeBlurPlane(res, lightMap = null) {\n    const blurMaterial = new MeshBasicMaterial();\n    blurMaterial.uniforms = {\n      previousShadowMap: { value: null },\n      pixelOffset: { value: 1 / res },\n      polygonOffset: true,\n      polygonOffsetFactor: -1,\n      polygonOffsetUnits: 3\n    };\n    blurMaterial.onBeforeCompile = (shader) => {\n      shader.vertexShader = \"#define USE_UV\\n\" + shader.vertexShader.slice(0, -1) + \"\tgl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0); }\";\n      const bodyStart = shader.fragmentShader.indexOf(\"void main() {\");\n      shader.fragmentShader = \"#define USE_UV\\n\" + shader.fragmentShader.slice(0, bodyStart) + \"\tuniform sampler2D previousShadowMap;\\n\tuniform float pixelOffset;\\n\" + shader.fragmentShader.slice(bodyStart - 1, -1) + `\tgl_FragColor.rgb = (\n\t\t\t  texture2D(previousShadowMap, vUv + vec2( pixelOffset,  0.0        )).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2( 0.0        ,  pixelOffset)).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2( 0.0        , -pixelOffset)).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2(-pixelOffset,  0.0        )).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2( pixelOffset,  pixelOffset)).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2(-pixelOffset,  pixelOffset)).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2( pixelOffset, -pixelOffset)).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2(-pixelOffset, -pixelOffset)).rgb)/8.0;\n\t\t}`;\n      shader.uniforms.previousShadowMap = { value: lightMap.texture };\n      shader.uniforms.pixelOffset = { value: 0.5 / res };\n      blurMaterial.uniforms = shader.uniforms;\n      blurMaterial.userData.shader = shader;\n      this.compiled = true;\n    };\n    this.blurringPlane = new Mesh(new PlaneGeometry(1, 1), blurMaterial);\n    this.blurringPlane.name = \"Blurring Plane\";\n    this.blurringPlane.frustumCulled = false;\n    this.blurringPlane.renderOrder = 0;\n    this.blurringPlane.material.depthWrite = false;\n    this.scene.add(this.blurringPlane);\n  }\n}\nexport {\n  ProgressiveLightMap\n};\n"]},"metadata":{},"sourceType":"module"}