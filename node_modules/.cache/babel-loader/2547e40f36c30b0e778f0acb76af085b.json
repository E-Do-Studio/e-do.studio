{"ast":null,"code":"import _classCallCheck from \"/Users/theodaguier/_workdir/dev/pro/e-do/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/theodaguier/_workdir/dev/pro/e-do/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { Object3D, Vector3, Quaternion, AnimationMixer } from \"three\";\nimport { CCDIKSolver } from \"./CCDIKSolver.js\";\nimport { MMDPhysics } from \"./MMDPhysics.js\";\n\nvar MMDAnimationHelper = /*#__PURE__*/function () {\n  /**\n   * @param {Object} params - (optional)\n   * @param {boolean} params.sync - Whether animation durations of added objects are synched. Default is true.\n   * @param {Number} params.afterglow - Default is 0.0.\n   * @param {boolean} params.resetPhysicsOnLoop - Default is true.\n   */\n  function MMDAnimationHelper() {\n    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, MMDAnimationHelper);\n\n    this.meshes = [];\n    this.camera = null;\n    this.cameraTarget = new Object3D();\n    this.cameraTarget.name = \"target\";\n    this.audio = null;\n    this.audioManager = null;\n    this.objects = /* @__PURE__ */new WeakMap();\n    this.configuration = {\n      sync: params.sync !== void 0 ? params.sync : true,\n      afterglow: params.afterglow !== void 0 ? params.afterglow : 0,\n      resetPhysicsOnLoop: params.resetPhysicsOnLoop !== void 0 ? params.resetPhysicsOnLoop : true,\n      pmxAnimation: params.pmxAnimation !== void 0 ? params.pmxAnimation : false\n    };\n    this.enabled = {\n      animation: true,\n      ik: true,\n      grant: true,\n      physics: true,\n      cameraAnimation: true\n    };\n\n    this.onBeforePhysics = function () {};\n\n    this.sharedPhysics = false;\n    this.masterPhysics = null;\n  }\n  /**\n   * Adds an Three.js Object to helper and setups animation.\n   * The anmation durations of added objects are synched\n   * if this.configuration.sync is true.\n   *\n   * @param {THREE.SkinnedMesh|THREE.Camera|THREE.Audio} object\n   * @param {Object} params - (optional)\n   * @param {THREE.AnimationClip|Array<THREE.AnimationClip>} params.animation - Only for THREE.SkinnedMesh and THREE.Camera. Default is undefined.\n   * @param {boolean} params.physics - Only for THREE.SkinnedMesh. Default is true.\n   * @param {Integer} params.warmup - Only for THREE.SkinnedMesh and physics is true. Default is 60.\n   * @param {Number} params.unitStep - Only for THREE.SkinnedMesh and physics is true. Default is 1 / 65.\n   * @param {Integer} params.maxStepNum - Only for THREE.SkinnedMesh and physics is true. Default is 3.\n   * @param {Vector3} params.gravity - Only for THREE.SkinnedMesh and physics is true. Default ( 0, - 9.8 * 10, 0 ).\n   * @param {Number} params.delayTime - Only for THREE.Audio. Default is 0.0.\n   * @return {MMDAnimationHelper}\n   */\n\n\n  _createClass(MMDAnimationHelper, [{\n    key: \"add\",\n    value: function add(object) {\n      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (object.isSkinnedMesh) {\n        this._addMesh(object, params);\n      } else if (object.isCamera) {\n        this._setupCamera(object, params);\n      } else if (object.type === \"Audio\") {\n        this._setupAudio(object, params);\n      } else {\n        throw new Error(\"THREE.MMDAnimationHelper.add: accepts only THREE.SkinnedMesh or THREE.Camera or THREE.Audio instance.\");\n      }\n\n      if (this.configuration.sync) this._syncDuration();\n      return this;\n    }\n    /**\n     * Removes an Three.js Object from helper.\n     *\n     * @param {THREE.SkinnedMesh|THREE.Camera|THREE.Audio} object\n     * @return {MMDAnimationHelper}\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove(object) {\n      if (object.isSkinnedMesh) {\n        this._removeMesh(object);\n      } else if (object.isCamera) {\n        this._clearCamera(object);\n      } else if (object.type === \"Audio\") {\n        this._clearAudio(object);\n      } else {\n        throw new Error(\"THREE.MMDAnimationHelper.remove: accepts only THREE.SkinnedMesh or THREE.Camera or THREE.Audio instance.\");\n      }\n\n      if (this.configuration.sync) this._syncDuration();\n      return this;\n    }\n    /**\n     * Updates the animation.\n     *\n     * @param {Number} delta\n     * @return {MMDAnimationHelper}\n     */\n\n  }, {\n    key: \"update\",\n    value: function update(delta) {\n      if (this.audioManager !== null) this.audioManager.control(delta);\n\n      for (var i = 0; i < this.meshes.length; i++) {\n        this._animateMesh(this.meshes[i], delta);\n      }\n\n      if (this.sharedPhysics) this._updateSharedPhysics(delta);\n      if (this.camera !== null) this._animateCamera(this.camera, delta);\n      return this;\n    }\n    /**\n     * Changes the pose of SkinnedMesh as VPD specifies.\n     *\n     * @param {THREE.SkinnedMesh} mesh\n     * @param {Object} vpd - VPD content parsed MMDParser\n     * @param {Object} params - (optional)\n     * @param {boolean} params.resetPose - Default is true.\n     * @param {boolean} params.ik - Default is true.\n     * @param {boolean} params.grant - Default is true.\n     * @return {MMDAnimationHelper}\n     */\n\n  }, {\n    key: \"pose\",\n    value: function pose(mesh, vpd) {\n      var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      if (params.resetPose !== false) mesh.pose();\n      var bones = mesh.skeleton.bones;\n      var boneParams = vpd.bones;\n      var boneNameDictionary = {};\n\n      for (var i = 0, il = bones.length; i < il; i++) {\n        boneNameDictionary[bones[i].name] = i;\n      }\n\n      var vector = new Vector3();\n      var quaternion = new Quaternion();\n\n      for (var _i = 0, _il = boneParams.length; _i < _il; _i++) {\n        var boneParam = boneParams[_i];\n        var boneIndex = boneNameDictionary[boneParam.name];\n        if (boneIndex === void 0) continue;\n        var bone = bones[boneIndex];\n        bone.position.add(vector.fromArray(boneParam.translation));\n        bone.quaternion.multiply(quaternion.fromArray(boneParam.quaternion));\n      }\n\n      mesh.updateMatrixWorld(true);\n\n      if (this.configuration.pmxAnimation && mesh.geometry.userData.MMD && mesh.geometry.userData.MMD.format === \"pmx\") {\n        var sortedBonesData = this._sortBoneDataArray(mesh.geometry.userData.MMD.bones.slice());\n\n        var ikSolver = params.ik !== false ? this._createCCDIKSolver(mesh) : null;\n        var grantSolver = params.grant !== false ? this.createGrantSolver(mesh) : null;\n\n        this._animatePMXMesh(mesh, sortedBonesData, ikSolver, grantSolver);\n      } else {\n        if (params.ik !== false) {\n          this._createCCDIKSolver(mesh).update();\n        }\n\n        if (params.grant !== false) {\n          this.createGrantSolver(mesh).update();\n        }\n      }\n\n      return this;\n    }\n    /**\n     * Enabes/Disables an animation feature.\n     *\n     * @param {string} key\n     * @param {boolean} enabled\n     * @return {MMDAnimationHelper}\n     */\n\n  }, {\n    key: \"enable\",\n    value: function enable(key, enabled) {\n      if (this.enabled[key] === void 0) {\n        throw new Error(\"THREE.MMDAnimationHelper.enable: unknown key \" + key);\n      }\n\n      this.enabled[key] = enabled;\n\n      if (key === \"physics\") {\n        for (var i = 0, il = this.meshes.length; i < il; i++) {\n          this._optimizeIK(this.meshes[i], enabled);\n        }\n      }\n\n      return this;\n    }\n    /**\n     * Creates an GrantSolver instance.\n     *\n     * @param {THREE.SkinnedMesh} mesh\n     * @return {GrantSolver}\n     */\n\n  }, {\n    key: \"createGrantSolver\",\n    value: function createGrantSolver(mesh) {\n      return new GrantSolver(mesh, mesh.geometry.userData.MMD.grants);\n    } // private methods\n\n  }, {\n    key: \"_addMesh\",\n    value: function _addMesh(mesh, params) {\n      if (this.meshes.indexOf(mesh) >= 0) {\n        throw new Error(\"THREE.MMDAnimationHelper._addMesh: SkinnedMesh '\" + mesh.name + \"' has already been added.\");\n      }\n\n      this.meshes.push(mesh);\n      this.objects.set(mesh, {\n        looped: false\n      });\n\n      this._setupMeshAnimation(mesh, params.animation);\n\n      if (params.physics !== false) {\n        this._setupMeshPhysics(mesh, params);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"_setupCamera\",\n    value: function _setupCamera(camera, params) {\n      if (this.camera === camera) {\n        throw new Error(\"THREE.MMDAnimationHelper._setupCamera: Camera '\" + camera.name + \"' has already been set.\");\n      }\n\n      if (this.camera) this.clearCamera(this.camera);\n      this.camera = camera;\n      camera.add(this.cameraTarget);\n      this.objects.set(camera, {});\n\n      if (params.animation !== void 0) {\n        this._setupCameraAnimation(camera, params.animation);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"_setupAudio\",\n    value: function _setupAudio(audio, params) {\n      if (this.audio === audio) {\n        throw new Error(\"THREE.MMDAnimationHelper._setupAudio: Audio '\" + audio.name + \"' has already been set.\");\n      }\n\n      if (this.audio) this.clearAudio(this.audio);\n      this.audio = audio;\n      this.audioManager = new AudioManager(audio, params);\n      this.objects.set(this.audioManager, {\n        duration: this.audioManager.duration\n      });\n      return this;\n    }\n  }, {\n    key: \"_removeMesh\",\n    value: function _removeMesh(mesh) {\n      var found = false;\n      var writeIndex = 0;\n\n      for (var i = 0, il = this.meshes.length; i < il; i++) {\n        if (this.meshes[i] === mesh) {\n          this.objects.delete(mesh);\n          found = true;\n          continue;\n        }\n\n        this.meshes[writeIndex++] = this.meshes[i];\n      }\n\n      if (!found) {\n        throw new Error(\"THREE.MMDAnimationHelper._removeMesh: SkinnedMesh '\" + mesh.name + \"' has not been added yet.\");\n      }\n\n      this.meshes.length = writeIndex;\n      return this;\n    }\n  }, {\n    key: \"_clearCamera\",\n    value: function _clearCamera(camera) {\n      if (camera !== this.camera) {\n        throw new Error(\"THREE.MMDAnimationHelper._clearCamera: Camera '\" + camera.name + \"' has not been set yet.\");\n      }\n\n      this.camera.remove(this.cameraTarget);\n      this.objects.delete(this.camera);\n      this.camera = null;\n      return this;\n    }\n  }, {\n    key: \"_clearAudio\",\n    value: function _clearAudio(audio) {\n      if (audio !== this.audio) {\n        throw new Error(\"THREE.MMDAnimationHelper._clearAudio: Audio '\" + audio.name + \"' has not been set yet.\");\n      }\n\n      this.objects.delete(this.audioManager);\n      this.audio = null;\n      this.audioManager = null;\n      return this;\n    }\n  }, {\n    key: \"_setupMeshAnimation\",\n    value: function _setupMeshAnimation(mesh, animation) {\n      var objects = this.objects.get(mesh);\n\n      if (animation !== void 0) {\n        var animations = Array.isArray(animation) ? animation : [animation];\n        objects.mixer = new AnimationMixer(mesh);\n\n        for (var i = 0, il = animations.length; i < il; i++) {\n          objects.mixer.clipAction(animations[i]).play();\n        }\n\n        objects.mixer.addEventListener(\"loop\", function (event) {\n          var tracks = event.action._clip.tracks;\n          if (tracks.length > 0 && tracks[0].name.slice(0, 6) !== \".bones\") return;\n          objects.looped = true;\n        });\n      }\n\n      objects.ikSolver = this._createCCDIKSolver(mesh);\n      objects.grantSolver = this.createGrantSolver(mesh);\n      return this;\n    }\n  }, {\n    key: \"_setupCameraAnimation\",\n    value: function _setupCameraAnimation(camera, animation) {\n      var animations = Array.isArray(animation) ? animation : [animation];\n      var objects = this.objects.get(camera);\n      objects.mixer = new AnimationMixer(camera);\n\n      for (var i = 0, il = animations.length; i < il; i++) {\n        objects.mixer.clipAction(animations[i]).play();\n      }\n    }\n  }, {\n    key: \"_setupMeshPhysics\",\n    value: function _setupMeshPhysics(mesh, params) {\n      var objects = this.objects.get(mesh);\n\n      if (params.world === void 0 && this.sharedPhysics) {\n        var masterPhysics = this._getMasterPhysics();\n\n        if (masterPhysics !== null) world = masterPhysics.world;\n      }\n\n      objects.physics = this._createMMDPhysics(mesh, params);\n\n      if (objects.mixer && params.animationWarmup !== false) {\n        this._animateMesh(mesh, 0);\n\n        objects.physics.reset();\n      }\n\n      objects.physics.warmup(params.warmup !== void 0 ? params.warmup : 60);\n\n      this._optimizeIK(mesh, true);\n    }\n  }, {\n    key: \"_animateMesh\",\n    value: function _animateMesh(mesh, delta) {\n      var objects = this.objects.get(mesh);\n      var mixer = objects.mixer;\n      var ikSolver = objects.ikSolver;\n      var grantSolver = objects.grantSolver;\n      var physics = objects.physics;\n      var looped = objects.looped;\n\n      if (mixer && this.enabled.animation) {\n        this._restoreBones(mesh);\n\n        mixer.update(delta);\n\n        this._saveBones(mesh);\n\n        if (this.configuration.pmxAnimation && mesh.geometry.userData.MMD && mesh.geometry.userData.MMD.format === \"pmx\") {\n          if (!objects.sortedBonesData) objects.sortedBonesData = this._sortBoneDataArray(mesh.geometry.userData.MMD.bones.slice());\n\n          this._animatePMXMesh(mesh, objects.sortedBonesData, ikSolver && this.enabled.ik ? ikSolver : null, grantSolver && this.enabled.grant ? grantSolver : null);\n        } else {\n          if (ikSolver && this.enabled.ik) {\n            mesh.updateMatrixWorld(true);\n            ikSolver.update();\n          }\n\n          if (grantSolver && this.enabled.grant) {\n            grantSolver.update();\n          }\n        }\n      }\n\n      if (looped === true && this.enabled.physics) {\n        if (physics && this.configuration.resetPhysicsOnLoop) physics.reset();\n        objects.looped = false;\n      }\n\n      if (physics && this.enabled.physics && !this.sharedPhysics) {\n        this.onBeforePhysics(mesh);\n        physics.update(delta);\n      }\n    } // Sort bones in order by 1. transformationClass and 2. bone index.\n    // In PMX animation system, bone transformations should be processed\n    // in this order.\n\n  }, {\n    key: \"_sortBoneDataArray\",\n    value: function _sortBoneDataArray(boneDataArray) {\n      return boneDataArray.sort(function (a, b) {\n        if (a.transformationClass !== b.transformationClass) {\n          return a.transformationClass - b.transformationClass;\n        } else {\n          return a.index - b.index;\n        }\n      });\n    } // PMX Animation system is a bit too complex and doesn't great match to\n    // Three.js Animation system. This method attempts to simulate it as much as\n    // possible but doesn't perfectly simulate.\n    // This method is more costly than the regular one so\n    // you are recommended to set constructor parameter \"pmxAnimation: true\"\n    // only if your PMX model animation doesn't work well.\n    // If you need better method you would be required to write your own.\n\n  }, {\n    key: \"_animatePMXMesh\",\n    value: function _animatePMXMesh(mesh, sortedBonesData, ikSolver, grantSolver) {\n      _quaternionIndex = 0;\n\n      _grantResultMap.clear();\n\n      for (var i = 0, il = sortedBonesData.length; i < il; i++) {\n        updateOne(mesh, sortedBonesData[i].index, ikSolver, grantSolver);\n      }\n\n      mesh.updateMatrixWorld(true);\n      return this;\n    }\n  }, {\n    key: \"_animateCamera\",\n    value: function _animateCamera(camera, delta) {\n      var mixer = this.objects.get(camera).mixer;\n\n      if (mixer && this.enabled.cameraAnimation) {\n        mixer.update(delta);\n        camera.updateProjectionMatrix();\n        camera.up.set(0, 1, 0);\n        camera.up.applyQuaternion(camera.quaternion);\n        camera.lookAt(this.cameraTarget.position);\n      }\n    }\n  }, {\n    key: \"_optimizeIK\",\n    value: function _optimizeIK(mesh, physicsEnabled) {\n      var iks = mesh.geometry.userData.MMD.iks;\n      var bones = mesh.geometry.userData.MMD.bones;\n\n      for (var i = 0, il = iks.length; i < il; i++) {\n        var ik = iks[i];\n        var links = ik.links;\n\n        for (var j = 0, jl = links.length; j < jl; j++) {\n          var link = links[j];\n\n          if (physicsEnabled === true) {\n            link.enabled = bones[link.index].rigidBodyType > 0 ? false : true;\n          } else {\n            link.enabled = true;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_createCCDIKSolver\",\n    value: function _createCCDIKSolver(mesh) {\n      if (CCDIKSolver === void 0) {\n        throw new Error(\"THREE.MMDAnimationHelper: Import CCDIKSolver.\");\n      }\n\n      return new CCDIKSolver(mesh, mesh.geometry.userData.MMD.iks);\n    }\n  }, {\n    key: \"_createMMDPhysics\",\n    value: function _createMMDPhysics(mesh, params) {\n      if (MMDPhysics === void 0) {\n        throw new Error(\"THREE.MMDPhysics: Import MMDPhysics.\");\n      }\n\n      return new MMDPhysics(mesh, mesh.geometry.userData.MMD.rigidBodies, mesh.geometry.userData.MMD.constraints, params);\n    }\n    /*\n     * Detects the longest duration and then sets it to them to sync.\n     * TODO: Not to access private properties ( ._actions and ._clip )\n     */\n\n  }, {\n    key: \"_syncDuration\",\n    value: function _syncDuration() {\n      var max = 0;\n      var objects = this.objects;\n      var meshes = this.meshes;\n      var camera = this.camera;\n      var audioManager = this.audioManager;\n\n      for (var i = 0, il = meshes.length; i < il; i++) {\n        var mixer = this.objects.get(meshes[i]).mixer;\n        if (mixer === void 0) continue;\n\n        for (var j = 0; j < mixer._actions.length; j++) {\n          var clip = mixer._actions[j]._clip;\n\n          if (!objects.has(clip)) {\n            objects.set(clip, {\n              duration: clip.duration\n            });\n          }\n\n          max = Math.max(max, objects.get(clip).duration);\n        }\n      }\n\n      if (camera !== null) {\n        var _mixer = this.objects.get(camera).mixer;\n\n        if (_mixer !== void 0) {\n          for (var _i2 = 0, _il2 = _mixer._actions.length; _i2 < _il2; _i2++) {\n            var _clip = _mixer._actions[_i2]._clip;\n\n            if (!objects.has(_clip)) {\n              objects.set(_clip, {\n                duration: _clip.duration\n              });\n            }\n\n            max = Math.max(max, objects.get(_clip).duration);\n          }\n        }\n      }\n\n      if (audioManager !== null) {\n        max = Math.max(max, objects.get(audioManager).duration);\n      }\n\n      max += this.configuration.afterglow;\n\n      for (var _i3 = 0, _il3 = this.meshes.length; _i3 < _il3; _i3++) {\n        var _mixer2 = this.objects.get(this.meshes[_i3]).mixer;\n        if (_mixer2 === void 0) continue;\n\n        for (var _j = 0, jl = _mixer2._actions.length; _j < jl; _j++) {\n          _mixer2._actions[_j]._clip.duration = max;\n        }\n      }\n\n      if (camera !== null) {\n        var _mixer3 = this.objects.get(camera).mixer;\n\n        if (_mixer3 !== void 0) {\n          for (var _i4 = 0, _il4 = _mixer3._actions.length; _i4 < _il4; _i4++) {\n            _mixer3._actions[_i4]._clip.duration = max;\n          }\n        }\n      }\n\n      if (audioManager !== null) {\n        audioManager.duration = max;\n      }\n    } // workaround\n\n  }, {\n    key: \"_updatePropertyMixersBuffer\",\n    value: function _updatePropertyMixersBuffer(mesh) {\n      var mixer = this.objects.get(mesh).mixer;\n      var propertyMixers = mixer._bindings;\n      var accuIndex = mixer._accuIndex;\n\n      for (var i = 0, il = propertyMixers.length; i < il; i++) {\n        var propertyMixer = propertyMixers[i];\n        var buffer = propertyMixer.buffer;\n        var stride = propertyMixer.valueSize;\n        var offset = (accuIndex + 1) * stride;\n        propertyMixer.binding.getValue(buffer, offset);\n      }\n    }\n    /*\n     * Avoiding these two issues by restore/save bones before/after mixer animation.\n     *\n     * 1. PropertyMixer used by AnimationMixer holds cache value in .buffer.\n     *    Calculating IK, Grant, and Physics after mixer animation can break\n     *    the cache coherency.\n     *\n     * 2. Applying Grant two or more times without reset the posing breaks model.\n     */\n\n  }, {\n    key: \"_saveBones\",\n    value: function _saveBones(mesh) {\n      var objects = this.objects.get(mesh);\n      var bones = mesh.skeleton.bones;\n      var backupBones = objects.backupBones;\n\n      if (backupBones === void 0) {\n        backupBones = new Float32Array(bones.length * 7);\n        objects.backupBones = backupBones;\n      }\n\n      for (var i = 0, il = bones.length; i < il; i++) {\n        var bone = bones[i];\n        bone.position.toArray(backupBones, i * 7);\n        bone.quaternion.toArray(backupBones, i * 7 + 3);\n      }\n    }\n  }, {\n    key: \"_restoreBones\",\n    value: function _restoreBones(mesh) {\n      var objects = this.objects.get(mesh);\n      var backupBones = objects.backupBones;\n      if (backupBones === void 0) return;\n      var bones = mesh.skeleton.bones;\n\n      for (var i = 0, il = bones.length; i < il; i++) {\n        var bone = bones[i];\n        bone.position.fromArray(backupBones, i * 7);\n        bone.quaternion.fromArray(backupBones, i * 7 + 3);\n      }\n    } // experimental\n\n  }, {\n    key: \"_getMasterPhysics\",\n    value: function _getMasterPhysics() {\n      if (this.masterPhysics !== null) return this.masterPhysics;\n\n      for (var i = 0, il = this.meshes.length; i < il; i++) {\n        var physics = this.meshes[i].physics;\n\n        if (physics !== void 0 && physics !== null) {\n          this.masterPhysics = physics;\n          return this.masterPhysics;\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"_updateSharedPhysics\",\n    value: function _updateSharedPhysics(delta) {\n      if (this.meshes.length === 0 || !this.enabled.physics || !this.sharedPhysics) return;\n\n      var physics = this._getMasterPhysics();\n\n      if (physics === null) return;\n\n      for (var i = 0, il = this.meshes.length; i < il; i++) {\n        var p = this.meshes[i].physics;\n\n        if (p !== null && p !== void 0) {\n          p.updateRigidBodies();\n        }\n      }\n\n      physics.stepSimulation(delta);\n\n      for (var _i5 = 0, _il5 = this.meshes.length; _i5 < _il5; _i5++) {\n        var _p = this.meshes[_i5].physics;\n\n        if (_p !== null && _p !== void 0) {\n          _p.updateBones();\n        }\n      }\n    }\n  }]);\n\n  return MMDAnimationHelper;\n}();\n\nvar _quaternions = [];\nvar _quaternionIndex = 0;\n\nfunction getQuaternion() {\n  if (_quaternionIndex >= _quaternions.length) {\n    _quaternions.push(new Quaternion());\n  }\n\n  return _quaternions[_quaternionIndex++];\n}\n\nvar _grantResultMap = /* @__PURE__ */new Map();\n\nfunction updateOne(mesh, boneIndex, ikSolver, grantSolver) {\n  var bones = mesh.skeleton.bones;\n  var bonesData = mesh.geometry.userData.MMD.bones;\n  var boneData = bonesData[boneIndex];\n  var bone = bones[boneIndex];\n  if (_grantResultMap.has(boneIndex)) return;\n  var quaternion = getQuaternion();\n\n  _grantResultMap.set(boneIndex, quaternion.copy(bone.quaternion));\n\n  if (grantSolver && boneData.grant && !boneData.grant.isLocal && boneData.grant.affectRotation) {\n    var parentIndex = boneData.grant.parentIndex;\n    var ratio = boneData.grant.ratio;\n\n    if (!_grantResultMap.has(parentIndex)) {\n      updateOne(mesh, parentIndex, ikSolver, grantSolver);\n    }\n\n    grantSolver.addGrantRotation(bone, _grantResultMap.get(parentIndex), ratio);\n  }\n\n  if (ikSolver && boneData.ik) {\n    mesh.updateMatrixWorld(true);\n    ikSolver.updateOne(boneData.ik);\n    var links = boneData.ik.links;\n\n    for (var i = 0, il = links.length; i < il; i++) {\n      var link = links[i];\n      if (link.enabled === false) continue;\n      var linkIndex = link.index;\n\n      if (_grantResultMap.has(linkIndex)) {\n        _grantResultMap.set(linkIndex, _grantResultMap.get(linkIndex).copy(bones[linkIndex].quaternion));\n      }\n    }\n  }\n\n  quaternion.copy(bone.quaternion);\n}\n\nvar AudioManager = /*#__PURE__*/function () {\n  /**\n   * @param {THREE.Audio} audio\n   * @param {Object} params - (optional)\n   * @param {Nuumber} params.delayTime\n   */\n  function AudioManager(audio) {\n    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, AudioManager);\n\n    this.audio = audio;\n    this.elapsedTime = 0;\n    this.currentTime = 0;\n    this.delayTime = params.delayTime !== void 0 ? params.delayTime : 0;\n    this.audioDuration = this.audio.buffer.duration;\n    this.duration = this.audioDuration + this.delayTime;\n  }\n  /**\n   * @param {Number} delta\n   * @return {AudioManager}\n   */\n\n\n  _createClass(AudioManager, [{\n    key: \"control\",\n    value: function control(delta) {\n      this.elapsed += delta;\n      this.currentTime += delta;\n      if (this._shouldStopAudio()) this.audio.stop();\n      if (this._shouldStartAudio()) this.audio.play();\n      return this;\n    } // private methods\n\n  }, {\n    key: \"_shouldStartAudio\",\n    value: function _shouldStartAudio() {\n      if (this.audio.isPlaying) return false;\n\n      while (this.currentTime >= this.duration) {\n        this.currentTime -= this.duration;\n      }\n\n      if (this.currentTime < this.delayTime) return false;\n      if (this.currentTime - this.delayTime > this.audioDuration) return false;\n      return true;\n    }\n  }, {\n    key: \"_shouldStopAudio\",\n    value: function _shouldStopAudio() {\n      return this.audio.isPlaying && this.currentTime >= this.duration;\n    }\n  }]);\n\n  return AudioManager;\n}();\n\nvar _q = /* @__PURE__ */new Quaternion();\n\nvar GrantSolver = /*#__PURE__*/function () {\n  function GrantSolver(mesh) {\n    var grants = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n    _classCallCheck(this, GrantSolver);\n\n    this.mesh = mesh;\n    this.grants = grants;\n  }\n  /**\n   * Solve all the grant bones\n   * @return {GrantSolver}\n   */\n\n\n  _createClass(GrantSolver, [{\n    key: \"update\",\n    value: function update() {\n      var grants = this.grants;\n\n      for (var i = 0, il = grants.length; i < il; i++) {\n        this.updateOne(grants[i]);\n      }\n\n      return this;\n    }\n    /**\n     * Solve a grant bone\n     * @param {Object} grant - grant parameter\n     * @return {GrantSolver}\n     */\n\n  }, {\n    key: \"updateOne\",\n    value: function updateOne(grant) {\n      var bones = this.mesh.skeleton.bones;\n      var bone = bones[grant.index];\n      var parentBone = bones[grant.parentIndex];\n\n      if (grant.isLocal) {\n        if (grant.affectPosition) {}\n\n        if (grant.affectRotation) {}\n      } else {\n        if (grant.affectPosition) {}\n\n        if (grant.affectRotation) {\n          this.addGrantRotation(bone, parentBone.quaternion, grant.ratio);\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"addGrantRotation\",\n    value: function addGrantRotation(bone, q, ratio) {\n      _q.set(0, 0, 0, 1);\n\n      _q.slerp(q, ratio);\n\n      bone.quaternion.multiply(_q);\n      return this;\n    }\n  }]);\n\n  return GrantSolver;\n}();\n\nexport { MMDAnimationHelper };","map":{"version":3,"sources":["/Users/theodaguier/_workdir/dev/pro/e-do/E-Do-Studio/node_modules/three-stdlib/animation/MMDAnimationHelper.js"],"names":["Object3D","Vector3","Quaternion","AnimationMixer","CCDIKSolver","MMDPhysics","MMDAnimationHelper","params","meshes","camera","cameraTarget","name","audio","audioManager","objects","WeakMap","configuration","sync","afterglow","resetPhysicsOnLoop","pmxAnimation","enabled","animation","ik","grant","physics","cameraAnimation","onBeforePhysics","sharedPhysics","masterPhysics","object","isSkinnedMesh","_addMesh","isCamera","_setupCamera","type","_setupAudio","Error","_syncDuration","_removeMesh","_clearCamera","_clearAudio","delta","control","i","length","_animateMesh","_updateSharedPhysics","_animateCamera","mesh","vpd","resetPose","pose","bones","skeleton","boneParams","boneNameDictionary","il","vector","quaternion","boneParam","boneIndex","bone","position","add","fromArray","translation","multiply","updateMatrixWorld","geometry","userData","MMD","format","sortedBonesData","_sortBoneDataArray","slice","ikSolver","_createCCDIKSolver","grantSolver","createGrantSolver","_animatePMXMesh","update","key","_optimizeIK","GrantSolver","grants","indexOf","push","set","looped","_setupMeshAnimation","_setupMeshPhysics","clearCamera","_setupCameraAnimation","clearAudio","AudioManager","duration","found","writeIndex","delete","remove","get","animations","Array","isArray","mixer","clipAction","play","addEventListener","event","tracks","action","_clip","world","_getMasterPhysics","_createMMDPhysics","animationWarmup","reset","warmup","_restoreBones","_saveBones","boneDataArray","sort","a","b","transformationClass","index","_quaternionIndex","_grantResultMap","clear","updateOne","updateProjectionMatrix","up","applyQuaternion","lookAt","physicsEnabled","iks","links","j","jl","link","rigidBodyType","rigidBodies","constraints","max","_actions","clip","has","Math","propertyMixers","_bindings","accuIndex","_accuIndex","propertyMixer","buffer","stride","valueSize","offset","binding","getValue","backupBones","Float32Array","toArray","p","updateRigidBodies","stepSimulation","updateBones","_quaternions","getQuaternion","Map","bonesData","boneData","copy","isLocal","affectRotation","parentIndex","ratio","addGrantRotation","linkIndex","elapsedTime","currentTime","delayTime","audioDuration","elapsed","_shouldStopAudio","stop","_shouldStartAudio","isPlaying","_q","parentBone","affectPosition","q","slerp"],"mappings":"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","sourcesContent":["import { Object3D, Vector3, Quaternion, AnimationMixer } from \"three\";\nimport { CCDIKSolver } from \"./CCDIKSolver.js\";\nimport { MMDPhysics } from \"./MMDPhysics.js\";\nclass MMDAnimationHelper {\n  /**\n   * @param {Object} params - (optional)\n   * @param {boolean} params.sync - Whether animation durations of added objects are synched. Default is true.\n   * @param {Number} params.afterglow - Default is 0.0.\n   * @param {boolean} params.resetPhysicsOnLoop - Default is true.\n   */\n  constructor(params = {}) {\n    this.meshes = [];\n    this.camera = null;\n    this.cameraTarget = new Object3D();\n    this.cameraTarget.name = \"target\";\n    this.audio = null;\n    this.audioManager = null;\n    this.objects = /* @__PURE__ */ new WeakMap();\n    this.configuration = {\n      sync: params.sync !== void 0 ? params.sync : true,\n      afterglow: params.afterglow !== void 0 ? params.afterglow : 0,\n      resetPhysicsOnLoop: params.resetPhysicsOnLoop !== void 0 ? params.resetPhysicsOnLoop : true,\n      pmxAnimation: params.pmxAnimation !== void 0 ? params.pmxAnimation : false\n    };\n    this.enabled = {\n      animation: true,\n      ik: true,\n      grant: true,\n      physics: true,\n      cameraAnimation: true\n    };\n    this.onBeforePhysics = function() {\n    };\n    this.sharedPhysics = false;\n    this.masterPhysics = null;\n  }\n  /**\n   * Adds an Three.js Object to helper and setups animation.\n   * The anmation durations of added objects are synched\n   * if this.configuration.sync is true.\n   *\n   * @param {THREE.SkinnedMesh|THREE.Camera|THREE.Audio} object\n   * @param {Object} params - (optional)\n   * @param {THREE.AnimationClip|Array<THREE.AnimationClip>} params.animation - Only for THREE.SkinnedMesh and THREE.Camera. Default is undefined.\n   * @param {boolean} params.physics - Only for THREE.SkinnedMesh. Default is true.\n   * @param {Integer} params.warmup - Only for THREE.SkinnedMesh and physics is true. Default is 60.\n   * @param {Number} params.unitStep - Only for THREE.SkinnedMesh and physics is true. Default is 1 / 65.\n   * @param {Integer} params.maxStepNum - Only for THREE.SkinnedMesh and physics is true. Default is 3.\n   * @param {Vector3} params.gravity - Only for THREE.SkinnedMesh and physics is true. Default ( 0, - 9.8 * 10, 0 ).\n   * @param {Number} params.delayTime - Only for THREE.Audio. Default is 0.0.\n   * @return {MMDAnimationHelper}\n   */\n  add(object, params = {}) {\n    if (object.isSkinnedMesh) {\n      this._addMesh(object, params);\n    } else if (object.isCamera) {\n      this._setupCamera(object, params);\n    } else if (object.type === \"Audio\") {\n      this._setupAudio(object, params);\n    } else {\n      throw new Error(\n        \"THREE.MMDAnimationHelper.add: accepts only THREE.SkinnedMesh or THREE.Camera or THREE.Audio instance.\"\n      );\n    }\n    if (this.configuration.sync)\n      this._syncDuration();\n    return this;\n  }\n  /**\n   * Removes an Three.js Object from helper.\n   *\n   * @param {THREE.SkinnedMesh|THREE.Camera|THREE.Audio} object\n   * @return {MMDAnimationHelper}\n   */\n  remove(object) {\n    if (object.isSkinnedMesh) {\n      this._removeMesh(object);\n    } else if (object.isCamera) {\n      this._clearCamera(object);\n    } else if (object.type === \"Audio\") {\n      this._clearAudio(object);\n    } else {\n      throw new Error(\n        \"THREE.MMDAnimationHelper.remove: accepts only THREE.SkinnedMesh or THREE.Camera or THREE.Audio instance.\"\n      );\n    }\n    if (this.configuration.sync)\n      this._syncDuration();\n    return this;\n  }\n  /**\n   * Updates the animation.\n   *\n   * @param {Number} delta\n   * @return {MMDAnimationHelper}\n   */\n  update(delta) {\n    if (this.audioManager !== null)\n      this.audioManager.control(delta);\n    for (let i = 0; i < this.meshes.length; i++) {\n      this._animateMesh(this.meshes[i], delta);\n    }\n    if (this.sharedPhysics)\n      this._updateSharedPhysics(delta);\n    if (this.camera !== null)\n      this._animateCamera(this.camera, delta);\n    return this;\n  }\n  /**\n   * Changes the pose of SkinnedMesh as VPD specifies.\n   *\n   * @param {THREE.SkinnedMesh} mesh\n   * @param {Object} vpd - VPD content parsed MMDParser\n   * @param {Object} params - (optional)\n   * @param {boolean} params.resetPose - Default is true.\n   * @param {boolean} params.ik - Default is true.\n   * @param {boolean} params.grant - Default is true.\n   * @return {MMDAnimationHelper}\n   */\n  pose(mesh, vpd, params = {}) {\n    if (params.resetPose !== false)\n      mesh.pose();\n    const bones = mesh.skeleton.bones;\n    const boneParams = vpd.bones;\n    const boneNameDictionary = {};\n    for (let i = 0, il = bones.length; i < il; i++) {\n      boneNameDictionary[bones[i].name] = i;\n    }\n    const vector = new Vector3();\n    const quaternion = new Quaternion();\n    for (let i = 0, il = boneParams.length; i < il; i++) {\n      const boneParam = boneParams[i];\n      const boneIndex = boneNameDictionary[boneParam.name];\n      if (boneIndex === void 0)\n        continue;\n      const bone = bones[boneIndex];\n      bone.position.add(vector.fromArray(boneParam.translation));\n      bone.quaternion.multiply(quaternion.fromArray(boneParam.quaternion));\n    }\n    mesh.updateMatrixWorld(true);\n    if (this.configuration.pmxAnimation && mesh.geometry.userData.MMD && mesh.geometry.userData.MMD.format === \"pmx\") {\n      const sortedBonesData = this._sortBoneDataArray(mesh.geometry.userData.MMD.bones.slice());\n      const ikSolver = params.ik !== false ? this._createCCDIKSolver(mesh) : null;\n      const grantSolver = params.grant !== false ? this.createGrantSolver(mesh) : null;\n      this._animatePMXMesh(mesh, sortedBonesData, ikSolver, grantSolver);\n    } else {\n      if (params.ik !== false) {\n        this._createCCDIKSolver(mesh).update();\n      }\n      if (params.grant !== false) {\n        this.createGrantSolver(mesh).update();\n      }\n    }\n    return this;\n  }\n  /**\n   * Enabes/Disables an animation feature.\n   *\n   * @param {string} key\n   * @param {boolean} enabled\n   * @return {MMDAnimationHelper}\n   */\n  enable(key, enabled) {\n    if (this.enabled[key] === void 0) {\n      throw new Error(\"THREE.MMDAnimationHelper.enable: unknown key \" + key);\n    }\n    this.enabled[key] = enabled;\n    if (key === \"physics\") {\n      for (let i = 0, il = this.meshes.length; i < il; i++) {\n        this._optimizeIK(this.meshes[i], enabled);\n      }\n    }\n    return this;\n  }\n  /**\n   * Creates an GrantSolver instance.\n   *\n   * @param {THREE.SkinnedMesh} mesh\n   * @return {GrantSolver}\n   */\n  createGrantSolver(mesh) {\n    return new GrantSolver(mesh, mesh.geometry.userData.MMD.grants);\n  }\n  // private methods\n  _addMesh(mesh, params) {\n    if (this.meshes.indexOf(mesh) >= 0) {\n      throw new Error(\"THREE.MMDAnimationHelper._addMesh: SkinnedMesh '\" + mesh.name + \"' has already been added.\");\n    }\n    this.meshes.push(mesh);\n    this.objects.set(mesh, { looped: false });\n    this._setupMeshAnimation(mesh, params.animation);\n    if (params.physics !== false) {\n      this._setupMeshPhysics(mesh, params);\n    }\n    return this;\n  }\n  _setupCamera(camera, params) {\n    if (this.camera === camera) {\n      throw new Error(\"THREE.MMDAnimationHelper._setupCamera: Camera '\" + camera.name + \"' has already been set.\");\n    }\n    if (this.camera)\n      this.clearCamera(this.camera);\n    this.camera = camera;\n    camera.add(this.cameraTarget);\n    this.objects.set(camera, {});\n    if (params.animation !== void 0) {\n      this._setupCameraAnimation(camera, params.animation);\n    }\n    return this;\n  }\n  _setupAudio(audio, params) {\n    if (this.audio === audio) {\n      throw new Error(\"THREE.MMDAnimationHelper._setupAudio: Audio '\" + audio.name + \"' has already been set.\");\n    }\n    if (this.audio)\n      this.clearAudio(this.audio);\n    this.audio = audio;\n    this.audioManager = new AudioManager(audio, params);\n    this.objects.set(this.audioManager, {\n      duration: this.audioManager.duration\n    });\n    return this;\n  }\n  _removeMesh(mesh) {\n    let found = false;\n    let writeIndex = 0;\n    for (let i = 0, il = this.meshes.length; i < il; i++) {\n      if (this.meshes[i] === mesh) {\n        this.objects.delete(mesh);\n        found = true;\n        continue;\n      }\n      this.meshes[writeIndex++] = this.meshes[i];\n    }\n    if (!found) {\n      throw new Error(\n        \"THREE.MMDAnimationHelper._removeMesh: SkinnedMesh '\" + mesh.name + \"' has not been added yet.\"\n      );\n    }\n    this.meshes.length = writeIndex;\n    return this;\n  }\n  _clearCamera(camera) {\n    if (camera !== this.camera) {\n      throw new Error(\"THREE.MMDAnimationHelper._clearCamera: Camera '\" + camera.name + \"' has not been set yet.\");\n    }\n    this.camera.remove(this.cameraTarget);\n    this.objects.delete(this.camera);\n    this.camera = null;\n    return this;\n  }\n  _clearAudio(audio) {\n    if (audio !== this.audio) {\n      throw new Error(\"THREE.MMDAnimationHelper._clearAudio: Audio '\" + audio.name + \"' has not been set yet.\");\n    }\n    this.objects.delete(this.audioManager);\n    this.audio = null;\n    this.audioManager = null;\n    return this;\n  }\n  _setupMeshAnimation(mesh, animation) {\n    const objects = this.objects.get(mesh);\n    if (animation !== void 0) {\n      const animations = Array.isArray(animation) ? animation : [animation];\n      objects.mixer = new AnimationMixer(mesh);\n      for (let i = 0, il = animations.length; i < il; i++) {\n        objects.mixer.clipAction(animations[i]).play();\n      }\n      objects.mixer.addEventListener(\"loop\", function(event) {\n        const tracks = event.action._clip.tracks;\n        if (tracks.length > 0 && tracks[0].name.slice(0, 6) !== \".bones\")\n          return;\n        objects.looped = true;\n      });\n    }\n    objects.ikSolver = this._createCCDIKSolver(mesh);\n    objects.grantSolver = this.createGrantSolver(mesh);\n    return this;\n  }\n  _setupCameraAnimation(camera, animation) {\n    const animations = Array.isArray(animation) ? animation : [animation];\n    const objects = this.objects.get(camera);\n    objects.mixer = new AnimationMixer(camera);\n    for (let i = 0, il = animations.length; i < il; i++) {\n      objects.mixer.clipAction(animations[i]).play();\n    }\n  }\n  _setupMeshPhysics(mesh, params) {\n    const objects = this.objects.get(mesh);\n    if (params.world === void 0 && this.sharedPhysics) {\n      const masterPhysics = this._getMasterPhysics();\n      if (masterPhysics !== null)\n        world = masterPhysics.world;\n    }\n    objects.physics = this._createMMDPhysics(mesh, params);\n    if (objects.mixer && params.animationWarmup !== false) {\n      this._animateMesh(mesh, 0);\n      objects.physics.reset();\n    }\n    objects.physics.warmup(params.warmup !== void 0 ? params.warmup : 60);\n    this._optimizeIK(mesh, true);\n  }\n  _animateMesh(mesh, delta) {\n    const objects = this.objects.get(mesh);\n    const mixer = objects.mixer;\n    const ikSolver = objects.ikSolver;\n    const grantSolver = objects.grantSolver;\n    const physics = objects.physics;\n    const looped = objects.looped;\n    if (mixer && this.enabled.animation) {\n      this._restoreBones(mesh);\n      mixer.update(delta);\n      this._saveBones(mesh);\n      if (this.configuration.pmxAnimation && mesh.geometry.userData.MMD && mesh.geometry.userData.MMD.format === \"pmx\") {\n        if (!objects.sortedBonesData)\n          objects.sortedBonesData = this._sortBoneDataArray(mesh.geometry.userData.MMD.bones.slice());\n        this._animatePMXMesh(\n          mesh,\n          objects.sortedBonesData,\n          ikSolver && this.enabled.ik ? ikSolver : null,\n          grantSolver && this.enabled.grant ? grantSolver : null\n        );\n      } else {\n        if (ikSolver && this.enabled.ik) {\n          mesh.updateMatrixWorld(true);\n          ikSolver.update();\n        }\n        if (grantSolver && this.enabled.grant) {\n          grantSolver.update();\n        }\n      }\n    }\n    if (looped === true && this.enabled.physics) {\n      if (physics && this.configuration.resetPhysicsOnLoop)\n        physics.reset();\n      objects.looped = false;\n    }\n    if (physics && this.enabled.physics && !this.sharedPhysics) {\n      this.onBeforePhysics(mesh);\n      physics.update(delta);\n    }\n  }\n  // Sort bones in order by 1. transformationClass and 2. bone index.\n  // In PMX animation system, bone transformations should be processed\n  // in this order.\n  _sortBoneDataArray(boneDataArray) {\n    return boneDataArray.sort(function(a, b) {\n      if (a.transformationClass !== b.transformationClass) {\n        return a.transformationClass - b.transformationClass;\n      } else {\n        return a.index - b.index;\n      }\n    });\n  }\n  // PMX Animation system is a bit too complex and doesn't great match to\n  // Three.js Animation system. This method attempts to simulate it as much as\n  // possible but doesn't perfectly simulate.\n  // This method is more costly than the regular one so\n  // you are recommended to set constructor parameter \"pmxAnimation: true\"\n  // only if your PMX model animation doesn't work well.\n  // If you need better method you would be required to write your own.\n  _animatePMXMesh(mesh, sortedBonesData, ikSolver, grantSolver) {\n    _quaternionIndex = 0;\n    _grantResultMap.clear();\n    for (let i = 0, il = sortedBonesData.length; i < il; i++) {\n      updateOne(mesh, sortedBonesData[i].index, ikSolver, grantSolver);\n    }\n    mesh.updateMatrixWorld(true);\n    return this;\n  }\n  _animateCamera(camera, delta) {\n    const mixer = this.objects.get(camera).mixer;\n    if (mixer && this.enabled.cameraAnimation) {\n      mixer.update(delta);\n      camera.updateProjectionMatrix();\n      camera.up.set(0, 1, 0);\n      camera.up.applyQuaternion(camera.quaternion);\n      camera.lookAt(this.cameraTarget.position);\n    }\n  }\n  _optimizeIK(mesh, physicsEnabled) {\n    const iks = mesh.geometry.userData.MMD.iks;\n    const bones = mesh.geometry.userData.MMD.bones;\n    for (let i = 0, il = iks.length; i < il; i++) {\n      const ik = iks[i];\n      const links = ik.links;\n      for (let j = 0, jl = links.length; j < jl; j++) {\n        const link = links[j];\n        if (physicsEnabled === true) {\n          link.enabled = bones[link.index].rigidBodyType > 0 ? false : true;\n        } else {\n          link.enabled = true;\n        }\n      }\n    }\n  }\n  _createCCDIKSolver(mesh) {\n    if (CCDIKSolver === void 0) {\n      throw new Error(\"THREE.MMDAnimationHelper: Import CCDIKSolver.\");\n    }\n    return new CCDIKSolver(mesh, mesh.geometry.userData.MMD.iks);\n  }\n  _createMMDPhysics(mesh, params) {\n    if (MMDPhysics === void 0) {\n      throw new Error(\"THREE.MMDPhysics: Import MMDPhysics.\");\n    }\n    return new MMDPhysics(mesh, mesh.geometry.userData.MMD.rigidBodies, mesh.geometry.userData.MMD.constraints, params);\n  }\n  /*\n   * Detects the longest duration and then sets it to them to sync.\n   * TODO: Not to access private properties ( ._actions and ._clip )\n   */\n  _syncDuration() {\n    let max = 0;\n    const objects = this.objects;\n    const meshes = this.meshes;\n    const camera = this.camera;\n    const audioManager = this.audioManager;\n    for (let i = 0, il = meshes.length; i < il; i++) {\n      const mixer = this.objects.get(meshes[i]).mixer;\n      if (mixer === void 0)\n        continue;\n      for (let j = 0; j < mixer._actions.length; j++) {\n        const clip = mixer._actions[j]._clip;\n        if (!objects.has(clip)) {\n          objects.set(clip, {\n            duration: clip.duration\n          });\n        }\n        max = Math.max(max, objects.get(clip).duration);\n      }\n    }\n    if (camera !== null) {\n      const mixer = this.objects.get(camera).mixer;\n      if (mixer !== void 0) {\n        for (let i = 0, il = mixer._actions.length; i < il; i++) {\n          const clip = mixer._actions[i]._clip;\n          if (!objects.has(clip)) {\n            objects.set(clip, {\n              duration: clip.duration\n            });\n          }\n          max = Math.max(max, objects.get(clip).duration);\n        }\n      }\n    }\n    if (audioManager !== null) {\n      max = Math.max(max, objects.get(audioManager).duration);\n    }\n    max += this.configuration.afterglow;\n    for (let i = 0, il = this.meshes.length; i < il; i++) {\n      const mixer = this.objects.get(this.meshes[i]).mixer;\n      if (mixer === void 0)\n        continue;\n      for (let j = 0, jl = mixer._actions.length; j < jl; j++) {\n        mixer._actions[j]._clip.duration = max;\n      }\n    }\n    if (camera !== null) {\n      const mixer = this.objects.get(camera).mixer;\n      if (mixer !== void 0) {\n        for (let i = 0, il = mixer._actions.length; i < il; i++) {\n          mixer._actions[i]._clip.duration = max;\n        }\n      }\n    }\n    if (audioManager !== null) {\n      audioManager.duration = max;\n    }\n  }\n  // workaround\n  _updatePropertyMixersBuffer(mesh) {\n    const mixer = this.objects.get(mesh).mixer;\n    const propertyMixers = mixer._bindings;\n    const accuIndex = mixer._accuIndex;\n    for (let i = 0, il = propertyMixers.length; i < il; i++) {\n      const propertyMixer = propertyMixers[i];\n      const buffer = propertyMixer.buffer;\n      const stride = propertyMixer.valueSize;\n      const offset = (accuIndex + 1) * stride;\n      propertyMixer.binding.getValue(buffer, offset);\n    }\n  }\n  /*\n   * Avoiding these two issues by restore/save bones before/after mixer animation.\n   *\n   * 1. PropertyMixer used by AnimationMixer holds cache value in .buffer.\n   *    Calculating IK, Grant, and Physics after mixer animation can break\n   *    the cache coherency.\n   *\n   * 2. Applying Grant two or more times without reset the posing breaks model.\n   */\n  _saveBones(mesh) {\n    const objects = this.objects.get(mesh);\n    const bones = mesh.skeleton.bones;\n    let backupBones = objects.backupBones;\n    if (backupBones === void 0) {\n      backupBones = new Float32Array(bones.length * 7);\n      objects.backupBones = backupBones;\n    }\n    for (let i = 0, il = bones.length; i < il; i++) {\n      const bone = bones[i];\n      bone.position.toArray(backupBones, i * 7);\n      bone.quaternion.toArray(backupBones, i * 7 + 3);\n    }\n  }\n  _restoreBones(mesh) {\n    const objects = this.objects.get(mesh);\n    const backupBones = objects.backupBones;\n    if (backupBones === void 0)\n      return;\n    const bones = mesh.skeleton.bones;\n    for (let i = 0, il = bones.length; i < il; i++) {\n      const bone = bones[i];\n      bone.position.fromArray(backupBones, i * 7);\n      bone.quaternion.fromArray(backupBones, i * 7 + 3);\n    }\n  }\n  // experimental\n  _getMasterPhysics() {\n    if (this.masterPhysics !== null)\n      return this.masterPhysics;\n    for (let i = 0, il = this.meshes.length; i < il; i++) {\n      const physics = this.meshes[i].physics;\n      if (physics !== void 0 && physics !== null) {\n        this.masterPhysics = physics;\n        return this.masterPhysics;\n      }\n    }\n    return null;\n  }\n  _updateSharedPhysics(delta) {\n    if (this.meshes.length === 0 || !this.enabled.physics || !this.sharedPhysics)\n      return;\n    const physics = this._getMasterPhysics();\n    if (physics === null)\n      return;\n    for (let i = 0, il = this.meshes.length; i < il; i++) {\n      const p = this.meshes[i].physics;\n      if (p !== null && p !== void 0) {\n        p.updateRigidBodies();\n      }\n    }\n    physics.stepSimulation(delta);\n    for (let i = 0, il = this.meshes.length; i < il; i++) {\n      const p = this.meshes[i].physics;\n      if (p !== null && p !== void 0) {\n        p.updateBones();\n      }\n    }\n  }\n}\nconst _quaternions = [];\nlet _quaternionIndex = 0;\nfunction getQuaternion() {\n  if (_quaternionIndex >= _quaternions.length) {\n    _quaternions.push(new Quaternion());\n  }\n  return _quaternions[_quaternionIndex++];\n}\nconst _grantResultMap = /* @__PURE__ */ new Map();\nfunction updateOne(mesh, boneIndex, ikSolver, grantSolver) {\n  const bones = mesh.skeleton.bones;\n  const bonesData = mesh.geometry.userData.MMD.bones;\n  const boneData = bonesData[boneIndex];\n  const bone = bones[boneIndex];\n  if (_grantResultMap.has(boneIndex))\n    return;\n  const quaternion = getQuaternion();\n  _grantResultMap.set(boneIndex, quaternion.copy(bone.quaternion));\n  if (grantSolver && boneData.grant && !boneData.grant.isLocal && boneData.grant.affectRotation) {\n    const parentIndex = boneData.grant.parentIndex;\n    const ratio = boneData.grant.ratio;\n    if (!_grantResultMap.has(parentIndex)) {\n      updateOne(mesh, parentIndex, ikSolver, grantSolver);\n    }\n    grantSolver.addGrantRotation(bone, _grantResultMap.get(parentIndex), ratio);\n  }\n  if (ikSolver && boneData.ik) {\n    mesh.updateMatrixWorld(true);\n    ikSolver.updateOne(boneData.ik);\n    const links = boneData.ik.links;\n    for (let i = 0, il = links.length; i < il; i++) {\n      const link = links[i];\n      if (link.enabled === false)\n        continue;\n      const linkIndex = link.index;\n      if (_grantResultMap.has(linkIndex)) {\n        _grantResultMap.set(linkIndex, _grantResultMap.get(linkIndex).copy(bones[linkIndex].quaternion));\n      }\n    }\n  }\n  quaternion.copy(bone.quaternion);\n}\nclass AudioManager {\n  /**\n   * @param {THREE.Audio} audio\n   * @param {Object} params - (optional)\n   * @param {Nuumber} params.delayTime\n   */\n  constructor(audio, params = {}) {\n    this.audio = audio;\n    this.elapsedTime = 0;\n    this.currentTime = 0;\n    this.delayTime = params.delayTime !== void 0 ? params.delayTime : 0;\n    this.audioDuration = this.audio.buffer.duration;\n    this.duration = this.audioDuration + this.delayTime;\n  }\n  /**\n   * @param {Number} delta\n   * @return {AudioManager}\n   */\n  control(delta) {\n    this.elapsed += delta;\n    this.currentTime += delta;\n    if (this._shouldStopAudio())\n      this.audio.stop();\n    if (this._shouldStartAudio())\n      this.audio.play();\n    return this;\n  }\n  // private methods\n  _shouldStartAudio() {\n    if (this.audio.isPlaying)\n      return false;\n    while (this.currentTime >= this.duration) {\n      this.currentTime -= this.duration;\n    }\n    if (this.currentTime < this.delayTime)\n      return false;\n    if (this.currentTime - this.delayTime > this.audioDuration)\n      return false;\n    return true;\n  }\n  _shouldStopAudio() {\n    return this.audio.isPlaying && this.currentTime >= this.duration;\n  }\n}\nconst _q = /* @__PURE__ */ new Quaternion();\nclass GrantSolver {\n  constructor(mesh, grants = []) {\n    this.mesh = mesh;\n    this.grants = grants;\n  }\n  /**\n   * Solve all the grant bones\n   * @return {GrantSolver}\n   */\n  update() {\n    const grants = this.grants;\n    for (let i = 0, il = grants.length; i < il; i++) {\n      this.updateOne(grants[i]);\n    }\n    return this;\n  }\n  /**\n   * Solve a grant bone\n   * @param {Object} grant - grant parameter\n   * @return {GrantSolver}\n   */\n  updateOne(grant) {\n    const bones = this.mesh.skeleton.bones;\n    const bone = bones[grant.index];\n    const parentBone = bones[grant.parentIndex];\n    if (grant.isLocal) {\n      if (grant.affectPosition) {\n      }\n      if (grant.affectRotation) {\n      }\n    } else {\n      if (grant.affectPosition) {\n      }\n      if (grant.affectRotation) {\n        this.addGrantRotation(bone, parentBone.quaternion, grant.ratio);\n      }\n    }\n    return this;\n  }\n  addGrantRotation(bone, q, ratio) {\n    _q.set(0, 0, 0, 1);\n    _q.slerp(q, ratio);\n    bone.quaternion.multiply(_q);\n    return this;\n  }\n}\nexport {\n  MMDAnimationHelper\n};\n"]},"metadata":{},"sourceType":"module"}