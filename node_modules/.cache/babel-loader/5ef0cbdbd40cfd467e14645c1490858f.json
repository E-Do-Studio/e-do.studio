{"ast":null,"code":"import _classCallCheck from \"/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _assertThisInitialized from \"/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nvar __defProp = Object.defineProperty;\n\nvar __defNormalProp = function __defNormalProp(obj, key, value) {\n  return key in obj ? __defProp(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\n\nvar __publicField = function __publicField(obj, key, value) {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n\n  return value;\n};\n\nimport { Mesh, PerspectiveCamera, Color, Plane, Vector3, Matrix4, Vector4, WebGLRenderTarget, HalfFloatType, ShaderMaterial, UniformsUtils, NoToneMapping } from \"three\";\n\nvar _Reflector = /*#__PURE__*/function (_Mesh) {\n  _inherits(_Reflector, _Mesh);\n\n  var _super = _createSuper(_Reflector);\n\n  function _Reflector(geometry) {\n    var _this;\n\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, _Reflector);\n\n    _this = _super.call(this, geometry);\n    _this.isReflector = true;\n    _this.type = \"Reflector\";\n    _this.camera = new PerspectiveCamera();\n\n    var scope = _assertThisInitialized(_this);\n\n    var color = options.color !== void 0 ? new Color(options.color) : new Color(8355711);\n    var textureWidth = options.textureWidth || 512;\n    var textureHeight = options.textureHeight || 512;\n    var clipBias = options.clipBias || 0;\n    var shader = options.shader || _Reflector.ReflectorShader;\n    var multisample = options.multisample !== void 0 ? options.multisample : 4;\n    var reflectorPlane = new Plane();\n    var normal = new Vector3();\n    var reflectorWorldPosition = new Vector3();\n    var cameraWorldPosition = new Vector3();\n    var rotationMatrix = new Matrix4();\n    var lookAtPosition = new Vector3(0, 0, -1);\n    var clipPlane = new Vector4();\n    var view = new Vector3();\n    var target = new Vector3();\n    var q = new Vector4();\n    var textureMatrix = new Matrix4();\n    var virtualCamera = _this.camera;\n    var renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, {\n      samples: multisample,\n      type: HalfFloatType\n    });\n    var material = new ShaderMaterial({\n      uniforms: UniformsUtils.clone(shader.uniforms),\n      fragmentShader: shader.fragmentShader,\n      vertexShader: shader.vertexShader\n    });\n    material.uniforms[\"tDiffuse\"].value = renderTarget.texture;\n    material.uniforms[\"color\"].value = color;\n    material.uniforms[\"textureMatrix\"].value = textureMatrix;\n    _this.material = material;\n\n    _this.onBeforeRender = function (renderer, scene, camera) {\n      reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n      rotationMatrix.extractRotation(scope.matrixWorld);\n      normal.set(0, 0, 1);\n      normal.applyMatrix4(rotationMatrix);\n      view.subVectors(reflectorWorldPosition, cameraWorldPosition);\n      if (view.dot(normal) > 0) return;\n      view.reflect(normal).negate();\n      view.add(reflectorWorldPosition);\n      rotationMatrix.extractRotation(camera.matrixWorld);\n      lookAtPosition.set(0, 0, -1);\n      lookAtPosition.applyMatrix4(rotationMatrix);\n      lookAtPosition.add(cameraWorldPosition);\n      target.subVectors(reflectorWorldPosition, lookAtPosition);\n      target.reflect(normal).negate();\n      target.add(reflectorWorldPosition);\n      virtualCamera.position.copy(view);\n      virtualCamera.up.set(0, 1, 0);\n      virtualCamera.up.applyMatrix4(rotationMatrix);\n      virtualCamera.up.reflect(normal);\n      virtualCamera.lookAt(target);\n      virtualCamera.far = camera.far;\n      virtualCamera.updateMatrixWorld();\n      virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\n      textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);\n      textureMatrix.multiply(virtualCamera.projectionMatrix);\n      textureMatrix.multiply(virtualCamera.matrixWorldInverse);\n      textureMatrix.multiply(scope.matrixWorld);\n      reflectorPlane.setFromNormalAndCoplanarPoint(normal, reflectorWorldPosition);\n      reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\n      clipPlane.set(reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant);\n      var projectionMatrix = virtualCamera.projectionMatrix;\n      q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n      q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n      q.z = -1;\n      q.w = (1 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];\n      clipPlane.multiplyScalar(2 / clipPlane.dot(q));\n      projectionMatrix.elements[2] = clipPlane.x;\n      projectionMatrix.elements[6] = clipPlane.y;\n      projectionMatrix.elements[10] = clipPlane.z + 1 - clipBias;\n      projectionMatrix.elements[14] = clipPlane.w;\n      scope.visible = false;\n      var currentRenderTarget = renderer.getRenderTarget();\n      var currentXrEnabled = renderer.xr.enabled;\n      var currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n      var currentToneMapping = renderer.toneMapping;\n      var isSRGB = false;\n      if (\"outputColorSpace\" in renderer) isSRGB = renderer.outputColorSpace === \"srgb\";else isSRGB = renderer.outputEncoding === 3001;\n      renderer.xr.enabled = false;\n      renderer.shadowMap.autoUpdate = false;\n      if (\"outputColorSpace\" in renderer) renderer.outputColorSpace = \"linear-srgb\";else renderer.outputEncoding = 3e3;\n      renderer.toneMapping = NoToneMapping;\n      renderer.setRenderTarget(renderTarget);\n      renderer.state.buffers.depth.setMask(true);\n      if (renderer.autoClear === false) renderer.clear();\n      renderer.render(scene, virtualCamera);\n      renderer.xr.enabled = currentXrEnabled;\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n      renderer.toneMapping = currentToneMapping;\n      if (\"outputColorSpace\" in renderer) renderer.outputColorSpace = isSRGB ? \"srgb\" : \"srgb-linear\";else renderer.outputEncoding = isSRGB ? 3001 : 3e3;\n      renderer.setRenderTarget(currentRenderTarget);\n      var viewport = camera.viewport;\n\n      if (viewport !== void 0) {\n        renderer.state.viewport(viewport);\n      }\n\n      scope.visible = true;\n    };\n\n    _this.getRenderTarget = function () {\n      return renderTarget;\n    };\n\n    _this.dispose = function () {\n      renderTarget.dispose();\n      scope.material.dispose();\n    };\n\n    return _this;\n  }\n\n  return _Reflector;\n}(Mesh);\n\nvar Reflector = _Reflector;\n\n__publicField(Reflector, \"ReflectorShader\", {\n  uniforms: {\n    color: {\n      value: null\n    },\n    tDiffuse: {\n      value: null\n    },\n    textureMatrix: {\n      value: null\n    }\n  },\n  vertexShader:\n  /* glsl */\n  \"\\n\\t\\tuniform mat4 textureMatrix;\\n\\t\\tvarying vec4 vUv;\\n\\n\\t\\t#include <common>\\n\\t\\t#include <logdepthbuf_pars_vertex>\\n\\n\\t\\tvoid main() {\\n\\n\\t\\t\\tvUv = textureMatrix * vec4( position, 1.0 );\\n\\n\\t\\t\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\n\\t\\t\\t#include <logdepthbuf_vertex>\\n\\n\\t\\t}\",\n  fragmentShader:\n  /* glsl */\n  \"\\n\\t\\tuniform vec3 color;\\n\\t\\tuniform sampler2D tDiffuse;\\n\\t\\tvarying vec4 vUv;\\n\\n\\t\\t#include <logdepthbuf_pars_fragment>\\n\\n\\t\\tfloat blendOverlay( float base, float blend ) {\\n\\n\\t\\t\\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\\n\\n\\t\\t}\\n\\n\\t\\tvec3 blendOverlay( vec3 base, vec3 blend ) {\\n\\n\\t\\t\\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\\n\\n\\t\\t}\\n\\n\\t\\tvoid main() {\\n\\n\\t\\t\\t#include <logdepthbuf_fragment>\\n\\n\\t\\t\\tvec4 base = texture2DProj( tDiffuse, vUv );\\n\\t\\t\\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\\n\\n\\t\\t\\t#include <tonemapping_fragment>\\n\\t\\t\\t#include <encodings_fragment>\\n\\n\\t\\t}\"\n});\n\nexport { Reflector };","map":{"version":3,"sources":["/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/three-stdlib/objects/Reflector.js"],"names":["__defProp","Object","defineProperty","__defNormalProp","obj","key","value","enumerable","configurable","writable","__publicField","Mesh","PerspectiveCamera","Color","Plane","Vector3","Matrix4","Vector4","WebGLRenderTarget","HalfFloatType","ShaderMaterial","UniformsUtils","NoToneMapping","_Reflector","geometry","options","isReflector","type","camera","scope","color","textureWidth","textureHeight","clipBias","shader","ReflectorShader","multisample","reflectorPlane","normal","reflectorWorldPosition","cameraWorldPosition","rotationMatrix","lookAtPosition","clipPlane","view","target","q","textureMatrix","virtualCamera","renderTarget","samples","material","uniforms","clone","fragmentShader","vertexShader","texture","onBeforeRender","renderer","scene","setFromMatrixPosition","matrixWorld","extractRotation","set","applyMatrix4","subVectors","dot","reflect","negate","add","position","copy","up","lookAt","far","updateMatrixWorld","projectionMatrix","multiply","matrixWorldInverse","setFromNormalAndCoplanarPoint","x","y","z","constant","Math","sign","elements","w","multiplyScalar","visible","currentRenderTarget","getRenderTarget","currentXrEnabled","xr","enabled","currentShadowAutoUpdate","shadowMap","autoUpdate","currentToneMapping","toneMapping","isSRGB","outputColorSpace","outputEncoding","setRenderTarget","state","buffers","depth","setMask","autoClear","clear","render","viewport","dispose","Reflector","tDiffuse"],"mappings":"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","sourcesContent":["var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Mesh, PerspectiveCamera, Color, Plane, Vector3, Matrix4, Vector4, WebGLRenderTarget, HalfFloatType, ShaderMaterial, UniformsUtils, NoToneMapping } from \"three\";\nconst _Reflector = class extends Mesh {\n  constructor(geometry, options = {}) {\n    super(geometry);\n    this.isReflector = true;\n    this.type = \"Reflector\";\n    this.camera = new PerspectiveCamera();\n    const scope = this;\n    const color = options.color !== void 0 ? new Color(options.color) : new Color(8355711);\n    const textureWidth = options.textureWidth || 512;\n    const textureHeight = options.textureHeight || 512;\n    const clipBias = options.clipBias || 0;\n    const shader = options.shader || _Reflector.ReflectorShader;\n    const multisample = options.multisample !== void 0 ? options.multisample : 4;\n    const reflectorPlane = new Plane();\n    const normal = new Vector3();\n    const reflectorWorldPosition = new Vector3();\n    const cameraWorldPosition = new Vector3();\n    const rotationMatrix = new Matrix4();\n    const lookAtPosition = new Vector3(0, 0, -1);\n    const clipPlane = new Vector4();\n    const view = new Vector3();\n    const target = new Vector3();\n    const q = new Vector4();\n    const textureMatrix = new Matrix4();\n    const virtualCamera = this.camera;\n    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, {\n      samples: multisample,\n      type: HalfFloatType\n    });\n    const material = new ShaderMaterial({\n      uniforms: UniformsUtils.clone(shader.uniforms),\n      fragmentShader: shader.fragmentShader,\n      vertexShader: shader.vertexShader\n    });\n    material.uniforms[\"tDiffuse\"].value = renderTarget.texture;\n    material.uniforms[\"color\"].value = color;\n    material.uniforms[\"textureMatrix\"].value = textureMatrix;\n    this.material = material;\n    this.onBeforeRender = function(renderer, scene, camera) {\n      reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n      rotationMatrix.extractRotation(scope.matrixWorld);\n      normal.set(0, 0, 1);\n      normal.applyMatrix4(rotationMatrix);\n      view.subVectors(reflectorWorldPosition, cameraWorldPosition);\n      if (view.dot(normal) > 0)\n        return;\n      view.reflect(normal).negate();\n      view.add(reflectorWorldPosition);\n      rotationMatrix.extractRotation(camera.matrixWorld);\n      lookAtPosition.set(0, 0, -1);\n      lookAtPosition.applyMatrix4(rotationMatrix);\n      lookAtPosition.add(cameraWorldPosition);\n      target.subVectors(reflectorWorldPosition, lookAtPosition);\n      target.reflect(normal).negate();\n      target.add(reflectorWorldPosition);\n      virtualCamera.position.copy(view);\n      virtualCamera.up.set(0, 1, 0);\n      virtualCamera.up.applyMatrix4(rotationMatrix);\n      virtualCamera.up.reflect(normal);\n      virtualCamera.lookAt(target);\n      virtualCamera.far = camera.far;\n      virtualCamera.updateMatrixWorld();\n      virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\n      textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);\n      textureMatrix.multiply(virtualCamera.projectionMatrix);\n      textureMatrix.multiply(virtualCamera.matrixWorldInverse);\n      textureMatrix.multiply(scope.matrixWorld);\n      reflectorPlane.setFromNormalAndCoplanarPoint(normal, reflectorWorldPosition);\n      reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\n      clipPlane.set(reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant);\n      const projectionMatrix = virtualCamera.projectionMatrix;\n      q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n      q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n      q.z = -1;\n      q.w = (1 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];\n      clipPlane.multiplyScalar(2 / clipPlane.dot(q));\n      projectionMatrix.elements[2] = clipPlane.x;\n      projectionMatrix.elements[6] = clipPlane.y;\n      projectionMatrix.elements[10] = clipPlane.z + 1 - clipBias;\n      projectionMatrix.elements[14] = clipPlane.w;\n      scope.visible = false;\n      const currentRenderTarget = renderer.getRenderTarget();\n      const currentXrEnabled = renderer.xr.enabled;\n      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n      const currentToneMapping = renderer.toneMapping;\n      let isSRGB = false;\n      if (\"outputColorSpace\" in renderer)\n        isSRGB = renderer.outputColorSpace === \"srgb\";\n      else\n        isSRGB = renderer.outputEncoding === 3001;\n      renderer.xr.enabled = false;\n      renderer.shadowMap.autoUpdate = false;\n      if (\"outputColorSpace\" in renderer)\n        renderer.outputColorSpace = \"linear-srgb\";\n      else\n        renderer.outputEncoding = 3e3;\n      renderer.toneMapping = NoToneMapping;\n      renderer.setRenderTarget(renderTarget);\n      renderer.state.buffers.depth.setMask(true);\n      if (renderer.autoClear === false)\n        renderer.clear();\n      renderer.render(scene, virtualCamera);\n      renderer.xr.enabled = currentXrEnabled;\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n      renderer.toneMapping = currentToneMapping;\n      if (\"outputColorSpace\" in renderer)\n        renderer.outputColorSpace = isSRGB ? \"srgb\" : \"srgb-linear\";\n      else\n        renderer.outputEncoding = isSRGB ? 3001 : 3e3;\n      renderer.setRenderTarget(currentRenderTarget);\n      const viewport = camera.viewport;\n      if (viewport !== void 0) {\n        renderer.state.viewport(viewport);\n      }\n      scope.visible = true;\n    };\n    this.getRenderTarget = function() {\n      return renderTarget;\n    };\n    this.dispose = function() {\n      renderTarget.dispose();\n      scope.material.dispose();\n    };\n  }\n};\nlet Reflector = _Reflector;\n__publicField(Reflector, \"ReflectorShader\", {\n  uniforms: {\n    color: {\n      value: null\n    },\n    tDiffuse: {\n      value: null\n    },\n    textureMatrix: {\n      value: null\n    }\n  },\n  vertexShader: (\n    /* glsl */\n    `\n\t\tuniform mat4 textureMatrix;\n\t\tvarying vec4 vUv;\n\n\t\t#include <common>\n\t\t#include <logdepthbuf_pars_vertex>\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t#include <logdepthbuf_vertex>\n\n\t\t}`\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tvarying vec4 vUv;\n\n\t\t#include <logdepthbuf_pars_fragment>\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <logdepthbuf_fragment>\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\n\t\t}`\n  )\n});\nexport {\n  Reflector\n};\n"]},"metadata":{},"sourceType":"module"}