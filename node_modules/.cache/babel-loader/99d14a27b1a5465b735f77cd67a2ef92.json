{"ast":null,"code":"import _classCallCheck from \"/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { Mesh, ShaderMaterial, SphereGeometry } from \"three\";\n\nvar LightProbeHelper = /*#__PURE__*/function (_Mesh) {\n  _inherits(LightProbeHelper, _Mesh);\n\n  var _super = _createSuper(LightProbeHelper);\n\n  function LightProbeHelper(lightProbe, size) {\n    var _this;\n\n    _classCallCheck(this, LightProbeHelper);\n\n    var material = new ShaderMaterial({\n      type: \"LightProbeHelperMaterial\",\n      uniforms: {\n        sh: {\n          value: lightProbe.sh.coefficients\n        },\n        // by reference\n        intensity: {\n          value: lightProbe.intensity\n        }\n      },\n      vertexShader: [\"varying vec3 vNormal;\", \"void main() {\", \"\tvNormal = normalize( normalMatrix * normal );\", \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n      fragmentShader: [\"#define RECIPROCAL_PI 0.318309886\", \"vec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\", \"\t// matrix is assumed to be orthogonal\", \"\treturn normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\", \"}\", \"// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf\", \"vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\", \"\t// normal is assumed to have unit length\", \"\tfloat x = normal.x, y = normal.y, z = normal.z;\", \"\t// band 0\", \"\tvec3 result = shCoefficients[ 0 ] * 0.886227;\", \"\t// band 1\", \"\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\", \"\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\", \"\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\", \"\t// band 2\", \"\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\", \"\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\", \"\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\", \"\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\", \"\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\", \"\treturn result;\", \"}\", \"uniform vec3 sh[ 9 ]; // sh coefficients\", \"uniform float intensity; // light probe intensity\", \"varying vec3 vNormal;\", \"void main() {\", \"\tvec3 normal = normalize( vNormal );\", \"\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\", \"\tvec3 irradiance = shGetIrradianceAt( worldNormal, sh );\", \"\tvec3 outgoingLight = RECIPROCAL_PI * irradiance * intensity;\", \"\tgl_FragColor = linearToOutputTexel( vec4( outgoingLight, 1.0 ) );\", \"}\"].join(\"\\n\")\n    });\n    var geometry = new SphereGeometry(1, 32, 16);\n    _this = _super.call(this, geometry, material);\n    _this.lightProbe = lightProbe;\n    _this.size = size;\n    _this.type = \"LightProbeHelper\";\n\n    _this.onBeforeRender();\n\n    return _this;\n  }\n\n  _createClass(LightProbeHelper, [{\n    key: \"dispose\",\n    value: function dispose() {\n      this.geometry.dispose();\n      this.material.dispose();\n    }\n  }, {\n    key: \"onBeforeRender\",\n    value: function onBeforeRender() {\n      this.position.copy(this.lightProbe.position);\n      this.scale.set(1, 1, 1).multiplyScalar(this.size);\n      this.material.uniforms.intensity.value = this.lightProbe.intensity;\n    }\n  }]);\n\n  return LightProbeHelper;\n}(Mesh);\n\nexport { LightProbeHelper };","map":{"version":3,"sources":["/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/three-stdlib/helpers/LightProbeHelper.js"],"names":["Mesh","ShaderMaterial","SphereGeometry","LightProbeHelper","lightProbe","size","material","type","uniforms","sh","value","coefficients","intensity","vertexShader","join","fragmentShader","geometry","onBeforeRender","dispose","position","copy","scale","set","multiplyScalar"],"mappings":";;;;AAAA,SAASA,IAAT,EAAeC,cAAf,EAA+BC,cAA/B,QAAqD,OAArD;;IACMC,gB;;;;;AACJ,4BAAYC,UAAZ,EAAwBC,IAAxB,EAA8B;AAAA;;AAAA;;AAC5B,QAAMC,QAAQ,GAAG,IAAIL,cAAJ,CAAmB;AAClCM,MAAAA,IAAI,EAAE,0BAD4B;AAElCC,MAAAA,QAAQ,EAAE;AACRC,QAAAA,EAAE,EAAE;AAAEC,UAAAA,KAAK,EAAEN,UAAU,CAACK,EAAX,CAAcE;AAAvB,SADI;AAER;AACAC,QAAAA,SAAS,EAAE;AAAEF,UAAAA,KAAK,EAAEN,UAAU,CAACQ;AAApB;AAHH,OAFwB;AAOlCC,MAAAA,YAAY,EAAE,CACZ,uBADY,EAEZ,eAFY,EAGZ,gDAHY,EAIZ,4EAJY,EAKZ,GALY,EAMZC,IANY,CAMP,IANO,CAPoB;AAclCC,MAAAA,cAAc,EAAE,CACd,mCADc,EAEd,oEAFc,EAGd,wCAHc,EAId,4DAJc,EAKd,GALc,EAMd,mEANc,EAOd,yEAPc,EAQd,2CARc,EASd,kDATc,EAUd,YAVc,EAWd,gDAXc,EAYd,YAZc,EAad,sDAbc,EAcd,sDAdc,EAed,sDAfc,EAgBd,YAhBc,EAiBd,0DAjBc,EAkBd,0DAlBc,EAmBd,mEAnBc,EAoBd,0DApBc,EAqBd,gEArBc,EAsBd,iBAtBc,EAuBd,GAvBc,EAwBd,0CAxBc,EAyBd,mDAzBc,EA0Bd,uBA1Bc,EA2Bd,eA3Bc,EA4Bd,sCA5Bc,EA6Bd,sEA7Bc,EA8Bd,0DA9Bc,EA+Bd,+DA/Bc,EAgCd,oEAhCc,EAiCd,GAjCc,EAkCdD,IAlCc,CAkCT,IAlCS;AAdkB,KAAnB,CAAjB;AAkDA,QAAME,QAAQ,GAAG,IAAId,cAAJ,CAAmB,CAAnB,EAAsB,EAAtB,EAA0B,EAA1B,CAAjB;AACA,8BAAMc,QAAN,EAAgBV,QAAhB;AACA,UAAKF,UAAL,GAAkBA,UAAlB;AACA,UAAKC,IAAL,GAAYA,IAAZ;AACA,UAAKE,IAAL,GAAY,kBAAZ;;AACA,UAAKU,cAAL;;AAxD4B;AAyD7B;;;;WACD,mBAAU;AACR,WAAKD,QAAL,CAAcE,OAAd;AACA,WAAKZ,QAAL,CAAcY,OAAd;AACD;;;WACD,0BAAiB;AACf,WAAKC,QAAL,CAAcC,IAAd,CAAmB,KAAKhB,UAAL,CAAgBe,QAAnC;AACA,WAAKE,KAAL,CAAWC,GAAX,CAAe,CAAf,EAAkB,CAAlB,EAAqB,CAArB,EAAwBC,cAAxB,CAAuC,KAAKlB,IAA5C;AACA,WAAKC,QAAL,CAAcE,QAAd,CAAuBI,SAAvB,CAAiCF,KAAjC,GAAyC,KAAKN,UAAL,CAAgBQ,SAAzD;AACD;;;;EAnE4BZ,I;;AAqE/B,SACEG,gBADF","sourcesContent":["import { Mesh, ShaderMaterial, SphereGeometry } from \"three\";\nclass LightProbeHelper extends Mesh {\n  constructor(lightProbe, size) {\n    const material = new ShaderMaterial({\n      type: \"LightProbeHelperMaterial\",\n      uniforms: {\n        sh: { value: lightProbe.sh.coefficients },\n        // by reference\n        intensity: { value: lightProbe.intensity }\n      },\n      vertexShader: [\n        \"varying vec3 vNormal;\",\n        \"void main() {\",\n        \"\tvNormal = normalize( normalMatrix * normal );\",\n        \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n        \"}\"\n      ].join(\"\\n\"),\n      fragmentShader: [\n        \"#define RECIPROCAL_PI 0.318309886\",\n        \"vec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\",\n        \"\t// matrix is assumed to be orthogonal\",\n        \"\treturn normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\",\n        \"}\",\n        \"// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf\",\n        \"vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\",\n        \"\t// normal is assumed to have unit length\",\n        \"\tfloat x = normal.x, y = normal.y, z = normal.z;\",\n        \"\t// band 0\",\n        \"\tvec3 result = shCoefficients[ 0 ] * 0.886227;\",\n        \"\t// band 1\",\n        \"\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\",\n        \"\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\",\n        \"\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\",\n        \"\t// band 2\",\n        \"\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\",\n        \"\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\",\n        \"\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\",\n        \"\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\",\n        \"\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\",\n        \"\treturn result;\",\n        \"}\",\n        \"uniform vec3 sh[ 9 ]; // sh coefficients\",\n        \"uniform float intensity; // light probe intensity\",\n        \"varying vec3 vNormal;\",\n        \"void main() {\",\n        \"\tvec3 normal = normalize( vNormal );\",\n        \"\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\",\n        \"\tvec3 irradiance = shGetIrradianceAt( worldNormal, sh );\",\n        \"\tvec3 outgoingLight = RECIPROCAL_PI * irradiance * intensity;\",\n        \"\tgl_FragColor = linearToOutputTexel( vec4( outgoingLight, 1.0 ) );\",\n        \"}\"\n      ].join(\"\\n\")\n    });\n    const geometry = new SphereGeometry(1, 32, 16);\n    super(geometry, material);\n    this.lightProbe = lightProbe;\n    this.size = size;\n    this.type = \"LightProbeHelper\";\n    this.onBeforeRender();\n  }\n  dispose() {\n    this.geometry.dispose();\n    this.material.dispose();\n  }\n  onBeforeRender() {\n    this.position.copy(this.lightProbe.position);\n    this.scale.set(1, 1, 1).multiplyScalar(this.size);\n    this.material.uniforms.intensity.value = this.lightProbe.intensity;\n  }\n}\nexport {\n  LightProbeHelper\n};\n"]},"metadata":{},"sourceType":"module"}