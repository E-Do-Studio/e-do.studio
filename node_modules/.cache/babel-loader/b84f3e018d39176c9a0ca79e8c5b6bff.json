{"ast":null,"code":"var __defProp = Object.defineProperty;\n\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\n\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n\n  return value;\n};\n\nimport { Mesh, Matrix4, Vector2, Color, Vector3, PerspectiveCamera, DepthTexture, UnsignedShortType, NearestFilter, HalfFloatType, WebGLRenderTarget, ShaderMaterial, UniformsUtils, Plane } from \"three\";\n\nconst _ReflectorForSSRPass = class extends Mesh {\n  constructor(geometry, options = {}) {\n    super(geometry);\n    this.isReflectorForSSRPass = true;\n    this.type = \"ReflectorForSSRPass\";\n    const scope = this;\n    const color = options.color !== void 0 ? new Color(options.color) : new Color(8355711);\n    const textureWidth = options.textureWidth || 512;\n    const textureHeight = options.textureHeight || 512;\n    const clipBias = options.clipBias || 0;\n    const shader = options.shader || _ReflectorForSSRPass.ReflectorShader;\n    const useDepthTexture = options.useDepthTexture === true;\n    const yAxis = new Vector3(0, 1, 0);\n    const vecTemp0 = new Vector3();\n    const vecTemp1 = new Vector3();\n    scope.needsUpdate = false;\n    scope.maxDistance = _ReflectorForSSRPass.ReflectorShader.uniforms.maxDistance.value;\n    scope.opacity = _ReflectorForSSRPass.ReflectorShader.uniforms.opacity.value;\n    scope.color = color;\n    scope.resolution = options.resolution || new Vector2(window.innerWidth, window.innerHeight);\n    scope._distanceAttenuation = _ReflectorForSSRPass.ReflectorShader.defines.DISTANCE_ATTENUATION;\n    Object.defineProperty(scope, \"distanceAttenuation\", {\n      get() {\n        return scope._distanceAttenuation;\n      },\n\n      set(val) {\n        if (scope._distanceAttenuation === val) return;\n        scope._distanceAttenuation = val;\n        scope.material.defines.DISTANCE_ATTENUATION = val;\n        scope.material.needsUpdate = true;\n      }\n\n    });\n    scope._fresnel = _ReflectorForSSRPass.ReflectorShader.defines.FRESNEL;\n    Object.defineProperty(scope, \"fresnel\", {\n      get() {\n        return scope._fresnel;\n      },\n\n      set(val) {\n        if (scope._fresnel === val) return;\n        scope._fresnel = val;\n        scope.material.defines.FRESNEL = val;\n        scope.material.needsUpdate = true;\n      }\n\n    });\n    const normal = new Vector3();\n    const reflectorWorldPosition = new Vector3();\n    const cameraWorldPosition = new Vector3();\n    const rotationMatrix = new Matrix4();\n    const lookAtPosition = new Vector3(0, 0, -1);\n    const view = new Vector3();\n    const target = new Vector3();\n    const textureMatrix = new Matrix4();\n    const virtualCamera = new PerspectiveCamera();\n    let depthTexture;\n\n    if (useDepthTexture) {\n      depthTexture = new DepthTexture();\n      depthTexture.type = UnsignedShortType;\n      depthTexture.minFilter = NearestFilter;\n      depthTexture.magFilter = NearestFilter;\n    }\n\n    const parameters = {\n      depthTexture: useDepthTexture ? depthTexture : null,\n      type: HalfFloatType\n    };\n    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, parameters);\n    const material = new ShaderMaterial({\n      transparent: useDepthTexture,\n      defines: Object.assign({}, _ReflectorForSSRPass.ReflectorShader.defines, {\n        useDepthTexture\n      }),\n      uniforms: UniformsUtils.clone(shader.uniforms),\n      fragmentShader: shader.fragmentShader,\n      vertexShader: shader.vertexShader\n    });\n    material.uniforms[\"tDiffuse\"].value = renderTarget.texture;\n    material.uniforms[\"color\"].value = scope.color;\n    material.uniforms[\"textureMatrix\"].value = textureMatrix;\n\n    if (useDepthTexture) {\n      material.uniforms[\"tDepth\"].value = renderTarget.depthTexture;\n    }\n\n    this.material = material;\n    const globalPlane = new Plane(new Vector3(0, 1, 0), clipBias);\n    const globalPlanes = [globalPlane];\n\n    this.doRender = function (renderer, scene, camera) {\n      material.uniforms[\"maxDistance\"].value = scope.maxDistance;\n      material.uniforms[\"color\"].value = scope.color;\n      material.uniforms[\"opacity\"].value = scope.opacity;\n      vecTemp0.copy(camera.position).normalize();\n      vecTemp1.copy(vecTemp0).reflect(yAxis);\n      material.uniforms[\"fresnelCoe\"].value = (vecTemp0.dot(vecTemp1) + 1) / 2;\n      reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n      rotationMatrix.extractRotation(scope.matrixWorld);\n      normal.set(0, 0, 1);\n      normal.applyMatrix4(rotationMatrix);\n      view.subVectors(reflectorWorldPosition, cameraWorldPosition);\n      if (view.dot(normal) > 0) return;\n      view.reflect(normal).negate();\n      view.add(reflectorWorldPosition);\n      rotationMatrix.extractRotation(camera.matrixWorld);\n      lookAtPosition.set(0, 0, -1);\n      lookAtPosition.applyMatrix4(rotationMatrix);\n      lookAtPosition.add(cameraWorldPosition);\n      target.subVectors(reflectorWorldPosition, lookAtPosition);\n      target.reflect(normal).negate();\n      target.add(reflectorWorldPosition);\n      virtualCamera.position.copy(view);\n      virtualCamera.up.set(0, 1, 0);\n      virtualCamera.up.applyMatrix4(rotationMatrix);\n      virtualCamera.up.reflect(normal);\n      virtualCamera.lookAt(target);\n      virtualCamera.far = camera.far;\n      virtualCamera.updateMatrixWorld();\n      virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\n      material.uniforms[\"virtualCameraNear\"].value = camera.near;\n      material.uniforms[\"virtualCameraFar\"].value = camera.far;\n      material.uniforms[\"virtualCameraMatrixWorld\"].value = virtualCamera.matrixWorld;\n      material.uniforms[\"virtualCameraProjectionMatrix\"].value = camera.projectionMatrix;\n      material.uniforms[\"virtualCameraProjectionMatrixInverse\"].value = camera.projectionMatrixInverse;\n      material.uniforms[\"resolution\"].value = scope.resolution;\n      textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);\n      textureMatrix.multiply(virtualCamera.projectionMatrix);\n      textureMatrix.multiply(virtualCamera.matrixWorldInverse);\n      textureMatrix.multiply(scope.matrixWorld);\n      const currentRenderTarget = renderer.getRenderTarget();\n      const currentXrEnabled = renderer.xr.enabled;\n      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n      const currentClippingPlanes = renderer.clippingPlanes;\n      renderer.xr.enabled = false;\n      renderer.shadowMap.autoUpdate = false;\n      renderer.clippingPlanes = globalPlanes;\n      renderer.setRenderTarget(renderTarget);\n      renderer.state.buffers.depth.setMask(true);\n      if (renderer.autoClear === false) renderer.clear();\n      renderer.render(scene, virtualCamera);\n      renderer.xr.enabled = currentXrEnabled;\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n      renderer.clippingPlanes = currentClippingPlanes;\n      renderer.setRenderTarget(currentRenderTarget);\n      const viewport = camera.viewport;\n\n      if (viewport !== void 0) {\n        renderer.state.viewport(viewport);\n      }\n    };\n\n    this.getRenderTarget = function () {\n      return renderTarget;\n    };\n  }\n\n};\n\nlet ReflectorForSSRPass = _ReflectorForSSRPass;\n\n__publicField(ReflectorForSSRPass, \"ReflectorShader\", {\n  defines: {\n    DISTANCE_ATTENUATION: true,\n    FRESNEL: true\n  },\n  uniforms: {\n    color: {\n      value: null\n    },\n    tDiffuse: {\n      value: null\n    },\n    tDepth: {\n      value: null\n    },\n    textureMatrix: {\n      value: /* @__PURE__ */new Matrix4()\n    },\n    maxDistance: {\n      value: 180\n    },\n    opacity: {\n      value: 0.5\n    },\n    fresnelCoe: {\n      value: null\n    },\n    virtualCameraNear: {\n      value: null\n    },\n    virtualCameraFar: {\n      value: null\n    },\n    virtualCameraProjectionMatrix: {\n      value: /* @__PURE__ */new Matrix4()\n    },\n    virtualCameraMatrixWorld: {\n      value: /* @__PURE__ */new Matrix4()\n    },\n    virtualCameraProjectionMatrixInverse: {\n      value: /* @__PURE__ */new Matrix4()\n    },\n    resolution: {\n      value: /* @__PURE__ */new Vector2()\n    }\n  },\n  vertexShader:\n  /* glsl */\n  `\n\t\tuniform mat4 textureMatrix;\n\t\tvarying vec4 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`,\n  fragmentShader:\n  /* glsl */\n  `\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform sampler2D tDepth;\n\t\tuniform float maxDistance;\n\t\tuniform float opacity;\n\t\tuniform float fresnelCoe;\n\t\tuniform float virtualCameraNear;\n\t\tuniform float virtualCameraFar;\n\t\tuniform mat4 virtualCameraProjectionMatrix;\n\t\tuniform mat4 virtualCameraProjectionMatrixInverse;\n\t\tuniform mat4 virtualCameraMatrixWorld;\n\t\tuniform vec2 resolution;\n\t\tvarying vec4 vUv;\n\t\t#include <packing>\n\t\tfloat blendOverlay( float base, float blend ) {\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\t\t}\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\t\t}\n\t\tfloat getDepth( const in vec2 uv ) {\n\t\t\treturn texture2D( tDepth, uv ).x;\n\t\t}\n\t\tfloat getViewZ( const in float depth ) {\n\t\t\treturn perspectiveDepthToViewZ( depth, virtualCameraNear, virtualCameraFar );\n\t\t}\n\t\tvec3 getViewPosition( const in vec2 uv, const in float depth/*clip space*/, const in float clipW ) {\n\t\t\tvec4 clipPosition = vec4( ( vec3( uv, depth ) - 0.5 ) * 2.0, 1.0 );//ndc\n\t\t\tclipPosition *= clipW; //clip\n\t\t\treturn ( virtualCameraProjectionMatrixInverse * clipPosition ).xyz;//view\n\t\t}\n\t\tvoid main() {\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\t#ifdef useDepthTexture\n\t\t\t\tvec2 uv=(gl_FragCoord.xy-.5)/resolution.xy;\n\t\t\t\tuv.x=1.-uv.x;\n\t\t\t\tfloat depth = texture2DProj( tDepth, vUv ).r;\n\t\t\t\tfloat viewZ = getViewZ( depth );\n\t\t\t\tfloat clipW = virtualCameraProjectionMatrix[2][3] * viewZ+virtualCameraProjectionMatrix[3][3];\n\t\t\t\tvec3 viewPosition=getViewPosition( uv, depth, clipW );\n\t\t\t\tvec3 worldPosition=(virtualCameraMatrixWorld*vec4(viewPosition,1)).xyz;\n\t\t\t\tif(worldPosition.y>maxDistance) discard;\n\t\t\t\tfloat op=opacity;\n\t\t\t\t#ifdef DISTANCE_ATTENUATION\n\t\t\t\t\tfloat ratio=1.-(worldPosition.y/maxDistance);\n\t\t\t\t\tfloat attenuation=ratio*ratio;\n\t\t\t\t\top=opacity*attenuation;\n\t\t\t\t#endif\n\t\t\t\t#ifdef FRESNEL\n\t\t\t\t\top*=fresnelCoe;\n\t\t\t\t#endif\n\t\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), op );\n\t\t\t#else\n\t\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\t\t\t#endif\n\t\t}\n\t`\n});\n\nexport { ReflectorForSSRPass };","map":{"version":3,"sources":["/Users/theodaguier/_dev/pro/e-do/website/old/E-Do-Studio/node_modules/three-stdlib/objects/ReflectorForSSRPass.js"],"names":["__defProp","Object","defineProperty","__defNormalProp","obj","key","value","enumerable","configurable","writable","__publicField","Mesh","Matrix4","Vector2","Color","Vector3","PerspectiveCamera","DepthTexture","UnsignedShortType","NearestFilter","HalfFloatType","WebGLRenderTarget","ShaderMaterial","UniformsUtils","Plane","_ReflectorForSSRPass","constructor","geometry","options","isReflectorForSSRPass","type","scope","color","textureWidth","textureHeight","clipBias","shader","ReflectorShader","useDepthTexture","yAxis","vecTemp0","vecTemp1","needsUpdate","maxDistance","uniforms","opacity","resolution","window","innerWidth","innerHeight","_distanceAttenuation","defines","DISTANCE_ATTENUATION","get","set","val","material","_fresnel","FRESNEL","normal","reflectorWorldPosition","cameraWorldPosition","rotationMatrix","lookAtPosition","view","target","textureMatrix","virtualCamera","depthTexture","minFilter","magFilter","parameters","renderTarget","transparent","assign","clone","fragmentShader","vertexShader","texture","globalPlane","globalPlanes","doRender","renderer","scene","camera","copy","position","normalize","reflect","dot","setFromMatrixPosition","matrixWorld","extractRotation","applyMatrix4","subVectors","negate","add","up","lookAt","far","updateMatrixWorld","projectionMatrix","near","projectionMatrixInverse","multiply","matrixWorldInverse","currentRenderTarget","getRenderTarget","currentXrEnabled","xr","enabled","currentShadowAutoUpdate","shadowMap","autoUpdate","currentClippingPlanes","clippingPlanes","setRenderTarget","state","buffers","depth","setMask","autoClear","clear","render","viewport","ReflectorForSSRPass","tDiffuse","tDepth","fresnelCoe","virtualCameraNear","virtualCameraFar","virtualCameraProjectionMatrix","virtualCameraMatrixWorld","virtualCameraProjectionMatrixInverse"],"mappings":"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","sourcesContent":["var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Mesh, Matrix4, Vector2, Color, Vector3, PerspectiveCamera, DepthTexture, UnsignedShortType, NearestFilter, HalfFloatType, WebGLRenderTarget, ShaderMaterial, UniformsUtils, Plane } from \"three\";\nconst _ReflectorForSSRPass = class extends Mesh {\n  constructor(geometry, options = {}) {\n    super(geometry);\n    this.isReflectorForSSRPass = true;\n    this.type = \"ReflectorForSSRPass\";\n    const scope = this;\n    const color = options.color !== void 0 ? new Color(options.color) : new Color(8355711);\n    const textureWidth = options.textureWidth || 512;\n    const textureHeight = options.textureHeight || 512;\n    const clipBias = options.clipBias || 0;\n    const shader = options.shader || _ReflectorForSSRPass.ReflectorShader;\n    const useDepthTexture = options.useDepthTexture === true;\n    const yAxis = new Vector3(0, 1, 0);\n    const vecTemp0 = new Vector3();\n    const vecTemp1 = new Vector3();\n    scope.needsUpdate = false;\n    scope.maxDistance = _ReflectorForSSRPass.ReflectorShader.uniforms.maxDistance.value;\n    scope.opacity = _ReflectorForSSRPass.ReflectorShader.uniforms.opacity.value;\n    scope.color = color;\n    scope.resolution = options.resolution || new Vector2(window.innerWidth, window.innerHeight);\n    scope._distanceAttenuation = _ReflectorForSSRPass.ReflectorShader.defines.DISTANCE_ATTENUATION;\n    Object.defineProperty(scope, \"distanceAttenuation\", {\n      get() {\n        return scope._distanceAttenuation;\n      },\n      set(val) {\n        if (scope._distanceAttenuation === val)\n          return;\n        scope._distanceAttenuation = val;\n        scope.material.defines.DISTANCE_ATTENUATION = val;\n        scope.material.needsUpdate = true;\n      }\n    });\n    scope._fresnel = _ReflectorForSSRPass.ReflectorShader.defines.FRESNEL;\n    Object.defineProperty(scope, \"fresnel\", {\n      get() {\n        return scope._fresnel;\n      },\n      set(val) {\n        if (scope._fresnel === val)\n          return;\n        scope._fresnel = val;\n        scope.material.defines.FRESNEL = val;\n        scope.material.needsUpdate = true;\n      }\n    });\n    const normal = new Vector3();\n    const reflectorWorldPosition = new Vector3();\n    const cameraWorldPosition = new Vector3();\n    const rotationMatrix = new Matrix4();\n    const lookAtPosition = new Vector3(0, 0, -1);\n    const view = new Vector3();\n    const target = new Vector3();\n    const textureMatrix = new Matrix4();\n    const virtualCamera = new PerspectiveCamera();\n    let depthTexture;\n    if (useDepthTexture) {\n      depthTexture = new DepthTexture();\n      depthTexture.type = UnsignedShortType;\n      depthTexture.minFilter = NearestFilter;\n      depthTexture.magFilter = NearestFilter;\n    }\n    const parameters = {\n      depthTexture: useDepthTexture ? depthTexture : null,\n      type: HalfFloatType\n    };\n    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, parameters);\n    const material = new ShaderMaterial({\n      transparent: useDepthTexture,\n      defines: Object.assign({}, _ReflectorForSSRPass.ReflectorShader.defines, {\n        useDepthTexture\n      }),\n      uniforms: UniformsUtils.clone(shader.uniforms),\n      fragmentShader: shader.fragmentShader,\n      vertexShader: shader.vertexShader\n    });\n    material.uniforms[\"tDiffuse\"].value = renderTarget.texture;\n    material.uniforms[\"color\"].value = scope.color;\n    material.uniforms[\"textureMatrix\"].value = textureMatrix;\n    if (useDepthTexture) {\n      material.uniforms[\"tDepth\"].value = renderTarget.depthTexture;\n    }\n    this.material = material;\n    const globalPlane = new Plane(new Vector3(0, 1, 0), clipBias);\n    const globalPlanes = [globalPlane];\n    this.doRender = function(renderer, scene, camera) {\n      material.uniforms[\"maxDistance\"].value = scope.maxDistance;\n      material.uniforms[\"color\"].value = scope.color;\n      material.uniforms[\"opacity\"].value = scope.opacity;\n      vecTemp0.copy(camera.position).normalize();\n      vecTemp1.copy(vecTemp0).reflect(yAxis);\n      material.uniforms[\"fresnelCoe\"].value = (vecTemp0.dot(vecTemp1) + 1) / 2;\n      reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n      rotationMatrix.extractRotation(scope.matrixWorld);\n      normal.set(0, 0, 1);\n      normal.applyMatrix4(rotationMatrix);\n      view.subVectors(reflectorWorldPosition, cameraWorldPosition);\n      if (view.dot(normal) > 0)\n        return;\n      view.reflect(normal).negate();\n      view.add(reflectorWorldPosition);\n      rotationMatrix.extractRotation(camera.matrixWorld);\n      lookAtPosition.set(0, 0, -1);\n      lookAtPosition.applyMatrix4(rotationMatrix);\n      lookAtPosition.add(cameraWorldPosition);\n      target.subVectors(reflectorWorldPosition, lookAtPosition);\n      target.reflect(normal).negate();\n      target.add(reflectorWorldPosition);\n      virtualCamera.position.copy(view);\n      virtualCamera.up.set(0, 1, 0);\n      virtualCamera.up.applyMatrix4(rotationMatrix);\n      virtualCamera.up.reflect(normal);\n      virtualCamera.lookAt(target);\n      virtualCamera.far = camera.far;\n      virtualCamera.updateMatrixWorld();\n      virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\n      material.uniforms[\"virtualCameraNear\"].value = camera.near;\n      material.uniforms[\"virtualCameraFar\"].value = camera.far;\n      material.uniforms[\"virtualCameraMatrixWorld\"].value = virtualCamera.matrixWorld;\n      material.uniforms[\"virtualCameraProjectionMatrix\"].value = camera.projectionMatrix;\n      material.uniforms[\"virtualCameraProjectionMatrixInverse\"].value = camera.projectionMatrixInverse;\n      material.uniforms[\"resolution\"].value = scope.resolution;\n      textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);\n      textureMatrix.multiply(virtualCamera.projectionMatrix);\n      textureMatrix.multiply(virtualCamera.matrixWorldInverse);\n      textureMatrix.multiply(scope.matrixWorld);\n      const currentRenderTarget = renderer.getRenderTarget();\n      const currentXrEnabled = renderer.xr.enabled;\n      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n      const currentClippingPlanes = renderer.clippingPlanes;\n      renderer.xr.enabled = false;\n      renderer.shadowMap.autoUpdate = false;\n      renderer.clippingPlanes = globalPlanes;\n      renderer.setRenderTarget(renderTarget);\n      renderer.state.buffers.depth.setMask(true);\n      if (renderer.autoClear === false)\n        renderer.clear();\n      renderer.render(scene, virtualCamera);\n      renderer.xr.enabled = currentXrEnabled;\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n      renderer.clippingPlanes = currentClippingPlanes;\n      renderer.setRenderTarget(currentRenderTarget);\n      const viewport = camera.viewport;\n      if (viewport !== void 0) {\n        renderer.state.viewport(viewport);\n      }\n    };\n    this.getRenderTarget = function() {\n      return renderTarget;\n    };\n  }\n};\nlet ReflectorForSSRPass = _ReflectorForSSRPass;\n__publicField(ReflectorForSSRPass, \"ReflectorShader\", {\n  defines: {\n    DISTANCE_ATTENUATION: true,\n    FRESNEL: true\n  },\n  uniforms: {\n    color: { value: null },\n    tDiffuse: { value: null },\n    tDepth: { value: null },\n    textureMatrix: { value: /* @__PURE__ */ new Matrix4() },\n    maxDistance: { value: 180 },\n    opacity: { value: 0.5 },\n    fresnelCoe: { value: null },\n    virtualCameraNear: { value: null },\n    virtualCameraFar: { value: null },\n    virtualCameraProjectionMatrix: { value: /* @__PURE__ */ new Matrix4() },\n    virtualCameraMatrixWorld: { value: /* @__PURE__ */ new Matrix4() },\n    virtualCameraProjectionMatrixInverse: { value: /* @__PURE__ */ new Matrix4() },\n    resolution: { value: /* @__PURE__ */ new Vector2() }\n  },\n  vertexShader: (\n    /* glsl */\n    `\n\t\tuniform mat4 textureMatrix;\n\t\tvarying vec4 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform sampler2D tDepth;\n\t\tuniform float maxDistance;\n\t\tuniform float opacity;\n\t\tuniform float fresnelCoe;\n\t\tuniform float virtualCameraNear;\n\t\tuniform float virtualCameraFar;\n\t\tuniform mat4 virtualCameraProjectionMatrix;\n\t\tuniform mat4 virtualCameraProjectionMatrixInverse;\n\t\tuniform mat4 virtualCameraMatrixWorld;\n\t\tuniform vec2 resolution;\n\t\tvarying vec4 vUv;\n\t\t#include <packing>\n\t\tfloat blendOverlay( float base, float blend ) {\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\t\t}\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\t\t}\n\t\tfloat getDepth( const in vec2 uv ) {\n\t\t\treturn texture2D( tDepth, uv ).x;\n\t\t}\n\t\tfloat getViewZ( const in float depth ) {\n\t\t\treturn perspectiveDepthToViewZ( depth, virtualCameraNear, virtualCameraFar );\n\t\t}\n\t\tvec3 getViewPosition( const in vec2 uv, const in float depth/*clip space*/, const in float clipW ) {\n\t\t\tvec4 clipPosition = vec4( ( vec3( uv, depth ) - 0.5 ) * 2.0, 1.0 );//ndc\n\t\t\tclipPosition *= clipW; //clip\n\t\t\treturn ( virtualCameraProjectionMatrixInverse * clipPosition ).xyz;//view\n\t\t}\n\t\tvoid main() {\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\t#ifdef useDepthTexture\n\t\t\t\tvec2 uv=(gl_FragCoord.xy-.5)/resolution.xy;\n\t\t\t\tuv.x=1.-uv.x;\n\t\t\t\tfloat depth = texture2DProj( tDepth, vUv ).r;\n\t\t\t\tfloat viewZ = getViewZ( depth );\n\t\t\t\tfloat clipW = virtualCameraProjectionMatrix[2][3] * viewZ+virtualCameraProjectionMatrix[3][3];\n\t\t\t\tvec3 viewPosition=getViewPosition( uv, depth, clipW );\n\t\t\t\tvec3 worldPosition=(virtualCameraMatrixWorld*vec4(viewPosition,1)).xyz;\n\t\t\t\tif(worldPosition.y>maxDistance) discard;\n\t\t\t\tfloat op=opacity;\n\t\t\t\t#ifdef DISTANCE_ATTENUATION\n\t\t\t\t\tfloat ratio=1.-(worldPosition.y/maxDistance);\n\t\t\t\t\tfloat attenuation=ratio*ratio;\n\t\t\t\t\top=opacity*attenuation;\n\t\t\t\t#endif\n\t\t\t\t#ifdef FRESNEL\n\t\t\t\t\top*=fresnelCoe;\n\t\t\t\t#endif\n\t\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), op );\n\t\t\t#else\n\t\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\t\t\t#endif\n\t\t}\n\t`\n  )\n});\nexport {\n  ReflectorForSSRPass\n};\n"]},"metadata":{},"sourceType":"module"}